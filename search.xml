<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Collection框架</title>
    <url>/2020/11/23/Collection%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Collection框架"><a href="#Collection框架" class="headerlink" title="Collection框架"></a>Collection框架</h1><p><img src="/2020/11/23/Collection%E6%A1%86%E6%9E%B6/Collection.png" alt="Collection"></p>
 <span id="more"></span> 

<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">//add()方法传入的数据类型必须是Object，所以写入基本数据类型时，会自动装箱和自动拆箱</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Colleciton&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"><span class="comment">//把另一个集合里的元素添加到此集合中</span></span><br></pre></td></tr></table></figure>

<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//删除指定元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"><span class="comment">//把集合中B的所有元素都删除</span></span><br></pre></td></tr></table></figure>

<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//查看集合中有没有某个特定的元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"><span class="comment">//查看集合A是否包含了集合B</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断集合是否为空</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//集合的大小</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] toArray();</span><br><span class="line"><span class="comment">//把集合转换成数组</span></span><br></pre></td></tr></table></figure>

<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>特点：有序、可重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(E e);</span><br><span class="line"><span class="comment">//在尾巴上加元素，ArrayList可能有扩容的情况出现。ArrayList和LinkedList的时间复杂度均为O(1)。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(<span class="keyword">int</span> index, E e);</span><br><span class="line"><span class="comment">//在特定的位置上加元素，LinkedList需要先找到这个位置，再加上这个元素，虽然加这个动作的复杂度为O(1),但是要找到这个位置还是O(n)。ArrayList和LinkedList的时间复杂度均为O(n)。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">remove(<span class="keyword">int</span> index);</span><br><span class="line"><span class="comment">//remove这个index上的元素</span></span><br><span class="line"><span class="comment">//ArrayList找到这个元素的过程是O(1)，但是remove之后，后续元素要往前移动一位，所以均摊复杂度是O(n);</span></span><br><span class="line"><span class="comment">//LinkedList也是要先找到这个index，这个过程是O(n)，所以整体也是O(n)。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">remove(E e);</span><br><span class="line"><span class="comment">//remove见到的第一个这个元素</span></span><br><span class="line"><span class="comment">//ArrayList找到这个元素的过程是O(n)，然后移除后还要往前移一位，这个更是O(n),总体还是O(n)。</span></span><br><span class="line"><span class="comment">//LinkedList也要先找，这个过程是O(n),然后移走，这个过程为O(1),总的是O(n)。</span></span><br></pre></td></tr></table></figure>

<h2 id="那造成时间复杂度的区别的原因是什么？"><a href="#那造成时间复杂度的区别的原因是什么？" class="headerlink" title="那造成时间复杂度的区别的原因是什么？"></a>那造成时间复杂度的区别的原因是什么？</h2><ul>
<li>因为ArrayList是用数组来实现的。</li>
<li>而数组和链表的最大区别就是数组可以随机访问(random access)。</li>
</ul>
<p>这个特点造成在数组可以通过下标用O(1)的时间拿到任何位置的数，而链表做不到，只能从头开始逐个遍历。</p>
<p>在【改查】这两个功能上，数组能够随机访问。所以ArrayList的效率高。</p>
<p>在【增删】中，若不考虑找到这个元素的时间，数组因为物理上的连续性，当要增删元素时，在尾部还好，但在其他地方就会导致后续元素都要移动所以效率较低；而链表则可以轻松的断开和下一个元素的链接，直接插入新元素或者移除旧元素。</p>
<p>实际上你不能不考虑找到元素的时间!如果在尾部操作，数据量大时ArrayList会更快。</p>
<ul>
<li>改查选择ArrayList</li>
<li>增删在尾部选择ArrayList</li>
<li>其他情况下，如果时间复杂度一样，推荐选择ArrayList，因为overhead更小，或者说内存使用更有效率。</li>
</ul>
<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><h2 id="Vector和ArrayList的区别是什么"><a href="#Vector和ArrayList的区别是什么" class="headerlink" title="Vector和ArrayList的区别是什么"></a>Vector和ArrayList的区别是什么</h2><ul>
<li>线程安全问题</li>
<li>扩容时扩多少的区别：ArrayList扩容为原容量的1.5倍；而Vector扩容为原来的两倍。</li>
</ul>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue是一端进另一端出的线性数据结构；而Deque是两端都可以进出的。</p>
<h2 id="PriorityQueue-heap"><a href="#PriorityQueue-heap" class="headerlink" title="PriorityQueue(heap)"></a>PriorityQueue(heap)</h2><p>并不按照进去的时间顺序出来，而是按照规定的优先级出去，并且它的操作并不是O(1)，时间复杂度的计算稍微有点复杂。</p>
<h2 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h2><p>其有两组API，基本功能一样，但是：</p>
<ul>
<li>一组会抛异常</li>
<li>另一组会返回一个特殊值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增		抛异常		返回值</span></span><br><span class="line">		add(e)		offter(e)</span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">         remove()	 poll()</span><br><span class="line"><span class="comment">//瞧		</span></span><br><span class="line">         element()	 peek()</span><br></pre></td></tr></table></figure>

<h2 id="为什么会抛异常呢？"><a href="#为什么会抛异常呢？" class="headerlink" title="为什么会抛异常呢？"></a>为什么会抛异常呢？</h2><p>比如队列空了，那就remove()就会抛异常，但是poll()就返回null；element()就会抛异常，而peek()就返回null</p>
<h2 id="add-e-怎么会抛异常呢？"><a href="#add-e-怎么会抛异常呢？" class="headerlink" title="add(e)怎么会抛异常呢？"></a>add(e)怎么会抛异常呢？</h2><p>有些Queue它会有容量的限制，比如BlockingQueue，那如果已经达到了它最大的容量且不会扩容，就会抛异常；但如果offer(e)，就会return false。</p>
<h2 id="怎么选择呢？"><a href="#怎么选择呢？" class="headerlink" title="怎么选择呢？"></a>怎么选择呢？</h2><ul>
<li>首先，要用就用同一组API，前后要统一；</li>
<li>其次，根据需求。如果你需要它抛异常，那就用抛异常的；不过做算法题时基本不用，所以选那组返回特殊值的就好了。</li>
</ul>
<h1 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h1><p>Deque是两端都可以进出的，那自然是针对First端的操作和对Last端的操作，那每端都有两组，一组抛异常，一组返回特殊值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增		抛异常						返回值</span></span><br><span class="line">		addFirst(e)/addLast(e)		offterFirst(e)/offerLast(e)</span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">         removeFirst()/removeLast()	 pollFirst()/pollLast()</span><br><span class="line"><span class="comment">//瞧		</span></span><br><span class="line">         getFirst()/getLast()	 	 peekFirst()/peekLast()</span><br></pre></td></tr></table></figure>

<p>使用时同理，要用就用一组。Queue和Deque的这些API都是O(1)的时间复杂度，准确来说是均摊时间复杂度。</p>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><ul>
<li><p>LinkedList</p>
</li>
<li><p>ArrayDeque</p>
</li>
<li><p>PriorityQueue</p>
</li>
<li><p>若想实现普通队列-先进先出的语义，就使用LinkedList或ArrayDeque；</p>
</li>
<li><p>若想实现优先队列，就使用PriorityQueue；</p>
</li>
<li><p>如果想实现栈的语义，就使用ArrayDeque</p>
</li>
</ul>
<h2 id="在实现一个普通的队列时，如何选择LinkedList还是ArrayDeque"><a href="#在实现一个普通的队列时，如何选择LinkedList还是ArrayDeque" class="headerlink" title="在实现一个普通的队列时，如何选择LinkedList还是ArrayDeque"></a>在实现一个普通的队列时，如何选择LinkedList还是ArrayDeque</h2><p>推荐使用ArrayDeque，因为效率高，LinkedList还会有其他的额外开销(overhead)。</p>
<h2 id="ArrayDeque和LinkedList的区别有哪些？"><a href="#ArrayDeque和LinkedList的区别有哪些？" class="headerlink" title="ArrayDeque和LinkedList的区别有哪些？"></a>ArrayDeque和LinkedList的区别有哪些？</h2><ul>
<li>ArrayDeque是一个可扩容的数组，LinkedList是链表结构；</li>
<li>ArrayDeque里不可以存null值，但是LinkedList可以；</li>
<li>ArrayDeque在操作头尾端的增删操作时更高效，但是LinkedList只有在当要移除中间某个元素且已经找到这个元素后的移除才是O(1)；</li>
<li>ArrayDeque在内存使用方面更高效。</li>
</ul>
<p>所以，只要不是必须存null值，就选择ArrayDeque！</p>
<h2 id="什么情况下选择用LinkedList呢？"><a href="#什么情况下选择用LinkedList呢？" class="headerlink" title="什么情况下选择用LinkedList呢？"></a>什么情况下选择用LinkedList呢？</h2><p>Java6之前。</p>
<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>Stack在语义上是后进先出(LIFO)的线性数据结构。</p>
<p>由于Vector已经被弃用了，而Stack是继承Vector的。那么想要实现Stack的语义，就用ArrayDeque吧！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set的特点是：无序，不重复的</p>
<h2 id="实现类-1"><a href="#实现类-1" class="headerlink" title="实现类"></a>实现类</h2><ul>
<li>HashSet：采用Hashmap的key来存储元素，主要特点是无序的，基本操作都是O(1)的时间复杂度</li>
<li>LinkedHashSet：这个是一个HashSet + LinkedList的结构，特点就是即拥有了O(1)的时间复杂度，又能够保留插入的顺序。</li>
<li>TreeSet：采用红黑树结构，特点是可以有序，可以用自然排序或者自己定义比较器来排序；缺点就是查询速度没有HashSet快。</li>
</ul>
<p>每个Set的底层实现其实就是对应的Map：数值放在map中的key上，value上放了个PRESENT，是一个静态的Object，相当于place holder，每个key都指向这个object。</p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title>Java错题</title>
    <url>/2021/03/31/Java%E9%94%99%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="20210331"><a href="#20210331" class="headerlink" title="20210331"></a>20210331</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">下面的类哪些可以处理Unicode字符？</span><br><span class="line">-------------------------------</span><br><span class="line">A InputStreamReader</span><br><span class="line">B BufferedReader</span><br><span class="line">C Writer</span><br><span class="line">D PipedInputStream</span><br><span class="line">--------------------------------</span><br><span class="line">正确答案：ABC</span><br><span class="line">解析：</span><br><span class="line">D选项是处理字节流的</span><br></pre></td></tr></table></figure>

 <span id="more"></span> 

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">关于JSP生命周期的叙述，下列哪些为真？</span><br><span class="line">----------------------------------------</span><br><span class="line">A JSP会解释成Servlet源文件，然后编译成Servlet类文件</span><br><span class="line">B 每当用户端运行JSP时，jsp init()方法都会运行一次</span><br><span class="line">C 每当用户端运行JSP时，jsp service()方法都会运行一次</span><br><span class="line">D 每当用户端运行JSP时，jsp destroy()方法都会运行一次</span><br><span class="line">-----------------------------------------</span><br><span class="line">正确答案：AC</span><br><span class="line">解析：</span><br><span class="line">JSP生命周期所走过的几个阶段：</span><br><span class="line">* 编译阶段：servlet容器编译servlet源文件，生成servlet类</span><br><span class="line">* 初始化阶段：加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</span><br><span class="line">* 执行阶段：调用与JSP对应的servlet实例的服务方法</span><br><span class="line">* 销毁阶段：调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Consider the following code:</span><br><span class="line">Integer s = new Integer(9);</span><br><span class="line">Integer t = new Integer(9);</span><br><span class="line">Long u = new Long(9);</span><br><span class="line">which test would return true?</span><br><span class="line">--------------------------------</span><br><span class="line">A (s==u)</span><br><span class="line">B (s==t)</span><br><span class="line">C (s.equals)</span><br><span class="line">D (s.equals(9))</span><br><span class="line">E (s.equals(new Integer(9)))</span><br><span class="line">--------------------------------</span><br><span class="line">正确答案：CDE</span><br><span class="line">解析：</span><br><span class="line">* int和int之间，用==比较，肯定为true。基本数据类型没有equals方法；</span><br><span class="line">* int和Integer比较，Integer会自动拆箱，==和equasl都肯定为true；</span><br><span class="line">* int和new Integer比较，Integer会自动拆箱，调用intValue方法，所以==和equals都肯定为true</span><br><span class="line">* Integer 和Integer比较的时候，由于直接赋值会进行自动装箱。所以当值在[-128,127]中的时候，由于值缓存在IntegerCache中，那么当赋值在这个区间的时候，不会创建新的Integer对象，而是直接从缓存中获取已经创建好的Integer对象。而当大于这个区间的时候，会直接new Integer；</span><br><span class="line">* 当Integer和Integer进行==比较的时候，在[-128.127]区间的时候，为true。不在这个区间，则为false；</span><br><span class="line">* 当Integer和Integer进行equals比较的时候，由于Integer的equals方法进行了重写，比较的是内容，所以为true；</span><br><span class="line">* Integer和new Integer进行==比较的话，肯定为false，Integer和new Integer进行equals进行比较的话，肯定为true；</span><br><span class="line">* new Interger和new Integer进行==比较的时候，肯定为false，进行equals比较的时候，肯定为true原因是new的时候，会在堆中创建对象，分配的地址不同，==比较的是内存地址，所以肯定不同；</span><br><span class="line">* 装箱过程是通过调用包装器的valueOf方法实现的，拆箱过程是通过调用包装器的xxxValue方法实现的；</span><br><span class="line">* 总结：Byte、Short、Integer、Long这几个类的valueOf方法实现类似的。所以在[-128,127]区间内，==比较的时候，值总是相等的，在这个区间外是不等的，而Float和Double则不相等，Boolean的值总是相等的。</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">在Java语言中，下列关于字符集编码(Character set encoding) 和国际化(i18n)的问题，哪些是正确的？</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">A 每个中文字符占2个字节，每个英文字符占用1字节</span><br><span class="line">B 假设数据库中的字符是GBK编码的，那么显示数据库数据的网页也必须是GBK编码的</span><br><span class="line">C Java的char类型，通常以UTF-16 Big Endian的方式保存一个字符</span><br><span class="line">D 实现国际化应用常用的手段是利用ResourceBundle类</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">正确答案：CD</span><br><span class="line">解析：</span><br><span class="line">A Java一律采用Unicode编码方式，每个字符无论中文还是英文都占用2个字节</span><br><span class="line">B 不同的编码之间是可以转换的</span><br><span class="line">C Java虚拟机中通常使用UTF-16的方式保存一个字符</span><br><span class="line">D ResourceBundle能够根据Local的不同，选择性的读取Local对应后缀的properties文件，以达到国际化的目的</span><br></pre></td></tr></table></figure>

<h2 id="20210402"><a href="#20210402" class="headerlink" title="20210402"></a>20210402</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">关于ASCII码和ANSI码，以下说法不正确的是？</span><br><span class="line">-------------------------------------</span><br><span class="line">A 标准ASCII码只使用7个bit</span><br><span class="line">B 在简体中文的Windows系统中，ANSI就是GB2312</span><br><span class="line">C ASCII码是ANSI码的子集</span><br><span class="line">D ASCII码都是可以可打印字符</span><br><span class="line">-------------------------------------</span><br><span class="line">正确答案：D</span><br><span class="line">解析：</span><br><span class="line">* 标准ASCII只是用7个bit，扩展的ASCII使用8个bit</span><br><span class="line">* ANSI通常使用0x00~0x7f范围的1个字节来表示1个英文字符。超出此范围的使用0x80~0xFFFF来编码，即扩展的ASCII编码。不同的ANSI编码之间互不兼容。在简体中文的windows操作系统中，ANSI编码代码GBK编码；在繁体中文Windows操作系统中，ANSI代表Big5；在日文Windows操作系统中，ANSI编码代表Shift_JIS编码。</span><br><span class="line">* ANSI通常使用0x00~0x7f范围的一个字节来表示1个英文字符，即ASCII码</span><br><span class="line">* ASCII码包含一些特殊空字符</span><br></pre></td></tr></table></figure>

<h2 id="20210404"><a href="#20210404" class="headerlink" title="20210404"></a>20210404</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">事务隔离级别是由谁实现的？</span><br><span class="line">-------------------------</span><br><span class="line">A Java应用程熙</span><br><span class="line">B Hibernate</span><br><span class="line">C 数据库系统</span><br><span class="line">D JDBC驱动程序</span><br><span class="line">--------------------------</span><br><span class="line">正确答案：C</span><br><span class="line">解析：</span><br><span class="line">* 事务隔离级别是由数据库系统实现，是数据库系统本身的一个功能</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">当我们需要所有线程都执行到某一处，才进行后面的代码执行我们可以使用？</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">A CountDownLatch</span><br><span class="line">B CyclicBarrier</span><br><span class="line">C Semaphore</span><br><span class="line">D Future</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">正确答案：A</span><br><span class="line">解析：</span><br><span class="line">* CountDownLatch允许一个线程或多个线程等待特定情况，同步完成线程中其他任务</span><br><span class="line">* CyclicBarrier和CountDownLatch一样可以协同多个线程，让指定数量的线程等待其他所有线程满足某些条件之后才继续执行</span><br><span class="line">* Semaphore通常叫它信号量，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源</span><br><span class="line">* Future表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后作出相应的操作</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">下面的对象创建方法中哪些会调用构造方法？</span><br><span class="line">-----------------------------------</span><br><span class="line">A new语句创建对象</span><br><span class="line">B 调用Java.io.ObjectInputStream的readObject方法</span><br><span class="line">C java反射机制使用java.lang.Class或java.lang.reflect.Constructor的newInstance()方法</span><br><span class="line">D 调用对象的clone()方法</span><br><span class="line">-------------------------------------</span><br><span class="line">正确答案：AC</span><br><span class="line">解析：</span><br><span class="line">* 构造函数的作用是完成对象的初始化</span><br><span class="line">* B和D中，对象的初始化并不是通过构造函数完成的，而是读取别的内存中的对象的各个域来完成的</span><br><span class="line">* new和反射都可以创建对象，但需要注意的是它们创建对象时执行的构造函数的类型不一样</span><br><span class="line">* new方式创建对象，其初始化过程中可以执行带参的构造器，也可以执行无参构造器</span><br><span class="line">* 反射，通过静态的newInstance()方法，其执行的构造器一定是无参构造器。</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">下面哪些赋值语句是正确的？</span><br><span class="line">---------------------------</span><br><span class="line">A long test=012</span><br><span class="line">B float f=-412</span><br><span class="line">C int other=(int)true</span><br><span class="line">D double d=0x12345678</span><br><span class="line">E byte b=128</span><br><span class="line">---------------------------</span><br><span class="line">正确答案：ABD</span><br><span class="line">解析：</span><br><span class="line">* 012默认为int类型，赋给long型没错</span><br><span class="line">* -412默认为int类型，赋给float没错</span><br><span class="line">* C中布尔类型无法强制转换为int或其他数值类型</span><br><span class="line">* 0x12345678默认应该是int型，赋值给double没错</span><br><span class="line">* E中128&gt;127默认为int类型，然而byte默认范围为-128~127(-2^7~2^7-1)</span><br></pre></td></tr></table></figure>

<h2 id="20210405"><a href="#20210405" class="headerlink" title="20210405"></a>20210405</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">JSP表达式的写法：</span><br><span class="line">---------------</span><br><span class="line">A &lt;% expression %&gt;</span><br><span class="line">B &lt;=% expression %&gt;</span><br><span class="line">C &lt;%= expression %&gt;</span><br><span class="line">D &lt;expression/&gt;</span><br><span class="line">----------------</span><br><span class="line">正确答案：C</span><br><span class="line">解析：</span><br><span class="line">* jsp表达式：&lt;%=变量或表达式%&gt;</span><br><span class="line">* jsp脚本：&lt;% java代码 %&gt;</span><br><span class="line">* jsp声明：&lt;%!变量或方法 %&gt;</span><br><span class="line">* jsp注释：&lt;%!--jsp注释--%&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">下面关于变量及其范围的陈述不正确的是？</span><br><span class="line">----------------------------------</span><br><span class="line">A 实例变量是类的成员变量</span><br><span class="line">B 实例变量用关键字static声明</span><br><span class="line">C 在方法中定义的局部变量在该方法被执行时创建</span><br><span class="line">D 局部变量在使用前必须被初始化</span><br><span class="line">-----------------------------------</span><br><span class="line">正确答案：BC</span><br><span class="line">解析：</span><br><span class="line">* 类的成员变量包括实例变量和类变量(静态变量)，成员方法包括实例方法和类方法(静态方法)</span><br><span class="line">* 类变量(静态变量)用关键字static声明</span><br><span class="line">* 方法中的局部变量在方法被调用加载时开始入栈时创建，方法入栈创建栈帧包括局部变量表操作数栈，局部变量表存放局部变量，并非在执行该方法时被创建</span><br><span class="line">* 局部变量被使用前必须初始化</span><br></pre></td></tr></table></figure>

<h2 id="20210406"><a href="#20210406" class="headerlink" title="20210406"></a>20210406</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">以下代码段执行后的输出结果为：</span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(test());</span><br><span class="line">&#125;</span><br><span class="line">private static int test()&#123;</span><br><span class="line">int temp = 1;</span><br><span class="line">try&#123;</span><br><span class="line">System.out.println(temp);</span><br><span class="line">return ++temp;</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">System.out.println(temp);</span><br><span class="line">return ++temp;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">++temp;</span><br><span class="line">System.out.println(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------</span><br><span class="line">A 1,2,2</span><br><span class="line">B 1,2,3</span><br><span class="line">C 1,3,3</span><br><span class="line">D 1,3,2</span><br><span class="line">-------------------------</span><br><span class="line">正确答案：D</span><br><span class="line">解析：</span><br><span class="line">* 输出try里面的初始temp：1；temp=2；保存return里面temp的值：2；执行finally的语句temp：3，输出temp：3；返回try中的return语句，返回存在里面的temp的值：2；输出temp:2。</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Java8中，下面哪个类用到了解决哈希冲突的开放定址法</span><br><span class="line">---------------------------------------------</span><br><span class="line">A LinkedHashSet</span><br><span class="line">B HashMap</span><br><span class="line">C ThreadLocal</span><br><span class="line">D TreeMap</span><br><span class="line">---------------------------------------------</span><br><span class="line">正确答案：C</span><br><span class="line">解析：</span><br><span class="line">* HashMap链地址法</span><br><span class="line">* ThreadLocal开放式地址</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">下列哪些操作会使线程释放锁资源？</span><br><span class="line">----------------------------</span><br><span class="line">A sleep()</span><br><span class="line">B wait()</span><br><span class="line">C join()</span><br><span class="line">D yield()</span><br><span class="line">----------------------------</span><br><span class="line">正确答案：BC</span><br><span class="line">解析：</span><br><span class="line">* sleep() 在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。sleep()使当前线程进入阻塞状态，在指定时间内不会执行。</span><br><span class="line">* wait() 在其他线程调用对象的notify或nitifyAll方法前，导致当前线程等待。线程会释放掉它所占有的&quot;锁标志&quot;，从而使别的线程有机会抢占该锁。当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。waite()和notify()必须在synchronized函数或synchronized block中进行调用。如果non-synchronized block中进行调用，虽然能通过编译，但在运行时会发生IllegalMonitorStateException的异常。</span><br><span class="line">* yield() 暂停当前正在执行的线程对象。yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。yield()只能使同优先级或更高优先级的线程有执行的机会。</span><br><span class="line">* join() 等待该线程终止。等待调用join方法的线程结束，再继续执行。如t.join()主要用于等待t线程运行结束，如无此句，main则会执行完毕，导致结果不可预测。</span><br></pre></td></tr></table></figure>

<h2 id="20210407"><a href="#20210407" class="headerlink" title="20210407"></a>20210407</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">String s = new String(&quot;xyz&quot;);创建了几个StringObject？</span><br><span class="line">----------------------------------------------------</span><br><span class="line">A 两个或一个都有可能</span><br><span class="line">B 两个</span><br><span class="line">C 一个</span><br><span class="line">D 三个</span><br><span class="line">----------------------------------------------------</span><br><span class="line">正确答案：A</span><br><span class="line">解析：</span><br><span class="line">* String对象的两种创建方式：</span><br><span class="line">* 第一种方式：String str1 = &quot;aaa&quot;;是在常量池中获取对象(&quot;aaa&quot;属于字符串字面量，u因此编译时期会在常量池中创建一个字符串对象)</span><br><span class="line">* 第二种方式：String str2 = new String(&quot;aaa&quot;)；一共会创建两个字符串对象一个在堆中，一个在常量池中(前提是常量池中还没有&quot;aaa&quot;字符串对象)</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">问这个程序的输出结果是什么？</span><br><span class="line">-------------------------</span><br><span class="line">package Wangyi;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">    public void method()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Base&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">class Son extends Base</span><br><span class="line">&#123;</span><br><span class="line">    public void method()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Son&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void methodB()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;SonB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test01</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Base base = new Son();</span><br><span class="line">        base.method();</span><br><span class="line">        base.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------</span><br><span class="line">A Base SonB</span><br><span class="line">B Son SonB</span><br><span class="line">C Base Son SonB</span><br><span class="line">D 编译不通过</span><br><span class="line">-------------------------------</span><br><span class="line">正确答案：D</span><br><span class="line">解析：</span><br><span class="line">* 多态问题，编译看左边，运行看右边。编译的时候没有该方法，运行的时候结果看new的对象是谁，就调用的谁。</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">下面选项中，哪些是interface中合法的定义？</span><br><span class="line">-------------------------------------</span><br><span class="line">A public void mian(String[] args);</span><br><span class="line">B private int getSum();</span><br><span class="line">C boolean setFlag(Boolean[] test);</span><br><span class="line">D public float get(int x);</span><br><span class="line">-------------------------------------</span><br><span class="line">正确答案：ACD</span><br><span class="line">解析：</span><br><span class="line">* interface中的默认方法为public abstract的，变量默认为public static final</span><br><span class="line">* JDK8以后，允许我们在接口中定义static方法和default方法</span><br></pre></td></tr></table></figure>

<h2 id="20210408"><a href="#20210408" class="headerlink" title="20210408"></a>20210408</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">执行以下代码的输出结果是？</span><br><span class="line">----------------------</span><br><span class="line">public class Demo&#123;</span><br><span class="line">　public static void main(String args[])&#123;</span><br><span class="line">　　　int num = 10;</span><br><span class="line">　　　System.out.println(test(num));</span><br><span class="line">&#125;</span><br><span class="line">public static int test(int b)&#123;</span><br><span class="line">　　　try</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　　b += 10;</span><br><span class="line">　　　　return b;</span><br><span class="line">　　　&#125;</span><br><span class="line">　　　catch(RuntimeException e)</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　&#125;</span><br><span class="line">　　　catch(Exception e2)</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　&#125;</span><br><span class="line">　　　finally</span><br><span class="line">　　　&#123;</span><br><span class="line">　　　　b += 10;</span><br><span class="line">　　　　return b;</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">A 10</span><br><span class="line">B 20</span><br><span class="line">C 30</span><br><span class="line">D 40</span><br><span class="line">-------------------</span><br><span class="line">正确答案：C</span><br><span class="line">解析：</span><br><span class="line">* 如果finally块中有return语句的话，它将覆盖掉函数中其他return语句。</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">URL u = new URL(&quot;http://www.123.com&quot;);如果www.123.com不存在，则返回</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">A http://www.123.com</span><br><span class="line">B &quot;&quot;</span><br><span class="line">C null</span><br><span class="line">D 抛出异常</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">正确答案：A</span><br><span class="line">解析：</span><br><span class="line">* new URL()时必须捕获检查异常，这个异常是由于字符串的格式和URL不符合导致的，与网址是否存在无关。URL的toStream方法返回字符串，无论网址是否存在。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于Java集合下列说法不正确的有哪些？</span><br><span class="line">--------------------------------</span><br><span class="line">A hashSet它是线程安全的，不允许存储相同的对象</span><br><span class="line">B ConcurrentHashMap它是线程安全的，其中存储的键的对象可以重复，值对象不能重复</span><br><span class="line">C Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用</span><br><span class="line">D ArrayList线程安全的，允许存放重复对象</span><br><span class="line">-----------------------------------</span><br><span class="line">正确答案：ABD</span><br><span class="line">解析：</span><br><span class="line">* HashSet不是线程安全的，属于Set接口下的实现类，Set下的实现类特征就是无序，不允许存储相同的对象</span><br><span class="line">* ConcurrentHashMap它是线程安全的的，其中存储的值对象可以重复键对象不能重复</span><br><span class="line">* Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用</span><br><span class="line">* ArrayList线程不安全的，底层是数组实现的，允许存放重复对象</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">以下哪些JVM的垃圾回收方式采用的是复制算法回收？</span><br><span class="line">------------------------------------------</span><br><span class="line">A 新生代串行收集器</span><br><span class="line">B 老年代串行收集器</span><br><span class="line">C 并行收集器</span><br><span class="line">D 新生代并行回收收集器</span><br><span class="line">E 老年代并行回收收集器</span><br><span class="line">F cms收集器</span><br><span class="line">------------------------------------------</span><br><span class="line">正确答案：AD</span><br><span class="line">解析：</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_206</title>
    <url>/2020/10/24/LeetCode-206/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Leetcode-206"><a href="#Leetcode-206" class="headerlink" title="Leetcode 206"></a>Leetcode 206</h1><h2 id="反转一个单链表。"><a href="#反转一个单链表。" class="headerlink" title="反转一个单链表。"></a>反转一个单链表。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<h3 id="遍历法"><a href="#遍历法" class="headerlink" title="遍历法"></a>遍历法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            </span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solutin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode newNode = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2021/03/05/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="数据库的概述"><a href="#数据库的概述" class="headerlink" title="数据库的概述"></a>数据库的概述</h2><p><strong>什么是数据库：</strong><br>数据库就是用来存储和管理数据的仓库！</p>
<p><strong>数据库存储数据的优点：</strong></p>
<ul>
<li>可以存储大量的数据</li>
<li>方便检索</li>
<li>保持数据的一致性、完整性</li>
<li>安全，可共享</li>
<li>通过组合分析，可产生新数据</li>
</ul>
 <span id="more"></span> 

<p><strong>数据库的发展历程：</strong></p>
<ul>
<li>没有数据库，使用磁盘文件存储数据</li>
<li>层次结构模型数据库</li>
<li>网状结构模型数据库</li>
<li>关系结构模型数据库：使用二维表格来存储数据</li>
<li>关系-对象模型数据库</li>
</ul>
<p>MySQL就是关系型数据库！</p>
<p><strong>常见数据库：</strong></p>
<ul>
<li>Oracle：甲骨文</li>
<li>BD2：IBM</li>
<li>SQL Server：微软</li>
<li>Sybase：塞尔斯</li>
<li>MySQL：甲骨文</li>
</ul>
<p><strong>理解数据库：</strong></p>
<ul>
<li>RDBMS = manager + database</li>
<li>database = N 个 table</li>
<li>table：<ul>
<li>表结构：定义表的列名和列类型</li>
<li>表记录： 一行一行的记录</li>
</ul>
</li>
</ul>
<p>我们现在所说的数据库泛指：关系型数据库管理系统(RDBMS-Relational database management system)，即数据库服务器。当我们安装了数据库服务器后，就可以在数据库服务器中创建数据库，每个数据库中还可以包含多张表。<br>数据库表就是一个多行多列的表格。在创建时，需要指定表的列数，以及列名称，列类型等信息。而不用指定表格的行数，行数是没有上限的。<br>当把表格创建好了之后，就可以向表格中添加数据了。向表格添加数据是以行为单位的。</p>
<h2 id="Java应用与数据库的关系"><a href="#Java应用与数据库的关系" class="headerlink" title="Java应用与数据库的关系"></a>Java应用与数据库的关系</h2><p>应用程序向数据库请求数据、并显示结果。数据库服务器响应和提供数据。</p>
<hr>
<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>安装文件存放路径不能有中文</p>
<h2 id="删除MySQL"><a href="#删除MySQL" class="headerlink" title="删除MySQL"></a>删除MySQL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure>

<p>删除前先停止mysql；添加删除程序；到安装目录删除MySQL；删除：c:\Documents and settings\All Users\Application Data\MySQL c:\ProgramData\MySQL；查看注册表 regedit：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\MySQL、HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\MySQL、搜索mysql，最后重启电脑。</p>
<h2 id="MySQL安装路径以及配置信息"><a href="#MySQL安装路径以及配置信息" class="headerlink" title="MySQL安装路径以及配置信息"></a>MySQL安装路径以及配置信息</h2><p><strong>MySQL安装成功后会在两个目录中存储文件：</strong></p>
<ul>
<li>D:\Program Files\MySQL Server</li>
<li>c:\ProgramData\MySQL Server</li>
</ul>
<p><strong>MySQL重要文件：</strong></p>
<ul>
<li>mysql.exe：客户端程序</li>
<li>mysqld.exe：服务器程序</li>
<li>my.ini：服务器配置文件</li>
</ul>
<p><strong>my.ini：MySQL最为重要的配置文件：</strong></p>
<ul>
<li>配置MySQL的端口</li>
<li>配置字符编码</li>
<li>配置二进制数据大小上限</li>
</ul>
<h2 id="开启关闭服务器以及登录退出客户端"><a href="#开启关闭服务器以及登录退出客户端" class="headerlink" title="开启关闭服务器以及登录退出客户端"></a>开启关闭服务器以及登录退出客户端</h2><p>开启服务器：net.start.mysql；关闭服务器：net.stop.mysql</p>
<p>登陆服务器：mysql -uroot -p123 -hlocalhost</p>
<ul>
<li>-u后面跟用户名</li>
<li>-p后面跟密码</li>
<li>-h后面跟ip</li>
</ul>
<p>退出服务器：exit或quit</p>
<hr>
<h2 id="SQL语言的概述"><a href="#SQL语言的概述" class="headerlink" title="SQL语言的概述"></a>SQL语言的概述</h2><p><strong>SQL</strong></p>
<p>1.什么是SQL：结构化查询语言(Structured Query Language)。<br>2.SQL的作用：客户端使用SQL来操作服务器。<br>3.SQL标准(例如SQL99)。<br>4.SQL方言：某种DBMS不只能支持SQL标准，而且还会有一些自己独有的语法，这称为方言！例如limit语句只在MySQL中可以使用。</p>
<p><strong>SQL语法</strong></p>
<p>1.SQL语句可以在单行或多行书写，以分号结尾<br>2.可以使用空格和缩进增强语句的可读性<br>3.MySQL不区别大小写，建议使用大写</p>
<p><strong>SQL语句分类</strong></p>
<p>1.DDL(Data Definition Language)：数据定义语言，用来定义数据库对象：库、表、列<br>2.DML(Data Manipulation Language)：数据操作语言，用来定义数据库记录<br>3.DCL(Data Control Language)：数据控制语言，用来定义访问权限和安全等级<br>4.DQL(Data Query Language)：数据查询语言，用来查询记录</p>
<hr>
<h2 id="DDL-操作数据库"><a href="#DDL-操作数据库" class="headerlink" title="DDL 操作数据库"></a>DDL 操作数据库</h2><p><strong>1.查询所有数据库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>

<p>2.切换数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建数据库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] 数据库名[CHARSET&#x3D;UTF8];</span><br></pre></td></tr></table></figure>

<p>4.删除数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] 数据库名;</span><br></pre></td></tr></table></figure>

<p><strong>5.修改数据库编码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 数据库名 CHARACTER SET UTF8;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数据类型介绍"><a href="#数据类型介绍" class="headerlink" title="数据类型介绍"></a>数据类型介绍</h2><p>int：整型<br>double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；<br>decimal：浮点型，在表价钱方面使用该类型，不会出现精度损失问题；<br>char：固定长度字符串类型，char(255)，数据的长度不是指定长度，补足到指定长度！例如：身份证，时间<br>varchar：可变长度字符串类型：varchar(65535)。例如：用户名<br>text(clob)：字符串类型</p>
<ul>
<li>tinytext：$2^8-18$B</li>
<li>text：$2^{16}-18$B</li>
<li>mediumtext：$2^{24}-18$B</li>
<li>longtext：$2^{32}-18$B</li>
</ul>
<p>blob：字节类型 可变长度二进制类型</p>
<ul>
<li>tinyblob</li>
<li>blob</li>
<li>mediumblob</li>
<li>longblob</li>
</ul>
<p>date：日期类型，格式为：yyyy-MM-dd<br>time：时间类型，格式为：hh:mm:ss<br>timestamp：时间戳类型</p>
<hr>
<h2 id="DDL操作表"><a href="#DDL操作表" class="headerlink" title="DDL操作表"></a>DDL操作表</h2><p><strong>1.创建表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] 表名(</span><br><span class="line">	列名 列类型,</span><br><span class="line">	列名 列类型,</span><br><span class="line">	...</span><br><span class="line">	列名 列类型</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tb_stu(</span><br><span class="line">	number char(11),</span><br><span class="line">	name varchar(50),</span><br><span class="line">	age int,</span><br><span class="line">	gender varchar(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>2.查看当前数据库中所有表名称</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<p><strong>3.查看指定表的创建语句</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure>

<p>4.查看表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>

<p><strong>5.删除表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE 表名;</span><br></pre></td></tr></table></figure>

<p>6.修改表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD(</span><br><span class="line">	列名 列类型,</span><br><span class="line">	列名 列类型,</span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 新列类型;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 列名;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 原表名 RENAME TO 新表名</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p><strong>1.插入数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名(</span><br><span class="line">	列名1,列名2,列名3,...</span><br><span class="line">)VALUES(</span><br><span class="line">	列值1,列值2,列值3,...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;插入所有列</span><br><span class="line">INSERT INTO stu(</span><br><span class="line">	number,name,age,gender</span><br><span class="line">)VALUES(</span><br><span class="line">	&#39;ITCAST_0001&#39;, &#39;zhangsan&#39;, 28, &#39;male&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;插入部分列，没有插入的列，为默认值NULL</span><br><span class="line">INSERT INTO stu(</span><br><span class="line">	number,name</span><br><span class="line">)VALUES(</span><br><span class="line">	&#39;ITCAST_0002&#39;, &#39;lisi&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;不给出插入列，那么默认值为插入所有列，值的顺序与创建列的顺序相同</span><br><span class="line">INSERT INTO stu VALUES(</span><br><span class="line">	&#39;ITCAST_0003&#39;, &#39;wangwu&#39;, 54, &#39;male&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>2.修改数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE 表名 SET 列名1&#x3D;列值, 列名2&#x3D;列值, ...[WHERE 条件];</span><br></pre></td></tr></table></figure>

<p>条件必须是一个boolean类型的值或表达式：UPDATE t_person SET gender=‘男’, age = age + 1 WHERE sid=‘1’;<br>运算符：=、!=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=、BETWEEN…AND、IN、IS NULL、NOT、OR、AND</p>
<p><strong>3.删除表记录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM 表名[WHERE 条件];</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="DCL数据控制语言"><a href="#DCL数据控制语言" class="headerlink" title="DCL数据控制语言"></a>DCL数据控制语言</h2><p><strong>1.创建用户</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER 用户名@IP地址 IDENTIFIED BY &#39;密码&#39;;&#x2F;&#x2F;用户只能在指定的IP地址上登录</span><br><span class="line">CREATE USER 用户名@&#39;%&#39; IDENTIFIED BY &#39;密码&#39;;&#x2F;&#x2F;用户可以在任意IP地址上登录</span><br></pre></td></tr></table></figure>

<p>2.给用户授权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT 权限1, ... , 权限n ON 数据库.* TO 用户名@IP地址;</span><br></pre></td></tr></table></figure>

<p>权限、用户、数据库<br>给用户分派在指定的数据库上的指定的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL ON 数据库.* TO 用户名@IP地址;</span><br></pre></td></tr></table></figure>

<p><strong>3.撤销权限</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REVOKE 权限1, ... , 权限n ON 数据库.* FROM 用户名@IP地址;</span><br></pre></td></tr></table></figure>

<p>撤销指定用户在指定数据库上的指定权限</p>
<p><strong>4.查看权限</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GRANT FOR 用户名@IP地址;</span><br></pre></td></tr></table></figure>

<p><strong>5.删除用户</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP USER 用户名@IP地址;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="DQL基础查询"><a href="#DQL基础查询" class="headerlink" title="DQL基础查询"></a>DQL基础查询</h2><p>1.查询所有列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名;</span><br></pre></td></tr></table></figure>

<p>2.查询指定列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列1 [, 列2, ... , 列N] FROM 表名;</span><br></pre></td></tr></table></figure>

<p>3.完全重复的记录只一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT * 列1 [, 列2, ... , 列N] FROM 表名;</span><br></pre></td></tr></table></figure>

<p>4.列运算</p>
<ul>
<li>数量类型的列可以做加、减、乘、除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名*1.5 FROM 表名;</span><br><span class="line">SELECT 列名1+列名2 FROM 表名;&#x2F;&#x2F;若与NULL相加为NULL</span><br><span class="line">SELECT 列名1+IF NULL(列名2,0) FROM 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串类型可以做连续运算</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(列名1,列名2) FROM 表名;</span><br><span class="line">SELECT CONCAT(&#39;我叫&#39;,列名1,&#39;,是个&#39;,列名2) FROM 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>转换NULL值，有时候需要把NULL值转换成其他值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名1+IFNULL(列名2,0) FROM 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>给列起别名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 列名1 [AS] 别名1,列名2 [AS] 别名2 FROM 表名;</span><br></pre></td></tr></table></figure>

<h2 id="DQL条件查询"><a href="#DQL条件查询" class="headerlink" title="DQL条件查询"></a>DQL条件查询</h2><p>1.条件查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE 条件;</span><br></pre></td></tr></table></figure>

<p>2.模糊查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 WHERE 列名 LIKE 条件;</span><br><span class="line"></span><br><span class="line">SELECT * FROM emp WHERE ename LIKE &#39;张_&#39;;</span><br><span class="line">SELECT * FROM emp WHERE ename LIKE &#39;张__&#39;;</span><br><span class="line">SELECT * FROM emp WHERE ename LIKE &#39;__&#39;;</span><br><span class="line">SELECT * FROM stu WHERE sname LIKE &#39;%刚&#39;;</span><br><span class="line">SELECT * FROM stu WHERE sname LIKE &#39;赵%&#39;;</span><br><span class="line">SELECT * FROM stu WHERE sname LIKE &#39;%小%&#39;;</span><br></pre></td></tr></table></figure>

<p>3.排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 ORDER BY 排序列;</span><br><span class="line">SELECT * FROM 表名 ORDER BY 排序列 ASC;&#x2F;&#x2F;升序</span><br><span class="line">SELECT * FROM 表名 ORDER BY 排序列 DESC;&#x2F;&#x2F;降序</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名 ORDER BY 排序列1 ASC, 排序列2 DESC;</span><br><span class="line">SELECT * FROM 表名 ORDER BY 排序列1 ASC, 排序列2 DESC, 排序列3 ASC;</span><br></pre></td></tr></table></figure>

<p>4.聚合函数</p>
<ul>
<li>COUNT</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) FROM 表名;</span><br><span class="line">SELECT COUNT(列名) FROM 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>MAX</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MAX(列名) FROM 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>MIN</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MIN(列名) FROM 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>SUM</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT SUM(列名) FROM 表名;</span><br></pre></td></tr></table></figure>

<ul>
<li>AVG</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT AVG(列名) FROM 表名;</span><br></pre></td></tr></table></figure>

<p>5.分组查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT job, COUNT(*) FROM emp GROUP BY job;</span><br><span class="line">SELECT gander, COUNT(*) FROM stu GROUP BY gander;</span><br><span class="line">SELECT province, COUNT(*) FROM stu GROUP BY province;</span><br><span class="line">SELECT deptno, COUNT(*) FROM emp WHERE sal &gt; 15000 GROUP BY deptno;</span><br><span class="line">SELECT deptno, COUNT(*) FROM emp WHERE sal &gt; 15000 GROUP BY deptno HAVING COUNT(*) &gt;&#x3D; 2;</span><br></pre></td></tr></table></figure>

<p>顺序：SELECT、FROM、WHERE、GROUP BY、HAVING、ORDER BY</p>
<p>6.limit子句</p>
<p>LIMIT用来限定查询结果的起始行，以及总行数；<br>例如：查询起始行为第5行，<br>一共查询3行记录，SELECT * FROM emp LIMIT 4,3;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp LIMIT 0,5;</span><br><span class="line">SELECT * FROM emp LIMIT 8,5;</span><br></pre></td></tr></table></figure>

<p>一页的记录数：10行；查询第3页。<br>（当前页-1）*每页记录数。</p>
]]></content>
      <categories>
        <category>MySQL基础</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶及查询练习</title>
    <url>/2021/03/19/MySQL%E8%BF%9B%E9%98%B6%E5%8F%8A%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="单表查询练习"><a href="#单表查询练习" class="headerlink" title="单表查询练习"></a>单表查询练习</h2><p>1.查询出部门编号为30的所有员工</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE deptno &#x3D; 30;</span><br></pre></td></tr></table></figure>

<p>2.查询所有销售员的姓名、编号和部门编号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ename, empno, deptno FROM emp WHERE job &#x3D; &#39;销售员&#39;;</span><br></pre></td></tr></table></figure>

 <span id="more"></span> 

<p>3.找出奖金高于工资的员工</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE comm &gt; sal;</span><br></pre></td></tr></table></figure>

<p>4.找出奖金高于工资60%的员工</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE comm &gt; sal*0.6;</span><br></pre></td></tr></table></figure>

<p>5.找出部门编号为10中所有经理，和部门编号为20中所有销售员的详细资料</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE (deptno &#x3D; 10 AND job&#x3D;&#39;经理&#39;) OR (deptno &#x3D; 20 AND job&#x3D;&#39;销售员&#39;);</span><br></pre></td></tr></table></figure>

<p>6.找出部门编号为10中所有经理，和部门编号为20中所有销售员，还有既不是经理又不是销售员但工资大于等于20000的所有员工详细资料</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE (deptno &#x3D; 10 AND job&#x3D;&#39;经理&#39;) OR (deptno &#x3D; 20 AND job&#x3D;&#39;销售员&#39;) OR</span><br><span class="line">(job NOT IN(&#39;经理&#39;,&#39;销售员&#39;) AND sal &gt;&#x3D; 20000);</span><br></pre></td></tr></table></figure>

<p>7.无奖金或奖金低于1000的员工</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE comm IS NULL OR comm &lt; 1000;</span><br></pre></td></tr></table></figure>

<p>8.查询名字由三个字的员工</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE ename LIKE &#39;___&#39;;</span><br></pre></td></tr></table></figure>

<p>9.查询所有员工详细信息，用编号升序排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp ORDER BY empno ASC;</span><br></pre></td></tr></table></figure>

<p>10.查询所有员工详细信息，用工资降序排序，如果工资相同使用入职日期升序排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp ORDER BY sal DESC, hiredate ASC;</span><br></pre></td></tr></table></figure>

<p>11.查询每个部门的平均工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT deptno, AVG(sal) AS 平均工资 FROM emp GROUP BY deptno;</span><br></pre></td></tr></table></figure>

<p>12.查询每个部门的雇员数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT deptno, COUNT(*) FROM emp GROUP BY deptno;</span><br></pre></td></tr></table></figure>

<p>13.查询每种工作的最高工资，最低工资，人数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT job, MAX(sal), MIN(sal), COUNT(*) FROM emp GROUP BY job;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="MySQL编码问题"><a href="#MySQL编码问题" class="headerlink" title="MySQL编码问题"></a>MySQL编码问题</h2><p>1.查看MySQL数据库编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;char%&#39;;</span><br></pre></td></tr></table></figure>

<p>2.编码解释</p>
<ul>
<li>character_set_client：MySQL使用该编码</li>
</ul>
<p>character_set_client：utf8，无论客户端发送的是什么编码的数据，mysql都当成是utf8的数据：若客户端发送的是GBK，服务器会当成utf8，必然乱码！处理手段：让客户端发送utf8 或 把character_set_client：修改为gbk。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET character_set_client &#x3D; gbk;&#x2F;&#x2F;只在当前窗口有效</span><br></pre></td></tr></table></figure>

<ul>
<li>character_set_result：把数据用什么编码发送给客户端。</li>
</ul>
<p>若服务器发送给客户端是utf8的数据，客户端会把它当成gbk，在cmd窗口中只显示gbk，必然乱码！处理手段：把character_set_client：修改为gbk。</p>
<p>在my.ini中进行配置，他可以修改client、result、connection。</p>
<hr>
<h2 id="MySQL备份与恢复数据"><a href="#MySQL备份与恢复数据" class="headerlink" title="MySQL备份与恢复数据"></a>MySQL备份与恢复数据</h2><p>数据库 –&gt; sql语句</p>
<p>sql语句 –&gt; 数据库</p>
<p><strong>1.数据库导出SQL脚本</strong>(备份数据库内容，不是备份数据库)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u用户名 -p密码 -hip地址 数据库名&gt;生成sql脚本的路径</span><br></pre></td></tr></table></figure>

<p><strong>2.执行SQL脚本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u用户名 -p密码 -hip地址 数据库名&lt;脚本文件路径</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><strong>1.主键约束</strong></p>
<ul>
<li>非空性</li>
<li>唯一性</li>
<li>被引用</li>
</ul>
<p>当表的某一列被指定为主键后，该列就不能为空，不能有重复出现。</p>
<p><strong>创建表时指定主键的两种方式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">    empno INT PRIMARY KEY,</span><br><span class="line">    ename VARCHAR(50);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO exp VALUES(1,&quot;zhangsan&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE exp(</span><br><span class="line">	empno INT,</span><br><span class="line">	ename VARCHAR(50),</span><br><span class="line">	PRIMARY KEY(empno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>修改表时指定主键：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD PRIMARY KEY(empno); </span><br></pre></td></tr></table></figure>

<p><strong>删除主键：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<p><strong>2.主键自增长</strong></p>
<p>因为主键列的特性是：必须唯一，不能为空，所以我们通常会指定主键类为整型，然后设置自动增长，这样可以保证在插入数据时主键列的唯一和非空特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_stu(</span><br><span class="line">	sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	sname VARCHAR(20),</span><br><span class="line">	age INT,</span><br><span class="line">	gender VARCHAR(10)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO t_stu VALUES(NULL,&#39;zhangsan&#39;,28,&#39;male&#39;);</span><br></pre></td></tr></table></figure>

<p><strong>3.非空约束</strong></p>
<p>因为某些列不能设置为NULL值，所以可以对列添加非空约束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	sname VARCHAR(20) NOT NULL,</span><br><span class="line">	age INT,</span><br><span class="line">	gender VARCHAR(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>4.唯一约束</strong></p>
<p>某些列不能设置重复的值，所以可以对列添加唯一约束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">	sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	sname VARCHAR(20) NOT NULL UNIQUE,</span><br><span class="line">	age INT,</span><br><span class="line">	gender VARCHAR(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>5.概念模型</strong></p>
<p>实体之间存在着关系，关系有三种：</p>
<ul>
<li>一对多</li>
<li>一对一</li>
<li>多对多</li>
</ul>
<p><strong>6.外键约束</strong></p>
<p>外键必须是另一表的主键的值(外键要引用主键)，外键可以重复，外键可以为空。一张表中可以有多个外键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">	empno INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    ename VARCHAR(50),</span><br><span class="line">    deptno INT,</span><br><span class="line">    CONSTRAINT fk_emp_dept FOREIGN KEY(deptno) REFERENCES dept(deptno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改表添加外键约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp ADD CONSTRAINT fk_emp_dept FOREIGN KEY(deptno) REFERENCES dept(deptno);</span><br></pre></td></tr></table></figure>

<p> <strong>7.一对一关系</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE husband(</span><br><span class="line">	hid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    hname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO husband VALUES(NULL,&#39;刘备&#39;);</span><br><span class="line">INSERT INTO husband VALUES(NULL,&#39;关羽&#39;);</span><br><span class="line">INSERT INTO husband VALUES(NULL,&#39;张飞&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM husband;</span><br><span class="line"></span><br><span class="line">CREATE TABLE wife(</span><br><span class="line">	wid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    wname VARCHAR(50),</span><br><span class="line">    CONSTRAINT fk_wife_husband FOREIGN KEY(wid) REFERENCES husband(hid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO wife VALUES(1,&#39;杨贵妃&#39;);</span><br><span class="line">INSERT INTO wife VALUES(2,&#39;妲己&#39;);</span><br></pre></td></tr></table></figure>

<p><strong>8.多对多关系</strong></p>
<p>在表中建立多对多关系需要使用中间表，即需要三张表，在中间表中使用两个外键，分别引用其他两个表的主键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student(</span><br><span class="line">	sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    sname VARCHAR(50) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE teacher(</span><br><span class="line">	tid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    tname VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE stu_tea(</span><br><span class="line">	sid INT,</span><br><span class="line">    tid INT</span><br><span class="line">    CONSTRAINT fk_student FOREIGN KEY(sid) REFERENCES student(sid),</span><br><span class="line">    CONSTRAINT fk_teacher FOREIGN KEY(tid) REFERENCES teacher(tid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO student VALUES(NULL,&#39;刘德华&#39;);</span><br><span class="line">INSERT INTO student VALUES(NULL,&#39;梁朝伟&#39;);</span><br><span class="line">INSERT INTO student VALUES(NULL,&#39;黄日华&#39;);</span><br><span class="line">INSERT INTO student VALUES(NULL,&#39;苗侨伟&#39;);</span><br><span class="line">INSERT INTO student VALUES(NULL,&#39;汤朕业&#39;);</span><br><span class="line"></span><br><span class="line">INSERT INTO teacher VALUES(NULL,&#39;崔老师&#39;);</span><br><span class="line">INSERT INTO teacher VALUES(NULL,&#39;刘老师&#39;);</span><br><span class="line">INSERT INTO teacher VALUES(NULL,&#39;石老师&#39;);</span><br><span class="line"></span><br><span class="line">INSERT INTO stu_tea VALUES(1,1);</span><br><span class="line">INSERT INTO stu_tea VALUES(2,1);</span><br><span class="line">INSERT INTO stu_tea VALUES(3,1);</span><br><span class="line">INSERT INTO stu_tea VALUES(4,1);</span><br><span class="line">INSERT INTO stu_tea VALUES(5,1);</span><br><span class="line"></span><br><span class="line">INSERT INTO stu_tea VALUES(2,2);</span><br><span class="line">INSERT INTO stu_tea VALUES(3,2);</span><br><span class="line">INSERT INTO stu_tea VALUES(4,2);</span><br><span class="line"></span><br><span class="line">INSERT INTO stu_tea VALUES(3,3);</span><br><span class="line">INSERT INTO stu_tea VALUES(4,3);</span><br><span class="line">INSERT INTO stu_tea VALUES(5,3);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><ul>
<li>合并结果集</li>
<li>连接查询</li>
<li>子查询</li>
</ul>
<p><strong>合并结果集</strong></p>
<ul>
<li>要求被合并的表中，列的类型和列数相同</li>
<li>UNION，去除重复行</li>
<li>UNION ALL 不去重复</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE ab(</span><br><span class="line">	a INT,</span><br><span class="line">    b VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO ab VALUES(1,&#39;1&#39;);</span><br><span class="line">INSERT INTO ab VALUES(2,&#39;2&#39;);</span><br><span class="line">INSERT INTO ab VALUES(3,&#39;3&#39;);</span><br><span class="line"></span><br><span class="line">CREATE TABLE cd(</span><br><span class="line">	c INT,</span><br><span class="line">    d VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO ab VALUES(3,&#39;3&#39;);</span><br><span class="line">INSERT INTO ab VALUES(4,&#39;4&#39;);</span><br><span class="line">INSERT INTO ab VALUES(5,&#39;5&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM ab</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT * FROM cd;</span><br><span class="line"></span><br><span class="line">SELECT * FROM ab</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM cd;</span><br></pre></td></tr></table></figure>

<p><strong>连接查询</strong></p>
<p><strong>1.内连接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#笛卡尔积</span><br><span class="line">SELECT * FROM emp, dept;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#用条件去除笛卡尔积产生的垃圾数据</span><br><span class="line">SELECT * FROM emp, dept WHERE exp.deptno&#x3D;dept.deptno;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT emp.ename, emp.sal, dept.dname FROM emp, dept WHERE exp.deptno&#x3D;dept.deptno;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT e.ename, e.sal, d.dname FROM emp e, dept d WHERE e.deptno&#x3D;d.deptno;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#标准写法</span><br><span class="line">SELECT * FROM 表1 别名1 INNER JOIN 表2 别名2 ON 别名1.xx &#x3D; 别名2.xx;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#标准写法</span><br><span class="line">SELECT e.ename, e.sal, d.dname FROM emp e INNER JOIN dept d ON e.deptno&#x3D;d.deptno;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表1 别名1 NATURAL JOIN 表2 别名2;</span><br></pre></td></tr></table></figure>

<p><strong>2.外连接</strong></p>
<p>外连接有一主一次，左外即为左主；即emp为主，那么主表中所有的记录无论满足不满足条件都打印出来。当不满足条件时，右表部分使用null补位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#左外连接</span><br><span class="line">SELECT e.ename, e.sal, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno&#x3D;d.deptno;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT e.ename, e.sal, IFNULL(d.dname,&#39;无部门&#39;) AS dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno&#x3D;d.deptno;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#右外连接</span><br><span class="line">SELECT e.ename, e.sal, d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno&#x3D;d.deptno;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#全外连接 &#x3D; 左外连接+右外连接+合并结果集</span><br><span class="line">SELECT e.ename, e.sal, d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno&#x3D;d.deptno</span><br><span class="line">UNION</span><br><span class="line">SELECT e.ename, e.sal, d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno&#x3D;d.deptno;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>查询中有查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询本公司工资最高的员工的详细信息</span><br><span class="line">SELECT * FROM emp WHERE sal&#x3D;(SELECT MAX(sal) FROM emp);</span><br></pre></td></tr></table></figure>

<p>子查询出现的位置：</p>
<ul>
<li>WHERE后作为条件存在</li>
<li>FROM后作为表存在</li>
</ul>
<p>条件：</p>
<ul>
<li>单行单列：SELECT * FROM 表1 别名1 WHERE 列1 [=,&gt;,&lt;,&gt;=,&lt;=,!=](SELECT 列 FROM 表2 别名2 WHERE 条件)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE sal &gt; (SELECT AVG(sal) FROM emp)</span><br></pre></td></tr></table></figure>

<ul>
<li>多行单列：SELECT * FROM 表1 别名1 WHERE 列1 [IN,ALL,ANY](SELECT 列 FROM 表2 别名2 WHERE 条件)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM emp WHERE sal &gt; ALL(SELECT sal FROM emp WHERE deptno &#x3D; 20)</span><br></pre></td></tr></table></figure>



<ul>
<li>单行多列：SELECT * FROM 表1 别名1 WHERE (列1,列2) IN(SELECT 列1,列2 FROM 表2 别名2 WHERE 条件)</li>
<li>多行多列：SELECT * FROM 表1 别名1 ,(SELECT ….)别名2 WHERE 条件</li>
</ul>
<hr>
<h2 id="多表查询练习"><a href="#多表查询练习" class="headerlink" title="多表查询练习"></a>多表查询练习</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询至少一个员工的部门，显示部门编号、部门名称、部门位置、部门人数</span><br><span class="line"></span><br><span class="line">SELECT d.*, z1.cnt</span><br><span class="line">SELECT * FROM dept d, (SELECT deptno, COUNT(*) cnt FROM EMP GROUP BY deptno) z1 </span><br><span class="line">WHERE d.deptno&#x3D;z1.deptno</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#列出所有员工的姓名及其直接上级的姓名</span><br><span class="line"></span><br><span class="line">SELECT e1.ename, IFNULL(e2.ename,&#39;BOSS&#39;) 领导 FROM emp e1 LEFT OUTER JOIN emp e2 ON e1.mgr&#x3D;e2.empno;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出受雇日期早于直接上级的所有员工编号，姓名，部门名称</span><br><span class="line"></span><br><span class="line">#先不查部门名称，只查部门编号！</span><br><span class="line">SELECT e1.empno, e1.ename, e1.deptno </span><br><span class="line">FROM emp e1, emp e2</span><br><span class="line">WHERE e1.mgr&#x3D;e2.empno AND e1.hiredate &lt; e2.hiredate;</span><br><span class="line"></span><br><span class="line">SELECT e1.empno, e1.ename, d.dname</span><br><span class="line">FROM emp e1, emp e2, dept d</span><br><span class="line">WHERE e1.mgr&#x3D;e2.empno AND e1.hiredate &lt; e2.hiredate AND e1.deptno &#x3D; d.deptno;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门</span><br><span class="line"></span><br><span class="line">SELECT * </span><br><span class="line">FROM emp e RIGHT OUTER JOIN dept d</span><br><span class="line">ON e.deptno&#x3D;d.deptno</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#列出最低薪金大于15000的各种工作及从事此工作的员工人数</span><br><span class="line"></span><br><span class="line">SELECT job, COUNT(*) </span><br><span class="line">FROM emp e </span><br><span class="line">GROUP BY job</span><br><span class="line">HAVING MIN(sal) &gt; 15000;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#列出在销售工作的员工的姓名，假定不知道销售部门的部门编号</span><br><span class="line"></span><br><span class="line">SELECT e.ename</span><br><span class="line">FROM emp e</span><br><span class="line">WHERE e.deptno&#x3D;(SELECT deptno FROM dept WHERE dname&#x3D;&#39;销售部&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#列出薪金高于公司平均薪金的所有员工信息，所在部门名称，上级领导，工资等级</span><br><span class="line"></span><br><span class="line">SELECT e.*, d.name, m.ename, s.grade</span><br><span class="line">FROM emp e LEFT OUTER JOIN dept d ON e.deptno&#x3D;d.deptno</span><br><span class="line">		  LEFT OUTER JOIN emp m ON e.mgr&#x3D;m.empno</span><br><span class="line">		  LEFT OUTER JOIN salgrade s ON e.sal BETWEEN s.losal AND s.hisal</span><br><span class="line">WHERE e.sal &gt; (SELECT VAG(sal) FROM emp)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#列出与庞统从事相同工作的所有员工及部门名称</span><br><span class="line"></span><br><span class="line">SELECT e.*, d.dname</span><br><span class="line">FROM emp e, dept d</span><br><span class="line">WHERE e.deptno &#x3D; d.deptno AND job&#x3D;(SELECT job FROM emp WHERE ename&#x3D;&#39;庞统&#39;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#列出薪金高于在部门30工作的所有员工的薪金的员工姓名和薪金、部门名称</span><br><span class="line"></span><br><span class="line">SELECT e.ename, e.sal, d.dname</span><br><span class="line">FROM emp e, dept d</span><br><span class="line">WHERE e.deptno &#x3D; d.deptno AND sal &gt; ALL (SELECT sal FROM emp WHERE deptno&#x3D;30);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查出年份、利润、年度增长比</span><br><span class="line">SELECT y1.*, IFNULL(CONCAT((y1.zz-y2.zz)&#x2F;y2.zz*100,&#39;%&#39;),&#39;0%&#39;) 增长率 </span><br><span class="line">FROM tb_year y1 LEFT OUTER JOIN tb_year y2</span><br><span class="line">ON y1.year&#x3D;y2.year+1;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>MySQL基础</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>你不了解的WiFi</title>
    <url>/2020/07/08/%E4%BD%A0%E4%B8%8D%E4%BA%86%E8%A7%A3%E7%9A%84WiFi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-WiFi名字的由来"><a href="#1-WiFi名字的由来" class="headerlink" title="1.WiFi名字的由来"></a>1.WiFi名字的由来</h2><p>WIFI（Wireless Fidelity，无线保真）听起来有点像是HIFI（High-Fidelity，高保真），然后制定无线技术的组织就借用这种深入人心的发音方式取名为WIFI，纯粹就是为了好记。</p>
<h2 id="2-WiFi的频率，信道，调制方式"><a href="#2-WiFi的频率，信道，调制方式" class="headerlink" title="2.WiFi的频率，信道，调制方式"></a>2.WiFi的频率，信道，调制方式</h2><p>WiFi的频段：例如$ 2.4GHz $，并不指的是一个特定的频率，而是一个范围。</p>
<ul>
<li><p>$ 2.4GHz $，指的是:$2.4GHz \sim 2.4835GHz$</p>
</li>
<li><p>$ 5GHz $，指的是:$5.15GHz \sim 5.85GHz$</p>
</li>
</ul>
 <span id="more"></span> 

<p>在$2.4GHz\sim2.4835GHz$之间有大约$8000万Hz$（$1GHz=10亿Hz$）的频率差别，这个范围中分成了很多信道（为了多个设备，多个网络尽可能不产生干扰，虽然都在$ 2.4GHz $大的频段，却工作在不同的信道上）。根据WiFi的标准不同，每个信道的频宽从$ 1MHz \sim 160MHz $不等。</p>
<p>无线主要的调制技术手段有三种：</p>
<ul>
<li><p>DSSS（Direct Sequence Spread Spectrum，直序列扩频调制技术）<br>其占用的频宽较大，可靠性和稳定性是其优点。但民用的无线频段是个有限资源，随着数据越来越大，占用大频宽来保证无线通讯的可靠性的DSSS应用越来越垂直，民用慢慢过渡到OFDM。</p>
</li>
<li><p>FHSS（Frequency-Hopping Spread Spectrum，跳频技术）<br>所谓跳频，比较确切的意思是：用一定码序列进行选择的多频率频移键控。也就是说，用扩频码序列去进行频移键控调制，使载波频率不断地跳变，所以称为跳频。FHSS比DSSS更不易受到干扰，但在传输速率上不及DSSS。</p>
</li>
<li><p>OFDM（Orthogonal Frequency Division Multiplexing，正交频分复用技术）<br>其特点是占用较小的频宽资源，来调制更多的数据，更有效率的利用有限的频宽，能极大的提升调制和传输的数据量。</p>
</li>
</ul>
<p>这些技术手段都是通过合理的方式把数字信号调制成电磁波，通过天线发射出去，接收端收到之后，把调制好的电磁波解码出来，还原成数据信号。</p>
<h2 id="3-主流的WiFi标准"><a href="#3-主流的WiFi标准" class="headerlink" title="3.主流的WiFi标准"></a>3.主流的WiFi标准</h2><ul>
<li><p>1999年第一代：802.11b, Frequency: $ 2.4GHz $, Data Rate:  $ 11Mbps $;</p>
</li>
<li><p>1999年第二代：802.11a, Frequency: $ 5GHz $, Data Rate: $ 54Mbps$;</p>
<ul>
<li>802.11b和802.11a解决的问题是从无到有。</li>
</ul>
</li>
<li><p>2003年第三代：802.11g, Frequency: $ 2.4GHz $, Data Rate: $ 54Mbps $;</p>
<ul>
<li>802.11g解决的问题是：1.通信速率的提高（OFDM实现）；2.向下兼容问题，支持802.11b。</li>
</ul>
</li>
<li><p>2009年第四代：802.11n, Frequency: $ 2.4/5GHz $, Data Rate: $ 288/600Mbps $;</p>
<ul>
<li>1.利用了双频技术，$ 2.4GHz $和$ 5GHz $双频段通信；2.搭载了MIMO（multiple-in multiple-out，多进多出）技术。</li>
<li>其中$ 2.4GHz $频段从802.11g演化而来；$ 5GHz $频段从802.11a演化而来。802.11n的一大特点：对以往标准的兼容性；另一特点是:十几倍的传输速率的提升。</li>
<li>MIMO技术解决的问题是：多个终端多条数据流同时通信的问题。</li>
</ul>
</li>
<li><p>2013年第五代：802.11ac, Frequency: $ 5GHz $, Data Rate: $ 1.6Gbps $;</p>
<ul>
<li>802.11ac兼容性是靠802.11n来兼容的，若是以老旧设备连接802.11ac是通过802.11n来兼容的以前的b，a，g。</li>
<li>同时也引入了一个天线硬件的技术Beam Forming（波束赋形），其通过阵列天线，电磁波可以被天线矩阵通过互相干涉改变电磁波的相位和振幅的这种方式实现转向电磁波传播的方向。通过波束赋形的技术，天线矩阵可以实时追踪设备的位置，始终把最强信号的电磁波送到设备附近。</li>
</ul>
</li>
<li><p>2019年第六代（WIFI6）：802.11ax, Frequency: $ 2.4/5/6GHz $, Data Rate: $ 3.5Gbps $;</p>
<ul>
<li>WIFI6的通信速率提升到了接近万兆网络级别</li>
<li>调制信号的方式从OFDM进一步优化到OFDMA（4GLTE）加强了多用户不同带宽需求同时信号传输能力。</li>
</ul>
</li>
</ul>
<h2 id="Wifi的一些常识知识"><a href="#Wifi的一些常识知识" class="headerlink" title="Wifi的一些常识知识"></a>Wifi的一些常识知识</h2><ul>
<li><p>理论速率和协商速率</p>
<ul>
<li>理论速率是WiFi最高支持的传输速率。</li>
<li>协商速率是实际使用过程中你的无线设备连接到路由器的实际速率，协商速率跟WiFi的协议，天线发射功率，干扰，距离，障碍物等外界因素相关。</li>
</ul>
</li>
<li><p>$ 2.4GHz $和$ 5GHz $频段的干扰</p>
<ul>
<li>$ 2.4GHz $频段的干扰比较严重，因为蓝牙，无线电话等占用$ 2.4GHz $频段的产品。</li>
<li>使用$ 5GHz $频段的设备比使用2.4GHz的设备少了一个级别，但同时$ 5GHz $频段信号的绕射能力也弱于$ 2.4GHz $频段。</li>
</ul>
</li>
<li><p>对于信号差的解决办法：1.更换高增益的天线；2.优化无线发射设备的位置；3.消除干扰，选用更好的信道。</p>
</li>
</ul>
<h2 id="WiFi的一些技术演变及应用"><a href="#WiFi的一些技术演变及应用" class="headerlink" title="WiFi的一些技术演变及应用"></a>WiFi的一些技术演变及应用</h2><ul>
<li>WiFi Direct（WiFi直连）<ul>
<li>手机热点</li>
<li>Air Drop</li>
<li>Air Play</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>硬核无线技术</category>
      </categories>
      <tags>
        <tag>WiFi</tag>
        <tag>无线电波</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表中的节点_237</title>
    <url>/2020/10/26/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-237/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="删除链表中的节点-237"><a href="#删除链表中的节点-237" class="headerlink" title="删除链表中的节点_237"></a>删除链表中的节点_237</h1><h2 id="请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为要被删除的节点。"><a href="#请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为要被删除的节点。" class="headerlink" title="请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为要被删除的节点。"></a>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为要被删除的节点。</h2><p><img src="/2020/10/26/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-237/image-20201025185014252.png" alt="image-20201025185014252"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释：给定你链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9.</span></span><br><span class="line">    </span><br><span class="line">输入：head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">解释：给定你链表中值为 <span class="number">1</span> 的第三个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">9.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路分析：将要被删除节点的下一个节点的数据赋值给当前节点，将当前节点的next指向下一节点的next(跳过下一节点)。</p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer 18. 删除链表的节点</title>
    <url>/2020/10/25/%E5%89%91%E6%8C%87Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="剑指Offer-18-删除链表的节点"><a href="#剑指Offer-18-删除链表的节点" class="headerlink" title="剑指Offer 18. 删除链表的节点"></a>剑指Offer 18. 删除链表的节点</h1><h2 id="给定单链表的头指针和一个要删除的节点值，定义一个函数删除该节点。返回删除后的链表的头节点。"><a href="#给定单链表的头指针和一个要删除的节点值，定义一个函数删除该节点。返回删除后的链表的头节点。" class="headerlink" title="给定单链表的头指针和一个要删除的节点值，定义一个函数删除该节点。返回删除后的链表的头节点。"></a>给定单链表的头指针和一个要删除的节点值，定义一个函数删除该节点。返回删除后的链表的头节点。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], val = <span class="number">5</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], val = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">1</span> 的第三个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">9.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.val = val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur.val != val)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = cru;</span><br><span class="line">            cru = cru.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = cru.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>曲率公式推导</title>
    <url>/2020/08/19/%E6%9B%B2%E7%8E%87%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="曲率公式："><a href="#曲率公式：" class="headerlink" title="曲率公式："></a>曲率公式：</h2><p>$k = \frac {|y’’|}{(1+y’^2)^{\frac{3}{2}}}$</p>
<h2 id="曲率及曲率半径的定义"><a href="#曲率及曲率半径的定义" class="headerlink" title="曲率及曲率半径的定义"></a>曲率及曲率半径的定义</h2><p>对于一条曲线来说我们可以研究其曲率。通常来想，以一条连续光滑的曲线上无限接近的两个点为端点的一弧线总可以视为是某个圆上的一段弧（可以简单的认为曲率半径在连续光滑的曲线上不会发生突变，所以在某点的无穷小领域内曲率半径可以作为一个常量）。而这个圆的半径就被定义为曲线在这一点的曲率半径，而曲率则被定义为曲率半径的倒数。</p>
<p>那么如何求曲率的半径呢？我们可以回想一下刚接触到弧度制的时候是怎么定义弧度的。弧度是圆弧长与该圆半径的比值，即$\alpha = \frac{S}{R}$；显然当$S=2\pi R$即整个圆周长时弧度为$2\pi$。</p>
<p>那么显然曲率半径很自然的可以定义为$R=\frac{dS}{d\alpha}$，即无穷小的一段弧长与其相对应的弧度的比值。</p>
 <span id="more"></span> 

<p>为了能使用最简单的运算步骤，我们要先研究一下几何关系：</p>
<p><img src="/2020/08/19/%E6%9B%B2%E7%8E%87%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/1.jpg" alt="几何关系"></p>
<p>如图，$A,B$即为连续光滑曲线上无线逼近的两个点，根据几何关系可以看出$d\alpha = \alpha _2 - \alpha_1$</p>
<h2 id="求-d-alpha"><a href="#求-d-alpha" class="headerlink" title="求$d\alpha$:"></a>求$d\alpha$:</h2><p>回想一下什么是曲线斜率，曲线的斜率就是其切线在这一点与水平线夹角的正切值，那么图片上曲线在$A,B$两点的斜率自然就是$\tan \alpha_1$与$\tan \alpha_2$。而我们需要的是这两个倾斜角的差值$d\alpha$。</p>
<p>则有$\tan \alpha = \frac{dy}{dx}$，我们对其求微分可得：<br>$d\tan \alpha = \frac{d\tan \alpha}{d\alpha} d\alpha = \sec ^2\alpha d\alpha = (1+\tan ^2\alpha)d\alpha = [1+(\frac{dy}{dx})^2]d\alpha$<br>这样可得：$d\alpha = \frac{d\tan \alpha}{1+(\frac{dy}{dx})^2} = \frac{d\frac{dy}{dx}}{1+(\frac{dy}{dx})^2}$</p>
<h2 id="求-dS"><a href="#求-dS" class="headerlink" title="求$dS$:"></a>求$dS$:</h2><p>这就是对弧长进行微分，也叫弧微分。简单来说就是用线段$AB$来代替弧$AB$，因为当这两点无限趋近的时候，它们基本就没什么区别了，也就是取一阶近似或者说线性近似的意思。</p>
<p>设$A(x_1,y_1),B(x_2,y_2)$，线段$AB$的长度很好计算，就是勾股定理：<br>$|AB| = dS = \sqrt {(x_2 - x_1)^2+(y_2-y_1)^2} = (x_2 - x_1) \sqrt {1+(\frac{y_2-y_1}{x_2-x_1})^2} = \sqrt {1+(\frac{dy}{dx})^2}dx$</p>
<h2 id="将-d-alpha-与-dS-代入公式："><a href="#将-d-alpha-与-dS-代入公式：" class="headerlink" title="将$d\alpha$与$dS$代入公式："></a>将$d\alpha$与$dS$代入公式：</h2><p>加一个绝对值，曲率半径就是被定义为一个正数，暂且没必要牵扯的负数，就这么解释一哈吧！<br>$R = |\frac{dS}{d\alpha}| = \frac{[1+(\frac{dy}{dx})^2]^{\frac{3}{2}}}{|d \frac{dy}{dx}\cdot \frac{1}{dx}|} = \frac{[1+(\frac{dy}{dx})^2]^{\frac{3}{2}}}{|\frac{d}{dx}\frac{dy}{dx}|} = \frac{[1+(\frac{dy}{dx})^2]^{\frac{3}{2}}}{|\frac{d^2y}{dx^2}|}$</p>
<p>而曲率就是曲率半径的一个倒数，即$\frac{|y’’|}{(1+y’^2)^\frac{3}{2}}$</p>
]]></content>
      <categories>
        <category>数学常识</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏数组</title>
    <url>/2020/10/01/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="稀疏数组-sparsearray"><a href="#稀疏数组-sparsearray" class="headerlink" title="稀疏数组(sparsearray)"></a>稀疏数组(sparsearray)</h1><p>当一个数组大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方法是：</p>
<ul>
<li>记录数组一共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行及列值记录在一个小规模的数组中，从而缩小程序的规模。</li>
</ul>
<p>二维数组转稀疏数组思路：</p>
<ol>
<li><p>遍历原始的二维数组，得到有效数据的个数sum；</p>
</li>
<li><p>根据sum创建稀疏数组sparseArr int[sum + 1][3]；</p>
</li>
<li><p>将二维数组的有效数据存入到稀疏数组。</p>
</li>
</ol>
<p>稀疏数组转二维数组：</p>
<ol>
<li>点读取稀疏数组的第一行，创建原始的二维数组，比如上面的chessArr2 = int[11][11]；</li>
<li> 读取稀疏数组后面的几行数据，并赋给原始的二维数组。</li>
</ol>
 <span id="more"></span> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建原始二维数组</span></span><br><span class="line">        <span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历二维数组，找出非0数的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chessArr1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chessArr1[i].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(chessArr1[i][j] !=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//完成稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chessArr1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chessArr1[i].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(chessArr1[i][j] != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//稀疏数组转原始二维数组</span></span><br><span class="line">        <span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA数据结构</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>符号表</title>
    <url>/2021/01/05/%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h1><hr>
<p>符号表最主要的目的就是将一个键和一个值联系起来，符号表能够存储的数据元素是一个键和一个值共同组成的键值对数据，可以根据键来查找对应的值。符号表中，键具有唯一性。</p>
 <span id="more"></span> 

<p><strong>符号表的API设计：</strong></p>
<p>结点类：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Node&lt;Key,Value&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key key, Value value, Node next)</td>
</tr>
<tr>
<td>成员变量</td>
<td>public Key key</td>
</tr>
<tr>
<td></td>
<td>public Value value</td>
</tr>
<tr>
<td></td>
<td>public Node next</td>
</tr>
</tbody></table>
<p>符号表：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>SymbolTable&lt;Key,Value&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>SymbolTable()</td>
</tr>
<tr>
<td>成员方法</td>
<td>public Vaule get(Key key)</td>
</tr>
<tr>
<td></td>
<td>public void put(Key key, Value val)</td>
</tr>
<tr>
<td></td>
<td>public void delete(Key key)</td>
</tr>
<tr>
<td></td>
<td>public int size()</td>
</tr>
<tr>
<td>成员变量</td>
<td>private Node head</td>
</tr>
<tr>
<td></td>
<td>private int N</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolTable</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Key key;</span><br><span class="line">        <span class="keyword">public</span> Value value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SymbolTable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//符号表中已经存在建为key的键值对，那么需要找到该结点，替换value</span></span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span>(temp.key.equals(key))&#123;</span><br><span class="line">                temp.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果符号表中不存在键为key的键值对，需要创建新结点，保存要插入的键值对，把新结点插入到链表头部即可</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(key, value, <span class="keyword">null</span>);</span><br><span class="line">        Node oldFirst = head.next;</span><br><span class="line">        newNode.next = oldFirst;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.key.equals(key))&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">                N--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span>(temp.key.equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span> temp.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有序符号表：</strong></p>
<p>上面实现的符号表，称之为无序符号表，因为在插入的时候，并没有考虑键值对的顺序，而在实际生活中，有时候需要根据键的大小进行排序，插入数据时要考虑顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSymbolTable</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Key key;</span><br><span class="line">        <span class="keyword">public</span> Value value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderSymbolTable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义Node变量，分别记录当前结点和上一结点</span></span><br><span class="line">        Node curr = head.next;</span><br><span class="line">        Node pre = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; key.compareTo(curr.key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr != <span class="keyword">null</span> &amp;&amp; key.compareTo(key) == <span class="number">0</span>)&#123;</span><br><span class="line">            curr.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(key,value,curr);</span><br><span class="line">        pre.next = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.key.equals(key))&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">                N--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span>(temp.key.equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span> temp.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序</title>
    <url>/2020/12/28/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h1><hr>
<h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><p>Java提供了Comparable就是用来定义排序规则的。</p>
<p><strong>例：</strong></p>
<ul>
<li>定义一个学生类Student，具体年龄age和姓名username两个属性，并通过Comparable接口提供比较规则；</li>
<li>定义测试类Test，在测试类Test中定义测试方法Comparable getMax(Comparable c1, Comparable c2)完成测试。</li>
</ul>
 <span id="more"></span> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.username = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String getUsername&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> + <span class="string">&quot;username=&quot;</span> + <span class="keyword">this</span>.username + <span class="string">&quot;, age=&quot;</span> + <span class="keyword">this</span>.age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAge() - o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        Comparable max = getMax(s1,s2);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">getMax</span><span class="params">(Comparable c1, Comparable c2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = c1.compareTo(c2);</span><br><span class="line">        <span class="keyword">if</span>(result &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> c1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>需求：</strong></p>
<ul>
<li>排序前：{4，5，6，3，2，1}</li>
<li>排序后：{1，2，3，4，5，6}</li>
</ul>
<p><strong>排序原理：</strong></p>
<ul>
<li>比较相邻的元素，如果前一个元素比后一个元素大，就交换这两个元素的位置；</li>
<li>对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。</li>
</ul>
<table>
<thead>
<tr>
<th>冒泡次数</th>
<th>冒泡后的结果</th>
</tr>
</thead>
<tbody><tr>
<td>初始状态</td>
<td>4，5，6，3，2，1</td>
</tr>
<tr>
<td>第一次冒泡</td>
<td>4，5，3，2，1，6</td>
</tr>
<tr>
<td>第二次冒泡</td>
<td>4，3，2，1，5，6</td>
</tr>
<tr>
<td>第三次冒泡</td>
<td>3，2，1，4，5，6</td>
</tr>
<tr>
<td>第四次冒泡</td>
<td>2，1，3，4，5，6</td>
</tr>
<tr>
<td>第五次冒泡</td>
<td>1，2，3，4，5，6</td>
</tr>
<tr>
<td>第六次冒泡</td>
<td>1，2，3，4，5，6</td>
</tr>
</tbody></table>
<p><strong>冒泡排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Bubble</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Bubble()</td>
</tr>
<tr>
<td>成员方法</td>
<td>public static void sort(Comparable[] a)：对数组内的元素进行排序</td>
</tr>
<tr>
<td></td>
<td>private static boolean greater(Comparable v, Comparable w)：判断v是否大于w</td>
</tr>
<tr>
<td></td>
<td>private static void exch(Comparable[] a, int i, int j)：交换a数组中，索引i和索引j处的值</td>
</tr>
</tbody></table>
<p><strong>冒泡排序的代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(greater(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        Bubble.sort(arr);</span><br><span class="line">        </span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>冒泡排序的时间复杂度分析</strong></p>
<p>在最坏情况下，也就是假如要排序的元素为{6，5，4，3，2，1}，那么元素的比较次数为：$(N-1)+(N-2)…+2+1=(1+N-1)*(N-1)/2=\frac{N^2-N}{2}$元素交换次数为：$\frac{N^2-N}{2}$，总执行次数为$N^2-N$，按照大O推导法则，冒泡排序的时间复杂度为$O(N^2)$。</p>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>需求：</strong></p>
<ul>
<li>排序前：{4，6，8，7，9，2，10，1}</li>
<li>排序后：{1，2，4，5，7，8，9，10}</li>
</ul>
<p><strong>排序原理：</strong></p>
<ul>
<li>每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引处的值为最小值，最后可以找到最小值所在的索引</li>
<li>交换第一个索引处和最小值所在的索引处的值</li>
</ul>
<table>
<thead>
<tr>
<th>{4，6，8，7，9，2，10，1}</th>
<th>原始数据</th>
</tr>
</thead>
<tbody><tr>
<td>{1，6，8，7，9，2，10，4}</td>
<td>第一趟排序Min=1</td>
</tr>
<tr>
<td>{1，2，8，7，9，6，10，4}</td>
<td>第二趟排序Min=2</td>
</tr>
<tr>
<td>{1，2，4，7，9，6，10，8}</td>
<td>第三趟排序Min=4</td>
</tr>
<tr>
<td>{1，2，4，6，9，7，10，8}</td>
<td>第四趟排序Min=6</td>
</tr>
<tr>
<td>{1，2，4，6，7，9，10，8}</td>
<td>第五趟排序Min=7</td>
</tr>
<tr>
<td>{1，2，4，6，7，8，10，9}</td>
<td>第六趟排序Min=8</td>
</tr>
<tr>
<td>{1，2，4，6，7，8，9，10}</td>
<td>第七趟排序Min=9</td>
</tr>
</tbody></table>
<p><strong>选择排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Selection</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Selection()</td>
</tr>
<tr>
<td>成员方法</td>
<td>public static void sort(Comparable[] a)</td>
</tr>
<tr>
<td></td>
<td>private static boolean greater(Comparable v, Comparable w)</td>
</tr>
<tr>
<td></td>
<td>private static void exch(Comparable[] a, int i, int j)</td>
</tr>
</tbody></table>
<p><strong>选择排序的代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(greater(a[minIndex],a[j]))&#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a,i,minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(Comparable v, Comparable m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionTest</span></span>&#123;</span><br><span class="line">    Integer[] arr = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    Selection.sort(arr);</span><br><span class="line">    </span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择排序的时间复杂度分析：</strong></p>
<p>数据比较的次数：$(N-1)+(N-2)..+2+1=\frac{N^2-N}{2}$，数据交换次数：N-1，时间复杂度为$O(N^2)$。</p>
<hr>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>需求：</strong></p>
<ul>
<li>排序前：{4，3，2，10，12，1，5，6}</li>
<li>排序后：{1，2，3，4，5，6，10，12}</li>
</ul>
<p><strong>排序原理：</strong></p>
<ul>
<li>把所有的元素分为两组，已经排序的未排序的；</li>
<li>找到未排序的组中第一个元素，向已排序的组中进行插入；</li>
<li>倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位。</li>
</ul>
<table>
<thead>
<tr>
<th>{4，3，2，10，12，1，5，6}</th>
<th>原始数据</th>
</tr>
</thead>
<tbody><tr>
<td>{4，3，2，10，12，1，5，6}</td>
<td>第一趟排序(待插入数字为3)</td>
</tr>
<tr>
<td>{3，4，2，10，12，1，5，6}</td>
<td>第二趟排序(待插入数字为2)</td>
</tr>
<tr>
<td>{2，3，4，10，12，1，5，6}</td>
<td>第三趟排序(待插入数字为10)</td>
</tr>
<tr>
<td>{2，3，4，10，12，1，5，6}</td>
<td>第四趟排序(待插入数字为12)</td>
</tr>
<tr>
<td>{2，3，4，10，12，1，5，6}</td>
<td>第五趟排序(待插入数字为1)</td>
</tr>
<tr>
<td>{1，2，3，4，10，12，5，6}</td>
<td>第六趟排序(待插入数字为5)</td>
</tr>
<tr>
<td>{1，2，3，4，5，10，12，6}</td>
<td>第七趟排序(待插入数字为6)</td>
</tr>
<tr>
<td>{1，2，3，4，5，6，10，12}</td>
<td>最终结果</td>
</tr>
</tbody></table>
<p><strong>插入排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Insertion</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Insertion()</td>
</tr>
<tr>
<td>成员方法</td>
<td>public static void sort(Comparable[] a)</td>
</tr>
<tr>
<td></td>
<td>private static boolean greater(Comparable v, Comparable w)</td>
</tr>
<tr>
<td></td>
<td>private static void exch(Comparable[] a, int i, int j)</td>
</tr>
</tbody></table>
<p><strong>插入排序代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(greater(a[j-<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                    exch(a,j-<span class="number">1</span>,j);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionTest</span></span>&#123;</span><br><span class="line">    Integer[] arr = &#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    Inserction.sort(arr);</span><br><span class="line">    </span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入排序的时间复杂度分析：</strong></p>
<p>在最坏情况下，比较次数为：$(N-1)+(N-2)…+2+1=\frac{N^2-N}{2}$，交换次数为：$\frac{N^2-N}{2}$，执行总次数为：$N^2-N$，因此插入排序的时间复杂度为：$O(N^2)$。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析</title>
    <url>/2020/12/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="算法的时间复杂度分析"><a href="#算法的时间复杂度分析" class="headerlink" title="算法的时间复杂度分析"></a>算法的时间复杂度分析</h2><ul>
<li><p>事后分析估算方法：这种统计方法主要是通过设计好的测试程序和测试数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低，但这种方法有很大的缺陷：必须依据算法实现编制好的测试程序，通常需要花费大量的时间和精力，测试完了如果发现测试的是非常糟糕的算法，那么之前所做的事情就全部白费了，并且不同的测试环境(硬件设备)的差别导致测试的结果差异也很大。</p>
</li>
<li><p>事前分析估算方法：在计算机程序编写前，根据统计方法对算法进行估算，经过总结，一个高级语言编写的程序在计算机上运行所消耗的时间取决于下列因素：</p>
<ul>
<li>算法采用的策略与方案；</li>
<li>编译产生的代码质量；</li>
<li>问题的输入规模(输入量的多少)</li>
<li>机器执行指令的速度</li>
</ul>
<p>由此可见，抛开与计算机硬件、软件有关因素，一个程序运行的时间依赖于算法的好坏与问题的输入规模。如果算法固定，那么算法的执行时间就只和问题的输入规模有关系了。</p>
<p>我们研究算法复杂度，侧重的是当输入规模不断增大时，算法的增长量的一个抽象，而不是精确地定位需要执行多少次，因为如果是这样的话，我们又得考虑回编译器优化等问题，容易主次颠倒。我们分析一个算法的运行时间，最重要的就是把核心操作的次数和输入规模关联起来。</p>
</li>
</ul>
 <span id="more"></span> 

<h3 id="函数渐进增长"><a href="#函数渐进增长" class="headerlink" title="函数渐进增长"></a>函数渐进增长</h3><p><strong>概念</strong> ：给定两个函数$f(n)和g(n)$，如果存在一个整数N，使得对于所有的$n &gt; N$，$f(n)$总是比$g(n)$大，那么我们说$f(n)$的增长渐进快于$g(n)$。</p>
<p>在比较随着输入规模的增长量时，可以有以下规则：</p>
<ul>
<li>算法函数中的常数可以忽略；</li>
<li>算法函数中最高次幂的常数因子可以忽略；</li>
<li>算法函数中最高次幂越小，算法效率越高。</li>
</ul>
<h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><h4 id="大O记法"><a href="#大O记法" class="headerlink" title="大O记法"></a>大O记法</h4><p><strong>定义</strong>：在进行算法分析时，语句总的执行次数$T(n)$是关于问题规模$n$的函数，进而分析$T(n)$随着$n$的变化情况并确定$T(n)$的量级。算法的时间复杂度，就是算法的时间度量，记作：$T(n)=O(f(n))$。它表示随着问题规模$n$的增长，算法执行时间的增长率和$f(n)$的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度，其中$f(n)$是问题规模$n$的某个函数。</p>
<p>在这里，我们需要明确一个事情：<strong>执行次数=执行时间</strong></p>
<p>用大写$O()$来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模$n$的增长，$T(n)$增长最慢的算法为最优算法。</p>
<p>基于对函数渐进增长的分析，推导大$O$阶的表示方法有以下几个规则可以使用：</p>
<ul>
<li>用常数1取代运行时间中的所有加法常数；</li>
<li>在修改后的运行次数中，只保留高阶项；</li>
<li>如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数。</li>
</ul>
<h4 id="常见的大O阶"><a href="#常见的大O阶" class="headerlink" title="常见的大O阶"></a>常见的大O阶</h4><ul>
<li>线性阶：一般含有非嵌套循环及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长。</li>
<li>平方阶：一般嵌套循环属于这种时间复杂度。</li>
<li>立方阶：一般三层嵌套循环属于这种时间复杂度。</li>
<li>对数阶：</li>
<li>常数阶：一般不涉及循环操作的都是常数阶。</li>
</ul>
<h4 id="函数调用的时间复杂度分析"><a href="#函数调用的时间复杂度分析" class="headerlink" title="函数调用的时间复杂度分析"></a>函数调用的时间复杂度分析</h4><h4 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == arr[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最好情况：查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1)</li>
<li>最坏的情况：查找最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n)</li>
<li>平均情况：任何数字查找的平均成本是O(n/2)</li>
</ul>
<h2 id="算法的空间复杂度分析"><a href="#算法的空间复杂度分析" class="headerlink" title="算法的空间复杂度分析"></a>算法的空间复杂度分析</h2><h3 id="JAVA中常见内存占用"><a href="#JAVA中常见内存占用" class="headerlink" title="JAVA中常见内存占用"></a>JAVA中常见内存占用</h3><ul>
<li><p>1.基本数据类型内存占用：</p>
<ul>
<li>byte：1字节</li>
<li>short：2字节</li>
<li>int：4字节</li>
<li>long：8字节</li>
<li>float：4字节</li>
<li>double：8字节</li>
<li>boolean：4字节</li>
<li>char：2字节</li>
</ul>
</li>
<li><p>2.计算机访问内存的方式都是一次一个字节</p>
</li>
<li><p>3.一个引用需要8个字节表示：</p>
<p>例如：Date date = new Date()，则date变量需要占用8个字节来表示</p>
</li>
<li><p>4.创建一个对象，比如new Date()，除了Date对象内部存储的数据占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。</p>
</li>
<li><p>5.一般内存的使用，如果不够8个字节，都会被自动填充为8字节</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通过new A()创建一个对象的内存占用如下：</span></span><br><span class="line"><span class="comment">1.整型成员变量a占用4个字节；</span></span><br><span class="line"><span class="comment">2.对象本身占用16个字节；</span></span><br><span class="line"><span class="comment">那么创建该对象总共需要20个字节，但由于不是以8为单位，会自动填充为24个字节。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>6.Java数组被限定为对象，它们一般会记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息(16个自己的对象开销，4个字节用于保存长度以及4个填充字节)再加上保存值所需的内存。</p>
</li>
</ul>
<h3 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h3><p>算法的空间复杂度计算公式记作：$S(n) = O(f(n))$，其中$n$为输入规模，$f(n)$为语句关于$n$所占存储空间的函数。</p>
<p>例：对指定的数组元素进行反转，并返回反转的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse1(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;<span class="comment">//申请4个字节</span></span><br><span class="line">    <span class="keyword">int</span> temp;<span class="comment">//申请4个字节</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end = n - <span class="number">1</span>; start &lt;= end; start++, end--)&#123;</span><br><span class="line">        temp = arr[start];</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        arr[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse2(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;<span class="comment">//申请4个字节</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//申请n*4个字节+数组自身的头信息24个字节</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        temp[n-<span class="number">1</span>-i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Java中有内存垃圾回收机制，并且$jvm$对程序的内存占用也有优化，无法精确的评估一个Java程序的内存占用情况，但是了解Java的基本内存占用，使得可以对Java程序内存占用情况进行估算。</p>
<p>由于现在计算机设备内存一般比较大，基本上个人计算机都是4G起步，大的可以达到32G，所以内存占用一般情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。</p>
<p>但是，如果你做的是嵌入式开发，尤其是传感器设备上的内置程序，由于这些设备的内存很小，一般为几$kb$，这个时候对算法的空间复杂度就有要求了，如果做Java开发，基本上是基于服务器开发，一般不存在这样的问题。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>通俗的无线技术原理</title>
    <url>/2020/07/06/%E9%80%9A%E4%BF%97%E7%9A%84%E6%97%A0%E7%BA%BF%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-什么是无线电波？"><a href="#1-什么是无线电波？" class="headerlink" title="1.什么是无线电波？"></a>1.什么是无线电波？</h2><p>无线电波是一种电磁波。低频的无线电波不能穿越大气层，只能在地面传播；而高频的无线电波可以穿透大气层的电离层，例如：X光可以穿透人体，生成X光影像；伽马射线产生的电离辐射，就是核武器的杀伤手段之一。不同频率的无线电波表现出来的性质不一样，其实就是一种东西都是电磁波。</p>
<h2 id="2-无线电波的信道。"><a href="#2-无线电波的信道。" class="headerlink" title="2.无线电波的信道。"></a>2.无线电波的信道。</h2><p> 生活中常用的无线电波主要在几千Hz~300GHz。根据频率的高低被国际电信联盟（Internationals Telecommunication Union,ITU）规定出各种专用的通信频率，也叫做信道。专业信道涵盖的业务范围特别广，例如：海上移动通信业务，AM广播，FM广播，无线电视广播，太空对地通信，GPS卫星通信服务，深空研究通信，卫星时间校准服务，卫星广播业务服务。</p>
 <span id="more"></span> 

<h2 id="3-无线电波的属性。"><a href="#3-无线电波的属性。" class="headerlink" title="3.无线电波的属性。"></a>3.无线电波的属性。</h2><ul>
<li>频率 (Frequency)<br>频率指的是波在一秒钟通过周期性变化的次数，例如：一秒钟通过一个完整的波长就是1Hz。</li>
<li>振幅（Amplitude）<br>振幅指的是波的波动幅度，往往能量越大，振幅越高，表现出来的信号强度就越高。</li>
<li>波长（Wavelength）<br>波长是波在一个振动周期传播的距离。</li>
</ul>
<h2 id="4-关于波长和频率的几个基础知识。"><a href="#4-关于波长和频率的几个基础知识。" class="headerlink" title="4.关于波长和频率的几个基础知识。"></a>4.关于波长和频率的几个基础知识。</h2><p>从宏观上讲：若天线的发射功率一定，频率越高的无线电波，带宽越大，承载的数据量越大。在大气层内，波长越长，频率越低，传播的距离就越远，有更好的传播性和穿透性；频率越高，波长越短，穿透性和传播距离就越短。这就是为什么现5G手机的网络，需要建立更多的子基站来保证信号覆盖和通信死角。</p>
<h2 id="5-模拟信号的调制及优缺点。"><a href="#5-模拟信号的调制及优缺点。" class="headerlink" title="5.模拟信号的调制及优缺点。"></a>5.模拟信号的调制及优缺点。</h2><p>模拟信号（Analog Signal）：是一个不断变化的信号，在时间的尺度上是一个不断变化的过程。若要传输一个声波信号，可以通过无线电波调制振幅的方式来改变无线电波的振幅，来表达这一段声波，这个就叫做振幅调节（Amplitude Modulation）;如果通过调节无线电频率，也可以同样表达一个声音波形，这个叫做频率调节（Frequency Modulation）;通过这两种方式调制出来的信号都是模拟信号。模拟信号的优点是：信号的细节保留特别完好；缺点是：易受干扰。模拟信号是个矢量的概念。</p>
<h2 id="6-数字信号的调制及优缺点。"><a href="#6-数字信号的调制及优缺点。" class="headerlink" title="6.数字信号的调制及优缺点。"></a>6.数字信号的调制及优缺点。</h2><p>数字信号的调制：移幅键空法（Amplitude Shift Keying）,通过振幅的大小表示0，1；移频键控法（Frequency Shift Keying）,通过频率的高低表示0，1；移相键控法（Phase Shift Keying），通过波的阶段来表示0，1。数字信号的缺点是：容易丢失细节（可通过增加采样率来加大数据量）。理论上用数字信号来完美表达模拟信号数据量是无限接近 $\infty$的。现实生活中模拟信号的例子就是数字音乐对比黑胶唱片；数码影像对比胶片的胶卷；打电话听到的声音，对比真实听到的声音。</p>
]]></content>
      <categories>
        <category>硬核无线技术</category>
      </categories>
      <tags>
        <tag>无线电波</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《On Java 8》--第一章 对象的概念</title>
    <url>/2021/04/18/%E9%98%85%E8%AF%BB%E3%80%8AOn-Java-8%E3%80%8B-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>​        我们可以理解“纯粹”的面向对象设计方法是什么样的：</p>
<ul>
<li>万物皆对象。你可以将对象想象成一种特殊的变量。它存储数据，但可以在你对其“发出请求”时执行本身的操作。</li>
<li>程序是一组对象，通过消息传递来告知彼此该做什么。要请求调用一个对象的方法，你需要向该对象发送消息。</li>
<li>每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂度。</li>
<li>每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”</li>
<li>同一类所有对象都能接收相同的消息。这实际是别有含义的一种说法。由于类型为Circle的一个对象也属于类型为Shape的一个对象，所以一个圆完全能接收发送给“形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。</li>
</ul>
 <span id="more"></span> 

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>​        使用访问控制的原因有以下两点：</p>
<ul>
<li>让应用程序员不要触摸他们不应该触摸的部分；</li>
<li>使类库的创建者在不影响后者使用的情况下完善更新工具库。</li>
</ul>
<p>Java有三个显示关键字来设置类中的访问权限：public、private和protected。这些访问修饰符决定了谁能使用它们修饰的方法，变量或类</p>
<ul>
<li>public：表示任何人都可以访问和使用该元素；</li>
<li>private：除了类本身和类内部的方法，外界无法直接访问该元素。private是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译错误；</li>
<li>protected：类似于private，区别是子类可以访问protected的成员，但不能访问private成员</li>
<li>default：如果你不使用前面三者，默认就是default访问权限，default被称为包访问，因为该权限下的资源可以被同一包中其类的成员访问。</li>
</ul>
<h2 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h2><p>​        一个类经创建和测试后，理应是可复用的。</p>
<p>​        代码和设计方案的复用性是面向对象程序设计的优点之一。我们可以通过重复使用某个类的对象来达到这种复用。同时，我们也可以将一个类的对象作为另一个类的成员变量使用。新的类可以是由任意数量和任意类型的其他对象构成。这里涉及到“组合”和“聚合”的概念：</p>
<ul>
<li>组合(Composition)经常用来表示“拥有关系”(has-a relationship)</li>
<li>聚合(Aggregation)动态的组合。</li>
</ul>
<p>​        组合和聚合都属于关联关系的一种，只是额外具有整体-部分的意义。至于是聚合还是组合，需要根据实际业务需求来判断。可能相同超类和子类，在不同的业务场景，关联关系会发生变化。只看代码是无法区分聚合和组合的具体是哪一种关系，只能从语义级别来区分。聚合关系中：整体不会拥有部件的生命周期，所以整体删除时，部件不会被删除。再者，多个整体可以共享一个部件。组合关系：整体拥有部件的生命周期，所以整体删除时，部件也一定跟着删除。而且，多个整体不可以同时共享同一部件。这个区别可以用来区分某个关联关系到底是聚合还是组合。两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。</p>
<p>​        使用“组合”关系给我们的程序带来极大的灵活性。通常新建的类中，成员变量会使用private访问权限，这样应用程序员则无法对其直接访问。我们可以在不影响客户代码的前提下，从容地修改那些成员。我们也可以在“运行时”改变成员对象从而动态地改变程序的行为，这进一步增大了灵活性。</p>
<p>​        在面向对象编程中经常重点强调“继承”。在新手程序员的印象里，或许先入为主地认为“继承应当随处可见”。沿着这种思路产生的程序设计通常拙劣又复杂。相反，在创建新类时首先要考虑“组合”，因为它更简单灵活，而且设计更加清晰。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>​        有两种方法可以区分新的派生类与原始基类。第一种方法很简单：在派生类中添加新的方法。这些新的方法不是基类接口的一部分。这意味着基类不能满足你的所有需求，所以你添加了更多的方法。继承的这种简单而原始的用途有时是解决问题的完美解决方案。然而，还是要仔细考虑是否在基类中也要有这些额外的方法。这种涉及的发现和迭代过程在面向对象程序设计中会经常发生。</p>
<p>​        尽管继承有时候意味着你要在接口中添加新方法(尤其是在以extends关键字表示继承的Java中)，但并总需如此。第二种也更重要地区分派生类和基类的方法是改变现有基类方法的行为，这被称为覆盖(overriding)。要想覆盖一个方法，只需要在派生类中重新定义这个方法即可。</p>
<h2 id="“是一个”与“像是一个”的关系"><a href="#“是一个”与“像是一个”的关系" class="headerlink" title="“是一个”与“像是一个”的关系"></a>“是一个”与“像是一个”的关系</h2><p>​        对于继承可能会发生争论：继承应该只覆盖基类的方法吗？如果这样的话，基类和派生类就是相同的类型了，因为它们具有相同的接口。这会造成，你可以用一个派生类对象完全替代基类对象，这叫做“纯粹替代”，也经常倍被称作“替代原则”。在某种意义上，这是一种继承的理想方式。我们经常把这种基类和派生类关系称为是一个(is - a)关系。</p>
<p>​        有时你在派生类添加了新的接口元素，从而扩展接口。虽然新类型仍然可以替代基类，但这种替代不完美，原因在于基类无法访问新添加的方法。这种关系称为像是一个(is-like-a)关系。新类型不但拥有旧类型的接口，而且包含其他方法，所以不能说新旧类型完全相同。</p>
<p>​        当你看到替代原则时，很容易会认为纯粹替代是唯一可行的方式，并且使用纯粹替代的设计很好。但有时候，你会发现必须得在派生类中添加新方法。只要仔细审视，你可以很明显地区分两种设计方式的使用场合。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>​        我们在处理类的层次结构时，通常把一个对象看成它是所属的基类，而不是把它看成具体类。通过这种方式，我们可以编写出不局限于特定类型的代码。</p>
<p>​        这样的代码不会受添加的新类型影响，并且添加新类型是扩展面向对象程序以处理新情况的常用方法。通过派生新的子类来扩展设计的这种能力是封装变化的基本方法之一。这种能力改善了我们的设计，且减少了软件的维护代价。</p>
<p>​        面向对象程序设计的妙诀：在传统意义上，编译器不能进行函数调用。由非OOP编译器产生的函数调用会引起所谓的早期绑定。这意味着编译器生成特定函数名的调用，该调用会被解析为执行的代码的绝对地址。</p>
<p>​        通过继承，程序直到运行时才能确定代码的地址，因此发送消息给对象时，还需要其他一些方案。为了解决这个问题，面向对象语言使用后期编译的概念。当面向对象发送消息时，被调用的代码直到运行时才确定。编译器确保方法存在，并对参数和返回值执行类型检查，但是它不知道要执行的确切代码。</p>
<p>​        为了执行后期绑定，Java使用一个特殊的代码位来代替绝对调用。这段代码使用对象中存储的信息来计算方法主体的地址。因此，每个对象的行为根据特定代码位的内容而不同。当你向对象发送消息时，对象知道该如何处理调用这条消息。</p>
<p>​        发送消息给对象时，如果程序不知道接收的具体类型是什么，最终执行是正确的，这就是对象的“多态性”(Polymorphism)。面向对象的程序设计语言是通过“动态绑定”的方式来实现对象的多态性。编译器和运行时系统会负责对所有细节的控制。</p>
<h2 id="单继承结构"><a href="#单继承结构" class="headerlink" title="单继承结构"></a>单继承结构</h2><p>​        自从C++引入以来，一个OOP问题变得尤为突出：是否所有类都应该默认从一个基类继承呢？这个答案在Java中是肯定的。在Java中，这个最终基类的名字就是Object。</p>
<p>​        Java的单继承结构有很多好处。由于所有对象都具有一个公共接口，因此它们最终都属于同一个基类。</p>
<p>​        另外，单继承的结构使得垃圾收集的实现更为容易。</p>
<p>​        由于运行期的类型信息会存在于所有对象中，所以我们永远不会遇到判断不了对象类型的情况。这对于系统级操作尤为重要，例如异常处理。同时，这也让我们的编程具有更大的灵活性。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>​        通常，我们并不知道解决某个问题需要的对象数量和持续时间，以及对象的存储方式。那么我们如何知悉程序在运行时需要分配的内存空间呢？</p>
<p>​        “集合”这种类型的对象可以存储任意类型，数量的其他对象。它能根据需要自动扩容，我们不需要关心过程是如何实现的。</p>
<p>​        在一些库中，一两个泛型集合就能满足我们所有需求了，而在其他一些类库中，不同类型的集合对应不同的需求：常见的有List，常用于保存序列；Map，也称为关联数组，常用于将对象与其他对象关联；Set，只能保存非重复的值；其他还包括如队列(Queue)、树(Tree)、栈(Stack)、堆(Heap)等等。</p>
<p>​        之所以选择集合有以下两个原因：</p>
<ul>
<li>集合可以提供不同类型的接口和外部行为。堆栈、队列的应用场景和集合、列表不同，它们中的一种提供解决方案可能比其他灵活得多。它们中的一种提供解决方案可能比其他灵活的多。</li>
<li>不同集合对某些操作有不同的效率。例如，List的两种基本类型：ArrayList和LinkedList。虽然两者具有相同的接口和外部行为，但是在某些操作中它们的效率差别很大。在ArrayList中随机查找元素是很高效的，而LinkedList随即查找效率低下。反之，在LinkedList中插入元素的效率要比ArrayList中高。由于底层数据结构的不同，每种集合类在执行相同的操作时会表现出效率的差别。</li>
</ul>
<p>​        我们可以一开始使用LinkedList构建程序，在优化系统性能时改用ArrayList。通过List接口的抽象，我们可以很容易地将LinkedList改为ArrayList。</p>
<p>​        在Java5泛型出来之前，集合中保存的通用类型Object。Java单继承的结构意味着所有元素都基于Object类，所以在集合中可以保存任何类型的数据。要使用这样的集合，我们先要往集合添加元素。由于Java5版本前的集合只保存Object，当我们往集合中添加元素时，元素都向上转型成了Object，从而丢失自己原有的类型特性。这时我们再从集合中取出该元素时，元素变成了Object。那么，我们该怎么将其转回原先具体的类型呢？这里，我们使用了强制类型转换将其转为更为具体的类型，这个过程称为对象的“向下转型”。向上转型的过程是安全的，向下转型的过程是不安全的。无论如何，我们要寻找一种在取出集合元素时确定其具体类型的方法。另外，每次取出元素都要做额外的“向下转型”对程序和程序员都是一种开销。以某种方式创建集合，以确认保证元素的具体类型，减少集合元素“向下转型”的开销和可能出现的错误难道不好吗？这种解决方案就是：参数化类型机制(Parameterized Type Mechanism)。</p>
<p>​        参数化类型机制可以使得编译器能够自动识别某个class的具体类型并正确地执行。Java5版本支持了参数化类型机制，称之为“泛型”(Generic)。泛型是Java5的主要特性之一。</p>
<h2 id="对象创建与声明周期"><a href="#对象创建与声明周期" class="headerlink" title="对象创建与声明周期"></a>对象创建与声明周期</h2><p>​        我们在使用对象时需要注意一个关键问题就是对象的创建和销毁。每个对象的生存都需要资源，尤其是内存。为了资源的重复利用，当对象不再被使用时，我们应该及时释放资源，清理内存。</p>
<p>​        在简单的编程场景下，对象的清理并不是问题。我们创建对象，按需使用，最后销毁它。然而，情况往往要比这更复杂。</p>
<p>​        Java使用动态内存分配。每次创建对象时，使用new关键字构建该对象的动态实例。这又带来了另一个问题：对象的生命周期。较之堆内存，在栈内存中创建对象，编译器能够确定该对象的生命周期并自动销毁它；然而如果你在堆内存创建对象的话，编译器是不知道它的生命周期的。在C++中你必须以编程方式确定何时销毁对象，否则可能导致内存泄漏。Java的内存管理是建立在垃圾收集器上的，它能自动发现对象不再被使用并释放内存。垃圾收集器的存在带来了极大的便利，它减少了我们之前必须要跟踪的问题和编写相关代码的数量。因此，垃圾收集器提供了更高级别的保险，以防止潜在的内存泄露问题。</p>
<p>​        Java的垃圾收集器被设计用来解决内存释放的问题。垃圾收集器知道对象什么时候不再被使用并且自动释放内存。结合单继承和仅可在堆中创建对象的机制，Java的编程过程中比用C++要简单得多。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>​        异常处理机制将程序错误直接交给编程语言甚至是操作系统。“异常”(Exception)是一个从错误点“抛出”(thrown)后能被特定类型的异常处理程序捕获(catch)的一个对象。它不会干扰程序的正常运行，仅当程序出错的时候才被执行。这让我们编程更加简单：不用再反复检查错误了。另外，异常不像方法返回的错误值和方法设置用来表示发生错误的标志位那样可以被忽略。异常的发生是不会被忽略的，它终究会在某一时刻被处理。</p>
<p>​        最后，“异常机制”提供了一种可靠地从错误状态中恢复的方法，使得我们可以编写出更健壮的程序。有时你只要处理好抛出的异常情况并且恢复程序的运行即可，无需退出。</p>
<p>​        Java的异常处理机制在编程语言中脱颖而出。Java从一开始就内置了异常处理，因此你不得不使用它。这是Java语言唯一接受的错误报告方法。如果没有编写适当的异常处理代码，你将会收到一条编译时错误消息。这种有保证的一致性有时会让程序的错误处理变得更容易。值得注意的是，异常处理并不是面向对象的特性。尽管在面向对象的语言中异常通常由对象表示，但在面向语言之前也存在异常处理。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>《On Java 8》</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2020/10/20/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是一个有序列表，可以用数组或是链表来实现；遵循先入先出的原则。</p>
<h2 id="数组模拟队列："><a href="#数组模拟队列：" class="headerlink" title="数组模拟队列："></a>数组模拟队列：</h2><ol>
<li>maxSize 为队列的最大容量；2. 队列的输入、输出从前后端处理的，因此需要两个变量front和rear。</li>
</ol>
<p>存入队列的思路分析：</p>
<ol>
<li>将尾指针往后移：rear+1，当front == rear 空</li>
<li>当尾指针real小于队列的最大值maxSize-1，可将数据存入rear所指的数组元素中，否则无法存入数据 rear == maxSize -1 队列满。</li>
</ol>
 <span id="more"></span> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//队列构造器</span></span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">        <span class="keyword">this</span>.front = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rear == <span class="keyword">this</span>.maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.front == <span class="keyword">this</span>.rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满？</span></span><br><span class="line">        <span class="keyword">if</span> (isFull())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已满！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空，不能取数据！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空，不能取数据！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;[\t&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r:<span class="keyword">this</span>.arr)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,r);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHeadQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空，不能取数据！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;头数据为：&quot;</span> + arr[front + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayQueue queue1 = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit):退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get):从队列中取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head):查看队列头数据&quot;</span>);</span><br><span class="line">            key = sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.show();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数字：&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = sc.nextInt();</span><br><span class="line">                    queue1.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue1.getQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;取出的数据为:&quot;</span> + res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.showHeadQueue();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;成功退出！&quot;</span>);</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题分析优化：目前数组使用一次就不能用了，没有达到复用的效果；将这个数组使用算法，改进成一个环形的数组。</p>
<h2 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h2><p>思路分析：</p>
<p>1.front变量的含义做个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素；front的初始值=0；</p>
<p>2.rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置。(希望空出一个空间做为约定。)rear初始值=0；</p>
<p>3.当队列满时，条件是：（rear +1）% maxSize = front</p>
<p>4.队列为空的条件是 rear==front</p>
<p>5.当我们这样分析，队列中有效的数据个数：(rear + maxSize -front) % maxSize</p>
<p>6.我们可以在原来的队列上修改得到，一个环形队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueCircle</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueueCircle</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列已满！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] = num;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> result = arr[front];</span><br><span class="line">            front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front+((maxSize - front + rear) % maxSize); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i % maxSize,arr[i % maxSize]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHeadQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;头元素为：&quot;</span> + arr[front]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayQueueCircle queue1 = <span class="keyword">new</span> ArrayQueueCircle(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit):退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get):从队列中取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head):查看队列头数据&quot;</span>);</span><br><span class="line">            key = sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.showQueue();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数字：&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = sc.nextInt();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.addQueue(value);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue1.getQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;取出的数据为:&quot;</span> + res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue1.showHeadQueue();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;成功退出！&quot;</span>);</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA数据结构</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML和CSS基础</title>
    <url>/2020/11/25/HTML%E5%92%8CCSS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="HTML和CSS"><a href="#HTML和CSS" class="headerlink" title="HTML和CSS"></a>HTML和CSS</h1><h2 id="1-B-S软件的结构"><a href="#1-B-S软件的结构" class="headerlink" title="1.B/S软件的结构"></a>1.B/S软件的结构</h2><p>JAVASE    C/S    Client/Server</p>
<p>B/S    Browser/Server</p>
<p><img src="/2020/11/25/HTML%E5%92%8CCSS%E5%9F%BA%E7%A1%80/image-20201123150000522.png" alt="image-20201123150000522"></p>
 <span id="more"></span> 

<h2 id="2-前端的开发流程"><a href="#2-前端的开发流程" class="headerlink" title="2.前端的开发流程"></a>2.前端的开发流程</h2><p><img src="/2020/11/25/HTML%E5%92%8CCSS%E5%9F%BA%E7%A1%80/image-20201123150126291.png" alt="image-20201123150126291"></p>
<h2 id="3-网页的组成部分"><a href="#3-网页的组成部分" class="headerlink" title="3.网页的组成部分"></a>3.网页的组成部分</h2><ul>
<li>内容：在页面中看到的数据。一般内容我们使用html技术来展现；</li>
<li>表现：这些内容在页面上的表现形式。比如说，布局，颜色，大小等等。一般使用CSS技术实现；</li>
<li>行为：指的是页面中元素与设备交互的响应。一般使用js技术实现。</li>
</ul>
<h2 id="4-HTML简介"><a href="#4-HTML简介" class="headerlink" title="4.HTML简介"></a>4.HTML简介</h2><p>Hyper Text Markup Language(超文本标记语言) HTML。HTML通过标签来标记要显示的网页中的各部分。网页文件本身是一种文本文件，通过在文本文件添加标记符，可以告诉浏览器如何显示其中的内容</p>
<h2 id="5-创建HTML文件"><a href="#5-创建HTML文件" class="headerlink" title="5.创建HTML文件"></a>5.创建HTML文件</h2><ul>
<li>创建一个web工程(静态的web工程)</li>
<li>在工程下创建html页面</li>
</ul>
<h2 id="6-HTML文件的书写规范"><a href="#6-HTML文件的书写规范" class="headerlink" title="6.HTML文件的书写规范"></a>6.HTML文件的书写规范</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="comment">&lt;!-- 约束，声明--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh_CN&quot;</span>&gt;</span><span class="comment">&lt;!-- html 标签表示html的开始 lang=&quot;zh_CN&quot;表示中文 html标签中一般分为两部分，分别是head和body--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="comment">&lt;!-- 表示头部信息，一般包含三部分内容：title标题，CSS样式，js代码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="comment">&lt;!-- 表示当前页面使用UTF-8字符集--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="comment">&lt;!-- 表示标题--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="comment">&lt;!-- body标签是整个heml页面显示的主体内容--&gt;</span></span><br><span class="line">    hello</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="comment">&lt;!-- 表示整个html页面的开始--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="comment">&lt;!-- 头信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="comment">&lt;!-- 标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="comment">&lt;!-- body页面的主体内容--&gt;</span></span><br><span class="line">        hello</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span><span class="comment">&lt;!-- 表示整个html页面的结束--&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-HTML标签介绍"><a href="#7-HTML标签介绍" class="headerlink" title="7.HTML标签介绍"></a>7.HTML标签介绍</h2><ul>
<li><p>标签的格式：&lt;标签名&gt;封装的数据&lt;/标签名&gt;</p>
</li>
<li><p>标签名大小写不敏感</p>
</li>
<li><p>标签拥有自己的属性：</p>
<ul>
<li>基本属性：bgcolor=“red”    可以修改简单的样式效果</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;green&quot;</span>&gt;</span></span><br><span class="line">    hello</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>事件属性：onclick=“alert(‘你好！ ’);”    可以直接设置事件响应后的代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;123&#x27;)&quot;</span>&gt;</span><span class="comment">&lt;!-- onlick表示单机事件；alert()是javaScript语言提供的一个警告函数，它可以接收任意参数，参数就是警告框的函数信息--&gt;</span></span><br><span class="line">    hello</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>标签又分为，单标签和双标签</p>
<ul>
<li>单标签格式：&lt;标签名/&gt;    br换行 hr水平线</li>
<li>双标签</li>
</ul>
</li>
</ul>
<h2 id="标签的语法"><a href="#标签的语法" class="headerlink" title="标签的语法"></a>标签的语法</h2><ul>
<li>标签不能交叉嵌套</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>123<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--正确--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="comment">&lt;!--错误--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>标签必须正确的关闭(闭合)</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--正确--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="comment">&lt;!--错误--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="comment">&lt;!--正确--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="comment">&lt;!--错误--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>属性必须有值，属性值必须加引号</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="comment">&lt;!--正确--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span>123<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="comment">&lt;!--错误--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>&gt;</span>123<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="comment">&lt;!--错误--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注释不能嵌套</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释内容--&gt;</span><span class="comment">&lt;!--正确--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注释内容&lt;!-- 注释内容--&gt;</span>--&gt;<span class="comment">&lt;!--错误--&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-常用标签介绍"><a href="#8-常用标签介绍" class="headerlink" title="8.常用标签介绍"></a>8.常用标签介绍</h2><ul>
<li>font字体标签</li>
</ul>
<p>例：在网页上显示，我是字体标签，并修改为宋体，颜色为红色。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span> <span class="attr">fece</span>=<span class="string">&quot;宋体&quot;</span> <span class="attr">size</span>=<span class="string">&quot;7&quot;</span>&gt;</span>我是字体标签<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="comment">&lt;!-- font标签是字体标签，它可以用来修改文本的字体，颜色，大小；color、face、size。--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>特殊字符</li>
</ul>
<p>例：把&lt;br&gt;换行标签变成文本转换成字符显示在页面上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">我是<span class="symbol">&amp;lt;</span>br<span class="symbol">&amp;gt;</span>标签</span><br><span class="line"><span class="comment">&lt;!-- 常用的特殊字符：</span></span><br><span class="line"><span class="comment">&lt; &amp;lt;</span></span><br><span class="line"><span class="comment">&gt; &amp;gt;</span></span><br><span class="line"><span class="comment">空格 &amp;nbsp;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>标题标签</li>
</ul>
<p>例：演示标题1到标题6</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span><span class="comment">&lt;!-- h1-h6都是标题标签；h1最大-h6最小</span></span><br><span class="line"><span class="comment">align 属性是对齐属性：left、center、right--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>超链接</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost:8080&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- a标签是超链接；</span></span><br><span class="line"><span class="comment">	href属性设置连接的地址；</span></span><br><span class="line"><span class="comment">	target属性设置哪个目标进行跳转</span></span><br><span class="line"><span class="comment">		_self	表示当前页面</span></span><br><span class="line"><span class="comment">		_blank	表示打开新页面来进行跳转</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost:8080&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost:8080&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列表标签<ul>
<li>无序列表&lt;ul&gt;</li>
<li>有序列表&lt;ol&gt;</li>
<li>定义列表</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>234<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>345<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>456<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>234<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>345<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>456<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ul	是无序列表；</span></span><br><span class="line"><span class="comment">		type属性可以修改列表项前面的符号(type=&quot;none&quot;)</span></span><br><span class="line"><span class="comment">	 li 是列表项；</span></span><br></pre></td></tr></table></figure>

<ul>
<li>img标签</li>
</ul>
<p>img标签可以在html页面上显示图片。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="comment">&lt;!-- img标签，用来显示图片；src属性可以设置图片的路径</span></span><br><span class="line"><span class="comment">在javaSE中路径也分为相对路径和绝对路径：</span></span><br><span class="line"><span class="comment">	相对路径：从工程名开始算</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	绝对路径：盘符：/目录/文件名</span></span><br><span class="line"><span class="comment">在web中路劲分为相对路径和绝对路径两种：</span></span><br><span class="line"><span class="comment">	相对路径：</span></span><br><span class="line"><span class="comment">	.	表示当前文件目录</span></span><br><span class="line"><span class="comment">	..	表示当前文件所在的上一级目录</span></span><br><span class="line"><span class="comment">	文件名	表示当前文件所在目录的文件，相当于./文件名(./可以省略)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	绝对路径：</span></span><br><span class="line"><span class="comment">	格式是:	http://ip:port/工程名/资源路径</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../imgs/1.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;260&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	img标签是图片标签，用来显示图片</span></span><br><span class="line"><span class="comment">	src		设置图片路径</span></span><br><span class="line"><span class="comment">	width	设置图片宽度</span></span><br><span class="line"><span class="comment">	height	设置图片宽度</span></span><br><span class="line"><span class="comment">	border	设置图片边框</span></span><br><span class="line"><span class="comment">	alt		当指定路径找不到图片时，用来代替显示的文本内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<ul>
<li>表格标签</li>
</ul>
<p>例：做一个带表头的，三行，三列的表格，并显示边框；修改表格的宽度、高度、表格的对齐方式，单元格间距</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- table标签	是表格标签</span></span><br><span class="line"><span class="comment">			align 设置表格相当于页面的对齐方式</span></span><br><span class="line"><span class="comment">			cellspacing 设置单元格间距</span></span><br><span class="line"><span class="comment">			boder 设置表格边框</span></span><br><span class="line"><span class="comment">			width 设置表格宽度</span></span><br><span class="line"><span class="comment">			height 设置表格高度</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	 tr			是行标签</span></span><br><span class="line"><span class="comment">	 th			是表头标签</span></span><br><span class="line"><span class="comment">	 td			是单元格标签</span></span><br><span class="line"><span class="comment">			align 设置单元格文本对齐方式</span></span><br><span class="line"><span class="comment">	 b 			是加粗标签</span></span><br></pre></td></tr></table></figure>

<ul>
<li>跨行跨列表格</li>
</ul>
<p>例：新建一个五行，五列表格；第一行，第一列的单元格要跨两列；第二行第一列的单元格跨两行，第四行第四列的单元格跨两行两列。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4.1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4.2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>4.3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>4.4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>5.1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>5.2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>5.3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- colspan 属性设置跨列</span></span><br><span class="line"><span class="comment">	 rowspan 属性设置跨行</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>iframe框架标签</li>
</ul>
<p>iframe标签可以在一个html页面上，打开一个小窗口，去加载一个单独的页面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;3.标题标签.html&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">name</span>=<span class="string">&quot;abc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;0.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;abc&quot;</span>&gt;</span>0.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- iframe标签可以在页面上开辟一个小区域显示一个单独的页面</span></span><br><span class="line"><span class="comment">	iframe 和 a标签组合使用的步骤：</span></span><br><span class="line"><span class="comment">		1.在iframe标签中使用name属性定义一个名称</span></span><br><span class="line"><span class="comment">		2.在a标签的target属性上设置iframe的name的属性值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>表单标签</li>
</ul>
<p>表单就是html页面中，用来收集用户信息的所有元素集合，然后把这些信息发送给服务器。</p>
<p>例：创建一个个人信息注册的表单界面。包含用户名、密码、确认密码。性别(单选)，兴趣爱好(多选)，国籍(下拉列表)，隐藏域，自我评价(多行文本域)。重置，提交。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	form标签就是表单</span></span><br><span class="line"><span class="comment">		input type=text		是文本输入框	value属性设置默认值显示内容</span></span><br><span class="line"><span class="comment">		input type=password  是密码输入框</span></span><br><span class="line"><span class="comment">		input type=radio	是单选框	 name属性可以对其进行分组		check=&quot;check&quot;表示默认选中</span></span><br><span class="line"><span class="comment">		input type=checkbox	 是复选框	 check=&quot;check&quot;表示默认选中</span></span><br><span class="line"><span class="comment">		input type=reset	 是重置按钮	value属性修改按钮上的文本</span></span><br><span class="line"><span class="comment">		input type=submit    提交按钮	 value属性修改按钮上的文本</span></span><br><span class="line"><span class="comment">		input type=button	 是按钮	  value属性修改按钮上的文本</span></span><br><span class="line"><span class="comment">		input type=file		 是文件上传域 </span></span><br><span class="line"><span class="comment">		input type=hidden	 是隐藏域	 当我们要发送某些信息 ，而这些信息，不需要用户参与，就可以使用隐藏域</span></span><br><span class="line"><span class="comment">		selset 标签是下拉列表框</span></span><br><span class="line"><span class="comment">			option	标签是下拉列表框中的选项 selected=&quot;selected&quot;设置默认选中</span></span><br><span class="line"><span class="comment">		textarea		表示多行文本输入框(起始标签和结束标签中的内容是默认值)</span></span><br><span class="line"><span class="comment">			rows	属性设置可以显示几行的高度</span></span><br><span class="line"><span class="comment">			cols	属性设置可以显示几个字符宽度</span></span><br><span class="line"><span class="comment">	form标签中的属性： </span></span><br><span class="line"><span class="comment">		action属性设置提交的服务器地址</span></span><br><span class="line"><span class="comment">		method属性设置提交的方式GET(默认)或POST</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		表单提交的时候，数据没有发送给服务器的三种情况：</span></span><br><span class="line"><span class="comment">		1.表单项没有name属性值</span></span><br><span class="line"><span class="comment">		2.单选、复选(下拉列表中option标签)都需要添加value属性，以便发送给服务器</span></span><br><span class="line"><span class="comment">		3.表单项不在提交的fore标签中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		GET请求的特点是：</span></span><br><span class="line"><span class="comment">		1.浏览器地址栏中的地址是：action属性[+?+请求参数]</span></span><br><span class="line"><span class="comment">			请求参数的格式是：name=value&amp;name=value</span></span><br><span class="line"><span class="comment">		2.不安全</span></span><br><span class="line"><span class="comment">		3.它有数据长度的限制</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		POST请求的特点是：</span></span><br><span class="line"><span class="comment">		1.浏览器地址栏中只有action属性值</span></span><br><span class="line"><span class="comment">		2.相对于GET请求要安全</span></span><br><span class="line"><span class="comment">		3.理论上没有数据长度的限制</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>表单的显示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>用户信息填写<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名称：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;默认值&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户密码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>确认密码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别: <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>/&gt;</span>男</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span>女</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>兴趣爱好：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>/&gt;</span>Java</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>/&gt;</span>JavaScript</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>/&gt;</span>C</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>/&gt;</span>C++</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>国籍：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择国籍--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">&quot;selected&quot;</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>美国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>日本<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>自我评价：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span>默认值<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他标签</li>
</ul>
<p>div、span、p标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">div标签	默认独占一行</span></span><br><span class="line"><span class="comment">span标签	它的长度是封装数据的长度</span></span><br><span class="line"><span class="comment">p标签		默认会在段落的上方或下方各空出一行</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="CSS技术"><a href="#CSS技术" class="headerlink" title="CSS技术"></a>CSS技术</h2><h3 id="CSS技术介绍"><a href="#CSS技术介绍" class="headerlink" title="CSS技术介绍"></a>CSS技术介绍</h3><p>CSS是【层叠样式表单】。用于(增强)控制网页样式并允许将样式信息与网页内容分离的一种标记性语言。</p>
<h3 id="CSS-语法规则："><a href="#CSS-语法规则：" class="headerlink" title="CSS 语法规则："></a>CSS 语法规则：</h3><p><img src="/2020/11/25/HTML%E5%92%8CCSS%E5%9F%BA%E7%A1%80/image-20201124142809366.png" alt="image-20201124142809366"></p>
<p>选择器：浏览器根据选择器决定受CSS样式影响的HTML元素(标签)</p>
<p>属性：是你要改变的样式名，并且每一个属性都有一个值。属性和值被冒号分开，并由花括号包围，这样就组成了一个完整的样式声明。例如：p{color:blue}</p>
<p>多个声明：如果要定义不止一个声明，则需要用分号将每个声明分开。虽然最后一条声明的最后可以不加分号。例如：p{color:red;font-size:30px;}</p>
<p>CSS注释：/* 注释内容*/</p>
<h3 id="CSS和HTML的结合方式"><a href="#CSS和HTML的结合方式" class="headerlink" title="CSS和HTML的结合方式"></a>CSS和HTML的结合方式</h3><p>1.在标签的style属性上设置“key:value value”，修改标签样式。</p>
<p>例：分别定义div、span标签，分别修改每个div标签的样式为：边框1个像素，实线，红色。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red&quot;</span>&gt;</span>div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red&quot;</span>&gt;</span>div标签2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red&quot;</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid red&quot;</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方式的缺点：</p>
<ul>
<li>如果标签多了。样式多了。代码量非常庞大</li>
<li>可读性非常差</li>
<li>CSS代码没什么复用性可言</li>
</ul>
<p>2.在head标签中，使用style标签来定义各种自己需要的CSS样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方式的缺点：</p>
<ul>
<li>只能在一个页面内复用，不能在多个页面上复用SCC代码</li>
<li>维护起来不方便，实际的项目中会有成千上万的页面，要到每个页面中去修改。工作量太大了。</li>
</ul>
<p>3.把CSS样式写到一个单独的CSS文件，再通过link标签引入即可复用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css1.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><ul>
<li>标签名选择器的格式是：标签名{属性：值}</li>
</ul>
<p>标签名选择器，可以决定哪些标签被动的使用这个样式。</p>
<p>例：在所有div标签上修改字体颜色为蓝色，字体大小为30个像素。边框为1像素黄色实线。并且修改所有span标签的字体颜色为黄色，字体大小20个像素，边框大小20个像素，边框为5像素蓝色虚线。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSSxuanzeqi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid yellow;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">5px</span> dashed blue;</span></span><br><span class="line"><span class="css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>id选择器</li>
</ul>
<p>#id属性值{属性：值}</p>
<p>id选择器，可以让我们通过id属性选择器性的去使用这个样式。</p>
<p>例：分别定义两个div标签，第一个div标签定义为id001，然后根据id属性定义CSS样式修改字体颜色为蓝色，字体大小30个像素，边框为1像素黄色实线。第二个div标签定义id为id002，然后根据id属性定义CSS样式修改的字体颜色为红色，字体大小20个像素，边框为5像素蓝色点线。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>IDxuanzeqi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">        #id001&#123;</span><br><span class="line"><span class="css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> yellow solid;</span></span><br><span class="line">        &#125;</span><br><span class="line">        #id002&#123;</span><br><span class="line"><span class="css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">5px</span> blue dotted;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;id001&quot;</span>&gt;</span>div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;id002&quot;</span>&gt;</span>div标签2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>class选择器</li>
</ul>
<p>class类型选择器的格式是：.class属性值{属性：值；}</p>
<p>class类型选择器，可以通过class属性有效地去使用这个样式。</p>
<p>例：修改class属性值为class01的span或div标签，字体颜色为蓝色，字体大小30个px，边框为1px黄色实线。修改class属性值为class02的div标签，字体颜色为灰色，字体大小26个像素。边框为1px红色实线。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>classleixingxuanzeqi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">        .class01&#123;</span><br><span class="line"><span class="css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid yellow;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        .class02&#123;</span><br><span class="line"><span class="css">            <span class="attribute">color</span>: grey;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">26px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;class01&quot;</span>&gt;</span>div标签class01<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;class02&quot;</span>&gt;</span>div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;class01&quot;</span>&gt;</span>span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>组合选择器</li>
</ul>
<p>组合选择器的格式：选择器1，选择器2，选择器n{属性：值}</p>
<p>组合选择器可以让多个选择器共用一个CSS代码</p>
<p>例：修改class=class01的div标签和id=id01所有的span标签，字体颜色为蓝色，字体大小20个像素，边框为1像素黄色实线。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>zuhexuanzeqi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">        .class01,#id01&#123;</span><br><span class="line"><span class="css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> yellow solid;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;class01&quot;</span>&gt;</span>div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;id01&quot;</span>&gt;</span>span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="常用样式"><a href="#常用样式" class="headerlink" title="常用样式"></a>常用样式</h2><ul>
<li>字体颜色 color：red</li>
<li>边框 boder</li>
<li>宽度 width</li>
<li>高度 height</li>
<li>背景颜色 background-color</li>
<li>字体样式：<ul>
<li>color</li>
<li>字体大小 font-size</li>
</ul>
</li>
<li>DIV居中 margin-left:auto;margin-right:auto;</li>
<li>文本居中 text-align:center</li>
<li>超链接去下划线 text-decoration:none</li>
<li>表格细线 table{border:1px solid black;border-collapse:collapse;}td,th{border:1px solid black;}</li>
<li>列表去除修饰 ul{list-style:none}</li>
</ul>
]]></content>
      <categories>
        <category>JAVAWeb</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList原理解析</title>
    <url>/2021/04/13/ArrayList%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="ArrayList集合底层数据结构"><a href="#ArrayList集合底层数据结构" class="headerlink" title="ArrayList集合底层数据结构"></a>ArrayList集合底层数据结构</h2><p><strong>ArrayList集合介绍</strong></p>
<p>List接口的可调整大小的数组实现。一般数组中：一旦初始化长度就不可以发生改变</p>
<p><strong>数组结构介绍</strong></p>
<ul>
<li>增删慢：每次删除元素，都需要更改数组的长度，拷贝以及移动元素位置</li>
<li>查询快：由于数组在内存中是一块连续空间，因此可以根据地址+索引的方式快速获取对应位置上的元素。</li>
</ul>
 <span id="more"></span> 

<h2 id="ArrayList继承关系"><a href="#ArrayList继承关系" class="headerlink" title="ArrayList继承关系"></a>ArrayList继承关系</h2><h3 id="Serializable标记性接口"><a href="#Serializable标记性接口" class="headerlink" title="Serializable标记性接口"></a>Serializable标记性接口</h3><p><strong>Serializable介绍</strong></p>
<p>​        类的序列化由实现java.io.Serializable接口的类启用。不实现此接口的类将不会使用任何状态序列化或反序列化。可序列化类的所有子类型都是可序列化的。序列化接口没有字段或方法，仅用于标识可序列化的语义。</p>
<p>​        序列化：将对象的数据写入到文件(写对象)；反序列化：将文件中对象的数据读取出来(读对象)。</p>
<p><strong>Serializable源码介绍</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Serializable基本使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POJO</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        writeObject();</span><br><span class="line">        readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempfile&quot;</span>));</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student(<span class="string">&quot;wk&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        oos.WriteObject(stu1);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;tempfile&quot;</span>));</span><br><span class="line">        Student stu = (Student) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ArrayList序列化反序列化的基本使用</strong></p>
<h3 id="Cloneable标记性接口"><a href="#Cloneable标记性接口" class="headerlink" title="Cloneable标记性接口"></a>Cloneable标记性接口</h3><p><strong>Cloneable介绍</strong></p>
<p>​        一个类实现Cloneable接口来指示Object.clone()方法，该方法对于该类的实例进行字段的复制是合法的。在不实现Cloneable接口的实例上调用对象的克隆方法会导致CloneNotSupportedException被抛出。简而言之：克隆就是依据已有的数据，创建一份新的完全的数据拷贝。</p>
<p><strong>Cloneable源码介绍</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ArrayList中clone()的实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.util.ArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Object</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<p><strong>clone方法的使用</strong></p>
<p>浅拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student(<span class="string">&quot;wk&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        Object stu2 = stu1.clone();</span><br><span class="line">        System.out.println(stu1 == stu2);</span><br><span class="line">        stu1.setAge(<span class="number">23</span>);</span><br><span class="line">        System.out.println(stu1);</span><br><span class="line">        System.out.println(stu2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浅拷贝的局限性：基本数据类型可以完全拷贝；引用数据类型则不可以。原因是当引用数据类型仅仅拷贝了一份引用，当引用数据类型发生改变时，被克隆对象中的属性也随之改变。</p>
<p>深拷贝</p>
<p>​        让属性中的引用数据类型也实现Cloneable接口，并且重写clone()方法。在类中先克隆一个对象。调用这个对象中的属性克隆一个对象。最后让属性克隆出来的对象复制到这个类的属性中。</p>
<h3 id="RandomAccess标记接口"><a href="#RandomAccess标记接口" class="headerlink" title="RandomAccess标记接口"></a>RandomAccess标记接口</h3><p><strong>RandomAccess介绍</strong></p>
<p>​        标记接口由List实现使用，以表明它们支持快速随机访问。此接口的主要目的是允许通用算法更改其行为，以便在应用于随机访问列表或顺序访问列表时提供良好的性能。<br>​        用于操纵随机访问列表的最佳算法(例如ArrayList)可以在应用于顺序访问列表时产生二次行为(如LinkedList)。鼓励通用列表算法在应用如果将其应用于顺序访问列表之前提供较差性能的算法时，结合给定列表是否为instanceof，并在必要时更改其行为以保证可接受的性能。<br>​        随机访问和顺序访问之间的区别通常是模糊的。例如，一些List实现提供渐进的线性访问时间，如果它们在实践中获得巨大但是恒定的访问时间。这样的一个List实现应该通常实现这个接口。根据经验，List实现应实现此接口，如果对于类的典型实例，此循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, n=list.size(); i &lt; n; i++)</span><br><span class="line">    list.get(i);</span><br></pre></td></tr></table></figure>

<p>比这个循环运行得更快：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator i=list.iterator(); i.hasNext();)</span><br><span class="line">    i.next();</span><br></pre></td></tr></table></figure>

<p><strong>RandomAccess源码介绍</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractList抽象类"><a href="#AbstractList抽象类" class="headerlink" title="AbstractList抽象类"></a>AbstractList抽象类</h3><h2 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table>
<thead>
<tr>
<th align="center">Constructor</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArrayList()</td>
<td align="center">构造一个初始容量为10的空列表</td>
</tr>
<tr>
<td align="center">ArrayList(int initialCapacity)</td>
<td align="center">构造具有指定初始容量的空列表</td>
</tr>
<tr>
<td align="center">ArrayList(Conllection&lt;? extends E&gt; c)</td>
<td align="center">构一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//集合真正存储数据的容器</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定初始容量的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将参数列表转成数组</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Arrays类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public boolean add(E e)</td>
<td align="center">将指定的元素追加到此列表的末尾</td>
</tr>
<tr>
<td align="center">public void add(int index, E element)</td>
<td align="center">在此列表中的指定位置插入指定的元素</td>
</tr>
<tr>
<td align="center">public boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td align="center">按指定集合的Iterator返回顺序将指定集合中的所有元素追加到此列表的末尾</td>
</tr>
<tr>
<td align="center">public boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>
<td align="center">将指定集合中的所有元素插入到此列表中，从指定的位置开始</td>
</tr>
</tbody></table>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData,</span><br><span class="line">                                             minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把有数据的集合转成数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">//有数据集合的长度</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">//校验及扩容 </span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">//正真拷贝的代码</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//要移动元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//取出被替换的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractCollection</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        E e = it.next();</span><br><span class="line">        sb.append(e == <span class="keyword">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">        sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//集合内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//光标</span></span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="comment">//将集合实际修改次数赋值给预期修改次数</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line">	<span class="comment">//判断集合是否有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//光标是否不等于集合的size</span></span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">//将光标赋值给i</span></span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="comment">//判断，如果大于集合的size就说明没有元素了</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">//把集合存储数据的地址赋值给该方法的局部变量</span></span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="comment">//进行判断，如果条件满足就会产生并发修改异常</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="comment">//光标自增</span></span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ConcurrentModificationException</strong></p>
<p>​        集合每次调用add方法，实际修改次数变量的值都会自增一次；在获取迭代器时，集合只会执行一次实际修改集合的次数赋值给预期修改集合的次数；集合在删除元素的时候也会针对实际修改次数的变量进行自增的操作。在调用next方法时，若实际修改次数不等于期望修改次数，则会发生并发修改异常。当要删除的元素在集合的倒数第二个位置的时候，不会产生并发修改异常。</p>
<h4 id="迭代器中的remove方法"><a href="#迭代器中的remove方法" class="headerlink" title="迭代器中的remove方法"></a>迭代器中的remove方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//把实际修改集合次数赋值给预期修改次数</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器调用remove方法删除元素，其实底层真正还是调用集合自己的删除方法来删除元素。在调用remove方法中会每次给预期修改次数的变量赋值。</p>
<h3 id="清空方法"><a href="#清空方法" class="headerlink" title="清空方法"></a>清空方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包含方法"><a href="#包含方法" class="headerlink" title="包含方法"></a>包含方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断集合是否为空"><a href="#判断集合是否为空" class="headerlink" title="判断集合是否为空"></a>判断集合是否为空</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题小结："><a href="#问题小结：" class="headerlink" title="问题小结："></a>问题小结：</h2><h3 id="ArrayList是如何扩容的？"><a href="#ArrayList是如何扩容的？" class="headerlink" title="ArrayList是如何扩容的？"></a>ArrayList是如何扩容的？</h3><p>第一次扩容为10，以后每次都是原容量的1.5倍。</p>
<h3 id="ArrayList频繁扩容导致添加性能急剧下降，如何处理？"><a href="#ArrayList频繁扩容导致添加性能急剧下降，如何处理？" class="headerlink" title="ArrayList频繁扩容导致添加性能急剧下降，如何处理？"></a>ArrayList频繁扩容导致添加性能急剧下降，如何处理？</h3><p>使用ArrayList的构造方法，在初始化的时候指定容量，防止频繁扩容问题。</p>
<h3 id="ArrayList插入或删除元素一定必LinkedList慢么？"><a href="#ArrayList插入或删除元素一定必LinkedList慢么？" class="headerlink" title="ArrayList插入或删除元素一定必LinkedList慢么？"></a>ArrayList插入或删除元素一定必LinkedList慢么？</h3><p>不一定慢。</p>
<h3 id="ArrayList是线程安全的么？"><a href="#ArrayList是线程安全的么？" class="headerlink" title="ArrayList是线程安全的么？"></a>ArrayList是线程安全的么？</h3><p>不是线程安全的。 </p>
<h3 id="ArrayList什么情况下需要加同步？"><a href="#ArrayList什么情况下需要加同步？" class="headerlink" title="ArrayList什么情况下需要加同步？"></a>ArrayList什么情况下需要加同步？</h3><p>在集合是局部变量的情况下，不用加同步；而集合是全局变量的时候需要加同步。</p>
<h3 id="如何复制某个ArrayList到另外一个ArrayList中取？"><a href="#如何复制某个ArrayList到另外一个ArrayList中取？" class="headerlink" title="如何复制某个ArrayList到另外一个ArrayList中取？"></a>如何复制某个ArrayList到另外一个ArrayList中取？</h3><p>使用clone()方法，使用ArrayList构造方法，使用addAll方法</p>
<h3 id="已知成员变量集合存储了N多名用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？"><a href="#已知成员变量集合存储了N多名用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？" class="headerlink" title="已知成员变量集合存储了N多名用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？"></a>已知成员变量集合存储了N多名用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？</h3><p>读写分离集合CopyOnWriteArrayList</p>
<h3 id="ArrayList和LinkedList区别？"><a href="#ArrayList和LinkedList区别？" class="headerlink" title="ArrayList和LinkedList区别？"></a>ArrayList和LinkedList区别？</h3><p><strong>ArrayList</strong>：</p>
<ul>
<li>基于动态数组的数据结构</li>
<li>对于随机访问的get和set，ArrayList优于LinkedList</li>
<li>对于随即操作的add和remove，ArrayList不一定比LinkedList慢(ArrayList底层是由于是动态数组，因此不是每次add和remove的时候都需要创建新数组)</li>
</ul>
<p><strong>LinkedList</strong>：</p>
<ul>
<li>基于链表的数组结构</li>
<li>对于顺序操作，Linked不一定比ArrayList慢</li>
<li>对于随即操作，LinkedList效率明显较低</li>
</ul>
<h2 id="自定义ArrayList"><a href="#自定义ArrayList" class="headerlink" title="自定义ArrayList"></a>自定义ArrayList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Object[] emptyArray = &#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elemntData = emptyArray;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.size + <span class="number">1</span> &gt;= elementData.length)&#123;</span><br><span class="line">            grow();</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.elementData == <span class="keyword">this</span>.emptyArray)&#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(size == elementData.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            Object[] obj = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">            System.arraycopy(<span class="keyword">this</span>.elementData, <span class="number">0</span>, obj, <span class="number">0</span>, <span class="keyword">this</span>.elementData.length);</span><br><span class="line">            <span class="keyword">this</span>.elementData = obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>&#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        E oldElement = (E)<span class="keyword">this</span>.elementData[index];</span><br><span class="line">        <span class="keyword">this</span>.elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldElement;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        E oldElement = (E)<span class="keyword">this</span>.elementData[index];</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(<span class="keyword">this</span>.elementData, index+<span class="number">1</span>, <span class="keyword">this</span>.elementData, index, numMoved);</span><br><span class="line">        <span class="keyword">this</span>.elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> oldElement;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        checkIndex(index);</span><br><span class="line">        <span class="keyword">return</span> (E)<span class="keyword">this</span>.elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == size - <span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(<span class="keyword">this</span>.elementData[i]).append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(<span class="keyword">this</span>.elementData[i]).append(<span class="string">&quot;,&quot;</span>).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Collection</category>
      </categories>
      <tags>
        <tag>Collection</tag>
        <tag>JAVASE</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCodea每日一题</title>
    <url>/2021/04/05/LeetCodea%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="20210426"><a href="#20210426" class="headerlink" title="20210426"></a>20210426</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">题目：1011在D天内送达包裹的能力</span><br><span class="line">-----------------------------</span><br><span class="line">传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</span><br><span class="line">传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</span><br><span class="line">返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力</span><br><span class="line">-----------------------------</span><br><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line">----------------------------</span><br><span class="line">输入：weights = [3,2,2,4,1,4], D = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br><span class="line">----------------------------</span><br><span class="line">输入：weights = [1,2,3,1,1], D = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br></pre></td></tr></table></figure>

<span id="more"></span> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDay</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> D)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">int</span> day = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> w : weights)&#123;</span><br><span class="line">                <span class="keyword">if</span>(w + sum &gt; mid)&#123;</span><br><span class="line">                    day++;</span><br><span class="line">                    sum = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum += w;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(day &lt;= D)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">解题思路：采用二分查找的方法。先找到左边界，由于船舶的最低运载量必须大于等于货物中最大的值，这样才能保证能够将货物运送。右边界为船舶一天将所有的货物运算完的运载量。</span><br></pre></td></tr></table></figure>

<h2 id="20210425"><a href="#20210425" class="headerlink" title="20210425"></a>20210425</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">题目：897递增顺序搜索树</span><br><span class="line">---------------------</span><br><span class="line">给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</span><br><span class="line">---------------------</span><br><span class="line">输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br><span class="line">----------------------</span><br><span class="line">输入：root = [5,1,7]</span><br><span class="line">输出：[1,null,5,null,7]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode res;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        TreeNode dummy = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>);</span><br><span class="line">        res = dummy;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> dummy.right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        res.right = root;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        res = root;</span><br><span class="line">        </span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">解题思路：采用二叉树的中序遍历，并修改其二叉树的结构。</span><br></pre></td></tr></table></figure>

<h2 id="20210424"><a href="#20210424" class="headerlink" title="20210424"></a>20210424</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：377组合总和IV</span><br><span class="line">-------------------</span><br><span class="line">给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</span><br><span class="line">-------------------</span><br><span class="line">输入：nums = [1,2,3], target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line">---------------------</span><br><span class="line">输入：nums = [9], target = 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n &lt;= i)&#123;</span><br><span class="line">                    dp[i] += dp[i-n];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20210423"><a href="#20210423" class="headerlink" title="20210423"></a>20210423</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：368最大整除子集</span><br><span class="line">--------------------</span><br><span class="line">给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：</span><br><span class="line">answer[i] % answer[j] == 0 ，或</span><br><span class="line">answer[j] % answer[i] == 0</span><br><span class="line">如果存在多个有效解子集，返回其中任何一个均可。</span><br><span class="line">----------------------</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：[1,3] 也会被视为正确答案。</span><br><span class="line">----------------------</span><br><span class="line">输入：nums = [1,2,4,8]</span><br><span class="line">输出：[1,2,4,8]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayLis();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt;[] res = <span class="keyword">new</span> ArrayList[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max = i;</span><br><span class="line">            <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span> &amp;&amp; maxLen &lt; res[j].size())&#123;</span><br><span class="line">                    max = j;</span><br><span class="line">                    maxLen = res[j].size();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            res[i].addAll(res[max]);</span><br><span class="line">            res[i].add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(res[maxIndex].size() &lt; res[i].size())&#123;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[maxIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20210422"><a href="#20210422" class="headerlink" title="20210422"></a>20210422</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：363矩形区域不超过 K 的最大数值和</span><br><span class="line">----------------------------------</span><br><span class="line">给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。</span><br><span class="line">题目数据保证总会存在一个数值和不超过 k 的矩形区域。</span><br><span class="line">----------------------------------</span><br><span class="line">输入：matrix = [[1,0,1],[0,-2,3]], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。</span><br><span class="line">------------------------------------</span><br><span class="line">输入：matrix = [[2,2,-1]], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumSubmatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] sum = <span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                sum[i][j] = sum[i-<span class="number">1</span>][j] + sum[i][j-<span class="number">1</span>] - sum[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p = i; p &lt; row+<span class="number">1</span>; p++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> q = j; q &lt; col+<span class="number">1</span>; q++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> cur = sum[p][q] - sum[i-<span class="number">1</span>][q] - sum[p][j-<span class="number">1</span>] + sum[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(cur &lt;= k)&#123;</span><br><span class="line">                            ans = Math.max(ans, cur);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20210421"><a href="#20210421" class="headerlink" title="20210421"></a>20210421</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：91解码方法</span><br><span class="line">---------------------</span><br><span class="line">一条包含字母A-Z的消息通过以下映射进行了编码 ：</span><br><span class="line">&#x27;A&#x27; -&gt; 1</span><br><span class="line">&#x27;B&#x27; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; -&gt; 26</span><br><span class="line">要解码已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&quot;11106&quot; 可以映射为：</span><br><span class="line">&quot;AAJF&quot; ，将消息分组为 (1 1 10 6)</span><br><span class="line">&quot;KJF&quot; ，将消息分组为 (11 10 6)</span><br><span class="line">注意，消息不能分组为(1 11 06) ，因为&quot;06&quot;不能映射为&quot;F&quot;，这是由于&quot;6&quot;和&quot;06&quot;在映射中并不等价。</span><br><span class="line">--------------------------</span><br><span class="line">输入：s = &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br><span class="line">--------------------------</span><br><span class="line">输入：s = &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br><span class="line">--------------------------</span><br><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有字符映射到以 0 开头的数字。</span><br><span class="line">含有 0 的有效映射是 &#x27;J&#x27; -&gt; &quot;10&quot; 和 &#x27;T&#x27;-&gt; &quot;20&quot; 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br><span class="line">---------------------------</span><br><span class="line">输入：s = &quot;06&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;06&quot; 不能映射到 &quot;F&quot; ，因为字符串含有前导 0（&quot;6&quot; 和 &quot;06&quot; 在映射中并不等价）。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                dp[i] += dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span> || s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">解题思路：采用动态规划的方法。若第一个字符为&#x27;0&#x27;则直接输出0；不然从第二个字符开始遍历，若该字符不为&#x27;0&#x27;，则它就可以被解码成一个字母。则我们可以写出状态转移方程：dp[i] += dp[i-1]</span><br><span class="line">第二种情况，我们使用了两个字符，当满足前一个字符==1或者前一个字符==2并且当前字符&lt;=6则条件成立。此时可以写出状态转移方程：dp[i] += dp[i-2]，注意i需要大于1才可。</span><br></pre></td></tr></table></figure>

<h2 id="20210404"><a href="#20210404" class="headerlink" title="20210404"></a>20210404</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：781森林中的兔子</span><br><span class="line">------------------------</span><br><span class="line">描述：森林中，每个兔子都有颜色。其中一些兔子(可能是全部)告诉你还有其他的兔子和自己有相同的颜色，我们将这些回答放在answers数组中。返回森林中兔子的最少数量。</span><br><span class="line">------------------------</span><br><span class="line">输入：answers=[1,1,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：两只回答了“1”的兔子可能有相同的颜色，设为红色。之后回答了“2”的兔子不会是红色，否则它们的回答会相互矛盾。设回答了“2”的兔子为蓝色。此外，森林中还应有另外2只蓝色兔子的回答没有包含在数组中。因此森林中兔子的最少数量是5：3只回答的和2只没有回答。</span><br><span class="line">--------------------------</span><br><span class="line">输入：answers = [10,10,10]</span><br><span class="line">输出：11</span><br><span class="line">--------------------------</span><br><span class="line">输入：answers = []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRabbits</span><span class="params">(<span class="keyword">int</span>[] answers)</span></span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : answers)&#123;</span><br><span class="line">            count.put(a, count.getOrDefault(a, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = entry.getKey(), y = entry.getValue();</span><br><span class="line">            res += (x+y)/(x+<span class="number">1</span>)*(x+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">解题思路：两只相同颜色的兔子看到的其他同色兔子数必然是相同的。反之，若两只兔子看到的其他同色兔子数不同，那么这两只颜色也不同。因此，将answers中值相同的元素分为一组，对于每一组，计算出兔子的最少数量，然后后将所有的计算结果类加，就是最终答案。</span><br><span class="line">一般地，如果回答的x的兔子有y只，则至少有(x+y)/(x+1)种不同的颜色，且每种颜色都有(x+1)只兔子。</span><br></pre></td></tr></table></figure>

<h2 id="20210405"><a href="#20210405" class="headerlink" title="20210405"></a>20210405</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：88合并两个有序数组</span><br><span class="line">----------------------</span><br><span class="line">描述：给你两个有序整数数组nums1和nums2，请你将nums2合并到nums1中，使nums1成为一个有序数组。初始化nums1和nums2的元素数量分别为m和n。你可以假设nums1的空间大小等于m+n，这样它就有足够的空间保存来自nums2的元素。</span><br><span class="line">----------------------</span><br><span class="line">输入：nums1=[1,2,3,0,0,0],m=3,nums2=[2,5,6],n=3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">----------------------</span><br><span class="line">输入：nums1=[1],m=1,nums2=[],n=0</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">解题思路：逆向双指针法！在nums1的后半部分是空的，可以直接覆盖不受影响。可将指针k设置为从后向前遍历，每次取值为i，j指针中较大的值；i指针和j指针分别从nums1的最大数值和nums2的最大数值开始；若当i指针&lt;0时说明nums剩下的数都可以直接赋给k指针指向剩下的数组；若当j指针&lt;0时，nums1中数组已经有序，合并结束。</span><br></pre></td></tr></table></figure>

<h2 id="20210406"><a href="#20210406" class="headerlink" title="20210406"></a>20210406</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：80删除有序数组中的重复项II</span><br><span class="line">------------------------------</span><br><span class="line">描述：给你一个有序数组nums,请你原地删除重复出现的元素，使每个元素最多出现两次，返回删除后数组的新长度。不要使用额外的空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。</span><br><span class="line">------------------------------</span><br><span class="line">输入：nums=[1,1,1,2,2,3]</span><br><span class="line">输出：5，nums=[1,1,2,2,3]</span><br><span class="line">------------------------------</span><br><span class="line">输入：nums=[0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：nums=[0,0,1,1,2,3,3]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">2</span>] != nums[j])&#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">解题思路：给定的是有序数组，若元素相等则元素必会连续。我们使用双指针来解决本题，遍历数组中的每一个元素并检查其是否应该被保留。定义两个快慢指针i,j；慢指针i用来表名数组中的元素个数，快指针j用来检查元素是否应该加入新数组中。本题要求相同元素最多出现两次，所以我们应该检查上上个保留的元素nums[i-2]是否与当前检查的元素nums[j]相等。若nums[i-2]=nums[j]则，检查元素不应该放入新数组中，让其检查后续元素；若nums[i-2]!=nums[j]，则将当前元素保存下来，慢指针向后移动。当快指针全部遍历完毕时结束。</span><br><span class="line">时间复杂度：O(n);空间复杂度O(1).</span><br></pre></td></tr></table></figure>



<h2 id="20210407"><a href="#20210407" class="headerlink" title="20210407"></a>20210407</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：81搜索旋转排序数组II</span><br><span class="line">-------------------------</span><br><span class="line">描述：已知存在一个按非降序排列的整数数组nums，数组中的值不必互不相同。在传递给函数之前，nums在预先未知的某个下标k上进行了旋转，使数组变为[nuk[k], nums[k+1]],...,nums[n-1], nums[0], nums[l], ...,nums[k-1]]。例如，[0,1,2,4,4,4,5,6,6,7]在下标5处经旋转后可能变为[4,5,6,6,7,0,1,2,4,4].给你旋转后的数组nums和一个整数target，请你编写一个函数来判断给定的目标是否存在于数组中。如果nums中存在这个目标值target,则返回true，否则返回false。</span><br><span class="line">--------------------------</span><br><span class="line">输入：nums=[2,5,6,0,0,1,2],target=0</span><br><span class="line">输出：true</span><br><span class="line">--------------------------</span><br><span class="line">输入：nums[2,5,6,0,0,1,2],target=3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ((j - i) &gt;&gt; <span class="number">1</span>) + i;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[mid] &amp;&amp; nums[mid] == nums[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= target &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                    j = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[j])&#123;</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">我们使用二分查找法来解决该问题。但是二分查找可能会出现a[i]=a[mid]=a[j]，此时无法判断左右两部分哪边是有序的。对于上述的问题我们可以当前二分区域的左边界+1，右边界-1，然后在新的分区上搜索。二分查找的思路可以详见33题。</span><br><span class="line">时间复杂度：O(n);空间复杂度：O(1)。</span><br></pre></td></tr></table></figure>

<h2 id="20210408"><a href="#20210408" class="headerlink" title="20210408"></a>20210408</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：153寻找旋转排序数组中的最小值</span><br><span class="line">--------------------------------</span><br><span class="line">描述：已知一个长度为n的数组，预先按照升序排序，经由1到n此旋转后，得到输入数组。例如，原数组nums=[0,1,2,4,5,6,7]在变化后可能得到：</span><br><span class="line">若旋转4次，则可以得到[4,5,6,7,0,1,2]</span><br><span class="line">若旋转7次，则可以得到[0,1,2,4,5,6,7]</span><br><span class="line">给你一个元素互不相同的数组nums，它原来是一个升序排序的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素。</span><br><span class="line">-----------------------------------</span><br><span class="line">输入：nums=[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">-----------------------------------</span><br><span class="line">输入：nums=[4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">------------------------------------</span><br><span class="line">输入：nums=[11,13,15,17]</span><br><span class="line">输出：11</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ((j - i) &gt;&gt; <span class="number">1</span>) + i;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[j])&#123;</span><br><span class="line">                j = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">我们使用二分法来查找最小数，原数组为一个升序排序数组，经过旋转后，通过数组中间的数值将这个数组分为两个部分，其中必有一部分为有序数组。我们用中间值与数组最后的值做比较，若中间值严格小于最后的值，那么数组的最小值应该在[左边界，中间值所在索引]之间，否则数组的最小值应该在[中间值索引+1，有边界]之间。当区间长度为1时，停止二分查找。</span><br><span class="line">时间复杂度为：O(logn);空间复杂度为：O(1)</span><br></pre></td></tr></table></figure>

<h2 id="20210409"><a href="#20210409" class="headerlink" title="20210409"></a>20210409</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：154寻找旋转排序数组中的最小值II</span><br><span class="line">---------------------------------</span><br><span class="line">描述：已知一个长度为n的数组，预先按照升序排序，经由1到n此旋转后，得到输入数组。例如，原数组nums=[0,1,2,4,5,6,7]在变化后可能得到：</span><br><span class="line">若旋转4次，则可以得到[4,5,6,7,0,1,2]</span><br><span class="line">若旋转7次，则可以得到[0,1,2,4,5,6,7]</span><br><span class="line">给你一个可能存在重复元素的数组nums，它原来是一个升序排序的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素。</span><br><span class="line">---------------------------------</span><br><span class="line">输入：nums=[1,3,5]</span><br><span class="line">输出：1</span><br><span class="line">--------------------------------</span><br><span class="line">输入：nums=[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span> nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ((j - i) &gt;&gt; <span class="number">1</span>) + i;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[mid] &amp;&amp; nums[mid] == nums[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[j])&#123;</span><br><span class="line">                j = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">我们使用二分查找。该数组经过旋转后，从中间切开，可以将数组分为两部分。由于数组中可能存在相等的数即nums[左边界]=nums[mid]=nums[有边界]，我们就让左边界+1，右边界-1.我们将比较nums[中间索引]和nums[有边界索引]，若nums[mid]严格小于nums[右边界]则让有边界赋值为mid，否则将左边界赋值为mid+1。</span><br></pre></td></tr></table></figure>

<h2 id="20210410"><a href="#20210410" class="headerlink" title="20210410"></a>20210410</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：263丑数</span><br><span class="line">-----------------------------------------</span><br><span class="line">描述：给你一个整数n，请你判断n是否为丑数，如果是，返回true；否则，返回false。</span><br><span class="line">丑数就是只包含质因数2，3或5的正整数。</span><br><span class="line">------------------------------------------</span><br><span class="line">输入：n = 6</span><br><span class="line">输出：true</span><br><span class="line">解释：6 = 2 × 3</span><br><span class="line">-----------------------------------------</span><br><span class="line">输入：n = 8</span><br><span class="line">输出：true</span><br><span class="line">解释：8 = 2 × 2 × 2</span><br><span class="line">------------------------------------------</span><br><span class="line">输入：n = 14</span><br><span class="line">输出：false</span><br><span class="line">解释：14 不是丑数，因为它包含了另外一个质因数 7 。</span><br><span class="line">------------------------------------------</span><br><span class="line">输入：n = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> isUgly(n / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> isUgly(n / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> isUgly(n / <span class="number">5</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">采用递归的方法。若n能被2，3，5整除，将其先整除再继续迭代。递归的出口是若n==1则为丑数，否则不为丑数。</span><br></pre></td></tr></table></figure>

<h2 id="20210411"><a href="#20210411" class="headerlink" title="20210411"></a>20210411</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：264丑数II</span><br><span class="line">---------------------------------</span><br><span class="line">给你一个整数n，请你找出并返回第n个丑数。</span><br><span class="line">丑数就是只包含质因数2、3或5的正整数。</span><br><span class="line">---------------------------------</span><br><span class="line">输入：n = 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br><span class="line">-----------------------------------</span><br><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">1</span>, p2 = <span class="number">1</span>; p3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = res[p1] * <span class="number">2</span>, num2 = res[p2] * <span class="number">3</span>, num3 = res[p3] * <span class="number">5</span>;</span><br><span class="line">            res[i] = Math.min(Math.min(num1, num2), num3);</span><br><span class="line">            <span class="keyword">if</span>(res[i] == num1)&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == num2)&#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == num3)&#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">采用三指针法，首先最小的丑数是1，再res中直接放入即res[1]=1；再通过三个指针来得到下一个丑数，让当前的丑数值乘以2，3，5得到对应的三个数，然后取其中最小的作为下一个丑数。</span><br><span class="line">然后分别比较得到的丑数值是否等于这三个指针得到三个数，若相同则指针向前移。</span><br></pre></td></tr></table></figure>

<h2 id="20210412"><a href="#20210412" class="headerlink" title="20210412"></a>20210412</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：179最大数</span><br><span class="line">-------------------</span><br><span class="line">给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</span><br><span class="line">--------------------</span><br><span class="line">输入：nums = [10,2]</span><br><span class="line">输出：&quot;210&quot;</span><br><span class="line">--------------------</span><br><span class="line">输入：nums = [3,30,34,5,9]</span><br><span class="line">输出：&quot;9534330&quot;</span><br><span class="line">---------------------</span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line">---------------------</span><br><span class="line">输入：nums = [10]</span><br><span class="line">输出：&quot;10&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] str = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            str[i] = nums[i] + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(str, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> (b+a).compareTo(a+b);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : str)&#123;</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="string">&quot;0&quot;</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20210413"><a href="#20210413" class="headerlink" title="20210413"></a>20210413</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：783二叉搜索树节点最小距离</span><br><span class="line">-----------------------------</span><br><span class="line">给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</span><br><span class="line">-----------------------------</span><br><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br><span class="line">-----------------------------</span><br><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        pre = -<span class="number">1</span>;</span><br><span class="line">        ans = Integer.MAX_VALUE;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == -<span class="number">1</span>)&#123;</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = Math.min(ans, root.val - pre);</span><br><span class="line">            pre = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目：208实现Trie</span><br><span class="line">-------------------</span><br><span class="line">Trie（发音类似 &quot;try&quot;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</span><br><span class="line">请你实现 Trie 类：</span><br><span class="line">Trie() 初始化前缀树对象。</span><br><span class="line">void insert(String word) 向前缀树中插入字符串 word 。</span><br><span class="line">boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</span><br><span class="line">boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</span><br><span class="line">--------------------</span><br><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Trie[] child;</span><br><span class="line">    <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        child = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.child[index] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                node.child[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.child[index] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> index = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.child[index] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>MyBatis基本使用</title>
    <url>/2021/04/14/MyBatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Mybaties介绍"><a href="#Mybaties介绍" class="headerlink" title="Mybaties介绍"></a>Mybaties介绍</h2><p>​        Mybatis是一款优秀的持久层框架。Mybatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作。</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>①数据准备<br>MySQL表的创建，记录的添加。</p>
 <span id="more"></span> 

<p>②导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>③编写核心配置</p>
<p>在资源目录下创建：mybatis-config.xml内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改其中的一些参数。</p>
<p>④定义接口及对应的xml映射文件<br>在资源目录下创建对应的文件xml映射文件</p>
<p>⑤编写测试类<br>获取SqiSession，通过SqiSession.getMapper获取UserDao调用对应的方法</p>
<h2 id="入门代码初步理解"><a href="#入门代码初步理解" class="headerlink" title="入门代码初步理解"></a>入门代码初步理解</h2><p>测试类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;<span class="comment">//定义核心配置文件的路径</span></span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="comment">//传入对应配置文件的输入流，读取配置文件获得SqlSessionFactory对象</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">//通过SqlSessionFactory获取SqlSession(理解为数据库连接)</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//通过SqlSessionFactory获取DAO接口的实现类对象</span></span><br><span class="line">    UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="光速开发"><a href="#光速开发" class="headerlink" title="光速开发"></a>光速开发</h2><p><strong>IDEA配置代码模板</strong></p>
<p>可以在IDEA中设置模板</p>
<p><strong>Mybatis插件</strong></p>
<p>下载Free Mybatis plugin。在接口中可以自动生成xml文件。在接口中的方法中自动生成写入xml中。</p>
<h2 id="参数获取"><a href="#参数获取" class="headerlink" title="参数获取"></a>参数获取</h2><h3 id="一个参数"><a href="#一个参数" class="headerlink" title="一个参数"></a>一个参数</h3><h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><p>​        我们可以使用#{}直接来取值，写任意名字都可以获取到参数，但是一般用方法的参数名来取。</p>
<p>接口中的方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>xml中内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SELECT</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">SELECT</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h4><p>接口中的方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByUser</span><span class="params">(user user)</span></span>;</span><br></pre></td></tr></table></figure>

<p>xml中内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SELECT</span> <span class="attr">id</span>=<span class="string">&quot;findByUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125; and username = #&#123;username&#125; and age = #&#123;age&#125; and address = #&#123;address&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">SELECT</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>接口中的方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByMap</span><span class="params">(Map map)</span></span>;</span><br></pre></td></tr></table></figure>

<p>xml中内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Select</span> <span class="attr">id</span>=<span class="string">&quot;findByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125; and username = #&#123;username&#125; and age = #&#123;age&#125; and address = #&#123;address&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">Select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">&quot;id&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;PDD&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">map.put(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">userDao.findByMap(map);</span><br></pre></td></tr></table></figure>



<h3 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h3><p>​        Mybatis会把多个参数放入一个Map集合中，默认的key是argx和paramx这种格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByCondition</span><span class="params">(Integer id, String username)</span></span>;</span><br></pre></td></tr></table></figure>

<p>最终map中的键值对如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&#123;arg1=PDD, arg0=2, param1=2, param2=PDD&#125;</span><br></pre></td></tr></table></figure>

<p>虽然可以使用对应的默认Key来获取，但是这样的可读性不好。我们一般在参数前使用@Param注解来设置参数名.</p>
<p>接口中的方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByCondition</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id, <span class="meta">@Param(&quot;username&quot;)</span> String username)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这样在Mapper中可以这样获取参数：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125; AND username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>如果只有一个参数的时候不用做什么处理；如果有多个参数情况下一定要加上@Param来设置参数名。</p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>SqlSessionFactory是一个SqlSession的工厂类，主要用于获取SqlSession对象。其成员方法方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">()</span></span>;<span class="comment">//默认不传，则为false</span></span><br><span class="line"><span class="comment">//获取SqlSession对象，传入的参数代表去创建的SqlSession是否自动提交</span></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>SqlSession提供了在数据库执行SQL命令所需要的方法。它还提供了事务相关操作。其成员方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">getMapper</span><span class="params">(class&lt;T&gt; type)</span></span>;<span class="comment">//获取mapper对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>;<span class="comment">//提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>;<span class="comment">//回滚事务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//释放资源</span></span><br></pre></td></tr></table></figure>

<h2 id="Mybatis实现增删改查"><a href="#Mybatis实现增删改查" class="headerlink" title="Mybatis实现增删改查"></a>Mybatis实现增删改查</h2><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>①接口中增加相关方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>

<p>②映射文件UserDao.xml增加相应的标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 新增数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO user VALUE (null , #&#123;username&#125;, #&#123;age&#125;, #&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：要记得提交事务：手动提交；或在openSession构造传入true</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>①接口中增加相关方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>②映射文件UserDao.xml增加相应的标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 删除数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">    DELETE FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：要记得提交事务：手动提交；或在openSession构造传入true</p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>①接口中增加相关方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updataUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>

<p>②映射文件UserDao.xml增加相应的标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 更新数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updataUser&quot;</span>&gt;</span></span><br><span class="line">    UPDATE user SET username = #&#123;username&#125;, age = #&#123;age&#125;, address = #&#123;address&#125; WHERE id = 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p><strong>根据ID查询</strong></p>
<p>①接口中增加相关方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>②映射文件UserDao.xml增加相应的标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>查询所有</strong></p>
<p>①接口中增加相关方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>②映射文件UserDao.xml增加相应的标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h2><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>在resources目录下有jdbc.properties文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis_db</span><br><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123456</span><br></pre></td></tr></table></figure>

<p>在mybatis-config.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置配置文件所在路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--获取配置文件中配置对应的值来设置连接相关参数 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/xiaohupao/dao/UserDao.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h3><p>可以使用该标签来进行一些设置</p>
<p>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><p>可以用来设置全类名设置别名，简化书写。一般设置一个包下的类全部具有默认别名，默认别名是类目首字母小写。例如：cn.xiaohupao.pojo.User别名为user。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.xiaohupao.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用&lt;package&gt;标签可以指定包名下面需要的Java Bean。也可以使用&lt;typeAlias alias=“User” type=“com.xiaohupao.pojo.User”/&gt;；也可以使用@Alias注解</p>
<h3 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h3><p>可以配置成适应多种环境，这种机制有助于SQL映射应用于多种数据库之中。</p>
<p>尽管可以配置多个环境，但每个SqlSessionFactory实例只能选择一种环境。所以如果想连接两个数据库，就需要创建两个SqlSessionFactory实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推。</p>
<h3 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h3><p>该标签的作用是加载映射，加载方式如下几种(主要使用四种)：</p>
<p>①使用相对于类路径的资源引用，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/xiaohupao/dao/UserDao.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②使用完全限定资源定位符(URL)<br>③使用映射器接口实现类的完全限定类名<br>④将包内的映射器接口实现全部注册为映射器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com/xiaohupao/dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h3><p>添加Log4J的jar包；配置Log4J</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 全局日志配置</span><br><span class="line">log4j.rootLogger=ERROR, stdout</span><br><span class="line"># MyBatis 日志配置</span><br><span class="line">log4j.logger.org.mybatis.example.BlogMapper=TRACE</span><br><span class="line"># 控制台输出</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br></pre></td></tr></table></figure>

<h3 id="获取参数时-和-的区别"><a href="#获取参数时-和-的区别" class="headerlink" title="获取参数时#{}和${}的区别"></a>获取参数时#{}和${}的区别</h3><p>如果使用#{}它是预编译的sql可以防止SQL注入攻击；如果使用${}它是直接把参数拿过来直接进行拼接，这样会有SQL注入的危险。</p>
<h2 id="Mybatis注解开发"><a href="#Mybatis注解开发" class="headerlink" title="Mybatis注解开发"></a>Mybatis注解开发</h2><p>我们也可以使用注解来进行开发，用注解替换掉XML。使用注解来映射简单语句会使代码显得更加简洁。对于稍微复杂的语句，Java注解不仅力不从心，还会让你本就复杂的SQL语句更加混乱不堪。所以在实际开发中一般都是使用XML的形式。</p>
<p>①在核心配置文件中配置mapper接口所在包名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com/xiaohupao/dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②在接口对应方法上使用注解来配置需要执行的sql</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>使用if标签进行条件判断，条件成立才会把if标签中的内容进行拼接。<br>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">        AND username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果参数username为null则执行的sql为：SELECT * FORM user WHERE id=?<br>如果参数username不为null则执行的sql为：SELECT * FORM user WHERE id=? AND       username=？</p>
<p><strong>注意</strong>：在test属性中表示参数不需要写#{}。</p>
<h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>可以使用该标签动态的添加前缀或后缀，也可以使用该标签动态的消除前缀。</p>
<h4 id="prefixOverrides属性"><a href="#prefixOverrides属性" class="headerlink" title="prefixOverrides属性"></a>prefixOverrides属性</h4><p>用来设置需要被清除的前缀，多个值可以用|分隔，注意|前后不要有空格。例如and|or<br>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">perfixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line">        and </span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终执行的sql为：SELECT * FROM user</p>
<h4 id="suffixOverrides属性"><a href="#suffixOverrides属性" class="headerlink" title="suffixOverrides属性"></a>suffixOverrides属性</h4><p>用来设置需要被清除的后缀可以用|分隔，注意|后不要有空格。例如and|or<br>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line">        id = #&#123;id&#125; and </span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终执行的sql为：SELECT * FROM user WHERE id = ？</p>
<h4 id="prefix属性"><a href="#prefix属性" class="headerlink" title="prefix属性"></a>prefix属性</h4><p>用来设置动态添加的前缀，如果标签中有内容就会添加上设置的前缀。<br>例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span>&gt;</span></span><br><span class="line">        id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终执行的sql为：SELECT * FROM user WHERE id = ？</p>
<h4 id="suffix属性"><a href="#suffix属性" class="headerlink" title="suffix属性"></a>suffix属性</h4><p>用来设置动态添加的后缀，如果标签中有内容就会添加上设置的后缀。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">suffix</span>=<span class="string">&quot;id = #&#123;id&#125;&quot;</span>&gt;</span></span><br><span class="line">        where</span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终执行的sql为：SELECT * FROM user WHERE id = ？</p>
<h4 id="动态添加前缀WHERE并且消除前缀AND或者OR"><a href="#动态添加前缀WHERE并且消除前缀AND或者OR" class="headerlink" title="动态添加前缀WHERE并且消除前缀AND或者OR"></a>动态添加前缀WHERE并且消除前缀AND或者OR</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">            AND username = #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>where标签等价于：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>动态的拼接where并且去除前缀and或者or。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set标签等价于</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用set标签动态拼接set并且去除后缀的逗号。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">    UPDATE user</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">            username = #&#123;username&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null&quot;</span>&gt;</span></span><br><span class="line">            age = #&#123;age&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null&quot;</span>&gt;</span></span><br><span class="line">            address = #&#123;address&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果调用方法传入User对象的id为2，username不为null，其他属性都为null则最终执行sql为：UPDATE USER SET username = ? WHERE id = ?</p>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>可以使用foreach标签遍历集合或者数组类型的参数，获取其中的元素拿来动态的拼接SQL语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByIds</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> Integer[] ids)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;ida&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;ida&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>collection：表示要遍历的参数；open：表示遍历开始时拼接的语句；item：表示给当前遍历到的元素的取得名字；separator：表示遍历完一次拼接得分隔符；close：表示最后一次遍历拼接得语句。</p>
<p><strong>注意：</strong>如果方法参数是数组类型，默认的参数名是array，如果方法参数是list集合默认的参数名是list。建议遇到数组或者集合类型的参数统一使用注解@Param进行命名。</p>
<h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">                id = #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">                username = #&#123;username&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                id = 3</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>choose类似于java中的switch；when类似于java中的case；otherwise类似于java中的default。<br>一个choose标签中最多只会有一个when中的判断成立。从上到下进行判断。如果成立了就把标签体的内容拼接到sql中，并且不会进行其他when的判断和拼接。如果所有的when都不成立则拼接otherwise中的语句。</p>
<h2 id="SQL片段抽取"><a href="#SQL片段抽取" class="headerlink" title="SQL片段抽取"></a>SQL片段抽取</h2><p>在xml映射文件中编写SQL语句的时候可能会遇到重复的SQL片段。这种SQL片段我们可以使用sql标签来进行抽取。然后在需要的时候include标签进行使用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;base_sql&quot;</span>&gt;</span>id, username, age, address<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span> = <span class="string">&quot;findAll&quot;</span> <span class="attr">resultType-</span>&quot;<span class="attr">com.xiaohupao.pojo.User</span>&quot;&gt;</span></span><br><span class="line">    SELECT <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;base_sql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    FROM user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终执行的sql为：SELECT id, username, age, address FROM user</p>
<h2 id="环境案例"><a href="#环境案例" class="headerlink" title="环境案例"></a>环境案例</h2><h3 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>我们可以使用resultMap标签来自定义结果集和实体类属性的映射规则。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">resultMap 用来自定义结果和实体类的映射</span><br><span class="line">	属性：</span><br><span class="line">		id 相当于resultMap的唯一标识</span><br><span class="line">		type 用来指定映射到哪个实体类</span><br><span class="line">	id标签：用来指定主键列的映射规则</span><br><span class="line">		属性：</span><br><span class="line">			property 要映射的实体类属性名</span><br><span class="line">			column sql中的列明</span><br><span class="line">	result标签：用来指定普通列的映射</span><br><span class="line">		属性：</span><br><span class="line">			property 要映射的实体类属性名</span><br><span class="line">			column sql中的列明</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.xiaohupao.dao.OrderDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;createtime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createtime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;price&quot;</span> <span class="attr">property</span>=<span class="string">&quot;price&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;remark&quot;</span> <span class="attr">property</span>=<span class="string">&quot;remark&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderMap&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM orders</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h4><p>我们定义resultMap时默认情况下自动映射是开启状态的。也就是如果结果集的列明和我们属性名相同是会自动映射的，我们只需要写特殊情况的映射关系即可。</p>
<p>自动映射的属性为autoMapping=false 则将设置自动映射关闭。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.Order&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="继承映射关系"><a href="#继承映射关系" class="headerlink" title="继承映射关系"></a>继承映射关系</h4><p>啊、我们可以使用resultMap的extends属性来指定一个resultMap，从而复用重复的映射关系配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseOrderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.Order&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;createtime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createtime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;price&quot;</span> <span class="attr">property</span>=<span class="string">&quot;price&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;remark&quot;</span> <span class="attr">property</span>=<span class="string">&quot;remark&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseOrderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.Order&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;false&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;baseOrderMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>                                                             </span><br></pre></td></tr></table></figure>

<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="多表关联查询"><a href="#多表关联查询" class="headerlink" title="多表关联查询"></a>多表关联查询</h4><p><strong>一对一关系</strong></p>
<p>两个实体之间是一对一关系。例如：我们需要查询订单，需求还需要下单用户的数据，这里的订单相当于用户是一对一。</p>
<p>接口中的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据订单id查询订单，要求把下单用户的信息也查询出来</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Order <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因为期望Order中还能包含下单用户的数据，所以可以在Order中增加一个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> User user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT o.&#96;id&#96;, o.&#96;createtime&#96;, o.&#96;price&#96;, o.&#96;remark&#96;, u.&#96;id&#96; AS uid, u.&#96;username&#96;, u.&#96;age&#96;, u.&#96;address&#96;</span><br><span class="line">FROM ORDERS o, USER u</span><br><span class="line">WHERE o.&#96;user_id&#96; &#x3D; u.&#96;id&#96;</span><br><span class="line">AND o.&#96;id&#96; &#x3D; 2</span><br></pre></td></tr></table></figure>

<p>我们可以使用如下两种方式封装结果集。</p>
<p><strong>使用ResultMap对所有字段进行映射</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseOrderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.Order&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;createtime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createtime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;price&quot;</span> <span class="attr">property</span>=<span class="string">&quot;price&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;remark&quot;</span> <span class="attr">property</span>=<span class="string">&quot;remark&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderUserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.Order&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;false&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;baseOrderMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderUserMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT o.`id`, o.`createtime`, o.`price`, o.`remark`, o.`user_id`, u.`id` AS uid, u.`username`, u.`age`, u.`address`</span><br><span class="line">    FROM ORDERS o, USER u</span><br><span class="line">    WHERE o.`user_id` = u.`id`</span><br><span class="line">    AND o.`id` = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用ResultMap中的association</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderUserMapAssociation&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.Order&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;baseOrderMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderUserMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT o.`id`, o.`createtime`, o.`price`, o.`remark`, o.`user_id`, u.`id` AS uid, u.`username`, u.`age`, u.`address`</span><br><span class="line">    FROM ORDERS o, USER u</span><br><span class="line">    WHERE o.`user_id` = u.`id`</span><br><span class="line">    AND o.`id` = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>一对多关系</strong></p>
<p>两个实体类之间是一对多的关系。例如：我们需要查询用户，要求还是该用户所具有的角色信息，这里的用户相对于角色是一对多的。</p>
<p>接口中的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由于一个用户可以对应多个角色，所以在实体类中增加集合用于存储角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Role&gt; roles;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT u.&#96;id&#96;, u.&#96;username&#96;, u.&#96;age&#96;, u.&#96;address&#96;, r.&#96;id&#96; AS rid, r.&#96;name&#96;, r.&#96;desc&#96;</span><br><span class="line">FROM user u, user_role ur, role r</span><br><span class="line">WHERE u.id &#x3D; ur.user_id</span><br><span class="line">AND ur.role_id &#x3D; r.id</span><br><span class="line">AND u.id &#x3D; 2;</span><br></pre></td></tr></table></figure>

<p>封装结果的方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userBase&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userRoleMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;false&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;userBase&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;roles&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.xiaohupao.pojo.Role&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;rid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;desc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userRoleMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT u.`id`, u.`username`, u.`age`, u.`address`, r.`id` AS rid, r.`name`, r.`desc`</span><br><span class="line">    FROM user u, user_role ur, role r</span><br><span class="line">    WHERE u.id = ur.user_id</span><br><span class="line">    AND ur.role_id = r.id</span><br><span class="line">    AND u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="分部查询"><a href="#分部查询" class="headerlink" title="分部查询"></a>分部查询</h4><p>​        如果有需要多表查询的需求我们也可以选择多次查询的方式来查询出我们想要的数据。Mybatis也提供了对应的配置。<br>​        例如我们需要查询用户。需求还需要查询出该用户所具有的角色信息。我们可以选择先查询User表查询用户信息。然后在去查询相关的角色信息。</p>
<p><strong>实现步骤</strong></p>
<p>①定义查询方法</p>
<p>​        因为我们要分两步查询：1.查询User；2.根据用户id查询role信息。所以我们需要定义两个方法，并且把对应的标签也写好。</p>
<p>查询User</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByUsername</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, username, age, address FROM USER WHERE username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据user_id查询Role</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Role&gt; <span class="title">findRoleByUserId</span><span class="params">(Integer userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findRoleByUserId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.Role&quot;</span>&gt;</span></span><br><span class="line">    SELECT r.`id`,r.`name`, r.`desc`</span><br><span class="line">    FROM `user_role` ur, `role` r</span><br><span class="line">    WHERE ur.role_id = r.id</span><br><span class="line">    AND ur.user_id = #&#123;userId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②定义分部查询</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userBase&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userRoleMapBySelect&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;userBase&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;roles&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.xiaohupao.pojo.Role&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.xiaohupao.dao.RoleDao.findRoleByUserId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByUsername&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userRoleMapBySelect&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, username, age, address FROM USER WHERE username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="设置按需加载"><a href="#设置按需加载" class="headerlink" title="设置按需加载"></a>设置按需加载</h5><p>​        我们可以设置按需加载，这样在我们代码中需要用到关联数据的时候才回去查询关联数据。有两种可以配置分别是全局配置和局部配置。</p>
<p>局部配置：设置fetchType属性为lazy</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userBase&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userRoleMapBySelect&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;userBase&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;roles&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.xiaohupao.pojo.Role&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.xiaohupao.dao.RoleDao.findRoleByUserId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByUsername&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userRoleMapBySelect&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, username, age, address FROM USER WHERE username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>全局配置：设置lazyLoadingEnabled为true</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="分页查询-Pagehelper"><a href="#分页查询-Pagehelper" class="headerlink" title="分页查询-Pagehelper"></a>分页查询-Pagehelper</h3><p>​        我们可以使用PageHelper非常方便的帮我们实现分页查询，不需要自己在SQL中拼接相关参数，并且能非常方便的获取的总页数总条数等分页相关数据。</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>①定义方法查询方法以及生成对应标签</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.xiaohupao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT id, username, age, address FROM USER</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>③配置Mybatis核心配置文件使用分页插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>④开始分页查询</p>
<p>我们只需要在使用查询方法前设置分页参数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserDao userDao = <span class="keyword">this</span>.sqlSession.getMapper(UserDao.class);</span><br><span class="line">PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">List&lt;User&gt; all = userDao.findAll();</span><br><span class="line">System.out.println(all.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>如果需要获取总页数总条数等分页相关数据，只需要创建一个PageInfo对象，把刚刚查询出的返回值作为构造方法参数传入。然后使用pageInfo对象获取即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageInfo&lt;User&gt; userPageInfo = <span class="keyword">new</span> PageInfo&lt;User&gt;(all);</span><br><span class="line">System.out.println(<span class="string">&quot;总条数: &quot;</span> + userPageInfo.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;总页数：&quot;</span> + userPageInfo.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;当前页：&quot;</span> + userPageInfo.getPageNum());</span><br><span class="line">System.out.println(<span class="string">&quot;每页显示长度：&quot;</span> + userPageInfo.getPageSize());</span><br></pre></td></tr></table></figure>

<h4 id="一对多多表查询分页问题"><a href="#一对多多表查询分页问题" class="headerlink" title="一对多多表查询分页问题"></a>一对多多表查询分页问题</h4><p>​        我们在进行一对多表查询时，如果使用了PageHelper进行分页，会出现关联数据不全的情况，我们可以使用分布查询的方式解决该问题。</p>
<h2 id="Mybatis缓存"><a href="#Mybatis缓存" class="headerlink" title="Mybatis缓存"></a>Mybatis缓存</h2><p>​        Mybatis的缓存其实就是把之前查到的数据存入内存(map)，下次如果还是查询相同的东西，就可以直接从缓存中取，从而提高效率。<br>​        Mybatis有一级缓存和二级缓存之分，一级缓存(默认开启)是sqlsession级别的缓存。二级缓存相当于mapper级别的缓存。</p>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>几种不会使用一级缓存的情况：</p>
<ul>
<li>调用相同方法但是传入的参数不同</li>
<li>调用相同的方法参数也相同，但是使用的是另外的SqlSession</li>
<li>如果查询完后，对同一个表进行了增，删改的操作，都会清空这个SqlSession上的缓存</li>
<li>如果手动调用SqlSession的clearCache方法清除了缓存，后面也使用不了缓存</li>
</ul>
<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>注意：只有SqlSession调用了close或者commit后的数据才会进入二级缓存。</p>
<h4 id="开启二级缓存"><a href="#开启二级缓存" class="headerlink" title="开启二级缓存"></a>开启二级缓存</h4><p>①全局开启</p>
<p>在Mybatis核心配置文件中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis-config.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②局部开启</p>
<p>在要开启二级缓存的mapper映射文件设置cache标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.xiaohupao.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><p>二级缓存在实际开发中基本不会使用。</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2021/01/06/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="二叉树入门"><a href="#二叉树入门" class="headerlink" title="二叉树入门"></a>二叉树入门</h1><hr>
<h2 id="树的基本定义"><a href="#树的基本定义" class="headerlink" title="树的基本定义"></a>树的基本定义</h2><p>树是我们计算机非常重要的一种数据结构，同时使用树这种结构，可以描述现世生活中的很多事物。</p>
<p>树是由$n(n&gt;=1)$个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是跟朝上，而叶朝下的。</p>
 <span id="more"></span> 

<p>树具有以下特点：</p>
<ul>
<li>每个结点有零个或多个子节点；</li>
<li>没有父结点的结点为根结点；</li>
<li>每一个非根结点只有一个父结点；</li>
<li>每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；</li>
</ul>
<h2 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h2><p><strong>结点的度：</strong></p>
<p>一个结点含有的子树的个数称为该结点的度；</p>
<p><strong>叶结点：</strong></p>
<p>度为0的结点称为叶节点，也可以叫做终端结点；</p>
<p><strong>分支结点：</strong></p>
<p>度不为0的结点称为分支结点，也可以叫做非终端结点；</p>
<p><strong>结点的层次：</strong></p>
<p>从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推；</p>
<p><strong>结点的层序编号：</strong></p>
<p>将树中的结点，按照从上层到下层，同层从左往右的次序排列成一个线性序列，把他们编成连续的自然数；</p>
<p><strong>树的度：</strong></p>
<p>树中所有结点的度的最大值；</p>
<p><strong>树的深度(高度)：</strong></p>
<p>树中结点的最大层次；</p>
<p><strong>森林：</strong></p>
<p>$m(m&gt;=0)$个互不相交的树的集合，将一棵非空树的根结点删去，树就变成了一个森林；给森林增加一个统一的根结点，森林就会变成一棵树；</p>
<p><strong>孩子结点：</strong></p>
<p>一个结点的直接后继结点称为该结点的孩子结点；</p>
<p><strong>双亲结点(父结点)：</strong></p>
<p>一个结点的直接前驱称为该结点的双亲结点；</p>
<p><strong>兄弟结点：</strong></p>
<p>同一双亲结点的孩子结点间互称为兄弟结点；</p>
<hr>
<h2 id="二叉树的基本定义"><a href="#二叉树的基本定义" class="headerlink" title="二叉树的基本定义"></a>二叉树的基本定义</h2><p>二叉树就是度不超过2的树(每个结点最多有两个子结点)</p>
<p><strong>满二叉树：</strong></p>
<p>一个二叉树，如果每一层的结点树都到达最大值，则这个二叉树就是满二叉树。</p>
<p><strong>完全二叉树：</strong></p>
<p>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树</p>
<h3 id="二叉查找树的创建"><a href="#二叉查找树的创建" class="headerlink" title="二叉查找树的创建"></a>二叉查找树的创建</h3><p><strong>结点类的API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Node&lt;Key, Value&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(Key key, Value value, Node left, Node right)</td>
</tr>
<tr>
<td>成员变量</td>
<td>public Node left</td>
</tr>
<tr>
<td></td>
<td>public Node right</td>
</tr>
<tr>
<td></td>
<td>public Key key</td>
</tr>
<tr>
<td></td>
<td>public Value value</td>
</tr>
</tbody></table>
<p><strong>结点类的代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Key key;</span><br><span class="line">    <span class="keyword">public</span> Value value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉查找树的API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>BinaryTree&lt;Key extends Comparable&lt;Key&gt;, Value value&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>BinaryTree()</td>
</tr>
<tr>
<td>成员变量</td>
<td>private Node root</td>
</tr>
<tr>
<td></td>
<td>private int N</td>
</tr>
<tr>
<td>成员方法</td>
<td>public void put(Key key, Value value)</td>
</tr>
<tr>
<td></td>
<td>public Node put(Node x, Key key, Value val)</td>
</tr>
<tr>
<td></td>
<td>public Value get(Key key)</td>
</tr>
<tr>
<td></td>
<td>private Value get(Node x, Key key)</td>
</tr>
<tr>
<td></td>
<td>public void delete(Key key)</td>
</tr>
<tr>
<td></td>
<td>private Node delete(Node x, Key key)</td>
</tr>
<tr>
<td></td>
<td>public int size()</td>
</tr>
</tbody></table>
<p><strong>二叉查找树的代码实现：</strong></p>
<ul>
<li><strong>插入方法put实现思想：</strong><ul>
<li>如果当前树中没有任何一个结点，则直接把新结点当做根结点使用</li>
<li>如果当前树不为空，则从根结点开始：<ul>
<li>如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；</li>
<li>如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；</li>
<li>如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</li>
</ul>
</li>
</ul>
</li>
<li><strong>查询方法get实现思想：</strong><ul>
<li>从根结点开始：<ul>
<li>如果要查询的key小于当前结点的key，则继续查找当前结点的左子结点；</li>
<li>如果要查询的key大于当前结点的key，则继续查找当前结点的右子结点；</li>
<li>如果要查询的key等于当前结点的key，则树中返回当前结点的value；</li>
</ul>
</li>
</ul>
</li>
<li><strong>删除方法delete实现思想：</strong><ul>
<li>找到被删除结点；</li>
<li>找到被删除结点右子树中的最小结点minNode；</li>
<li>删除右子树中的最小结点；</li>
<li>让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树；</li>
<li>让被删除结点的父结点指向最小结点minNode。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Key key;</span><br><span class="line">        <span class="keyword">public</span> Value value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果x子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">            N++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子树不为空,比较x结点的键key的大小</span></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.right = put(x.right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.left = put(x.left,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            x.value = value</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x, Key key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//x树为null</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//x树不为null</span></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.right = delete(x.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x.left = delete(x.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            N--;</span><br><span class="line">            <span class="comment">//找到右子树中最小结点</span></span><br><span class="line">            <span class="keyword">if</span>(x.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> x.right;</span><br><span class="line">            &#125;</span><br><span class="line">            Node minNode = x.right;</span><br><span class="line">            <span class="keyword">while</span>(minNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                minNode = minNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除右子树中最小哦结点</span></span><br><span class="line">            Node temp = x.right;</span><br><span class="line">            <span class="keyword">while</span>(temp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.left.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = temp.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让x结点的左子树成为minNode的左子树</span></span><br><span class="line">            minNode.left = x.left;</span><br><span class="line">            <span class="comment">//让x结点的右子树成为minNode的右子树</span></span><br><span class="line">            minNode.right = x.right;</span><br><span class="line">            <span class="comment">//让x结点的父结点指向minNode</span></span><br><span class="line">            x = minNode;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉查找树其他便捷方法"><a href="#二叉查找树其他便捷方法" class="headerlink" title="二叉查找树其他便捷方法"></a>二叉查找树其他便捷方法</h3><p><strong>查找二叉树中最小的键：</strong></p>
<table>
<thead>
<tr>
<th>public Key min()</th>
<th>找出树中最小的键</th>
</tr>
</thead>
<tbody><tr>
<td>private Node min(Node x)</td>
<td>找出指定树x中，最小键所在的结点</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min(root).key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> min(x.left);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找二叉树中最大的键：</strong></p>
<table>
<thead>
<tr>
<th>Public Key max()</th>
<th>找出树中最大的键</th>
</tr>
</thead>
<tbody><tr>
<td>public Node max(Node x)</td>
<td>找出指定树x中，最大键所在的结点</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> max(x.right);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的基础遍历"><a href="#二叉树的基础遍历" class="headerlink" title="二叉树的基础遍历"></a>二叉树的基础遍历</h3><p>很多情况下，我们可能需要像遍历数组一样，遍历树，从而拿出树中存储的每一个元素，由于树状结构和线性结构不一样，它没有办法从头开始依次向后遍历，所以存在如何遍历，也就是按照什么样的搜索路径进行遍历的问题。</p>
<p>二叉树的遍历分为以下三种方式：</p>
<ul>
<li>前序遍历：先访问根结点，然后再访问左子树，最后访问右子树</li>
<li>中序遍历：先访问左子树，中间访问根结点，最后访问右子树</li>
<li>后序遍历：先访问左子树，在访问右子树，最后访问根结点</li>
</ul>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><table>
<thead>
<tr>
<th>public Queue&lt;Key&gt; preErgodic()</th>
<th>使用前序遍历，获取整个树中的所有键</th>
</tr>
</thead>
<tbody><tr>
<td>private void preErgodic(Node x, Queue&lt;Key&gt; keys)</td>
<td>使用前序遍历，获取指定树x中的所有键</td>
</tr>
</tbody></table>
<p><strong>实现步骤：</strong></p>
<ul>
<li>把当前结点的key放入到队列中；</li>
<li>找到当前结点的左子树，如果不为空，递归遍历左子树；</li>
<li>找到当前结点的右子树，如果不为空，递归调用遍历右子树。</li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Queue&lt;Key&gt; <span class="title">preErgodic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue&lt;key&gt; keys = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    preErgodic(root,keys);</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preErgodic</span><span class="params">(Node x, Queue&lt;Key&gt; keys)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把x结点的key放入到keys中</span></span><br><span class="line">    keys.enqueue(x.key);</span><br><span class="line">    <span class="comment">//递归遍历x结点的左子树</span></span><br><span class="line">    <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        preErgodic(x.left,keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归遍历x结点的右子树</span></span><br><span class="line">    <span class="keyword">if</span>(x.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        preErgodic(x.right,keys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        BinaryTree&lt;String, String&gt; tree = <span class="keyword">new</span> BinaryTree&lt;&gt;();</span><br><span class="line">        <span class="comment">//在树中添加对象</span></span><br><span class="line">        tree.put(<span class="string">&quot;E&quot;</span>,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        tree.put(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        tree.put(<span class="string">&quot;G&quot;</span>,<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        tree.put(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        tree.put(<span class="string">&quot;D&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        tree.put(<span class="string">&quot;F&quot;</span>,<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        tree.put(<span class="string">&quot;H&quot;</span>,<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        tree.put(<span class="string">&quot;C&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        Queue&lt;String&gt; keys = tree.preErgodic();</span><br><span class="line">        <span class="keyword">for</span>(String key: keys)&#123;</span><br><span class="line">            String value = tree.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><table>
<thead>
<tr>
<th>public Queue&lt;Key&gt; midErgodic()</th>
<th>使用中序遍历，获取整个树的所有键</th>
</tr>
</thead>
<tbody><tr>
<td>private void midErgodic(Node x, Queue&lt;Key&gt; keys)</td>
<td>使用中序遍历，获取指定树x中的所有键</td>
</tr>
</tbody></table>
<p><strong>实现步骤：</strong></p>
<ul>
<li>找到当前结点的左子树，如果不为空，递归遍历左子树；</li>
<li>把当前结点的key放入到队列中；</li>
<li>找到当前结点的右子树，如果不为空，递归遍历右子树。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Queue&lt;Key&gt; <span class="title">midErgodic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue&lt;Key&gt; keys = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    midErgodic(root,keys);</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">midErgodic</span><span class="params">(Node x, Queue&lt;Key&gt; keys)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归，把左子树中的键放入keys中</span></span><br><span class="line">    <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        midErgodic(x.left,keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把当前结点x的键放入keys中</span></span><br><span class="line">    keys.enqueue(x.key);</span><br><span class="line">    <span class="comment">//递归，把右子树中键放入到keys中</span></span><br><span class="line">    <span class="keyword">if</span>(x.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        midErgodic(x.right,keys);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><table>
<thead>
<tr>
<th>public Queue&lt;Key&gt; afterErgodic()</th>
<th>使用后序遍历，获取整个树中的所有键</th>
</tr>
</thead>
<tbody><tr>
<td>private void afterErgodic(Node x, Queue&lt;Key&gt; keys)</td>
<td>使用后序遍历，获取指定树x的所有键</td>
</tr>
</tbody></table>
<p><strong>实现步骤：</strong></p>
<ul>
<li>找到当前结点的左子树，如果不为空，递归遍历左子树；</li>
<li>找到当前结点的右子树，如果不为空，递归遍历右子树；</li>
<li>把当前结点的key放入到队列中。</li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Queue&lt;Key&gt; <span class="title">afterErgodic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue&lt;Key&gt; keys = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    afterErgodic(root,keys);</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterErgodic</span><span class="params">(Node x, Queue&lt;Key&gt; keys)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> afterErgodic(x.left,keys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> afterErgodic(x.right,keys);</span><br><span class="line">    &#125;</span><br><span class="line">    keys.enqueue(x.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p>所谓的层序遍历，就是从根结点开始，依次向下，获取每一层所有结点的值。</p>
<p><strong>层序遍历的API：</strong></p>
<table>
<thead>
<tr>
<th>public Queue&lt;Key&gt; layerErgodic()</th>
<th>使用层序遍历，获取整个树中的所有键</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>实现步骤：</strong></p>
<ul>
<li>创建队列，存储每一层的结点；</li>
<li>使用循环从队列中弹出一个结点：<ul>
<li>获取当前结点的key；</li>
<li>如果当前结点的左子结点不为空，则把左子结点放入到队列中；</li>
<li>如果当前结点的右子结点不为空，则把右子结点放入到队列中；</li>
</ul>
</li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Queue&lt;Key&gt; <span class="title">layerErgodic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义两个队列，分别存储树中的键和树中的结点</span></span><br><span class="line">    Queue&lt;Key&gt; keys = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    Queue&lt;Node&gt; nodes = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认，往队列中放入根结点</span></span><br><span class="line">    nodes.enqueue(root);</span><br><span class="line">    <span class="keyword">while</span>(nodes.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//从队列中弹出节点，把key放入keys中</span></span><br><span class="line">        Node temp = nodes.dequeue();</span><br><span class="line">        keys.enqueue(temp.key);</span><br><span class="line">        <span class="comment">//判断当前结点还有没有左子结点，如果有，则放入到nodes中</span></span><br><span class="line">        <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nodes.enqueue(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前结点还有没有右子结点，如果有，则放入等nodes中</span></span><br><span class="line">        <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nodes.enqueue(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的最大深度问题"><a href="#二叉树的最大深度问题" class="headerlink" title="二叉树的最大深度问题"></a>二叉树的最大深度问题</h3><p><strong>需求：</strong></p>
<p>给定一棵树，请计算出树的最大深度。</p>
<p><strong>最大深度的API：</strong></p>
<table>
<thead>
<tr>
<th>public int maxDepth()</th>
<th>计算整个树的最大深度</th>
</tr>
</thead>
<tbody><tr>
<td>private int maxDepth(Node x)</td>
<td>计算指定树x的最大深度</td>
</tr>
</tbody></table>
<p><strong>实现步骤：</strong></p>
<ul>
<li>如果根结点为空，则最大深度为0；</li>
<li>计算左子树的最大深度；</li>
<li>计算右子树的最大深度；</li>
<li>当前树的最大深度=左子树的最大深度和右子树的最大深度的较大者 + 1</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxDepth(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxR = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算左子树的最大深度</span></span><br><span class="line">    <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        maxL = maxDepth(x.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算右子树的最大深度</span></span><br><span class="line">    <span class="keyword">if</span>(x.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        maxR = maxDepth(x.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较左子树最大深度和右子树最大深度，取较大值+1</span></span><br><span class="line">    max = maxL &gt; maxR ? (maxL+<span class="number">1</span>) : (maxR+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h3><p><strong>需求：</strong></p>
<p>把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折一次，压出折痕后展开。此时，折痕是凹下去的，即折痕突起的方向指向纸条的背面，如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。</p>
<p>给定一个输入参数N，代表纸条从下边向上方对折N次，请从上到下打印所有折痕的方向；例如：N=1，打印：down；N=2，打印：donw，donw，up。</p>
<p><strong>分析：</strong></p>
<p>我们把对折后的纸张翻过来，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折痕就是该结点的左子结点，而第二次对折的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构来描述对折后产生的折痕。</p>
<p>这棵树有这样的特点：</p>
<ul>
<li>根结点为下折痕；</li>
<li>每一个结点的左子结点为下折痕；</li>
<li>每一个结点的右子结点为上折痕；</li>
</ul>
<p><strong>构建深度为N的折痕树：</strong></p>
<ul>
<li>第一次对折，只有一条折痕，创建根结点；</li>
<li>如果不是第一次对折，则使用队列保存根结点；</li>
<li>循环遍历队列：<ul>
<li>从队列中拿出一个结点</li>
<li>如果这个结点的左子结点不为空，则把这个左子结点添加到队列中</li>
<li>如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；</li>
<li>判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。</li>
</ul>
</li>
</ul>
<p><strong>代码的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PagerFoldingTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过模拟对折N次纸，产生树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node&lt;String&gt; <span class="title">createTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        Node&lt;String&gt; root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="comment">//当前是第一次对折</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                root = <span class="keyword">new</span> Node&lt;&gt;(<span class="string">&quot;down&quot;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前不是第一次对折</span></span><br><span class="line">            <span class="comment">//定义一个辅助队列，通过层序遍历的思想，找到叶子结点</span></span><br><span class="line">            Queue&lt;Node&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">            queue.enqueue(root);</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//从队列中弹出一个节点</span></span><br><span class="line">                Node&lt;String&gt; temp = queue.dequeue();</span><br><span class="line">                <span class="comment">//如果有左子结点，则把左子结点放入到队列中</span></span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.enqueue(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果有右子结点，则把右子结点放入队列中</span></span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.enqueue(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//同时没有左子结点和右子结点，则为叶子节点，只需要给该结点添加左子结点或右子结点</span></span><br><span class="line">                <span class="keyword">if</span>(temp.left == <span class="keyword">null</span> &amp;&amp; temp.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.left = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">&quot;down&quot;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">                    temp.right = <span class="keyword">new</span> Node&lt;String&gt;(<span class="string">&quot;up&quot;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node&lt;String&gt; root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//需要使用中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            printTree(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(root.item+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            printTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node left, Node right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>硬核显示技术</title>
    <url>/2020/12/20/%E7%A1%AC%E6%A0%B8%E6%98%BE%E7%A4%BA%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="硬核显示技术"><a href="#硬核显示技术" class="headerlink" title="硬核显示技术"></a>硬核显示技术</h1><hr>
<h2 id="显示器的原理"><a href="#显示器的原理" class="headerlink" title="显示器的原理"></a>显示器的原理</h2><p>目前最普及的商用显示器技术从技术原理上分成两大类：</p>
<ul>
<li>液晶显示器LCD(Liquid Crystal Display)</li>
<li>有机发光半导体OLED(Organic Light-emitting Diode)</li>
<li>CRT显像管显示器(太过久远，略)</li>
</ul>
<p>目前这两类显示器的显示原理都是基于通过三基色组合成像素点的光学原理。像素点非常微小并且非常密集人眼视距在正常的范围是看不到像素点的。LCD和OLED组成最小发光单元的原理却有着本质上的不同。</p>
 <span id="more"></span> 

<h3 id="LCD显示技术原理"><a href="#LCD显示技术原理" class="headerlink" title="LCD显示技术原理"></a>LCD显示技术原理</h3><p>LCD液晶显示器面板有很多层的结构，LCD面板的发光原理是通过在显示面板最下方的一层背光面板，发射白光。光线透过显示面板的多层结构照亮整个显示面板来实现发光。</p>
<p>每个物理像素点Pixel由RGB三个颜色的子像素(Sub Pixel)组成，每一个子像素都是一个可以被单独控制的透光单元。子像素本身是不带颜色的，而是透过背光板发出来的白光通过最外层RGB三种颜色的涂层被白光照亮而显示出来的颜色。在这个过程中通过三个基色的子像素分别控制进光量实现三基色不同亮度的组合，加上距离足够远的话人眼是无法分辨出三个不同颜色的子像素，就能组合出特定颜色的像素点。例如：一个像素中的三个子像素全部允许最大背光通过红色、绿色和蓝色同时达到最高亮度，那么由这三个子像素组成的一个像素点，在一定的距离外就会被人眼识别成白色；红色和绿色的子像素如果不透光，而蓝色透光，从远处看这个像素就是蓝色；红色和绿色都透光，蓝色不透光，那么这个像素点显示的就是黄色。那么黑色是怎么显示出来的呢？</p>
<p>当三个子像素全部屏蔽掉背光看起来就是黑色了！那么子像素是如何屏蔽掉白色背光的呢？这就是利用到了两层偏振膜。偏振膜的作用就是过滤掉多角度射入的杂光，只保留某一个角度射入的光线。具体来说就是，光从背光板发出只有某个特定偏振角度的光通了过去，在到达第二层偏振膜的时候，因为偏振角度跟第一层垂直光就无法穿透了，黑色就是通过这种方式显示的。</p>
<p>每一个子像素都是通过这种利用光的偏振原理实现单独控制进光量大小来调节亮度来最终显示彩色和黑白。</p>
<p>一块LCD屏幕上像素点有几百几千万甚至上亿颗，每一个像素点又由三基色的三个子像素组成，如何才能旋转这么大数量的偏振膜来单独控制每一个子像素的进光量呢？在两层偏振膜之间有一层特殊的材料就是传说中的液晶层，通过电压能够控制液晶的螺旋结构改变通过液晶层的光波的光学特性使光的偏振角度发生变化最终实现光线是否能够过第二层偏振膜。每一个子像素都有单独控制电压的逻辑电路，这就解决了几百上千万级别的子像素透光控制的问题。</p>
<p>上述就是LCD液晶显示器的一个子像素的工作原理，三个子像素组成一个像素点，成千上万个像素点平铺在一起就是一块LCD屏幕了。</p>
<p>LCD的优点：</p>
<ul>
<li>技术和产业非常成熟</li>
<li>能够以相对低廉的价格大量生产</li>
</ul>
<p>LCD的缺点：</p>
<ul>
<li>无法显示出纯黑色(虽然经过两层偏振膜，绝大多数的光线已经被过滤掉了，但还是会有少量的光线穿过了偏振膜。)</li>
<li>画面的对比度不够大(画面对比度可以理解为最亮的白色与最暗的黑色的比值，由于无法显示纯黑色，所以这个比值相对较低)</li>
<li>背光发出来的光线有至少80%的光线都被过滤掉了，光线透过这些层会造成相当大的亮度损耗，所以功耗也相对较大，即便显示黑色整块背光板的功率也是恒定的。(如果LCD面板需要显示更亮的画面就需要背光板提供更大的亮度的背光，亮度更大会导致黑色的像素的黑度更加不够。)</li>
</ul>
<p>目前LCD技术需要优化的主要：</p>
<ul>
<li>对比度</li>
<li>功耗</li>
<li>亮度</li>
</ul>
<h3 id="OLED显示技术原理"><a href="#OLED显示技术原理" class="headerlink" title="OLED显示技术原理"></a>OLED显示技术原理</h3><p>OLED依然是通过三基色组成像素的原理。不同于LCD的主要在于：</p>
<ul>
<li>OLED没有背光板，OLED通过每个像素点自发光。</li>
<li>OLED不需要两层偏振膜，OLED的面板的偏振膜是在最上层用来过滤自然光照射到显示面板之后再反射回人眼的杂光。(按道理来说OLED根本不需要偏振膜，至少偏振膜在OLED的显示器上的作用跟LCD不一样)</li>
<li>OLED显示黑色的时候子像素是完全关闭的，OLED的黑是纯黑色，因为根本没有光被发射出来。</li>
</ul>
<p>OLED的优点：</p>
<ul>
<li>OLED面板可以做的很薄，因为不需要背光板和底层的偏振膜，少了很多层的结构。</li>
<li>节电，因为OLED每个像素自发光而不依靠最下面一整层的背光板，电能转换为光的效率非常高，没有太多的热损耗。甚至是显示纯黑的部分是不耗费电能的。</li>
<li>显示的对比度高于LCD技术，因为黑色是纯粹的黑，且高亮的区域又是由于OLED自发光。</li>
<li>OLED可做成柔性屏，在可穿戴设备上OLED基本上是目前最好的解决方案。</li>
</ul>
<p>OLED的缺点：</p>
<ul>
<li>成本高<ul>
<li>OLED显示面板在生产的时候对氧气和空气湿度非常敏感，需要在真空或氮气环境中生产。</li>
<li>有机材料对封装和隔绝也要求特别高，导致生产大面积的OLED面板的难度和工艺呈指数级上升。</li>
</ul>
</li>
<li>烧屏现象(Screen Burning)<ul>
<li>持续通电的时间</li>
<li>温度</li>
<li>解决方法：<ul>
<li>LG、苹果通过位移那些长期固定显示某个元素的像素点的方式来避免像素过度的使用。例如苹果手机下发的拉杆会自己周期性的位移来避免烧屏</li>
<li>注意周期性的更换壁纸、控制屏幕的最高亮度。</li>
</ul>
</li>
<li>LCD屏幕也有烧屏现象，但产生的原理跟OLED不一样并且不是永久性的，LCD屏上出现的烧屏现象一般关机冷却几个小时都会自动复原。</li>
</ul>
</li>
</ul>
<h3 id="AMOLED和MicroLED"><a href="#AMOLED和MicroLED" class="headerlink" title="AMOLED和MicroLED"></a>AMOLED和MicroLED</h3><p>AMOLED本质上就是OLED；MicroLED从发光原理上也跟OLED差不多，因为没有使用有机材料基本上解决了烧屏问题，并且从色彩亮度和功耗还有像素密度上都是OLED的大幅度升级版本。MiicroLED是真正意义上的以后屏幕技术的发展方向。</p>
<h3 id="目前主流屏幕"><a href="#目前主流屏幕" class="headerlink" title="目前主流屏幕"></a>目前主流屏幕</h3><p>目前最主流的仍然是LCD液晶显示屏，虽然说整体的显示效果不如OLED，但是整个产业链非常成熟，成本优势非常大，再加上各种新型技术不断的在给LCD一次又一次的续命和优化LCD和OLED的显示效果的差距主要体现在对比度上，整体显示质量上没有一个天一个地那么大。虽然OLED显示面板的需求和供应连年上涨，但是LCD依然是高性价比和中低端市场占据主流。</p>
<h2 id="显示器和屏幕常用参数详解"><a href="#显示器和屏幕常用参数详解" class="headerlink" title="显示器和屏幕常用参数详解"></a>显示器和屏幕常用参数详解</h2><h3 id="分辨率和PPI"><a href="#分辨率和PPI" class="headerlink" title="分辨率和PPI"></a>分辨率和PPI</h3><p>分辨率指的是屏幕上水平方向和垂直方向的像素的数量的乘积。这个指标衡量的是显示器显示的精细程度。下面是不同分辨率之间的关系：</p>
<ul>
<li>HD：1280x720</li>
<li>Full HD：1920x1080</li>
<li>Quad HD：2560x1440</li>
<li>4K UHD：3840x2160</li>
<li>5K UHD+：5120x2880</li>
<li>8K UHD：7680x4320</li>
</ul>
<p>但是抛开屏幕的尺寸和视距不谈，只通过分辨率来讨论显示画面够不够精细是很不完善的，例如：一台100寸的电视在正常的视距下如果分辨率只有1920x1080那么按照目前的标准来看是一个非常糟糕的分辨率，因为你几乎可以清楚的看到像素点和画面中的锯齿；但是如果同样的分辨率放在一块手机屏幕上甚至是在智能手表的屏幕上，你就会觉得非常精细；同样的分辨率在VR显示设备里面，因为视距可能只有几厘米到十几厘米显示效果会比100寸的电视还要差，你可以很明显地分辨出每一个像素点。</p>
<p>所以衡量屏幕的精细程度要用更符合实际的PPI指标来考量。PPI(Pixel Per Inch)意思为在一英寸的对角线长度内像素的数量。这个指标衡量的是像素的密集程度，在一定的视距内PPI当然越高越好，但超过一个值你就看不太出来了，因为已经达到了人眼观察的极限。例如2010年 iPhone 4 视网膜屏幕的概念刚出来的时候，苹果用来界定人眼无法分辨出像素点的PPI是326，所以所谓的视网膜屏幕的概念也只是由苹果自己定义的。可以说手机上300的PPI再往上提升对于实际的肉眼的观感来说区别不大；电脑屏幕超过200PPI也很高了。在2019年IPhone 11 Pro Max的PPI就达到了458；</p>
<p>目前对于分辨率和PPI的要求越来越高的其实不是电脑显示器也不是手机屏幕，因为这两类屏幕在目前看来已接近于饱和了。现在对于屏幕的分辨率和PPI进一步提升的需求更大的设备是VR和AR的类型的显示器，因为VR和AR屏幕几乎是贴近人眼的，凑得更近看的也更清楚越容易看出像素点。</p>
<p>所以衡量一块屏幕的精细程度第一要看分辨率；第二要看屏幕的尺寸结合分辨率算出的PPI；第三要看视距。</p>
<h3 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h3><p>亮度的概念是个比较难统一的概念，在摄影领域、投影领域、电灯泡等照明设备的领域衡量亮度的指标分别有：流明、照度、坎德拉、Lux、nits等。</p>
<p>在显示设备里面，采用尼特nits这个指标来衡量一块屏幕的亮度。一尼特指的是：在一个平方米的范围内一个烛光也就是candela的亮度。现在主流的LCD显示屏亮度一般在两三百到四五百这个区间，也就是相当于一平方米内大概有几百个烛光candela的亮度。</p>
<p>nits衡量的是一块屏幕最高的亮度峰值而不是恒定的，一块屏幕在显示一幅画面的时候根据显示内容的不同亮度会有比较大的跨越，所以当你看到某个型号的显示器宣称自己能达到500nits，就意味着这块显示屏显示某个高亮的物体比如说太阳最高能够达到500nits，这个画面中如果同时有太阳和背光的悬崖，那么显示太阳的部分虽然到达500nits，但是背光下的悬崖可能只有几十个nits。</p>
<h3 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h3><p>HDR(High Dynamic Range)高动态范围，摄影领域的HDR和显示领域的HDR概念不太一样。HDR可以理解为画面中最亮的元素用最高亮度来显示，低亮度的元素依然能够维持比较低的亮度。</p>
<p>在目前主流的LCD显示面板是非常难以实现的。主流支持HDR显示面板的一般是自发光的OLED显示面板和量子点QLED面板(QLED其实就是背光技术不同的LCD面板)。OLED的有机发光半导体显示技术有两个特点非常适合HDR：一个就是自发光的高亮度，很多OLED的屏幕亮度能够达到上千nits；另一个就是纯黑色的显示。</p>
<p>HDR的标准有很多，做显示器和电视的厂商可能欺负小白不清楚这么多复杂的概念纷纷宣称自己支持HDR标准。例如：HDR10这个标准中，其中一个指标认为屏幕最高亮度达到1000nits就算支持了HDR10里面的一个标准，一个厂商的屏幕能达到1000nits的亮度，但另一个厂商能做到2000nits，都支持HDR10，但其显示效果能一样么？</p>
<p>对于用户来说，哪一类人更看重HDR这个指标：第一类为普通的观影爱好者、第二类是影视编辑相关工作的人、第三类人是一部分的游戏玩家。</p>
<h3 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h3><p>色域指的是一块屏幕能够显示的色彩范围，目前主流的色域标准有sRGB、AdobeRGB、DCI-P3。举个例子来说，如果用一块颜色显示不标准的显示器来调色一段视屏或者一张照片，那么成品在不同的显示器显示出来的实际效果可能是不一样的。</p>
<p>平面设计、打印行业比较统一的标准是sRGB和AdobeRGB；影视编辑这个行业比较标准的色域是NTSC和P3。</p>
<p>色域没有好坏并不是说某个色域的标准就一定比另一种色域好，不同的色域标准应用的场景不同。</p>
<p>sRGB相比之下色域比较窄。如果你发现某个显示器的厂商标注自己的显示器支持百分百的sRGB色域，你心里应该清楚这基本上就是一句废话，大概率是因为显示器厂商够不到AdobeRGB和P3色域的门槛。</p>
<h3 id="可视角度"><a href="#可视角度" class="headerlink" title="可视角度"></a>可视角度</h3><p>目前IPS面板碾压其他各类面板，其中TN面板的可视角度是最差的。这两种面板类型都是基于LCD显示面板。OLED的类型的面板天然有可视角度这个优势。 IPS屏把电机层和液晶层做在了一个平面，使得光线的方向性没有了，所以可视角度接近一百八十度，但是漏光现象就比较明显。目前TN面板虽然说可视角度差，但优点在于相对便宜，同时液晶分子的扭曲速度非常快，响应速度可以达到惊人的一毫秒，特别适合打游戏。所以TN面板适合游戏玩家选择，IPS面板泛用性比较强，但相对有点贵。OLED屏幕色彩更加鲜艳亮度和对比度非常高特别适合观影同时也是最贵的。</p>
<h3 id="FPS与屏幕刷新率"><a href="#FPS与屏幕刷新率" class="headerlink" title="FPS与屏幕刷新率"></a>FPS与屏幕刷新率</h3><p>FPS(frame per second)指的是一秒钟计算机显卡产生出的画面的数量，FPS并不是一个常量，而是根据画面生成的难度和显卡的性能随时动态改变的，静态下的计算机画面的FPS非常低，一旦画面变得相对复杂之后FPS变高对应的显卡负载变大。</p>
<p>屏幕刷新率是一个硬件指标，例如一块显示器的工作频率也就是屏幕刷新率是60Hz，那么只要通电后这块屏幕就以每秒60次的固定频率来显示画面，跟这块屏幕接收到的画面的FPS没有直接的关系。</p>
<p>如果FPS大于屏幕刷新率的情况呢？同理就算FPS好几百甚至上千，实际你人眼观察到的显示器频率受限于显示器最大刷新率。如果说显示器最大的刷新率是60Hz，如果FPS小于60，例如说是15，也就是一秒钟生成15帧，那么显示器每一帧会显示4次；如果FPS为10，那么显示器每一帧会显示6次。如果FPS高于屏幕刷新率，多出来的画面会被有规律的抛弃掉，因为显示器来不及显示出多出来的画面。</p>
<h4 id="你到底需要什么样的屏幕刷新率"><a href="#你到底需要什么样的屏幕刷新率" class="headerlink" title="你到底需要什么样的屏幕刷新率"></a>你到底需要什么样的屏幕刷新率</h4><h5 id="对于电脑显示器来说："><a href="#对于电脑显示器来说：" class="headerlink" title="对于电脑显示器来说："></a>对于电脑显示器来说：</h5><p>目前市面上主流的显示器都是60Hz的，这个刷新率应对日常办公基本够用了。而且目前主流的视频流媒体：电影和各种短视频在拍摄的时候都在60FPS以内，所以60Hz的屏幕足够用了。关于游戏与刷新率会在之后详解。</p>
<h5 id="手机的显示器来说："><a href="#手机的显示器来说：" class="headerlink" title="手机的显示器来说："></a>手机的显示器来说：</h5><p>为什么现在出现了90Hz甚至更高刷新率的屏幕的手机了。简单来说是观看距离变近了，导致人眼对刷新率的要求变高了。展开来说，因为人眼对屏幕的刷新率的感知是非常复杂的，涉及到亮度，观看距离，颜色，画面动态的幅度，屏幕的大小等。</p>
<p>90Hz甚至120Hz的屏幕的手机对于多数人来说，只是锦上添花的功能，实际意义并不大。在真实的使用场景下高刷新率的屏幕只有在显示UI动画和APP在支持高FPS渲染的情况下才具体能体现出来。</p>
<p>手机刷新率的提升是必要的，但是应该在成熟的时机下，根据屏幕的成本、性能、功耗和支持的APP生态这几个维度同步的良性提升。</p>
<h3 id="游戏和显示器刷新率"><a href="#游戏和显示器刷新率" class="headerlink" title="游戏和显示器刷新率"></a>游戏和显示器刷新率</h3><p>随着硬件性能的提升和游戏在计算机平台爆炸式的发展，现在很多的电脑游戏，很多画面非常激烈。尤其是FPS游戏，一旦拉动鼠标快速转身，画面运动太大导致往往50，60的FPS输出在60Hz的显示器上会有明显的撕裂感。甚至很多竞技类游戏，确实会因为毫秒级的画面显式滞后，造成严重的后果，所以高刷新率和高响应的显示面板在计算机游戏领域异军突起，144Hz甚至240Hz的游戏显示器也应运而生。</p>
<p>帧率对游戏的影响是非常重要的，很多人上了高刷新率显示器，一玩游戏就只觉得好爽好流畅，但是根本不知道是为什么这么流畅。你通过高刷新率的显示器感受到的爽来自两个角度：1. 你直接能够感受到的就是流畅的画面，单位时间内你的眼睛获取到的画面的数量更多，自然看起来就更流畅了。但仅仅是更流畅并不能带来游戏上的优势。2. 画面延迟的降低，一个游戏以60FPS的画面输出给60Hz的显示器，每一帧的显示时间为1s/60=16.67ms。你的每一次操作不考虑输入延迟的情况下，每16毫秒会更新一次出现在显示器上。然而同一个游戏以144FPS的画面输出给144Hz的显示器，同样的一秒内比60Hz的显示器多展示了将近60%的画面数量，每一帧的显式时间为1s/144=6.9ms。你的操作每过7ms就会被画面更新一次，比60Hz的显示器速度快了一倍多的时间，就是因为这个原因，你才会觉得操作更跟手反应更快，同时因为每一帧显示的速度更快，你也会比60Hz显示器的显示画面快那么几毫秒，提前看到下一帧。在对抗性的竞技游戏里面，这一点才是真正高刷新率显示器的优势。</p>
<p>其他情况的说明：如果你用一块高刷新率的显示器玩游戏，但是你的显卡很差，游戏输出的FPS只有几十，那么你高刷新率的屏幕基本上就是浪费了；比如你玩的游戏并不是竞技性的游戏，那么用不用高刷新率的屏幕玩其实只有画面流畅度有些许的区别而已，整体的体验不会差太多。</p>
]]></content>
      <categories>
        <category>硬核显示技术</category>
      </categories>
      <tags>
        <tag>显示技术</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章 异常、断言和日志</title>
    <url>/2020/11/03/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第七章-异常、断言和日志"><a href="#第七章-异常、断言和日志" class="headerlink" title="第七章 异常、断言和日志"></a>第七章 异常、断言和日志</h1><h2 id="7-1-处理错误"><a href="#7-1-处理错误" class="headerlink" title="7.1 处理错误"></a>7.1 处理错误</h2><p>假设在一个Java程序运行期间出现了一个错误。这个错误可能由于文件包含错误信息，或者网络连接出现问题造成的，也有可能是因为使用了无效的数组下标，或者试图使用一个没有被赋值的对象引用而造成的。用户期望在出现错误时，程序能够采取合理的行为。如果由于出现错误而使得某些操作没有完成，程序应该：</p>
<ul>
<li>返回到一种安全状态，并能够让用户执行其他的命令；或者</li>
<li>允许用户保存所有工作的结果，并以妥善的方式终止程序。</li>
</ul>
<p>为了能够处理程序中的异常情况，必须考虑到程序中可能会出现的错误和问题。那么需要考虑哪些问题呢？</p>
<ul>
<li>用户输入错误</li>
<li>设备错误</li>
<li>物理限制</li>
<li>代码错误</li>
</ul>
<p>正如第五章中所提到的那样，在Java中，如果某个方法不能采用正常的途经完成它的任务，可以通过另外一个路径退出方法。在这种情况下，方法并不返回任何值，而是抛出(throw)一个封装了错误信息的对象。需要注意的是，这个方法将会立刻退出，并不返回正常值。此外，也不会从调用这个方法的代码继续执行，取而代之的是，异常处理机制开始搜索能够处理这种异常状况的异常处理器(exception handler)。</p>
<p>异常有自己的语法和特定的继承层次结构。下面首先介绍语法，然后给出有效地使用这种语言特性的技巧。</p>
 <span id="more"></span> 

<h3 id="7-1-1-异常分类"><a href="#7-1-1-异常分类" class="headerlink" title="7.1.1 异常分类"></a>7.1.1 异常分类</h3><p>在Java程序设计语言中，异常对象都是派生于Throwable类的一个类实例。如果Java中内置的异常类不能满足需求，用户还可以创建自己的异常类。</p>
<p>需要注意的是，所有的异常都是Throwable继承而来，但在下一层立即分解为两个分支：Error和Exception。</p>
<p>Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。你的应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通知用户，并尽力妥善地终止程序之外，你几乎无能为力。这种情况很少出现。</p>
<p>在设计Java程序时，要重点关注Exception层次结构。这个层次结构又分解为两个分支：一个分支派生于RuntimeException；另一个分支包含其他异常。一般规则是：由编程错误导致的异常属于RuntimeException；如果程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。</p>
<p>派生于RuntimeException的异常包括以下问题：</p>
<ul>
<li>错误的强制类转换</li>
<li>数组访问越界</li>
<li>访问null指针。</li>
</ul>
<p>不是派生于RuntiomeException的异常包括：</p>
<ul>
<li>试图超越文件末尾继续读取数据</li>
<li>试图打开一个不存在的文件</li>
<li>试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。</li>
</ul>
<p>如果出现了RuntimeException异常，那么就一定是你的问题，这个规则很有道理。应该通过检测数组下标是否越界来避免ArrayIndexOutBoundsExceptiont异常；应该在使用变量之前通过检测它是否为null来杜绝NullPointerException异常的发生。</p>
<p>如何处理不存在的文件呢？难道不能先检查文件是否存在再打开它呢？嗯，这个文件有可能在你检查它是否存在之后就立即被删除了。因此，“是否存在”取决于环境，而不只是取决于你的代码。</p>
<p>Java语言规范将派生于Error类或RuntimeException类的所有异常称为非检查型(unchecked)异常，所有其他的异常称为检查型(checked)异常。这是很有用的术语，在后面还会用到。编译器将检查你是否为所有的检查型异常提供了异常处理器。</p>
<h3 id="7-1-2-声明检查型异常"><a href="#7-1-2-声明检查型异常" class="headerlink" title="7.1.2 声明检查型异常"></a>7.1.2 声明检查型异常</h3><p>如果遇到了无法处理的情况，Java方法可以抛出一个异常。这个道理很简单：方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。例如，一段读取文件的代码知道有可能读取的文件不存在，或者文件内容为空，因此，试图处理文件信息的代码就需要通知编译器可能抛出IOException类的异常。</p>
<p>要在方法的首部指出这个方法可能抛出一个异常，所以要修改方法首部，以反映这个方法可能抛出的检查异常。例如，下面是标准类库中的FileInputStream类的一个构造器的声明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br></pre></td></tr></table></figure>

<p>这个声明表示这个构造器将根据给定的String参数产生一个FileInputStream对象，但也有可能抛出一个FileNotFoundException异常。如果发生了这种情况，构造器将不会初始化一个新的FileInputStream对象，而是抛出一个FileNotFoundException类对象。如果这个方法真的抛出了这样一个异常对象，运行时系统就会开始搜索直到如何处理FileNotFoundException对象的异常处理器。</p>
<p>在自己编写方法时，不必声明这个方法可能抛出的所有异常。至于什么时候需要在方法中throws子句声明异常，以及要用throws子句声明哪些异常，需要记住在遇到下面四种情况会抛出异常：</p>
<ul>
<li>调用了一个抛出检查型异常的方法，例如FileInputStream构造器。</li>
<li>检测到一个错误，并且利用throw语句抛出一个检查型异常。</li>
<li>程序出现错误，例如，a[-1] = 0会抛出一个非检查型异常。</li>
<li>Java虚拟机或运行时库内出现内部错误。</li>
</ul>
<p>如果出现了前两种情况，则必须告诉调用这个方法的程序员有可能抛出异常。为什么？因为任何一个抛出异常的方法都有可能是一个死亡陷阱。如果没有处理器捕获这个异常，当前执行的线程就会终止。</p>
<p>有些Java方法包含在对外提供的类中，对于这些方法，应该通过方法首部的异常规范(exception specification)声明这个方法可能抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnimation</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Image <span class="title">loadImage</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个方法有可能抛出多个检查型异常类型，那么就必须在方法的首部列出所有的异常类。每个异常类之间用逗号隔开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnimation</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Image <span class="title">loadImage</span><span class="params">(String s)</span> <span class="keyword">throws</span> FileNotFoundException, EOFException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，不需要声明Java的内存错误，即从Error继承的异常。任何程序代码都有可能抛出那些异常，而我们对此完全无法控制。同样，也不应该声明从RuntimeException继承的那些非检查型异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnimation</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawImage</span><span class="params">(<span class="keyword">int</span> i)</span><span class="keyword">throws</span> ArrayIndexOutOfBoundsException <span class="comment">//bad style</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些运行时错误完全在我们的控制之中。如果特别担心数组下标错误，就应该多花些时间修正这些错误，而不只是声明这些错误有可能发生。</p>
<p>总之，一个方法必须声明所有可能抛出的检查型异常，而非检查型异常要么在你的控制之外(Error)，要么是由从一开始就应该避免的情况所导致的(RuntimeException)。如果你的方法没有声明所有可能发生的检查异常，编译器就会发出一个错误消息。</p>
<p>当然，从前面的示例中可以知道：不只是声明异常，你还可以捕获异常。这样就不会从这个方法抛出这个异常，所以也没有必要使用throws。</p>
<p>如果类中的一个方法声明它会抛出一个异常，而这个异常是某个特定类的实例，那么这个方法抛出的异常可能属于这个类，也可能属于这个类的任意一个子类。例如，FileInputStream构造器声明有可能抛出一个IOExcetion异常，在这种情况下，你并不知道具体是哪种IOException异常。它既可能是IOException异常，也可能是某个子类的对象，例如，FileNotFoundException。    </p>
<h3 id="7-1-3-如何抛出异常"><a href="#7-1-3-如何抛出异常" class="headerlink" title="7.1.3 如何抛出异常"></a>7.1.3 如何抛出异常</h3><p>现在假设在程序代码中发生了糟糕的事情。一个名为readData的方法正在读取一个文件，文件首部包含以下信息，承诺文件长度1024个字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Content - leangth: <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>然而，读到733个字符之后文件就结束了。你可能认为这是一种不正常的情况，希望抛出一个异常。</p>
<p>首先要决定应该抛出什么类型的异常。可能某种IOException是个不错的选择。仔细地阅读Java API文档之后会发现：EOFException异常的描述是：“指示输入过程中意外遇到了EOF”。完美，这正是我们要抛出的异常。下面是抛出这个异常的语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line"><span class="comment">//或者，也可以是</span></span><br><span class="line">EOFException e = <span class="keyword">new</span> EOFException();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"><span class="comment">//下面将这些代码放在一起</span></span><br><span class="line"><span class="function">String <span class="title">readData</span><span class="params">(Scanner in)</span> <span class="keyword">throws</span> EOFException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">while</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!in.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;len)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EOFException类还有一个带一个字符串参数的构造器。你可以很好地利用这个构造器，更细致地描述异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String gripe = <span class="string">&quot;Content - length:&quot;</span> + len + <span class="string">&quot;,Received:&quot;</span> + n;</span><br><span class="line"><span class="function"><span class="keyword">throws</span> new <span class="title">EOFException</span><span class="params">(gripe)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在前面已经看到，如果一个已有的异常类能够满足你的要求，抛出这个异常非常容易。在这种情况下：</p>
<ul>
<li>找到一个合适的异常类</li>
<li>创建这个类的一个对象</li>
<li>将对象抛出</li>
</ul>
<p>一旦方法抛出异常，这个方法就不会返回到调用者。也就是说，不必操心建立一个默认的返回值或错误码。</p>
<h3 id="7-1-4-创建异常类"><a href="#7-1-4-创建异常类" class="headerlink" title="7.1.4 创建异常类"></a>7.1.4 创建异常类</h3><p>你的代码可能会遇到任何标准异常类都无法描述清楚的问题。在这种情况下，创建自己的异常类就是一件顺理成章的事情了。我们需要做的只是一个派生于Exception的类，或者派生于Exception的某个子类，如IOException。习惯做法是，自定义的这个类应该包含两个构造器，一个是默认的构造器，另一个是包含详细描述信息的构造器(超类Throwable的toString方法会返回一个字符串，其中包含这个详细信息，这在调式中非常有用。)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> FileFormatException extends IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileFormatException</span><span class="params">(String gripe)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">readData</span><span class="params">(BufferedReader in)</span> <span class="keyword">throws</span> FileFormatException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">while</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &lt; len) <span class="function"><span class="keyword">throws</span> new <span class="title">FileFormatException</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-2-捕获异常"><a href="#7-2-捕获异常" class="headerlink" title="7.2 捕获异常"></a>7.2 捕获异常</h2><h3 id="7-2-1-捕获异常"><a href="#7-2-1-捕获异常" class="headerlink" title="7.2.1 捕获异常"></a>7.2.1 捕获异常</h3><p>如果发生了某个异常，但没有在任何地方捕获这个异常，程序就会终止，并在控制台上打印一个消息，其中包括这个异常的类型和一个堆栈轨迹。</p>
<p>想要捕获一个异常，需要设置try/catch语句块。最简单的try语句块如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code;</span><br><span class="line">    more code;</span><br><span class="line">    more code;</span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionType e)</span><br><span class="line">&#123;</span><br><span class="line">    handler <span class="keyword">for</span> <span class="keyword">this</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果try语句块中的任何代码抛出了catch子句中指定的一个异常类，那么：</p>
<ul>
<li>程序将跳过try语句块的其余代码。</li>
<li>程序将执行catch子句中的处理器代码。</li>
</ul>
<p>如果try语句块中的代码没有抛出任何异常，那么程序将跳过catch子句。</p>
<p>如果方法中的任何代码抛出了catch子句没有声明的一个异常类型，那么这个方法就会立即退出(希望它的调用者为这种类型的异常提供catch子句)。</p>
<p>为了展示捕获异常的处理过程，下面给出了一个很典型的读取数据的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">while</span>((b = in.read())!= -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            process input;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException exception)</span><br><span class="line">    &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，try子句中的大多数代码都很容易理解：读取并处理字节，直到遇到文件结束符为止。正如在JavaAPI中看到的那样，read方法有可能抛出一个IOException异常。在这种情况下，将跳出整个while循环，进入catch子句，并生成一个堆栈轨迹。对于一个“玩具类”的简单程序来说，这样处理异常看上去很有道理。还有其他选择么？</p>
<p>通常，最好的选择是什么也不做，而是将异常传递给调用者。如果read方法出现了错误，就让read方法调用者去操心这个问题！如果采用这种处理方法，就必须声明这个方法可能会抛出一个IOException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputString(filename);</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">   	<span class="keyword">while</span>((b = in.read()) != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        process input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请记住，编译器将严格地执行throws说明符。如果调用了一个抛出检查型异常的方法，就必须处理这个异常，或者继续传递这个异常。哪种方法更好呢？一般经验是，要捕获那些你知道如何处理的异常，而继续传播那些你不知道怎么处理的异常。如果想传播一个异常，就必须在方法的首部添加一个throws说明符，提醒调用者这个方法可能会抛出异常。查看API文档，可以看到每个方法可能会抛出哪些异常，然后决定是由自己处理，还是添加到throws列表中。对于后一种选择，不用感到难堪。将异常交给胜任的处理器进行处理要比压制这个异常更好。</p>
<p>同时记住，这个规则也有一个例外。前面曾经提到过：如果编写一个方法覆盖超类的方法，而这个超类的方法没有抛出异常(如JComponent中的paintComponent)，你就必须捕获你的方法代码中出现的每一检查型异常。不允许在子类的throws说明符中出现超类方法未列出的异常类。</p>
<h3 id="7-2-2-捕获多个异常"><a href="#7-2-2-捕获多个异常" class="headerlink" title="7.2.2 捕获多个异常"></a>7.2.2 捕获多个异常</h3><p>在一个try语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。要为每个异常类型使用一个单独的catch子句，如下列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code that might <span class="keyword">throw</span> exceptions</span><br><span class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> missing files</span><br><span class="line">&#125;<span class="keyword">catch</span>(UnknowHostException e)</span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> unknown hosts</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> all other I/O problems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常对象可能包含有关异常性质的信息。想要获得这个对象的更多信息，可以尝试使用e.getMessage()；得到详细的错误消息(如果有的话)，或者使用e.getClass().getName()得到异常对象的实际类型。</p>
<p>在Java7中，通过一个catch子句中可以捕获多个异常类型。例如，假设对应缺少文件和未知主机异常的动作是一样的，就可以合并catch子句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code that might <span class="keyword">throw</span> ceceptions</span><br><span class="line">&#125;<span class="keyword">catch</span>(FileNotFoundException | UnknownHostException e)</span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> missing files and unknown hosts</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    emergemcy action <span class="keyword">for</span> all other I/O problems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。</p>
<h3 id="7-2-3-再次抛出异常与异常链"><a href="#7-2-3-再次抛出异常与异常链" class="headerlink" title="7.2.3 再次抛出异常与异常链"></a>7.2.3 再次抛出异常与异常链</h3><p>可以在catch子句中抛出一个异常。通常，希望改变异常的类型时会这样做。如果开发了一个供其他程序员使用的子系统，可以使用一个指示子系统故障的异常类型，这很有道理。ServletException就是这样一个异常类型的例子。执行一个servlet的代码可能不想知道发生错误的细节原因，但希望明确地直到Servlet是否有问题。</p>
<p>可以如下捕获异常并将它再次抛出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    access the database;</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">&quot;databese error :&quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，构造ServletException时提供了异常的消息文本。</p>
<p>不过，可以有一种更好的处理方法，可以把原始异常设置为新异常的“原因”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    access the database</span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException original)</span><br><span class="line">&#123;</span><br><span class="line">    ServletException e = <span class="keyword">new</span> ServletException(<span class="string">&quot;database error&quot;</span>);</span><br><span class="line">    e.initCause(original);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕获到这个异常时，可以使用下面这条语句获取原始异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Throwable original = caughtException.getCause();</span><br></pre></td></tr></table></figure>

<p>强烈建议使用这种包装技术。这样可以在子系统中抛出高层异常，而不会丢失原始异常。</p>
<p>有时候你可能只想记录一个异常，再将它重新抛出，而不做任何改变：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    access the database;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    logger.log(level, message, e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-4-finally-子句"><a href="#7-2-4-finally-子句" class="headerlink" title="7.2.4 finally 子句"></a>7.2.4 finally 子句</h3><p>代码抛出一个异常时，就会停止处理这个方法中 剩余的代码，并退出这个方法。如果这个方法已经获得了只有它自己知道一些本地资源，而且这些资源必须清理，这就会有问题。一种解决方案是捕获所有异常，完成资源的清理，再重新抛出异常。但是，这种解决方案比较繁琐，这是因为需要在两个点地方清理资源分配。一个在正常的代码中；另一个在异常代码中。finally子句可以解决这个问题。</p>
<p>不管是否有异常被捕获，finally子句中的代码都会执行。在下面的示例中，所有情况下程序都将关闭输入流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(...);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    code that might <span class="keyword">throw</span> exceptions;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    show error message;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">&#125;<span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>这个程序可能在以下3中情况执行finally子句：</p>
<ul>
<li>代码没有抛出异常。这种情况下，程序首先执行try语句块中的全部代码，然后执行行finally子句中的代码。随后，继续执行finally子句之后的第一条语句。也就是说，执行顺序为1，2，5，6。</li>
<li>代码抛出一个异常，并在一个catch子句中捕获。在上面的示例中就是IOException异常。在这种情况下，程序将执行try语句块中的所有代码，直到抛出异常为止。此时，将跳过try语句块中的剩余代码，转去执行与该异常匹配的catch子句中的代码，最后执行finally子句中的代码。如果catch子句没有抛出异常，程序将执行finally子句之后的第一条语句。在这种情况下，执行顺序是1，3，4，5，6。如果catch子句抛出了一个异常，异常将被抛回到这个方法的调用者。执行顺序则只是1，3，5。</li>
<li>代码抛出了一个异常，但没有任何catch子句捕获这个异常。在这种情况下，程序将执行try语句块中的所有语句，直到抛出异常为止。此时，将跳过try语句块的剩余代码，然后执行finally子句中语句，并将异常抛回给这个方法的调用者。在这里，执行的顺序只是1，5。</li>
</ul>
<p>try语句可以只有finally子句，而没有catch子句。例如，下面这条try语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = ...;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code that might <span class="keyword">throw</span> exceptions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论在try语句块中是否遇到异常，finally子句中的in.close()语句都会执行。当然，如果真的遇到一个异常，这个异常将会被重新抛出，并且必须由另一个catch子句捕获。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = ...;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        code that might <span class="keyword">throw</span> exceptions</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    show error message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内层的try语句块只有一个职责，就是确保关闭输入流。外层的try语句块也只有一个职责，就是确保报告出现的错误。这种解决方法不仅清楚，而且功能更强大：将会报告finally子句中出现的错误。</p>
<h3 id="7-2-5-try-with-Resources-语句"><a href="#7-2-5-try-with-Resources-语句" class="headerlink" title="7.2.5 try-with-Resources 语句"></a>7.2.5 try-with-Resources 语句</h3><p>在Java7中，对于以下代码模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open a resource</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    work with the resource</span><br><span class="line">&#125;<span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    close the resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设资源属于一个实现了AutoCloseable接口的类。Java7为这种代码模式提供了一个很有用的快捷方式。AutoCloseable接口有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure>

<p>try-with-resources语句的最简形式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Resource res =...)</span><br><span class="line">&#123;</span><br><span class="line"> 	work with res   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try块退出时，会自动调用res.close()。下面给出一个典型的例子，这里要读取一个文件中的所有单词：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/usr/share/dict/words&quot;</span>),StandardCharsets.UTF_8))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(in.hasNext())</span><br><span class="line">        System.out.println(in.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个块正常退出时，或者存在一个异常时，都会调用in.close()方法，就好像使用了finally一样。还可以指定多个资源。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/usr/share/dict/words&quot;</span>,StandardCharsets.UTF_8);</span><br><span class="line">                            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;out.txt&quot;</span>,StandardCharsets.UTF_8))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())</span><br><span class="line">            out.println(in.next().toUpperCase());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>不论这个块如何退出，in和out都会关闭。如果你用常规方式手动编程，就需要两个嵌套的try/finally语句。</p>
<p>在Java9中，可以在try首部中提供之前声明的事实最终变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">(String[] lines, PrintWriter out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(out)</span><br><span class="line">    &#123;<span class="comment">//effectively final cariable</span></span><br><span class="line">        <span class="keyword">for</span>(String line: lines)</span><br><span class="line">            out.println(line);</span><br><span class="line">    &#125;<span class="comment">//out.close() called here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果try块抛出一个异常，而且close方法也抛出一个异常，这就带来一个难题。try-with-resources语句可以很好地处理这种情况。原来的异常会重新抛出，而close方法抛出的异常会“被抑制”。这些异常将自动捕获，并由addSuppressed方法增加到原来的异常。如果对这些异常感兴趣，可以调用getSuppressed方法，它会生成从close方法抛出并被抑制的异常数组。</p>
<p>你肯定不想采用这种常规方式编程。只要需要关闭资源，就要尽可能使用try-with-resources语句。</p>
<h3 id="7-2-6-分析堆栈轨迹元素"><a href="#7-2-6-分析堆栈轨迹元素" class="headerlink" title="7.2.6 分析堆栈轨迹元素"></a>7.2.6 分析堆栈轨迹元素</h3><p>堆栈轨迹(stack trace)是程序执行过程中某个特定点上所有挂起的方法调用的一个列表。你肯定已经看到过这种堆栈轨迹列表，当Java程序因为一个未捕获的异常而终止时，就会显示堆栈轨迹。</p>
<p>可以调用Throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Throwable t = <span class="keyword">new</span> Throwable();</span><br><span class="line">StringWriter out = <span class="keyword">new</span> StringWriter();</span><br><span class="line">t.printStackTrace(<span class="keyword">new</span> PrintWriter(out));</span><br><span class="line">String description = out.toString();</span><br></pre></td></tr></table></figure>

<p>一种更灵活的方法是使用StackWalker类，它会生成一个StackWalker.StackFrame实例流，其中每个实例分别描述一个栈帧(stack frame)。可以利用以下调用迭代处理这些栈帧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StackWalker walker = StackWalker.getInstance();</span><br><span class="line">walker.forEach(frame -&gt; analyze frame)</span><br></pre></td></tr></table></figure>

<p>如果想要以懒方式处理Stream&lt;StackWalker.StackFrame&gt;，可以调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">walker.walk(stream -&gt; process stream)</span><br></pre></td></tr></table></figure>



<h2 id="7-3-使用异常的技巧"><a href="#7-3-使用异常的技巧" class="headerlink" title="7.3 使用异常的技巧"></a>7.3 使用异常的技巧</h2><ul>
<li>1.异常处理不能代替简单的测试：作为一个示例，在这里编写了一段代码，试着将一个空栈弹出10000000次。首先，在弹栈之前先查看栈是否为空。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!s.empty()) s.pop()</span><br></pre></td></tr></table></figure>

<p>接下来，我们强制要求不论栈是否为空都执行弹出操作，然后捕获EmptyStackException异常来指示我们不能这样做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    s.pop();</span><br><span class="line">&#125;<span class="keyword">catch</span>(EmptyStackException e)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的测试机器上，调用isEmpty的版本运行时间为646毫秒。捕获EmptyStackException的版本运行时间为21739毫秒。可以看出，与完成简单的测试相比，捕获异常所花费的时间大大超过了前者，因此使用异常的基本规则是：只在异常情况下使用异常。</p>
<ul>
<li>2.不要过分地细化异常：很多程序员习惯将每一条语句都分装在一个独立的try语句块中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream out;</span><br><span class="line">Stack s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = s.pop();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(EmptyStackException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//stack was empty</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        out.writeInt(n);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//problem writing to file</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种编程方式将导致代码量的急剧膨胀。首先来看你希望这段代码完成的任务。在这里，我们希望从栈中弹出100个数，将它们存入一个文件中。如果出现了问题，我们什么也做不了。如果栈是空的，他不会变成非空状态；如果文件包含错误，这个错误也不会魔法般地消失。因此，有必要将整个任务包在一个try语句块中，这样，当任何一个操作出现问题时，就可以取消整个任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n = s.pop();</span><br><span class="line">        out.writeInt(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//problem writing to file</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(EmptyStackException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Stack was empty</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看起来清晰多了。这样也满足了异常处理的一个承诺：将正常处理与错误处理分开。</p>
<ul>
<li>3.充分利用异常层次结构：不要只抛出RuntimeException异常。应该寻找一个合适的子类或创建自己的异常类。不要只捕获Throwable异常，否则，这会使你的代码更难读、更难维护。考虑检查型异常与非检查型异常的区别。检查型异常本来就很庞大，不要为逻辑错误抛出这些异常。如果能够将一种异常转换成另一种更加合适的异常，那么不要犹豫。例如，在解析某个文件中的一个整数时，可以捕获NumberFormatException异常，然后将它转换为IOException的一个子类或MySubsystemException。</li>
<li>4.不要压制异常：在Java中，往往非常希望关闭异常。如果你编写了一个方法要调用另一个方法，而那个方法有可能100年才抛出一个异常，但是，如果没有在你的方法的throws列表中声明这个异常，编译器就会报错。你不想把它放在throws列表中，以为这样一来，编译器会对调用了你的方法的所有方法报错。因此，你会将这个异常关闭：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Image <span class="title">loadImage</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        code that threatens to <span class="keyword">throw</span> checked exception</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你的代码可以通过编译了。除非出现异常，否则它能很好地运行。但是一旦出现异常，这个异常会悄无声息地被忽略。如果你认为异常都非常重要，就应当是当地进行处理。</p>
<ul>
<li>5.在检测错误时，“苛刻”要比放任更好：当检测到错误的时候，有些程序员对抛出异常很担心。在用无效的参数调用一个方法时，返回一个虚拟值是不是比抛出一个异常更好？例如，党栈为空时，Stack.pop是该返回一个null，还是要抛出一个异常？我们认为：最好在出错的地方抛出一个EmptyStackException异常，这要好于以后抛出一个NullPointerException异常。</li>
<li>6.不要羞于传递异常：很多程序员都感觉应该捕获抛出的全部异常。如果调用了一个抛出异常的方法，例如，FileInputStream构造器或readLine方法，它们就会本能地捕获这些可能产生的异常。其实，最好继续传递这个异常，而不是自己捕获：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readStuff</span><span class="params">(String filename)</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(filename, StandardCharsets.UTF_8);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更高层的方法通常可以更好地通知用户发生了错误，或者放弃不成功的命令。</p>
<h2 id="7-4-使用断言"><a href="#7-4-使用断言" class="headerlink" title="7.4 使用断言"></a>7.4 使用断言</h2><h3 id="7-4-1-断言的概念"><a href="#7-4-1-断言的概念" class="headerlink" title="7.4.1 断言的概念"></a>7.4.1 断言的概念</h3><p>假设确信某个属性符合要求，并且代码的执行依赖于这个属性。例如，需要计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> y = Math.sqrt(x);</span><br></pre></td></tr></table></figure>

<p>你确信这里的x是一个非负数。原因是：x是另外一个计算结果，而这个结果不可能是一个负值；或者x是一个方法的参数，这个方法要求它的调用者只能提供一个正数输入。不过，你可能还是想再做一次检查，不希望计算中潜入让人困惑的“不是一个数”(NaN)浮点数。当然，也可以抛出一个异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllagalArgumentException(<span class="string">&quot;x &lt; 0&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但是即使测试完毕后，这个代码还会一直保留在程序中。如果在程序中含有大量这种检查，程序运行起来慢很多。</p>
<p>断言机制允许在测试期间向代码中插入一些检查，而在生产代码中会自动删除这些检查。</p>
<p>Java语言引入了关键字assert。这个关键字有两种形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition;</span><br><span class="line"><span class="keyword">assert</span> condition : expression;</span><br></pre></td></tr></table></figure>

<p>这两个语句都会计算条件，如果结果为false，则抛出一个AssertionError异常。在第二个语句中，表达式将传入AssertionError对象构造器，并转换成一个消息字符串。</p>
<p>想要断言x是一个非负数，只需要简单地使用下面这条语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//或者将x的实际值传递给AssertionError对象，以便以后显示。</span></span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : x;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-2-启用和禁用断言"><a href="#7-4-2-启用和禁用断言" class="headerlink" title="7.4.2 启用和禁用断言"></a>7.4.2 启用和禁用断言</h3><p>在默认情况下，断言是禁用的。可以在运行程序时用 -enableassertions或 -ea 选项启用断言：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -enableassertions MyApp</span><br></pre></td></tr></table></figure>

<p>需要注意的是，不必重新编译程序来启用或禁用断言。启用或禁用断言是类加载器(class loader)的功能。禁用断言时，类加载器会取出断言代码，因此，不会降低程序运行的速度。也可以在某个类或整个包中启用断言，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -ea:MyClass -ea:com.mycompany.mylib MyApp</span><br></pre></td></tr></table></figure>

<p>这条命令将为MyClass类以及com.mycompany.mylib包和它的子包中的所有类打开断言。选项 -ea将打开无名包中所有类的断言。也可以用选项 -disableassertions 或 - da 在某个特定类和包中禁用断言：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -ea:... -da:MyClass MyApp</span><br></pre></td></tr></table></figure>

<p>有些类不是由类加载器加载，而是直接由虚拟机加载的。可以使用这些开关有选择地启用或禁用那些类中的断言。</p>
<p>不过，启用和禁用所有断言的 -ea和 -da开关不能应用到那些没有类加载器的“系统类”上。对于这些系统类，需要使用 -enablesystemassertions/-esa 开关启用断言。也可以通过变成控制类加载器的断言状态。</p>
<h3 id="7-4-3-使用断言完成参数检查"><a href="#7-4-3-使用断言完成参数检查" class="headerlink" title="7.4.3 使用断言完成参数检查"></a>7.4.3 使用断言完成参数检查</h3><h3 id="7-4-4-使用断言提供假设文档"><a href="#7-4-4-使用断言提供假设文档" class="headerlink" title="7.4.4 使用断言提供假设文档"></a>7.4.4 使用断言提供假设文档</h3><h2 id="7-5-日志"><a href="#7-5-日志" class="headerlink" title="7.5 日志"></a>7.5 日志</h2><h3 id="7-5-1-基本日志"><a href="#7-5-1-基本日志" class="headerlink" title="7.5.1 基本日志"></a>7.5.1 基本日志</h3><h3 id="7-5-2-高级日志"><a href="#7-5-2-高级日志" class="headerlink" title="7.5.2 高级日志"></a>7.5.2 高级日志</h3><h3 id="7-5-3-修改日志管理器配置"><a href="#7-5-3-修改日志管理器配置" class="headerlink" title="7.5.3 修改日志管理器配置"></a>7.5.3 修改日志管理器配置</h3><h3 id="7-5-4-本地化"><a href="#7-5-4-本地化" class="headerlink" title="7.5.4 本地化"></a>7.5.4 本地化</h3><h3 id="7-5-5-处理器"><a href="#7-5-5-处理器" class="headerlink" title="7.5.5 处理器"></a>7.5.5 处理器</h3><h3 id="7-5-6-过滤器"><a href="#7-5-6-过滤器" class="headerlink" title="7.5.6 过滤器"></a>7.5.6 过滤器</h3><h3 id="7-5-7-格式化器"><a href="#7-5-7-格式化器" class="headerlink" title="7.5.7 格式化器"></a>7.5.7 格式化器</h3><h3 id="7-5-8-日志技巧"><a href="#7-5-8-日志技巧" class="headerlink" title="7.5.8 日志技巧"></a>7.5.8 日志技巧</h3><h2 id="7-6-调试技巧"><a href="#7-6-调试技巧" class="headerlink" title="7.6 调试技巧"></a>7.6 调试技巧</h2>]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 Java的基本程序设计结构</title>
    <url>/2020/10/05/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第三章-Java的基本程序设计结构"><a href="#第三章-Java的基本程序设计结构" class="headerlink" title="第三章 Java的基本程序设计结构"></a>第三章 Java的基本程序设计结构</h1><h2 id="3-1-一个简单的Java应用程序"><a href="#3-1-一个简单的Java应用程序" class="headerlink" title="3.1 一个简单的Java应用程序"></a>3.1 一个简单的Java应用程序</h2><h2 id="3-2-注释"><a href="#3-2-注释" class="headerlink" title="3.2 注释"></a>3.2 注释</h2><h2 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h2><h3 id="3-3-1-整型"><a href="#3-3-1-整型" class="headerlink" title="3.3.1 整型"></a>3.3.1 整型</h3><h3 id="3-3-2-浮点类型"><a href="#3-3-2-浮点类型" class="headerlink" title="3.3.2 浮点类型"></a>3.3.2 浮点类型</h3><p>三个特殊的浮点类型：</p>
<ul>
<li>正无穷大 (Double.POSITIVE_INFINITY)以及相应的Float类型</li>
<li>负无穷大(Double.NEGATIVE_INFINITY)以及相应的Float类型</li>
<li>NaN (Double.NaN)以及相应的Float类型</li>
</ul>
<p>检测一个特定值是否等于Double.NaN:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == Double.NaN)<span class="comment">// is never true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Double.isNaN(X))</span><br></pre></td></tr></table></figure>

<p>浮点数不适用于无法接受舍入误差的金融计算，可以使用BigDecimal类。</p>
<h3 id="3-3-3-char类型"><a href="#3-3-3-char类型" class="headerlink" title="3.3.3 char类型"></a>3.3.3 char类型</h3><h3 id="3-3-4-Unicode和char类型"><a href="#3-3-4-Unicode和char类型" class="headerlink" title="3.3.4 Unicode和char类型"></a>3.3.4 Unicode和char类型</h3><h3 id="3-3-5-boolean类型"><a href="#3-3-5-boolean类型" class="headerlink" title="3.3.5 boolean类型"></a>3.3.5 boolean类型</h3><h2 id="3-4-变量与常量"><a href="#3-4-变量与常量" class="headerlink" title="3.4 变量与常量"></a>3.4 变量与常量</h2><h3 id="3-4-1-声明变量"><a href="#3-4-1-声明变量" class="headerlink" title="3.4.1 声明变量"></a>3.4.1 声明变量</h3><h3 id="3-4-2-变量初始化"><a href="#3-4-2-变量初始化" class="headerlink" title="3.4.2 变量初始化"></a>3.4.2 变量初始化</h3><h3 id="3-4-3-常量"><a href="#3-4-3-常量" class="headerlink" title="3.4.3 常量"></a>3.4.3 常量</h3><p>可以利用关键字final 指示常量。关键字final表示这个变量只能被赋值一次，一旦被赋值之后就不能够再更改了；常量使用全大写。</p>
<p>当希望某个常量可以在一个类的多个方法中使用，通常将这些常量称为类常量（class constant）；可以使用static final设置一个常量；类常量的定义位于main方法的外部，在同一个类的其他方法也可以使用这个常量。若一个常量被声明为public，那么其他类的方法也可以使用这个常量。</p>
<h3 id="3-4-4-枚举类型"><a href="#3-4-4-枚举类型" class="headerlink" title="3.4.4 枚举类型"></a>3.4.4 枚举类型</h3><p>变量的取值只有在一个有限的集合内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123;SMALL,MEDIUM,LARGE,EXTRA_LARGE&#125;;</span><br><span class="line">Size s = Size.MEDIUM;</span><br></pre></td></tr></table></figure>

<p>Size类型的变量只能存储这个类型声明中给定的某个枚举值，或是特殊值null。</p>
 <span id="more"></span> 

<h2 id="3-5-运算符"><a href="#3-5-运算符" class="headerlink" title="3.5 运算符"></a>3.5 运算符</h2><h3 id="3-5-1-算术运算符"><a href="#3-5-1-算术运算符" class="headerlink" title="3.5.1 算术运算符"></a>3.5.1 算术运算符</h3><h3 id="3-5-2-数学函数与常量"><a href="#3-5-2-数学函数与常量" class="headerlink" title="3.5.2 数学函数与常量"></a>3.5.2 数学函数与常量</h3><h3 id="3-5-3-数值类型之间的转换"><a href="#3-5-3-数值类型之间的转换" class="headerlink" title="3.5.3 数值类型之间的转换"></a>3.5.3 数值类型之间的转换</h3><p>当一个二元运算符连接两个值时，先要将两个操作数值转换为同一类型，然后再进行计算。</p>
<ul>
<li>如果两个操作数中有一个是double类型，另一个操作数就会转换为double；</li>
<li>否则，如果其中一个操作数是float类型，另一个操作数将会转为float；</li>
<li>否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型；</li>
<li>否则，两个操作数都被转换为int类型。</li>
</ul>
<h3 id="3-5-4-强制类型转换"><a href="#3-5-4-强制类型转换" class="headerlink" title="3.5.4 强制类型转换"></a>3.5.4 强制类型转换</h3><p>若想对浮点数进行舍入运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x =<span class="number">9.997</span>;</span><br><span class="line"><span class="keyword">int</span> nx = (<span class="keyword">int</span>) Math.round(x) <span class="comment">//round 方法返回结果为long类型 +0.5向下取整</span></span><br></pre></td></tr></table></figure>

<p>对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器会自动隐含地为我们补上一个强制类型转换；编译器的常量优化；</p>
<h3 id="3-5-5-结合赋值和运算符"><a href="#3-5-5-结合赋值和运算符" class="headerlink" title="3.5.5 结合赋值和运算符"></a>3.5.5 结合赋值和运算符</h3><h3 id="3-5-6-自增与自减运算符"><a href="#3-5-6-自增与自减运算符" class="headerlink" title="3.5.6 自增与自减运算符"></a>3.5.6 自增与自减运算符</h3><h3 id="3-5-7-关系和boolean运算符"><a href="#3-5-7-关系和boolean运算符" class="headerlink" title="3.5.7 关系和boolean运算符"></a>3.5.7 关系和boolean运算符</h3><p>三元操作符：condition? expression1 : expression2；如果条件为true，就为第一个表达式的值，否则计算为第二个表达式的值。</p>
<h3 id="3-5-8-位运算符"><a href="#3-5-8-位运算符" class="headerlink" title="3.5.8 位运算符"></a>3.5.8 位运算符</h3><h3 id="3-5-9-括号与运算符级别"><a href="#3-5-9-括号与运算符级别" class="headerlink" title="3.5.9 括号与运算符级别"></a>3.5.9 括号与运算符级别</h3><h2 id="3-6-字符串"><a href="#3-6-字符串" class="headerlink" title="3.6 字符串"></a>3.6 字符串</h2><p>创建字符串的常见3+1种方式：</p>
<p>三种构造方法：</p>
<p>public String()；创建一个空白字符串，不含有任何内容。</p>
<p>public String(char[] array)：根据字符数组的内容，来创建对应的字符串。</p>
<p>public String(byte[] array)：根据字节数组的内容，来创建对应的字符串。</p>
<p>一种直接创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_String</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> String();<span class="comment">//使用空参构造</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个字符串：&quot;</span>+ str1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据字符数组创建字符串</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(charArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个字符串:&quot;</span>+str2);<span class="comment">//ABC</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据字节数组来创建数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(byteArray);</span><br><span class="line">        System.out.println(<span class="string">&quot;第三个字符串：&quot;</span>+str3);<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接创建</span></span><br><span class="line">        String str4 = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-1-子串"><a href="#3-6-1-子串" class="headerlink" title="3.6.1 子串"></a>3.6.1 子串</h3><p>String类的substring 方法可以从一个较大的字符串提取一个子串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String greeting = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String s = greeting.substring(<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//从0开始计数，直到3为止，但不包含3。</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-拼接"><a href="#3-6-2-拼接" class="headerlink" title="3.6.2 拼接"></a>3.6.2 拼接</h3><p>如果需要把多个字符串放在一起，用一个界定符号分隔，可以使用静态join方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String all = String.join(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;S&quot;</span>,<span class="string">&quot;M&quot;</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;XL&quot;</span>); <span class="comment">// all is the string &quot;S / M / L / XL&quot;</span></span><br><span class="line"></span><br><span class="line">String repeated = <span class="string">&quot;java&quot;</span>.repeat(<span class="number">3</span>);<span class="comment">//java 11 中的repeat方法</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-3-不可变字符串"><a href="#3-6-3-不可变字符串" class="headerlink" title="3.6.3 不可变字符串"></a>3.6.3 不可变字符串</h3><p>字符串的特点：</p>
<ul>
<li>字符串的内容用不可变。</li>
<li>正是因为字符串不可改变，所以字符串是可以共享使用的。</li>
<li>字符串效果上相当于char[]字符数组，但底层原理是byte[]字节数组。</li>
</ul>
<h3 id="3-6-4-检测字符串是否相等"><a href="#3-6-4-检测字符串是否相等" class="headerlink" title="3.6.4 检测字符串是否相等"></a>3.6.4 检测字符串是否相等</h3><p>可以使用equals方法检测两个字符串是否相等；s.equals(t)，可以是字符串变量，也可以是字符串字面量；“Hello”.equals(greeting)。</p>
<p>若想检测两个字符串是否相等，而不区分大小写，可以使用equilsIgnoreCase方法；“Hello”.equalsIgnoreCase(“Hello”)。</p>
<p>一定不要使用 == 运算符检测两个字符串是否相等！这个运算符只能确定两个字符串是否存放在同一个位置上。若字符串在同一个位置上，它们必然相等；但完全有可能将内同相同的多个字符串副本放在不同的位置上。</p>
<p>字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中。</p>
<p>对于基本类型来说==是进行数值的比较；对于引用类型来说==地址值的比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_StringPool</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1 == str2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(str1 == str3);<span class="comment">//false</span></span><br><span class="line">        System.out.println(str2 == str3);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/05/%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/image-20201010145711894.png" alt="image-20201010145711894"></p>
<p>字符串的比较相关方法</p>
<p>public boolean equals(Object obj)：参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false。任何对象都能用Object进行接收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_StringEquals</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArray = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">        System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str1.equals(str3));<span class="comment">//true</span></span><br><span class="line">        System.out.println(str2.equals(str3));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>任何对象都能用Object进行接收</li>
<li>equals方法具有对称性</li>
<li>如果比较双方一个常量一个变量，推荐把常量字符串写在前面。(防止空指针异常)</li>
</ul>
<p>public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。</p>
<h3 id="3-6-5-空串与Null串"><a href="#3-6-5-空串与Null串" class="headerlink" title="3.6.5 空串与Null串"></a>3.6.5 空串与Null串</h3><p>空串“”是长度为0的字符串，可以调用以下代码来检查字符串是否为空：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(str.length() == <span class="number">0</span>)<span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span>(str.equals(<span class="string">&quot;&quot;</span>))<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>空串是一个java对象，有自己的长度0和内容空；不过String变量还可以存放一个特殊的值，名为null，表示目前没有任何对象与该变量关联。要检查一个字符串是否为null，要使用以下条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(str == <span class="keyword">null</span>)<span class="comment">//1</span></span><br><span class="line"><span class="keyword">if</span>(str != <span class="keyword">null</span> &amp;&amp; str.length() != <span class="number">0</span>)<span class="comment">//检查一个字符串既不是null，也不是空串</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-6-码点与代码单元"><a href="#3-6-6-码点与代码单元" class="headerlink" title="3.6.6 码点与代码单元"></a>3.6.6 码点与代码单元</h3><p>调用s.charAt(n)将返回位置n的代码单元</p>
<h3 id="3-6-7-String-API"><a href="#3-6-7-String-API" class="headerlink" title="3.6.7 String API"></a>3.6.7 String API</h3><p>String当中与获取相关的常用方法有：</p>
<p>public int length()：获取字符串当中还有的字符个数，拿到字符串长度。</p>
<p>public String concat(String str)：将当前字符串和参数字符串拼接成为返回值新的字符串。</p>
<p>public char charAt(int index)：获取索引位置的单个字符(索引从0开始)</p>
<p>public int indexOf(String str)：查找参数字符串在本字符串当中首次出现的索引位置，如果没有则返回-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_StringGet</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//获取字符串的长度</span></span><br><span class="line">        String str = <span class="string">&quot;iroghvaiosuigbbvapwur&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串的长度为：&quot;</span>+str.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拼接字符串</span></span><br><span class="line">        String str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        String str3 = str1.concat(str2);</span><br><span class="line">        System.out.println(str3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定索引位置的单个字符</span></span><br><span class="line">        <span class="keyword">char</span> ch = str.charAt(<span class="number">5</span>);</span><br><span class="line">        System.out.println(ch);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找参数字符串在本来字符串当中出现的第一次索引位置，没有返回-1</span></span><br><span class="line">        <span class="keyword">int</span> index1 = str.indexOf(<span class="string">&quot;osu&quot;</span>);</span><br><span class="line">        System.out.println(index1);</span><br><span class="line">        <span class="keyword">int</span> index2 = str.indexOf(<span class="string">&quot;hdc&quot;</span>);</span><br><span class="line">        System.out.println(index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串的截取方法：</p>
<p>public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。</p>
<p>public String substring(int begin,int end)：截取从begin开始，一直到end结束，中间的字符串。备注：[begin,end)，即包含左边，不包含右边。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_StringSubstring</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;puytbbvnbjkajbdfvthtugh&quot;</span>;</span><br><span class="line">        String str2 = str1.substring(<span class="number">8</span>);</span><br><span class="line">        System.out.println(str2);<span class="comment">//bjkajbdfvthtugh</span></span><br><span class="line"></span><br><span class="line">        String str3 = str1.substring(<span class="number">8</span>,<span class="number">16</span>);</span><br><span class="line">        System.out.println(str3);<span class="comment">//bjkajbdf</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String当中与转换相关的常用方法有：</p>
<p>public char[] toCharArray()：将当前字符串拆分成字符数组作为返回值。</p>
<p>public byte[] getBytes()：获得当前字符串底层的字节数组。</p>
<p>public String replace(CharSequence oldString，CharSequence newString)；将所有出现的老字符串替换成新的字符串，返回替换后的结果新字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_StringConvert</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//转换成为字符串数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="string">&quot;Helloworld&quot;</span>.toCharArray();</span><br><span class="line">        System.out.println(chars[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(chars.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换成为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">&quot;abc&quot;</span>.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            System.out.println(bytes[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str1 = <span class="string">&quot;How do you do?&quot;</span>;</span><br><span class="line">        String str2 = str1.replace(<span class="string">&quot;o&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个方法，把数组{1，2，3}按照指定的格式拼接成一个字符串。格式参照如下：[word1#word2#word3]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_StringPractise</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        String str1 = fromArrayToString(array);</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fromArrayToString</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == array.length -<span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                str += <span class="string">&quot;word&quot;</span>+array[i]+ <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                str += <span class="string">&quot;word&quot;</span>+array[i] + <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>键盘输入一个字符，并且统计其中各种字符出现的次数，大写字母，小写字母，数字，其他。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7_StringCount</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        String str = sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> countUpper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> countLower = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> countNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> countOther = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = chars[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= ch &amp;&amp; ch &lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                countUpper++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                countLower++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                countNumber++;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                countOther++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;大写字母有：&quot;</span>+countUpper+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小写字母有：&quot;</span>+countLower+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字有：&quot;</span>+countNumber+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;其他的有：&quot;</span>+countOther+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-8-阅读联机API文档"><a href="#3-6-8-阅读联机API文档" class="headerlink" title="3.6.8 阅读联机API文档"></a>3.6.8 阅读联机API文档</h3><h3 id="3-6-9-构建字符串"><a href="#3-6-9-构建字符串" class="headerlink" title="3.6.9 构建字符串"></a>3.6.9 构建字符串</h3><p>若需要用许多小段的字符串来构建一个字符串，可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(ch);</span><br><span class="line">builder.append(str);</span><br><span class="line"><span class="comment">//字符串构建完成时就调用toSting方法</span></span><br><span class="line">String completedString = builder.toSring();</span><br></pre></td></tr></table></figure>

<h2 id="3-7-输入与输出"><a href="#3-7-输入与输出" class="headerlink" title="3.7 输入与输出"></a>3.7 输入与输出</h2><h3 id="3-7-1-读取输入"><a href="#3-7-1-读取输入" class="headerlink" title="3.7.1 读取输入"></a>3.7.1 读取输入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;What is your name ?&quot;</span>);</span><br><span class="line">        String name = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;How old are you ?&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>+name+<span class="string">&quot;.Next year,you&#x27;ll be &quot;</span>+(age + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-7-2-格式化输出"><a href="#3-7-2-格式化输出" class="headerlink" title="3.7.2 格式化输出"></a>3.7.2 格式化输出</h3><p>%[argument_index$][flags][width][.precision]conversion</p>
<h3 id="3-7-3-文件输入与输出"><a href="#3-7-3-文件输入与输出" class="headerlink" title="3.7.3 文件输入与输出"></a>3.7.3 文件输入与输出</h3><p>Scanner类的功能：可以实现键盘输入数据到程序当中。</p>
<p>1.导包：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>

<p>2.创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//System.in代表从键盘输入</span></span><br></pre></td></tr></table></figure>

<p>3.使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = sc.nextInt();<span class="comment">//获取键盘输入的一个int数字</span></span><br><span class="line">String str = sc.next();<span class="comment">//获取键盘输入的一个字符串</span></span><br></pre></td></tr></table></figure>



<p>想要读取一个文件，需要构造一个Scanner对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(Path.of(<span class="string">&quot;myfile.txt&quot;</span>),StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p>若文件名中包含反斜杠符号，就要记住在每个反斜杠之前加一个额外的反斜杠转义：“c:\mydirectory\myfile.text”。</p>
<p>想要写入文件，就需要构造一个PrintWriter对象。在构造器中，需要提供文件名和字符编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;myfile.txt&quot;</span>,StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p>若文件不存在，则创建该文件。</p>
<h2 id="3-8-控制流程"><a href="#3-8-控制流程" class="headerlink" title="3.8 控制流程"></a>3.8 控制流程</h2><h3 id="3-8-1-块作用域"><a href="#3-8-1-块作用域" class="headerlink" title="3.8.1 块作用域"></a>3.8.1 块作用域</h3><p>不能在嵌套的两个块中声明同名变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">int</span> n;<span class="comment">//ERROR</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-2-条件语句"><a href="#3-8-2-条件语句" class="headerlink" title="3.8.2 条件语句"></a>3.8.2 条件语句</h3><h3 id="3-8-3-循环"><a href="#3-8-3-循环" class="headerlink" title="3.8.3 循环"></a>3.8.3 循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Retirement</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;How much money do you need to retire?&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> goal = sc.nextDouble();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;How much money will you contribute every year?&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> payment = sc.nextDouble();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Interest rate is in %:&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> interestRate = sc.nextDouble();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> balance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> year = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (balance &lt; goal)</span><br><span class="line">        &#123;</span><br><span class="line">            balance += payment;</span><br><span class="line">            <span class="keyword">double</span> interest = balance * interestRate / <span class="number">100</span>;</span><br><span class="line">            balance += interest;</span><br><span class="line">            year++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;you can retire in &quot;</span>+year+<span class="string">&quot; years&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-8-4-确定循环"><a href="#3-8-4-确定循环" class="headerlink" title="3.8.4 确定循环"></a>3.8.4 确定循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LotteryOdds</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scaner(System.in);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;How many numbers do you need to draw?&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;What is the highest number you can draw?&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lotteryOdds = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lotteryOdds = lotteryOdds * (n - i + <span class="number">1</span>) / i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Your odds are 1 in &quot;</span>+lotteryOdds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Retirement2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;How much money will you contribute every year ?&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> payment = sc.nextDouble();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Interest rate in %:&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> interestRate = sc.nextDouble();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> balance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> years = <span class="number">0</span>;</span><br><span class="line">        String input;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            balance += payment;</span><br><span class="line">            <span class="keyword">double</span> interest = balance * interestRate / <span class="number">100</span>;</span><br><span class="line">            balance += interest;</span><br><span class="line">            years++;</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;After year %d, you balance is %,.2f&quot;</span>,years,balance);</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;Ready to retire ? (Y/N)&quot;</span>);</span><br><span class="line">            input = sc.next();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (input.equals(<span class="string">&quot;N&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-8-5-多重选择：switch语句"><a href="#3-8-5-多重选择：switch语句" class="headerlink" title="3.8.5 多重选择：switch语句"></a>3.8.5 多重选择：switch语句</h3><p>多个case后面的数值不可以重复；switch后面小括号当中只能是下列数据类型：基本数据类型：byte/short/char/int，引用数据类型：String字符串、enum枚举； switch语句可以很灵活，前后顺序可以颠倒，break语句可以省略，匹配哪一个case就从哪一个位置向下执行，直到遇到break或整体结束为止。</p>
<h3 id="3-8-6-中断控制流程的语句"><a href="#3-8-6-中断控制流程的语句" class="headerlink" title="3.8.6 中断控制流程的语句"></a>3.8.6 中断控制流程的语句</h3><h2 id="3-9-大数"><a href="#3-9-大数" class="headerlink" title="3.9 大数"></a>3.9 大数</h2><p>若基本的整数和浮点数精度不能够满足需求，可以使用java.math包中两个很有用的类：BigInteger和BigDecimal。可以使用静态的valueOf方法将普通的数值转换为大数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger a = BigInteger.valueOf(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>对于更大的数，可以使用一个带字符串参数的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger reallyBig = <span class="keyword">new</span> BigInteger(<span class="string">&quot;223432532432993288872843924002048423&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意：不能使用熟悉的算术运算符（+，*）处理大数，而需要使用大数类中的add和multiply方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger c = a.add(b);<span class="comment">//c = a + b</span></span><br><span class="line">BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="number">2</span>)));<span class="comment">// d = c * (b + 2)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigIntegerTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;How many numbers do you need to draw?&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;What is the highest number you can draw?&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        BigInteger lotteryOdds = BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lotteryOdds = lotteryOdds.multiply(BigInteger.valueOf(n - i +<span class="number">1</span>)).divide(BigInteger.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Your odds are 1 in &quot;</span>+lotteryOdds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BigInteger add(BigInteger other)</li>
<li>BigInteger subtract(BigInteger other)</li>
<li>BigInteger multiply(BigInteger other)</li>
<li>BigInteger divide(BigInteger other)</li>
<li>BigInteger mod(BigInteger other)</li>
</ul>
<p>返回这个大整数和另一个大整数other的和、差、积、商、余数。</p>
<ul>
<li>BigInteger sqrt()</li>
</ul>
<p>得到这个大数的平方根。</p>
<ul>
<li>int compareTo(BigInteger other)</li>
</ul>
<p>若这个大数与另一个大数other相等，返回0；若这个大整数小于另一个大整数other，返回负数；否则返回正数。</p>
<ul>
<li>static BigInteger valueOf(long x)</li>
</ul>
<p>返回值等于x的大整数。</p>
<ul>
<li>BigDecimal add(BigDecimal other)</li>
<li>BigDecimal subtract(BigDecimal other)</li>
<li>BigDecimal multiplyBigDecimal other)</li>
<li>BigDecimal divide(BigDecimal other)</li>
<li>BigDecimal divide(BigDecimal other，RoundingMode mode)</li>
</ul>
<p>返回一个大实数与other的和、差、积、商。若商是一个无限循环小数，第一个divide方法会抛出异常。要得到一个舍入的结果，就要使用第二个方法。RoundingMode.HALF_UP是四舍五入方式。</p>
<ul>
<li>int compareTo(BigDecimal other)</li>
</ul>
<p>若这个大实数与other相等，返回0；若这个大实数小于另一个大实数other，返回负数；否则返回正数。</p>
<ul>
<li>static BigDecimal valueOf(long x)</li>
<li>static BigDecimal valueOf(long x，int scale)</li>
</ul>
<p>返回值等于x或$x/10^{scale}$的一个大实数。</p>
<h2 id="3-10-数组"><a href="#3-10-数组" class="headerlink" title="3.10 数组"></a>3.10 数组</h2><p>数组：是一种容器，可以同时存放多个数组。</p>
<p>特点：数组是一种引用数据类型；数组中的多个数据，类型必须统一；数组的长度在程序运行期间不可改变</p>
<h3 id="3-10-1-声明数组"><a href="#3-10-1-声明数组" class="headerlink" title="3.10.1 声明数组"></a>3.10.1 声明数组</h3><p>两种常见的初始化方式：动态初始化；静态初始化。</p>
<p>如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体内容，用静态初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span>[] smallPrimes = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-10-2-访问数组元素"><a href="#3-10-2-访问数组元素" class="headerlink" title="3.10.2 访问数组元素"></a>3.10.2 访问数组元素</h3><p>访问数组元素的格式：数组名称[索引值]；索引值，就是一个int数字，代表数组当中元素的编号；索引值从0开始，一直到数组长度-1为止。</p>
<p>使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。规则如下：</p>
<ul>
<li>整数类型默认为0；</li>
<li>浮点类型默认为0.0；</li>
<li>字符类型默认为‘\u0000’；</li>
<li>布尔类型默认为false；</li>
<li>引用类型默认为null；</li>
</ul>
<p>如果访问数组元素的时候，索引编号并不存在，那么将会发生数组索引越界异常。ArrayIndexOutBoundsException</p>
<p>数组必须进行new初始化才能使用其中的元素，如果只是赋值一个null，没有进行new创建，那么将会发生空指针异常。NullPointerException</p>
<h3 id="3-10-3-for-each循环"><a href="#3-10-3-for-each循环" class="headerlink" title="3.10.3 for each循环"></a>3.10.3 for each循环</h3><p>for(variable：collection) statement</p>
<h3 id="3-10-4-数组拷贝"><a href="#3-10-4-数组拷贝" class="headerlink" title="3.10.4 数组拷贝"></a>3.10.4 数组拷贝</h3><p>在java中，允许将一个数组变量拷贝到另一个数组变量。这时，两个变量将引用同一个数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] luckyNumbers = smallPrimes;</span><br><span class="line">luckyNumbers[<span class="number">5</span>] = <span class="number">12</span>;<span class="comment">//now smallPrimes[5] is also 12</span></span><br></pre></td></tr></table></figure>

<p>若希望将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的copyOf方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">luckyNumbers = Arrays.copyOf(luckyNumbers, <span class="number">2</span> * luckNumbers.length)</span><br></pre></td></tr></table></figure>

<p>第二个参数是新数组的长度。这个方法通常用来增加数组的大小。如果数组元素是数值型，那么额外的元素将被赋值为0；如果数组是布尔型，则将赋值为false。相反，若长度小于原始数组的长度，则只拷贝前面的值。</p>
<h3 id="3-10-5-命令行参数"><a href="#3-10-5-命令行参数" class="headerlink" title="3.10.5 命令行参数"></a>3.10.5 命令行参数</h3><h3 id="3-10-6-数组排序"><a href="#3-10-6-数组排序" class="headerlink" title="3.10.6 数组排序"></a>3.10.6 数组排序</h3><p>想要对数值型数组进行排序，可以使用Arrays类中的sort方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line">...</span><br><span class="line">Array.sort(a);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LotteryDrawing</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;How many numbers do you need to draw ?&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> k = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;What is the highest number you can draw ?&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=========================================&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            numbers[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] results = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> result = (<span class="keyword">int</span>)(Math.random() * n);</span><br><span class="line">            results[i] = numbers[result];</span><br><span class="line">            numbers[result] = numbers[n - <span class="number">1</span>];</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(results);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r : results)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组中的最值实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5_ArrayMax</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">99</span>,<span class="number">6</span>,<span class="number">35</span>,<span class="number">57</span>,<span class="number">68</span>,<span class="number">266</span>,-<span class="number">13</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;max = &quot;</span>+ max);</span><br><span class="line">        System.out.println(<span class="string">&quot;min = &quot;</span>+ min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组元素反转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5_Reverse</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">76</span>,<span class="number">24</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = array.length - <span class="number">1</span>;i &lt; j; i++, j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[i];</span><br><span class="line">            array[i] = array[j];</span><br><span class="line">            array[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r : array)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>+ r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组作为方法的参数时，传递的其实是数组的地址值；数组作为方法的返回值，返回的其实也是数组的地址值。</p>
<h3 id="3-10-7-多维数组"><a href="#3-10-7-多维数组" class="headerlink" title="3.10.7 多维数组"></a>3.10.7 多维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompoundInterset</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> STARTRATE = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> COL = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> ROW = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] interestRate = <span class="keyword">new</span> <span class="keyword">double</span>[COL];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interestRate.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            interestRate[i] = (STARTRATE + i) / <span class="number">100.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[][] balances = <span class="keyword">new</span> <span class="keyword">double</span>[ROW][COL];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; balances[<span class="number">0</span>].length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            balances[<span class="number">0</span>][i] = <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; balances.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; balances[i].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">double</span> oldBalance = balances[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">double</span> interset = oldBalance * interestRate[j];</span><br><span class="line">                balances[i][j] = oldBalance + interset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interestRate.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%9.0f%%&quot;</span>,<span class="number">100</span> * interestRate[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span>[] row : balances)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> r : row)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%10.2f&quot;</span>,r);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-10-8-不规则数组"><a href="#3-10-8-不规则数组" class="headerlink" title="3.10.8 不规则数组"></a>3.10.8 不规则数组</h3><p>java实际上没有多维数组，只有一维数组；多维数组被解释为数组的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LotteryArray</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> ROW = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] odds = <span class="keyword">new</span> <span class="keyword">int</span>[ROW + <span class="number">1</span>][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; odds.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            odds[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; odds.length; n++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; odds[n].length; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> lotteryOdds = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    lotteryOdds = lotteryOdds * (n - i + <span class="number">1</span>) / i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                odds[n][k] = lotteryOdds;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : odds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r : row)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%5d&quot;</span>,r);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 对象与类</title>
    <url>/2020/10/12/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第四章-对象与类"><a href="#第四章-对象与类" class="headerlink" title="第四章 对象与类"></a>第四章 对象与类</h1><h2 id="4-1-面向对象程序设计概述"><a href="#4-1-面向对象程序设计概述" class="headerlink" title="4.1 面向对象程序设计概述"></a>4.1 面向对象程序设计概述</h2><p>面向对象程序设计(object-oriented programming，OOP)；面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些自定义的。</p>
<p>面向对象三大特征：封装、继承、多态。</p>
<h3 id="4-1-1-类"><a href="#4-1-1-类" class="headerlink" title="4.1.1 类"></a>4.1.1 类</h3><p>类(class)是构造对象的模板或蓝图。由类构造(construct)对象的过程称为创建类的实例(instance)。</p>
<p>封装(encapsulation)是处理对象的一个重要概念。从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。对象中的数据称为实例字段(instance field)，操作数据的过程称为方法(method)。</p>
<p>实现封装的关键在于，绝对不能让类中的方法直接访问其他类的实例字段。程序只能通过对象的方法与对象数据进行交互。封装给对象赋予“黑盒”特征，这是提高重用性和可靠性的关键。</p>
<p>在扩展一个已有的类时，这个扩展后新类具有被扩展的类的全部属性和方法。你只需要在新类提供适用于这个新类的新方法和数据字段就可以了。通过扩展一个类来建立另外一个类的过程称为继承(inheritance)。</p>
<h3 id="4-1-2-对象"><a href="#4-1-2-对象" class="headerlink" title="4.1.2 对象"></a>4.1.2 对象</h3><p>对象的三个主要特性：</p>
<ul>
<li>对象的行为(behavior)，可以完成哪些操作，或者可以对对象应用哪些方法。</li>
<li>对象的状态(state)，当调用那些方法时，对象会如何相应。</li>
<li>对象的标识(identity)，如何区分具有相同行为与状态的不同对象。</li>
</ul>
<h3 id="4-1-3-识别类"><a href="#4-1-3-识别类" class="headerlink" title="4.1.3 识别类"></a>4.1.3 识别类</h3><h3 id="4-1-4-类之间的关系"><a href="#4-1-4-类之间的关系" class="headerlink" title="4.1.4 类之间的关系"></a>4.1.4 类之间的关系</h3><p>在类之间，最常见的关系有：</p>
<ul>
<li>依赖(dependence)(“uses-a”)</li>
<li>聚合(aggregation)(“has-a”)</li>
<li>继承(inheritance)(“is-a”)</li>
</ul>
 <span id="more"></span> 

<h2 id="4-2-使用预定义类"><a href="#4-2-使用预定义类" class="headerlink" title="4.2 使用预定义类"></a>4.2 使用预定义类</h2><h3 id="4-2-1-对象与对象变量"><a href="#4-2-1-对象与对象变量" class="headerlink" title="4.2.1 对象与对象变量"></a>4.2.1 对象与对象变量</h3><p>想要使用对象，首先必须构造对象，并指定其初始状态。然后对对象应用方法。</p>
<p>在Java在程序设计语言中，要使用构造器(constructor)构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。</p>
<p>构造器的名字应该与类名相同。因此Date类的构造器名为Date。想要构造一个Date对象，需要在构造器前面加上new操作符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Date();<span class="comment">//这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间。</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> Date());<span class="comment">//可以将这个对象传递给一个方法</span></span><br></pre></td></tr></table></figure>

<p>Date类中有一个toString方法，这个方法返回日期的字符串描述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> Date().toString();</span><br></pre></td></tr></table></figure>

<p>在这两个例子中，构造对象仅使用了一次。通常，你会希望构造的对象可以多次使用，因此，需要将对象存放在一个变量中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date birthday = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure>

<p>对象变量并没有实际包含一个对象，它只是引用一个对象。在Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。new操作符的返回值也是一个引用。</p>
<h3 id="4-2-2-Java类库中的-LocalDate类"><a href="#4-2-2-Java类库中的-LocalDate类" class="headerlink" title="4.2.2 Java类库中的 LocalDate类"></a>4.2.2 Java类库中的 LocalDate类</h3><p>不要使用构造器来构造LocalDate类的对象。实际上，应当使用静态工厂方法(factory method)，它会代表你调用构造器。下面的表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate.now()</span><br></pre></td></tr></table></figure>

<p>会构造一个新对象、表示构造这个对象时的日期。</p>
<p>可以提供年、月、日来构造对应一个特定日期的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate newYearsEve = LocalDate.of(<span class="number">1999</span>,<span class="number">12</span>,<span class="number">31</span>)</span><br></pre></td></tr></table></figure>

<p>有了LocalDate对象，可以使用方法getYear、getMonthValue、getDayOfMonth得到年、月、日。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> year = newYearsEve.getYear();<span class="comment">//1999</span></span><br><span class="line"><span class="keyword">int</span> month = newYearsEve.getMonthValue();<span class="comment">//12</span></span><br><span class="line"><span class="keyword">int</span> day = newYearsEve.getDayOfMonth();<span class="comment">//31</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate aThousandDaysLater = newYearsEve.plusDay(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">int</span> year = newYearsEve.getYear();<span class="comment">//2002</span></span><br><span class="line"><span class="keyword">int</span> month = newYearsEve.getMonthValue();<span class="comment">//09</span></span><br><span class="line"><span class="keyword">int</span> day = newYearsEve.getDayOfMonth();<span class="comment">//26</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-更改器方法与访问器方法"><a href="#4-2-3-更改器方法与访问器方法" class="headerlink" title="4.2.3 更改器方法与访问器方法"></a>4.2.3 更改器方法与访问器方法</h3><p>上一节中的plusDays方法调用，这个调用后newYearsEve会有什么变化？它会改为1000天后的日期吗？事实上，并没有。plusDays方法会生成一个新的LocalDate对象，然后把这个新对象赋给aThousandDaysLater变量。原来的对象不做任何改动。我们说plusDays方法没有更改调用这个方法的对象。</p>
<p>与LocalDate.plusDays方法不同，GregorianCalendar.add方法是一个更改器方法(mutator method)。相反，只访问对象而不修改对象的方法有时称为访问器方法(accessor method)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarText</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LocalDate date = LocalDate.now();</span><br><span class="line">        <span class="keyword">int</span> month = date.getMonthValue();</span><br><span class="line">        <span class="keyword">int</span> today = date.getDayOfMonth();</span><br><span class="line">        </span><br><span class="line">        date = date.minusDay(today - <span class="number">1</span>);</span><br><span class="line">        DayOfWeek weekday = date.getDayOfWeek();</span><br><span class="line">        <span class="keyword">int</span> value = weekday.getValue();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; value; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(data.getMonthValue == month)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d&quot;</span>,date.getDayOfMonth);</span><br><span class="line">            <span class="keyword">if</span>(date,getDayOfMonth == today)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            date = date.plusDay(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(date.getDayOfWeek().getValue() == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(date.getDayOfWeek().getValue() != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-用户自定义类"><a href="#4-3-用户自定义类" class="headerlink" title="4.3 用户自定义类"></a>4.3 用户自定义类</h2><h3 id="4-3-1-Employee类"><a href="#4-3-1-Employee类" class="headerlink" title="4.3.1 Employee类"></a>4.3.1 Employee类</h3><p>成员变量是直接定义在类当中的，在方法外边；成员方法不要写static关键字。</p>
<p>通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用：</p>
<ul>
<li>1.导包：也就是指出需要使用的类，在什么位置。import 包名称.类名称；import cn.itcast.day05.demo01.Student；对于和当前类属于同一个包的情况，可以省略导包语句不写。</li>
<li>创建，格式：类名称 对象名 = new 类名称()；</li>
<li>使用，分两种情况：使用成员变量：对象名.成员变量名；使用成员方法：对象名.成员方法名(参数)</li>
</ul>
<p>在Java中，最简单的类定义形式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    field_1;</span><br><span class="line">    field_2;</span><br><span class="line">    ...;</span><br><span class="line">    constructor_1;</span><br><span class="line">    constructor_2;</span><br><span class="line">    ...;</span><br><span class="line">    method_1;</span><br><span class="line">    method_2;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee_1[] staff = <span class="keyword">new</span> Employee_1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee_1(<span class="string">&quot;Carl Cracker&quot;</span>,<span class="number">75000</span>,<span class="number">1987</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee_1(<span class="string">&quot;Harry Hacker&quot;</span>,<span class="number">50000</span>,<span class="number">1989</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee_1(<span class="string">&quot;Tony Tester&quot;</span>,<span class="number">40000</span>,<span class="number">1990</span>,<span class="number">3</span>,<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Employee_1 e : staff)</span><br><span class="line">        &#123;</span><br><span class="line">            e.raiseSalary(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Employee_1 e : staff)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name=&quot;</span>+e.getName()+<span class="string">&quot;,salary=&quot;</span>+e.getSalary()+<span class="string">&quot;,hireDay=&quot;</span>+e.getHireDay());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee_1</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = LocalDate.of(year,month,day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span> ;</span><br><span class="line">        <span class="keyword">this</span>.salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个程序中，我们构造了一个Employee_1数组，并填入了3个Employee_1对象；接下来，使用Employee类的raiseSalary方法将每个员工的薪水提高5%；最后调用getName、getSalary、getHireDay方法打印各个员工的信息。</p>
<p>注意，在这个示例程序中包含两个类：Emloyee_1和带有public访问修饰符的EmplyeeTest。在一个源文件中，只能有一个公共类，但可以有任意数目的非公共类。</p>
<h3 id="4-3-2-多个源文件的使用"><a href="#4-3-2-多个源文件的使用" class="headerlink" title="4.3.2 多个源文件的使用"></a>4.3.2 多个源文件的使用</h3><h3 id="4-3-3-剖析Employee类"><a href="#4-3-3-剖析Employee类" class="headerlink" title="4.3.3 剖析Employee类"></a>4.3.3 剖析Employee类</h3><p>这个类包含了一个构造器和4个方法；这个类的所有方法都被标记为public。关键字public意味着任何类的任何方法都可以调用这些方法。</p>
<p>在Employee类的实例中有3个实例字段用来存放将要操作的数据，关键字private确保只有Employee类自身的方法能够访问这些实例字段，而其他类的方法不能够写这些字段。</p>
<p>有两个实例字段本身就是对象：name字段是Sting类对象，hireDay字段是LocalDate类对象。</p>
<p>一个标准的类通常要有四个组成部分：</p>
<ul>
<li>所有成员变量都要使用private关键字修饰</li>
<li>每一个成员变量编写一对儿Getter/Setter方法</li>
<li>编写一个无参数的构造方法</li>
<li>编写一个全参数的构造方法</li>
</ul>
<p>这样标准的类也叫做Java Bean。</p>
<h3 id="4-3-4-从构造器开始"><a href="#4-3-4-从构造器开始" class="headerlink" title="4.3.4 从构造器开始"></a>4.3.4 从构造器开始</h3><p>构造器与类同名。在构造Employee类的对象时，构造器会运行，从而将实例字段初始化为所有希望的初始状态。</p>
<p>构造器与其他方法有一个重要的不同，构造器总是结合new操作符来调用的。不能对一个已经存在的对象调用构造器来达到重新实例字段的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">james.Employee(<span class="string">&quot;James Bond&quot;</span>,<span class="number">250000</span>,<span class="number">1950</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>构造器的特点：</p>
<ul>
<li>构造器与类同名；</li>
<li>每个类可以有一个以上的构造器；</li>
<li>构造器可以有0个、1个或多个参数；</li>
<li>构造器没有返回值；</li>
<li>构造器总是伴随着new操作符一起调用。</li>
</ul>
<p>构造方法的格式：public 类名称(参数类型 参数名称){方法体}</p>
<ul>
<li>构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</li>
<li>构造方法不要写返回值类型，连void都不写。</li>
<li>构造方法不能return一个具体的返回值</li>
<li>如果没有任何构造方法，那么编译器会默认赠送一个构造方法，没有参数、方法体什么事情都不做。</li>
<li>一旦编写了至少一个构造方法，那么编译器将不再赠送。</li>
<li>构造方法也是可以进行重载的</li>
</ul>
<h3 id="4-3-5-用var声明局部变量"><a href="#4-3-5-用var声明局部变量" class="headerlink" title="4.3.5 用var声明局部变量"></a>4.3.5 用var声明局部变量</h3><p>在Java10中，如果可以从变量的初始值推导出它们的类型，那么可以用var关键字声明局部变量，从而无需指定类型。注意var关键字只能用于方法中的局部变量，参数和字段的类型必须声明。</p>
<h3 id="4-3-6-使用null引用"><a href="#4-3-6-使用null引用" class="headerlink" title="4.3.6 使用null引用"></a>4.3.6 使用null引用</h3><p>一个对象变量包含一个对象的引用，或者包含一个特殊值null，后者表示没有引用任何对象。听上去这是一种处理特殊情况的便捷机制，如未知的名字或雇佣日期。不过使用null值时要非常小心。如果对null值应用一个方法，会产生一个NullPointerException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate birthday = <span class="keyword">null</span>;</span><br><span class="line">String s = birthday.toString();<span class="comment">//NullPointerException</span></span><br></pre></td></tr></table></figure>

<p>定义一个类时，最好清楚地知道哪些字段可能为null。对此有两种解决方法。“宽容型”方法是把null参数转换为一个适当的非null值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n == <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    name = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    name = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java9中，Objects类对此提供了一个便利方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    name = Objects.requireNonNullElse(n,<span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“严格型”方法则是干脆拒绝null参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(n,<span class="string">&quot;The name cannot be null&quot;</span>);</span><br><span class="line">    name = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-7-隐式参数与显示参数"><a href="#4-3-7-隐式参数与显示参数" class="headerlink" title="4.3.7 隐式参数与显示参数"></a>4.3.7 隐式参数与显示参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> raise = salary * byPercent / <span class="number">100</span>;</span><br><span class="line">    salary += raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>salary称为隐式(implicit)参数，byPercent位于方法名后面的括号中，这是一个显示(explicit)参数。可以把隐式参数称为方法调用的目标或接收者。在每一个方法中，关键字this指示隐式参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.salary += raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量，如果需要访问本类当中的成员变量，需要使用格式：this.成员变量名。</p>
<p>局部变量和成员变量的区别：</p>
<ul>
<li>局部变量在方法的内部，成员变量在方法的外部，直接写在类当中；</li>
<li>作用域不一样，局部变量只有方法中才可以使用，出了方法就不能再用；成员变量整个类都可以通用。</li>
<li>默认值不一样，局部变量没有默认值，要想使用必须手动赋值；成员变量：如果没有赋值，会有默认值，规则和数组一样。</li>
<li>内存的位置不一样，局部变量位于栈内存；成员变量位于堆内存。</li>
<li>生命周期不一样，局部变量随着方法进栈而诞生，随着方法出栈而消失；成员变量，随着对象创建而诞生，随着对象被垃圾回收而消失。</li>
</ul>
<h3 id="4-3-8-封装的优点"><a href="#4-3-8-封装的优点" class="headerlink" title="4.3.8 封装的优点"></a>4.3.8 封装的优点</h3><p>封装性在java当中的体现：</p>
<ul>
<li>方法就是一种封装</li>
<li>关键字private也是一种封装</li>
</ul>
<p>一旦使用private进行修饰后，那么本类当中仍然可以随意访问；但是！超出本类范围之外就不能再直接访问了。</p>
<p>有些时候，可能想要获得或设置实例字段的值。那么你需要提供下面三项内容：</p>
<ul>
<li>一个私有的数据字段；</li>
<li>一个公共的字段访问器方法；</li>
<li>一个公共的字段更改器方法。</li>
</ul>
<p>间接访问private成员变量，就是定义一对setter/getter方法。</p>
<p>对于基本类型当中的boolean值，getter方法一定要写成isXxx的形式。</p>
<h3 id="4-3-9-基于类的访问权限"><a href="#4-3-9-基于类的访问权限" class="headerlink" title="4.3.9 基于类的访问权限"></a>4.3.9 基于类的访问权限</h3><p>方法可以访问调用这个方法的对象的私有数据。一个方法可以访问所属类的所有对象的私有数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.equals(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>典型的调用方式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(harry.equals(boss))...</span><br></pre></td></tr></table></figure>

<h3 id="4-3-10-私有方法"><a href="#4-3-10-私有方法" class="headerlink" title="4.3.10 私有方法"></a>4.3.10 私有方法</h3><p>在实现一个类时，由于公共数据非常危险，所以应该将所有的数据字段设置为私有的。尽管绝大多数方法都被设计为公共的，但在某些特殊情况况下，将方法设计为私有可能很有用。有时，你希望将一个计算机代码分解成若干个独立的辅助方法。通常，这些辅助方法不应该成为公共接口的一部分，这是由于它们与当前实现关系非常紧密，或者需要一个特殊协议或者调用次序。最好将这样的方法设计为私有方法。</p>
<p>在java中，要实现私有方法，只需要将关键字public改为private即可。</p>
<h3 id="4-3-11-final实例字段"><a href="#4-3-11-final实例字段" class="headerlink" title="4.3.11 final实例字段"></a>4.3.11 final实例字段</h3><p>可以将实例字段定义为final。这样的字段必须在构造对象初始化。必须保证在每一个构造器执行之后，这个字段的值已经设置，并且以后不能再修改这个字段，即没有set方法。</p>
<h2 id="4-4-静态字段与静态方法"><a href="#4-4-静态字段与静态方法" class="headerlink" title="4.4 静态字段与静态方法"></a>4.4 静态字段与静态方法</h2><h3 id="4-4-1-静态字段"><a href="#4-4-1-静态字段" class="headerlink" title="4.4.1 静态字段"></a>4.4.1 静态字段</h3><p>静态字段只在类中保存唯一一份，那所有本类对象共享同一份。一旦使用static关键字，那么这样的内容不再属于对象自己，而是属于类的。凡是本类的对象，都共享一份。</p>
<p>如果将一个字段定义为static，每个类只有一个这样的字段。而对于非静态的实例字段，每个对象都有自己的一个副本。例如，假设需要给每一个员工赋予唯一的标识码。这里给Employee类添加一个实例字段id和一个静态字段nextId。</p>
<h3 id="4-4-2-静态常量"><a href="#4-4-2-静态常量" class="headerlink" title="4.4.2 静态常量"></a>4.4.2 静态常量</h3><p>静态变量使用得比较少，但静态常量却很常用。例如，在Math类中定义一个静态常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-3-静态方法"><a href="#4-4-3-静态方法" class="headerlink" title="4.4.3 静态方法"></a>4.4.3 静态方法</h3><p>静态方法是不在对象上执行的方法。例如，Math类的pow就是一个静态方法。</p>
<p>一旦使用static修饰成员方法，那么就成为了静态方法。静态方法不属于对象，而是属于类。</p>
<p>如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用；如果有了static关键字，那么不需要对象，直接就能通过类名称来使用它。</p>
<p>无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。</p>
<p>静态变量：类名称.静态变量</p>
<p>静态方法：类名称.静态方法()</p>
<p>对于本类当中的静态方法，可以省略类名</p>
<p>注意事项：</p>
<ul>
<li>静态只能直接访问静态，不能直接访问非静态。 (成员方法可以访问成员变量，成员方法可以访问静态变量；静态方法可以访问静态变量，静态方法不能直接访问成员变量)(原因：内存当中先有静态内容，后有非静态内容)</li>
<li>静态方法中不能用this：this代表当前对象，通过谁调用的方法，谁就是当前对象。</li>
</ul>
<p>在下面两种情况下可以使用静态方法：</p>
<ul>
<li>方法不需要访问对象状态，因为它需要的所有参数都是通过显式参数提供</li>
<li>方法只需要访问类的静态字段</li>
</ul>
<p>静态static的内存图：</p>
<p><img src="/2020/10/12/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/image-20201011102241582.png" alt="image-20201011102241582"></p>
<h3 id="4-4-4-工厂方法"><a href="#4-4-4-工厂方法" class="headerlink" title="4.4.4  工厂方法"></a>4.4.4  工厂方法</h3><p>静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法(factory method)来构造对象。</p>
<h3 id="4-4-5-main-方法"><a href="#4-4-5-main-方法" class="headerlink" title="4.4.5  main 方法"></a>4.4.5  main 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee_2[] staff = <span class="keyword">new</span> Employee_2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee_2(<span class="string">&quot;Tom&quot;</span>,<span class="number">40000</span>);</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee_2(<span class="string">&quot;Dick&quot;</span>,<span class="number">60000</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee_2(<span class="string">&quot;Harry&quot;</span>,<span class="number">65000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Employee_2 e : staff)</span><br><span class="line">        &#123;</span><br><span class="line">            e.setId();</span><br><span class="line">            System.out.println(<span class="string">&quot;name = &quot;</span>+e.getName()+<span class="string">&quot;salary =&quot;</span>+e.getSalary()+<span class="string">&quot;Harry = &quot;</span>+e.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = Employee_2.getNextId();</span><br><span class="line">        System.out.println(<span class="string">&quot;Next available id=&quot;</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee_2</span><span class="params">(String name, <span class="keyword">double</span> salary)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-5-方法参数"><a href="#4-5-方法参数" class="headerlink" title="4.5 方法参数"></a>4.5 方法参数</h2><p>程序设计语言中关于如何将参数传递给方法(或函数)的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值。而按引用调用(call by reference)表示方法接收的是调用者提供的变量地址。方法可以修改按引用传递的变量的值，而不能修改按值传递的变量的值。</p>
<p>java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个副本。具体来讲，方法不能修改传递给它的任何参数变量的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">harry.reiseSalary(percent);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleValue</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="number">3</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">tripleValue(percent);</span><br></pre></td></tr></table></figure>

<p>然而，有两种类型的方法参数：基本数据类型，对象引用。你已经看到，一个方法不可能修改基本数据类型的参数，而对象引用作为参数就不同了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleSalary</span><span class="params">(Employee x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.raiseSalary(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line">harry = <span class="keyword">new</span> Employee(...);</span><br><span class="line">tripleSalary(harry);</span><br></pre></td></tr></table></figure>

<p>下面总结一下在Java中对方法参数能做什么和不能做什么：</p>
<ul>
<li>方法不能修改基本数据类型的参数</li>
<li>方法可以改变对象参数的状态</li>
<li>方法不能让一个对象参数引用一个新的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test 1:Method can&#x27;t modify numeric parameters&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before: percent= &quot;</span>+percent);</span><br><span class="line">        tripleValue(percent);</span><br><span class="line">        System.out.println(<span class="string">&quot;After: percent= &quot;</span>+percent);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Test 2:Methods can change the state of object parameters&quot;</span>);</span><br><span class="line">        Employee_3 harry = <span class="keyword">new</span> Employee_3(<span class="string">&quot;harry&quot;</span>,<span class="number">50000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Before: salary=&quot;</span>+harry.getSalary());</span><br><span class="line">        tripleSalary(harry);</span><br><span class="line">        System.out.println(<span class="string">&quot;After: salary=&quot;</span>+harry.getSalary());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Test 3:Methods can&#x27;t attach new objects to object&quot;</span>);</span><br><span class="line">        Employee_3 a = <span class="keyword">new</span> Employee_3(<span class="string">&quot;Alice&quot;</span>,<span class="number">70000</span>);</span><br><span class="line">        Employee_3 b = <span class="keyword">new</span> Employee_3(<span class="string">&quot;Bob&quot;</span>,<span class="number">60000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Before: a=&quot;</span>+a.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Before: b=&quot;</span>+b.getName());</span><br><span class="line">        swap(a,b);</span><br><span class="line">        System.out.println(<span class="string">&quot;After: a=&quot;</span>+a.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;After: b=&quot;</span>+b.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleValue</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = x * <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;End of method:x= &quot;</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tripleSalary</span><span class="params">(Employee_3 x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x.raiseSalary(<span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;End of method: salary=&quot;</span>+x.getSalary());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee_3 x, Employee_3 y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee_3 temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;End of method: x=&quot;</span>+x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;End of method: y=&quot;</span>+y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee_3</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee_3</span><span class="params">(String name, <span class="keyword">double</span> salary)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">int</span> byPercent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-对象构造"><a href="#4-6-对象构造" class="headerlink" title="4.6 对象构造"></a>4.6 对象构造</h2><h3 id="4-6-1-重载"><a href="#4-6-1-重载" class="headerlink" title="4.6.1 重载"></a>4.6.1 重载</h3><p>有些类有多个构造器。这种功能叫做重载(overloading)。如果多个方法(构造器方法)有相同的名字、不同的参数，便出现了重载。编译器必须挑选出具体调用哪个方法。它用各个方法首部中的参数类型与特定方法调用中所使用的值类型进行匹配，来选出正确的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好(这个查找匹配的过程被称为重载解析(overloading resolution))。</p>
<p>方法重载与下列因素相关：</p>
<ul>
<li>参数个数不同；</li>
<li>参数类型不同；</li>
<li>参数的多类型顺序不同</li>
</ul>
<p>方法重载与下列因素无关：</p>
<ul>
<li>与参数的名称无关；</li>
<li>与方法的返回值类型无关；</li>
</ul>
<h3 id="4-6-2-默认字段初始化"><a href="#4-6-2-默认字段初始化" class="headerlink" title="4.6.2 默认字段初始化"></a>4.6.2 默认字段初始化</h3><p>如果在构造器中没有显示地为字段设置初值，那么就会被自动赋为默认值：数值为0，布尔值为false，对象引用为null。有些人认为以来默认值的做法是一种不好的编程实践。确实，如果不明确地对字段进行初始化，就会影响程序代码地可读性。</p>
<h3 id="4-6-3-无参数的构造器"><a href="#4-6-3-无参数的构造器" class="headerlink" title="4.6.3 无参数的构造器"></a>4.6.3 无参数的构造器</h3><p>很多类包含了一个无参数的构造器，由无参数构造器创建对象时，对象的状态会设置为适当的默认值。</p>
<p>如果写一个类时没有编写构造器，就会为你提供一个无参数构造器。这个构造器将所有实例字段设置为默认值。</p>
<p>如果类中提供了至少一个构造器，但没有提供无参数构造器，那么构造对象时如果不提供参数就是不合法的。</p>
<h3 id="4-6-4-显示字段初始化"><a href="#4-6-4-显示字段初始化" class="headerlink" title="4.6.4 显示字段初始化"></a>4.6.4 显示字段初始化</h3><p>通过重载类的构造器方法，可以采用多种形式设置类的实例字段的初始状态。不管怎么调用构造器，每个实例字段都要设置为一个有意义的初值，确保这一点总是一个好主意。</p>
<h3 id="4-6-5-参数名"><a href="#4-6-5-参数名" class="headerlink" title="4.6.5 参数名"></a>4.6.5 参数名</h3><h3 id="4-6-6-调用另一个构造器"><a href="#4-6-6-调用另一个构造器" class="headerlink" title="4.6.6 调用另一个构造器"></a>4.6.6 调用另一个构造器</h3><p>关键字this指示一个方法的隐式参数。不过，这个关键字还有另外一个含义。如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">double</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">&quot;Employee #&quot;</span>+nextId,s);</span><br><span class="line">    nextId++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用new Employee(60000)时，Employee(double)构造器将调用Employee(String,double)构造器。采用这种方式使用this关键字非常有用，这样对公共的构造器代码只需要编写一次即可。</p>
<h3 id="4-6-7-初始化块"><a href="#4-6-7-初始化块" class="headerlink" title="4.6.7 初始化块"></a>4.6.7 初始化块</h3><p>前面已经讲过两种初始化数据字段的方法：</p>
<ul>
<li>在构造器中设置值；</li>
<li>在声明中赋值。</li>
</ul>
<p>实际上，Java还有第三种机制，称为初始化块(initialization block)。在一个类的声明中，可以包含任意多个代码块。只要构造这个类，这些块就会被执行。</p>
<p>首先运行初始化块，然后才运行构造器的主体部分。这种机制不是必须的，也不常见。通常会直接将初始化代码放在构造器中。</p>
<p>下面是调用构造器的具体处理步骤：</p>
<ul>
<li>如果构造器的第一行调用了另一个构造器，则基于所提供的参数执行第二个构造器。</li>
<li>否则，所有数据字段初始化为默认值，按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块。</li>
<li>执行构造器主体代码。</li>
</ul>
<p>当第一次用到本类时，静态代码块执行唯一一次。静态内容总是优先于非静态，所以静态代码块比构造方法先执行。静态代码块的典型用途：用来一次性地对静态成员变量进行赋值。</p>
<p>在类第一次加载的时候，将会进行静态字段的初始化。与实例字段一样，除非将静态字段显式地设置成其他值，否则默认地初始值为0，false，null。所有的静态字段初始化方法以及静态初始化块都是依照类声明中出现的顺序执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee_4[] staff = <span class="keyword">new</span> Employee_4[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee_4(<span class="string">&quot;Harry&quot;</span>,<span class="number">40000</span>);</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee_4(<span class="number">60000</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee_4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Employee_4 e : staff)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name=&quot;</span>+e.getName()+<span class="string">&quot;,id=&quot;</span>+e.getId()+<span class="string">&quot;,salary=&quot;</span>+e.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee_4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        nextId = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee_4</span><span class="params">(String name, <span class="keyword">double</span> salary)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee_4</span><span class="params">(<span class="keyword">double</span> salary)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;Employee #&quot;</span>+nextId,salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee_4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-8-对象析构与finalize方法"><a href="#4-6-8-对象析构与finalize方法" class="headerlink" title="4.6.8 对象析构与finalize方法"></a>4.6.8 对象析构与finalize方法</h3><p>由于Java会完成自动的垃圾回收，不需要人工回收内存，所以Java不支持析构器。当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用显得十分重要。如果一个资源一旦使用完毕就需要立即关闭，那么应当提供一个close方法来完成必要的清理工作。可以在对象使用完时调用这个close方法。</p>
<h2 id="4-7-包"><a href="#4-7-包" class="headerlink" title="4.7 包"></a>4.7 包</h2><p>Java允许使用包(package)将类组织在一个集合中。借助包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。</p>
<h3 id="4-7-1-包名"><a href="#4-7-1-包名" class="headerlink" title="4.7.1 包名"></a>4.7.1 包名</h3><p>使用包的主要原因是确保类名的唯一性。假如两个程序员不约而同地建立了Employee类。只要将这些类放置在不同的包中，就不会产生冲突。事实上，为了保证包名的绝对唯一性，要使用一个因特网域名以逆序的形式作为包名，然后对于不同的工程使用不同的子包。例如，考虑域名horstman.com。如果逆序来写，就得到了包名com.horstman。然后可以追加一个工程名，如com.horstman.corejava。如果把Employee类放在这个包里，那么让这个类的“完全限定”名就是com.horstman.corejava.Employee。</p>
<h3 id="4-7-2-类的导入"><a href="#4-7-2-类的导入" class="headerlink" title="4.7.2 类的导入"></a>4.7.2 类的导入</h3><p>一个类可以使用所属包中的所有类，以及其他包中的公共类(public class)。可以采用两种方式访问另一个包中的公共类。第一种方式就是完全限定名(fully qualified name)；就是包名后面跟着类名。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.time.LocalDate today = java,time.LocalDate.now();</span><br></pre></td></tr></table></figure>

<p>这显然很繁琐。更简单更常用的方式是使用import语句。import语句是一种引用包中名个类的简单方式。一旦使用了import语句，在使用类时，就不必写出类的全名了。</p>
<p>可以使用import语句导入一个特定的类或者整个包。import语句应该位于源文件的顶部。例如，可以使用下面这条语句导入java.util包中的所有类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br></pre></td></tr></table></figure>

<p>import java.time.*;的语法比较简单，对代码的规模也没有任何负面影响。不过，如果能够明确地指出所导入的类，代码的读者就能更加准确地知道你使用了哪些类。</p>
<p>但是，需要注意的是，只能使用星号*导入的包，而不能使用import java.*或import.java.*.*导入以java为前缀的所有包。在大多数情况下，可以只导入你需要的包，并不必过多地考虑他们。但在发生命名冲突的时候，就要注意包了。例如java.util和java.sql包都有Date类。如果在程序中导入了这两个包：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br></pre></td></tr></table></figure>

<p>在程序中使用Date类的时候，就会出现一个编译错误。此时编译器无法确定你想使用的是哪一个Date类。可以增加一个特定的import语句来解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br></pre></td></tr></table></figure>

<p>如果这两个类都修要使用，又该怎么办呢？答案是，在每个类名的前面加上完整的包名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deadline = <span class="keyword">new</span> java.util.Date();</span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> java.sql.Date();</span><br></pre></td></tr></table></figure>

<h3 id="4-7-3-静态导入"><a href="#4-7-3-静态导入" class="headerlink" title="4.7.3 静态导入"></a>4.7.3 静态导入</h3><h3 id="4-7-4-在包中增加类"><a href="#4-7-4-在包中增加类" class="headerlink" title="4.7.4 在包中增加类"></a>4.7.4 在包中增加类</h3><p>想要将类放入包中，就必须将包的名字放在源文件的开头，即放在定义这个包中各个类的代码之前。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.horstmann.corejava;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-5-包访问"><a href="#4-7-5-包访问" class="headerlink" title="4.7.5 包访问"></a>4.7.5 包访问</h3><p>前面已经接触过访问修饰符public和private。标记为publice的部分可以由任意类使用；标记为private的部分只能由定义他们的类使用。如果没有指定public和private，这个部分(类、方法或变量)可以被同一个包中的所有方法访问。</p>
<h3 id="4-7-6-类路径"><a href="#4-7-6-类路径" class="headerlink" title="4.7.6 类路径"></a>4.7.6 类路径</h3><h3 id="4-7-7-设置类路径"><a href="#4-7-7-设置类路径" class="headerlink" title="4.7.7 设置类路径"></a>4.7.7 设置类路径</h3><h2 id="4-8-JAR文件"><a href="#4-8-JAR文件" class="headerlink" title="4.8 JAR文件"></a>4.8 JAR文件</h2><h3 id="4-8-1-创建JAR文件"><a href="#4-8-1-创建JAR文件" class="headerlink" title="4.8.1 创建JAR文件"></a>4.8.1 创建JAR文件</h3><h3 id="4-8-2-清单文件"><a href="#4-8-2-清单文件" class="headerlink" title="4.8.2 清单文件"></a>4.8.2 清单文件</h3><h3 id="4-8-3-可执行JAR文件"><a href="#4-8-3-可执行JAR文件" class="headerlink" title="4.8.3 可执行JAR文件"></a>4.8.3 可执行JAR文件</h3><h3 id="4-8-4-多版本JAR文件"><a href="#4-8-4-多版本JAR文件" class="headerlink" title="4.8.4 多版本JAR文件"></a>4.8.4 多版本JAR文件</h3><h3 id="4-8-5-关于命令行选项的说明"><a href="#4-8-5-关于命令行选项的说明" class="headerlink" title="4.8.5 关于命令行选项的说明"></a>4.8.5 关于命令行选项的说明</h3><h2 id="4-9-文档注释"><a href="#4-9-文档注释" class="headerlink" title="4.9 文档注释"></a>4.9 文档注释</h2><h3 id="4-9-1-注释的插入"><a href="#4-9-1-注释的插入" class="headerlink" title="4.9.1 注释的插入"></a>4.9.1 注释的插入</h3><h3 id="4-9-2-类注释"><a href="#4-9-2-类注释" class="headerlink" title="4.9.2 类注释"></a>4.9.2 类注释</h3><p>类注释必须放在import语句之后，类定义之前。</p>
<h3 id="4-9-3-方法注释"><a href="#4-9-3-方法注释" class="headerlink" title="4.9.3 方法注释"></a>4.9.3 方法注释</h3><h3 id="4-9-4-字段注释"><a href="#4-9-4-字段注释" class="headerlink" title="4.9.4 字段注释"></a>4.9.4 字段注释</h3><h3 id="4-9-5-通用注释"><a href="#4-9-5-通用注释" class="headerlink" title="4.9.5 通用注释"></a>4.9.5 通用注释</h3><h3 id="4-9-6-包注释"><a href="#4-9-6-包注释" class="headerlink" title="4.9.6 包注释"></a>4.9.6 包注释</h3><h3 id="4-9-7-注释抽取"><a href="#4-9-7-注释抽取" class="headerlink" title="4.9.7 注释抽取"></a>4.9.7 注释抽取</h3><h2 id="4-10-类设计技巧"><a href="#4-10-类设计技巧" class="headerlink" title="4.10 类设计技巧"></a>4.10 类设计技巧</h2><ul>
<li>一定要保证数据私有</li>
<li>一定要对数据进行初始化</li>
<li>不要在类中使用过多的基本类型</li>
<li>不是所有的字段都需要单独的字段访问器和字段更改器</li>
<li>分解有过多指职责的类</li>
<li>类名和方法名要能够体现它们的职责</li>
<li>优先使用不可变的类</li>
</ul>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>链表总结</title>
    <url>/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>链表是物理存储单元上非连续、非顺序的存储结构，它由一个个结点，通过指针来联系起来，其中每个结点都包括数据和指针。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/image-20201027082655248.png" alt="image-20201027082655248"></p>
<p>链表的非连续，非顺序，对应数组的连续、顺序，来看一个例子：整型数组1，2，3，4在内存中是如何表示的</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/image-20201027082807682.png" alt="image-20201027082807682"></p>
<p>可以看到数组的每个元素都是连续紧邻分配的，这叫连续性，同时由于数组的元素占用的大小是一样的，在Java中int型大小固定为4个字节，所以如果数组的起始位置是100，由于这些元素在内存中都是连续紧邻分配的，大小也一样，可以很容易地找出数组中任意一个元素的位置，比如数组中的第三个元素起始地址为100+2*4=108，这就叫顺序性。查找的时间复杂度是O(1)，效率很高！</p>
 <span id="more"></span> 

<p>那么链表在内存中是怎么表示的呢？</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/image-20201027083257491.png" alt="image-20201027083257491"></p>
<p>可以看到每个结点都分配在非连续的位置，结点与结点之间通过指针连在了一起，所以如果我们要找比如为3的节点，只能通过结点1从头到尾遍历寻找，如果元素少还好，如果元素太多(比如超过一万个)，每个元素的查找都要从头开始查找，时间复杂度是O(n)，比起数组的O(1)，差距不小。</p>
<p>除了查找性能链表不如数组之外，还有另一个优势让数组的性能高于链表，这里引入程序局部性原理。</p>
<p>CPU运行速度是非常快的，如果CPU每次运算都要到内存里去取数据无疑是很耗时的，所以在CPU与内存之间往往集成了挺多层级的缓存，这些缓存越接近CPU，速度越快，所以如果能提前把内存中的数据加载到如下图中的L1、L2、L3缓存中，那么下一次CPU取数的话直接从这些缓存里取即可，能让CPU执行速度加快，那么什么情况下内存中的数据会被提前加载到L1、L2、L3缓存中呢，答案是当某个元素被用到的时候，那么这个元素地址附近的元素会被提前加载到缓存中</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/image-20201027084355365.png" alt="image-20201027084355365"></p>
<p>以整数型1，2，3，4为例，当程序用到了数组的第一个元素时，由于CPU认为既然1被用到了，那么紧邻它的元素2，3，4被用到的概率会很大，所以会提前把2，3，4加到L1,L2,L3缓存中去，这样CPU再次执行的时候如果用到2，3，4，直接从L1、L2、L3缓存里取就行了，能提升不少性能。【若将CPU的一个时钟看成一秒，则从L1读取数据需要3秒，从L2读取需要11秒，L3读取需要25秒，而从内存读取，需要1分40秒，所以程序局部性原理对CPU执行性能有很大的提升】</p>
<p>然而链表呢，由于链表的每个结点在内存中里都是随机分布的，只是通过指针联系在一起，所以这些结点地址并不相邻，自然无法利用程序局部性原理来提前加载到L1，L2，L3缓存中来提升程序性能。</p>
<p>综上所述，相比数组，链表的非连续，非顺序确实让它在性能上处于劣势，那么什么情况下该使用链表呢？考虑以下的情况：</p>
<ul>
<li>大内存空间分配</li>
</ul>
<p>由于数组空间的连续性，如果要为数组分配500M的空间，这500M的空间必须是连续的，未使用的，所以在内存空间的分配上数组的要求会比较严格，如果内存碎片太多，分配连续的大空间很可能导致失败。而链表由于是非连续的，所以这种情况下选择链表更合适。</p>
<ul>
<li>元素的频繁删除和插入</li>
</ul>
<p>如果涉及元素的频繁删除和插入，用链表就会高效很多，对于数组来说，如果要在元素间插入一个元素，需要把其余元素一个个往后移，为新元素腾空间(若是要删除则需要把被删除元素之后的一个个往前移)，效率上无疑是比较低的。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/893bed259241d4237deb1b90403940c2bc5edcea636b0e7e95a79750a5840f7e-file_1582118989941" alt="img"></p>
<p>而链表的插入删除相对来说就比较简单了，修改指针位置即可，其他元素无需做任何移动操作。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/ca536142f21ce2769080876ed588b5eba67dcd955426c4ec20546886aba2808c-file_1582118989943" alt="img"></p>
<p>综上所述：如果数据以查为主，很少涉及增和删，选择数组，如果数据涉及到频繁的插入和删除，或元素所需分配空间过大，倾向于选择链表。</p>
<h2 id="链表的表示"><a href="#链表的表示" class="headerlink" title="链表的表示"></a>链表的表示</h2><p>由于链表的特点，所以我们只要在链表中定义头节点即可，另外如果要频繁的用到链表的长度，还可以额外定义一个变量来表示。</p>
<p>需要注意的是这个头节点的定义是有讲究的，一般来说头结点有两种形式，一种是直接以某个元素结点为头节点，如下：</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/image-20201027090630791.png" alt="image-20201027090630791"></p>
<p>一种是以一个虚拟结点作为头结点，即我们常说的哨兵，如下：</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/image-20201027090735273.png" alt="image-20201027090735273"></p>
<p>定义这个哨兵有什么好处呢，假设我们不定义这个哨兵，来看看链表的基本操作怎么定义的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    Node head = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node(val);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node temp = head;</span><br><span class="line">            <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.next = <span class="keyword">new</span> Node(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题所在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(val);</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个问题：</p>
<ul>
<li>每插入一个元素都要对头结点进行判空比较，如果一个链表有很多元素需要被插入，就需要进行很多次的判空处理，不是那么高效。</li>
<li>头结点与其他结点插入逻辑不统一(一个需要判空后再插入，一个不需要判空直接插入)，从程序逻辑性来说不是那么合理(因为结点与结点是平级，添加逻辑理应相同)</li>
</ul>
<p>如果定义了哨兵结点，以上两个问题都可以解决。来看使用哨兵结点的链表定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = <span class="keyword">new</span> Node(val);</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，定义了哨兵结点的逻辑上清楚了很多，不用每次插入元素都对头结点进行判空，也统一了每个结点的添加逻辑。</p>
<p>所以之后的习题讲解中我们使用的链表都是使用定义了哨兵节点的形式。</p>
<h2 id="链表常见解题套路–翻转"><a href="#链表常见解题套路–翻转" class="headerlink" title="链表常见解题套路–翻转"></a>链表常见解题套路–翻转</h2><p>题目：给定数组1，2，3，4构造成如下链表：head–&gt;4–&gt;3–&gt;2–&gt;1</p>
<p>看清楚了，是逆序构造链表！顺序构造我们都知道怎么构造，对每个元素持续调用上文代码定义的addNode方法即可(尾插法)，与尾插法对应的，是头插法，即把每一个元素插到头结点后面即可，这样就能做到逆序构造链表。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/28baedb65387563b93344a576406a2e0b9b0feeb7ff3d21187a11c4871a70c96-file_1582118989961" alt="img"></p>
<p>头插法比较简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leangth = <span class="number">0</span>;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">headInsert</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">        newNode.next = head.next;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedList likedlist = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            likedlist.heandInsert(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        linkedlist.printList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>现在我们加大一些难度，来看下曾经的Google面试题：</p>
<p>给定单向链表的头指针和一个节点指针，定义一个函数在O(1)内删除这个结点。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/d478f6fbaf4d73f60d1a2a1c712bb1c12fc08c6c97aede760b0ca0a439d4d99c-file_1582118989972" alt="img"></p>
<p>即给定值为2的结点，如何把2给删了。</p>
<p>我们知道，如果给定了一个结点要删除它的后继结点是很简单的，只要把这个结点的指针指向后继结点的后继结点即可。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/abe5e10a6baaf6e675b966ca7d728c1cf7325ed5b8638657333c48717872b267-file_1582118989982" alt="img"></p>
<p>给定结点2，删除它的后继结点3，把结点2的next指针指向3的后继结点4即可。</p>
<p>但给定结点2，该怎么删除结点2本身呢，注意题目没有规定说不能改变结点中的值，所以有一种很巧妙的方法，狸猫换太子！先通过结点2找到结点3，再把结点3的值赋给结点2，此时结点2的值变成了3，这时候问题就转化成了上图这种比较简单的需求，即根据结点2把结点3移除即可。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/aede9ee8a068b7e45a37366b596e4fd71863e8e444623d2daffe22e832de8763-file_1582118989985" alt="img"></p>
<p>不过需要注意的是这种解题技巧只适用于被删除的指定结点是中间结点的情况，如果指定节点是尾节点，还是要老老实实地找到尾结点的前继结点，再把尾结点删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSelecteNode</span><span class="params">(Node deleteNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deleteNode.next == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next !=deleteNode)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        deleteNode.data = deleteNode.next.data;</span><br><span class="line">        deleNode.next = deleNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="入门到进阶：链表翻转"><a href="#入门到进阶：链表翻转" class="headerlink" title="入门到进阶：链表翻转"></a>入门到进阶：链表翻转</h2><p>接下来我们会重点看一下链表的翻转，链表的翻转可以衍生出很多的变形，是面试考试中非常热门的考点，基本上考链表必考翻转！所以掌握链表的翻转是必修课！</p>
<p>什么是链表的翻转：给定链表head –&gt;4–&gt;3–&gt;2–&gt;1，将其翻转成head–&gt;1–&gt;2–&gt;3–&gt;4。</p>
<ul>
<li>递归翻转</li>
</ul>
<p>首先我们要查看翻转链表是否符合递归规律：问题可以分解成具有相同解决思路的子问题，子子问题…，直到最终的子问题再也无法分解。</p>
<p>要翻转 head –&gt;4–&gt;3–&gt;2–&gt;1链表，不考虑head结点，分析4–&gt;3–&gt;2–&gt;1。仔细观察我们发现只要先把3–&gt;2–&gt;1翻转成3&lt;—-2&lt;—-1，之后再把3指向4即可。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/abb4f6e92de6c77e0c444c7949540ef8f1bb66502c899a5fdbaafea1cf0d5016-file_1582118989988" alt="img"></p>
<p>只要按以上步骤定义好这个翻转函数功能即可，这样由于子问题与最初的问题具有相同的解决思路，拆分后的子问题持续调用这个翻转函数即可达到目的。</p>
<p>既然符合递归条件，那我们就可以套用递归四步骤来解题：</p>
<p>1.定义递归函数，明确函数功能：根据前面分析，这个递归函数的功能显然是翻转某个节点开始的链表，然后返回新的头结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">invertLinkedList</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.寻找递推公式：</p>
<ul>
<li>针对结点node4，先翻转node之后的结点invert(node.next)，反转之后4—&gt;3—&gt;2—&gt;1变成4—&gt;3&lt;—2&lt;—1</li>
<li>再把node结点的下一个结点3指向node，node的后继结点设置为空，此时变成了4&lt;—3&lt;—2&lt;—1</li>
<li>返回新的头结点，因为此时新的头结点从原来的4变成了1，需要重新设置一下head</li>
</ul>
<p>3.将递推公式带入第一步定义好的函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">invrtLinkedList</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    Node newHead = inverLinkedList(node.next);</span><br><span class="line">    node.next.next = node;</span><br><span class="line">    node.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.计算时间/空间复杂度</p>
<p>由于递归了n次invertLinkedList函数，所以时间复杂度是O(n)，空间复杂度呢，没有用到额外的空间，但是由于递归调用了n次invertLinkedList函数，压了n次栈，所以空间复杂度也是O(n)。</p>
<p>递归一定要从函数的功能去理解，从函数的功能看，定义的递归函数清晰易懂，定义好了之后，由于问题与被拆分的子问题具有相同的解决思路，所以子问题只要持续调用定义好的函数功能即可，切勿层层展开子问题，此乃递归常见的陷阱！</p>
<ul>
<li>非递归翻转链表(迭代解法)</li>
</ul>
<p>我们知道递归比较容易造成栈溢出，所以有其他时间/空间复杂度相近或更好的算法，应该优先选择非递归的解法，那我们看看如何用迭代法来翻转链表：</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/20f22b18ea01d10571a64d14f982877c9aaecb8e00a504e7ee32492a7a9da630-file_1582118989997" alt="img"></p>
<p>1.定义两个节点：pre，cur，其中cur是pre的后继结点，如果是首次定义，需要把pre指向cur的指针去掉，否则由于之后链表翻转，cur会指向pre，就进行了一个环，这点需要注意</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/7188a1ae4266570b2734f8159143cf1e8d7a15ffbcae1e61e3c04d4a61031690-file_1582118990002" alt="img"></p>
<p>2.知道了cur和pre，翻转就很容易了，把cur指向pre即可，之后把pre设置为cur，cur设置为cur的后继结点，一直重复此步骤即可：</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/ccfcd27db1a7f34208012daf0838c23645c1bc6f40ae9e98411050ffc2b91898-file_1582118990003" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterationInverLinkedList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node pre = head.next;</span><br><span class="line">    Node cur = Pre.next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node temp = cur.next;</span><br><span class="line">        cru.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用了迭代的思路来做由于循环n次，显然时间复杂度为O(n)，另外由于没有额外的空间使用，也不像递归那样调用递归函数不断压栈，所以空间复杂度为O(1)，对比递归，显然应该使用迭代的方式来处理！</p>
<h2 id="变形题1：给定一个链表的头结点head，以及两个整数from和to，在链表上把第from个节点和第to个结点这一部分进行翻转。"><a href="#变形题1：给定一个链表的头结点head，以及两个整数from和to，在链表上把第from个节点和第to个结点这一部分进行翻转。" class="headerlink" title="变形题1：给定一个链表的头结点head，以及两个整数from和to，在链表上把第from个节点和第to个结点这一部分进行翻转。"></a>变形题1：给定一个链表的头结点head，以及两个整数from和to，在链表上把第from个节点和第to个结点这一部分进行翻转。</h2><p>例如：给定如下链表，from = 2, to = 4 head–&gt;5–&gt;4–&gt;3–&gt;2–&gt;1；将其翻转后，链表变成head–&gt;5—&gt;2–&gt;3–&gt;4–&gt;1</p>
<p>1.根据from和to找到from-1，from，to，to+1四个结点(注意临界条件，如果from从头结点开始，则from-1为空，反转后需要把to设置为头结点的后继结点，from和to结点也可能超过尾结点，这两种情况不符合条件翻转)。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/6019f62c100fa85730111b29e977143a33ce89c2216831f3489ea8b7fd46c328-file_1582118990010" alt="img"></p>
<p>2.对from和to的结点进行翻转</p>
<p>3.from-1结点指向to结点，将from结点指向to+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterationInvertLinkedList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node fromPre = <span class="keyword">null</span>;</span><br><span class="line">    Node from = <span class="keyword">null</span>;</span><br><span class="line">    Node to = <span class="keyword">null</span>;</span><br><span class="line">    Node toNext = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    <span class="keyword">int</span> curIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(curIndex == fromIndex - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fromPre = temp;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curIndex == fromindex)</span><br><span class="line">        &#123;</span><br><span class="line">            from = temp</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curIndex == toIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            to = temp;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curIndext == toIndex + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            toNext = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">        curIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (from == <span class="keyword">null</span> || to == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;不符合条件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node pre = from;</span><br><span class="line">    Node cur = pre.next;</span><br><span class="line">    <span class="keyword">while</span>(cur != toNext)</span><br><span class="line">    &#123;</span><br><span class="line">        Node next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fromPre !=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        from.next = to;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head.next = to;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    from.next = toNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变形题2：给出一个链表，每K个节点一组进行翻转，并返回反转后的链表。k是一个整数，它的值小于等于链表的长度。如果节点总数不是k的倍数，那么将最后剩余结点保持原有顺序。"><a href="#变形题2：给出一个链表，每K个节点一组进行翻转，并返回反转后的链表。k是一个整数，它的值小于等于链表的长度。如果节点总数不是k的倍数，那么将最后剩余结点保持原有顺序。" class="headerlink" title="变形题2：给出一个链表，每K个节点一组进行翻转，并返回反转后的链表。k是一个整数，它的值小于等于链表的长度。如果节点总数不是k的倍数，那么将最后剩余结点保持原有顺序。"></a>变形题2：给出一个链表，每K个节点一组进行翻转，并返回反转后的链表。k是一个整数，它的值小于等于链表的长度。如果节点总数不是k的倍数，那么将最后剩余结点保持原有顺序。</h2><p>给定这个链表：head–&gt;1-&gt;2-&gt;3-&gt;4-&gt;5；当 k = 2 时，应当返回: head–&gt;2-&gt;1-&gt;4-&gt;3-&gt;5；当 k = 3 时，应当返回: head–&gt;3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>接下来，我们以以下链表为例</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/c6a8e523df1172f9c06f1f64cee979bcf1b7c55e1ca683396b74c0e2c416bc35-file_1582118990012" alt="img"></p>
<p>1.首先要记录3个一组链表的前继结点，定义为startKpre，然后定义再一个step，从这一段的头结点(1)开始遍历2次，找出这段链表的起始和终止结点，如同</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/83187dd02fd6822343bb333b11c7aa2d6fbaff12bcb850562fd0d8b8838ee01b-file_1582118990020" alt="img"></p>
<p>2.找到startK和endK之后，根据之前的迭代反转发对startK和endK的这段链表进行翻转</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/ae2d535fdff55d54da5b6c65c5ac2a1631239c990c4d5baae55bb97d03fd7b36-file_1582118990022" alt="img">3.然后将startKpre指向endK，将startK指向endKNent，即完成了对k个一组结点的翻转。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/dd7ace16a2d7552b1f1a8540d040a3daf2f67df975d126a74cea6ea410a776b8-file_1582118990023" alt="img"></p>
<p>知道了一组k个怎么翻转，之后只要重复对k个结点一组的链表进行翻转即可。</p>
<h2 id="变形题-变形2针对的是顺序的k个一组翻转，那如何逆序K个一组进行翻转呢"><a href="#变形题-变形2针对的是顺序的k个一组翻转，那如何逆序K个一组进行翻转呢" class="headerlink" title="变形题 变形2针对的是顺序的k个一组翻转，那如何逆序K个一组进行翻转呢"></a>变形题 变形2针对的是顺序的k个一组翻转，那如何逆序K个一组进行翻转呢</h2><p>例如：给定如下链表，head–&gt;1–&gt;2–&gt;3–&gt;4–&gt;5；逆序 k 个一组翻转后，链表变成（k = 2 时）head–&gt;1—&gt;3–&gt;2–&gt;5–&gt;4</p>
<p>这道题是字节跳动的面试题，顺序K个一组翻转已经属于hard级别了，逆序k个一组翻转更是superhard ，不过有了之前知识的铺垫，应该不难，只是稍微变形了一个，只要对链表做如下变形即可。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/aa05d66b070d9ca844593d466cac291a723c7e18c0d03922b557bcf3def5d909-file_1582118990024" alt="img"></p>
<h2 id="链表解题利器——快慢指针"><a href="#链表解题利器——快慢指针" class="headerlink" title="链表解题利器——快慢指针"></a>链表解题利器——快慢指针</h2><p>下文详细讲述如何用快慢指针解题技巧。下文详细讲述如何用快慢指针解决以下两大类问题：</p>
<ul>
<li>寻找/删除第K个结点</li>
<li>有关链表环问题的相关解法</li>
</ul>
<h2 id="寻找-删除第K个结点"><a href="#寻找-删除第K个结点" class="headerlink" title="寻找/删除第K个结点"></a>寻找/删除第K个结点</h2><p>LeetCode 876：给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</p>
<h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>要知道链表的中间结点，首先我们需要知道链表的长度，说到链表长度，还记得我们上文说到过哨兵结点可以保存链表长度，这样直接从head的后继结点开始遍历 链表长度/2次即可找到中间结点。为什么中简洁点是 链表长度/2，我们来仔细分析一下</p>
<p>1.假如链表长度是奇数：head–&gt;1–&gt;2–&gt;3–&gt;4–&gt;5，从1开始遍历 5/2 = 2，到达3，3确实是中间结点。</p>
<p>2.假如链表长度是偶数：head–&gt;1–&gt;2–&gt;3–&gt;4–&gt;5–&gt;6，从1开始遍历 6/2=3，到达4，4确实是中间结点的第二个结点。</p>
<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>由于要遍历两次链表，显得不是那么高效，那能否只遍历一次链表就能拿到中间结点呢。</p>
<p>这里就引入了我们的快慢指针，主要有三步：</p>
<ul>
<li>快慢指针同时指向head的后继结点；</li>
<li>慢指针走一步，快指针走两步；</li>
<li>不断地重复步骤2，什么时候停下来呢，这取决于链表的长度是奇数还是偶数</li>
</ul>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/d1457985986ddc24a6856dcb8e61348067b4a5ff9afec8476434d5151998d9b0-file_1582118990027" alt="img"></p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/59a68b3183bd12d0740afbe10ee0d58366f5fb23135d9ac315886cae8f1e8f67-file_1582118990029" alt="img"></p>
<p>综上所述，当fast == null 或 fast.next == null 时，此时的slow结点即为我们要求的中间结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">pulic Node <span class="title">fideMiddleNodeWithSlowFastPointer</span><span class="params">(Node head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node fast = head;</span><br><span class="line">    Node slow = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp;  fast.next !=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上面的基础，我们现在再大一下难度，看下下面这道题。</p>
<p>输入一个链表，输出该链表中的倒数第 k 个结点。比如链表为 head–&gt;1–&gt;2–&gt;3–&gt;4–&gt;5。求倒数第三个结点（即值为 3 的节点）</p>
<p>分析：我们知道如果要求顺序的第K个结点还是比较简单的，从head开始遍历k次即可，如果要求逆序的第k个结点，常规的做法是先顺序遍历一边链表，拿到链表长度，然后再遍历链表长度 - k次即可，这样要遍历两次链表，不是那么高效，如何只遍历一次呢，还是用我们的说的快慢指针解法</p>
<ul>
<li>首先让快慢指针同时指向head的后继结点</li>
<li>快指针往前走k-1步，先走到第k个结点</li>
<li>快慢指针同时往后走一步，不断重复此步骤，直到快指针走到尾结点，此时slow结点即为我们要找的倒叙第k个结点</li>
</ul>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/2876ebccbe18f6186d73f72d9d0f2262e5b353d7c7def294d581352db16d3a84-file_1582118990030" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道了如何求倒叙k个结点，再来看看下面这道题</p>
<p>给定一个单链表，设计一个算法实现链表向右旋转 K 个位置。举例：给定 head-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, K=3,右旋后即为 head-&gt;3-&gt;4-&gt;5–&gt;1-&gt;2-&gt;NULL</p>
<p>分析：这道题其实是对求倒叙第K个位置的一个变型，主要思路如下：</p>
<ul>
<li>先找到倒数第K+1个结点，此结点的后继结点即为倒数第K个结点</li>
<li>将倒数K+1结点的后继结点设置为null</li>
<li>将head的后继结点设置为以上所得的倒数第K个结点，将原尾结点的后继结点设置为原head的后继结点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k % count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = k % count;</span><br><span class="line">            ListNode pre = find(head,t+<span class="number">1</span>);</span><br><span class="line">            ListNode preNext = pre.next;</span><br><span class="line">            ListNode end = preNext;</span><br><span class="line">            <span class="keyword">while</span>(end.next != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            end.next = head;</span><br><span class="line">            head = preNext;</span><br><span class="line">            pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">find</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">                ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小试牛刀之二"><a href="#小试牛刀之二" class="headerlink" title="小试牛刀之二"></a>小试牛刀之二</h3><p>判断两个单链表是否相交及找到第一个交点,要求空间复杂度 O(1)。如图示：如果两个链表相交，5为这两个链表相交的第一个交点。</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/798cfe354436d3000f2b8c3055d6d90c608891ae650ef3de7eb28627bb09527c-file_1582118990033" alt="img"></p>
<p>分析：首先我们要明白，由于链表本身的性质，如果有一个相交结点，那么相交结点之后的所有结点都是这两个链表公用的，也就是说两个链表的长度主要相差在相交结点之前的结点长度，于是我们有以下思路：</p>
<p>1.如果链表没有定义长度，则我们先遍历这两个链表长度，假设分别为L1，L2(L1&gt;=L2)，定义p1，p2指针分别指向各自链表head结点，然后p1先往前走L1-L2步。这一步保证了p1，p2指向的指针与相交结点一样近。</p>
<p>2.然后p1，p2不断往后遍历，每次走一步，一边遍历一遍判断相应结点是否相等，如果相等即为这两个链表的相交结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">commonNode</span><span class="params">(ListNode l1, ListNode l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode lista = l1;</span><br><span class="line">    ListNode listb = l2;</span><br><span class="line">    <span class="keyword">while</span>(lista != listb)</span><br><span class="line">    &#123;</span><br><span class="line">        lista = lista == <span class="keyword">null</span>?l2:lista.next;</span><br><span class="line">        listb = listb == <span class="keyword">null</span>?l1:listb.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lista;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>接下来我们来看如何用快慢指针来判断链表是否有环，这是快慢指针最常见的用法。</p>
<p>判断链表是否有环，如果有，找到环的入口位置（下图中的 2），要求空间复杂度为O(1)</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/f56c56b7d4e36604afd4bd9cd561265310c7bc32f99480613ba8e6787755ba42-file_1582118990036" alt="img"></p>
<p>首先我们要看如果链表有环有什么规律，如果从head结点开始遍历，则这个遍历指针一定会在以上的环中绕圈子，所以我们可以分别定义快慢指针，慢指针走一步，快指针走两步，由于最后快慢指针在遍历过程中一直会在圈中里绕，且快慢指针每次遍历的步长不一样，所以它们在里面不断绕圈子的过程一定会相遇。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">detectCrossNode</span><span class="params">(Node head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node fast = head;</span><br><span class="line">    Node slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(slow.data == fast.data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否有环为什么要返回相遇结点而不是返回true或flase呢？因为题目还需要判断环的入口位置</p>
<p><img src="/2020/10/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/c8d93855ed4256c99420ee9d7014e405231978d205fe27492139187ff4e094a8-file_1582118990038" alt="img"></p>
<p>不难看出，慢指针走了L+S步，快指针比慢指针走的更快，除了走了L+S外，还在环里绕了L+S+nR步，且快指针是慢指针的两倍。即(L+S+nR)/(L+S) = 2；</p>
<p>要想找到入口节点，需要定义两个指针，一个指向head，一个指针指向相遇点，然后这两个指针不断遍历，当他们指向同一个结点时即时环的入口结点。</p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《On-Java-8》-第七章-封装</title>
    <url>/2021/05/07/%E9%98%85%E8%AF%BB%E3%80%8AOn-Java-8%E3%80%8B-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>​        Java提供了访问修饰符(access specifier)供类库开发者指明哪些对于客户端程序员是可用的，哪些是不可用的。访问控制权限的等级，从“最大权限”到“最小权限”依次是：public、protected，包访问权限(package access)(没有关键字)和private。</p>
 <span id="more"></span> 

<h2 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h2><p>​        包内包含一组类，它们被组织在一个单独的命名空间(namespace)下。</p>
<p>​        例如，标准Java发布中有一个工具库，它被组织在java.util命名空间下。java.util中含有一个类，叫做ArrayList。使用ArrayList的一种方式是用其全名java.util.ArrayList。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/FullQualification.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullQualification</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.util.ArrayList list = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这种方式使得程序冗长乏味，因此你可以换一种方式，使用import关键字。如果需要导入某个类，就需要在import语句中声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/SingleImport.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleImport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        现在你就可以不加限定词，直接使用ArrayList了。但是对于java.util包下的其他类，你还是不能用。要导入其中所有的类，只需使用*：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br></pre></td></tr></table></figure>

<p>​        之所以使用导入，是为了提供一种管理命名空间的机制。所有类名之间都是相互隔离的。类A中的方法f()不会与类B中具有相同签名的方法f()冲突。但是如果类名冲突呢？为了解决冲突，我们为每个类创建一个唯一标识符组合。</p>
<p>​        到目前为止的大部分示例都存在单个文件，并为本地使用的，所以尚未受到包名的干扰。但是，这些示例其实已经位于包中了，叫做“未命名”包或默认包(default package)。但是，如果你打算为相同机器上的其他Java程序创建友好的类库或程序时，就必须仔细考虑以防类名冲突。</p>
<p>​        一个Java源代码文件称为一个编译单元(compilation unit)(有时也称翻译单元(translation unit))。每个编译单元的文件后缀名必须是.java。在编译单元中可以有一个public类，它的类名必须与文件同名(包括大小写，但不包括后缀名.java)。每个编译单元中只能有一个public类，否则编译器不接受。如果这个编译单元中还有其他类，那么在包之外是无法访问到这些类的，因为它们不是public类，此时它们为主public类提供“支持”类。</p>
<h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>​        当编译一个.java文件时，.java文件的每个类都会有一个输出文件。每个输出文件的文件名和.java文件中每个类的类名相同，只是后缀名是.class。因此，在编译少量的.java文件后，会得到大量的.class文件。如果你使用过编译型语言，那么你可能习惯编译后产生的一个中间文件(通常称为“obj”文件)，然后与使用链接器(创建可执行文件)或类库生成器(创建类库)产生的其他同类文件打包到一起的情况。这不是Java工作的方式。在Java中，可运行程序是一组.class文件，它们可以打包压缩成一个Java文档文件(JAR，使用jar文档生成器)。Java解释器负责查找、加载和解释这些文件。</p>
<p>​        类库是一组类文件。每个源文件通常都含有一个public类和任意数量的非public类，因此每个文件都有一个public组件。如果把这些组件集中在一起，就需要使用关键字package。</p>
<p>​        如果你使用了package语句，它必须是文件中除了注释之外的第一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hiding;</span><br></pre></td></tr></table></figure>

<p>​        意味着这个编译单元是一个名为hiding类库的一部分。换句话说，你正在生命的编译单元中的public类名称位于名为hiding的保护伞下。任何人想要使用该名称，必须指明完整的类名或者使用import关键字导入hiding。</p>
<p>​        例如，假设文件名是MyClass.java，这意味着文件中只能有一个public类，且类名必须是MyClass：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/mypackage/MyClass.java</span></span><br><span class="line"><span class="keyword">package</span> hiding.mypackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        现在，如果有人想使用MyClass或hiding.mypackage中的其他public类，就必须使用关键字import来使hiding.mypackage中的名称可用。还有一种选择是使用完整的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/QualifiedMyClass.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifiedMyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hiding.mypackage.MyClass m = <span class="keyword">new</span> hiding.mypackage.MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        关键字<strong>import</strong>使之更加简洁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/ImportedMyClass.java</span></span><br><span class="line"><span class="keyword">import</span> hiding.mypackage.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportedMyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass m = <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>​        package和import这两个关键字将单一的全局命名空间分隔开，从而避免名称冲突。</p>
<h3 id="创建独一无二的包名"><a href="#创建独一无二的包名" class="headerlink" title="创建独一无二的包名"></a>创建独一无二的包名</h3><p>​        你可能注意到，一个包从未真正被打包成单一的文件，它可以由很多.class文件构成，因而事情就变得有点复杂了。为了避免这种情况，一种合乎逻辑的做法是将特定包下的所有.class文件都放在一个子目录下。也就是说，利用操作系统的文件结构的层次性。这是Java解决混乱问题的一种方式。</p>
<p>​        将所有的文件放在一个子目录还解决了其他的两个问题：创建独一无二的包名和查找可能隐藏于目录结构某处的类。这是通过将.class文件所在的路径位置编码成package名称来实现的。按照惯例，package名称是类的创建者的反顺序的Internet域名。如果你遵循惯例，因为Integer域名是独一无二的，所以你的package名称也应该是独一无二的，不会发生名称冲突。如果你没有自己的域名，你就得构造一组不大可能与他人重复的组合，来创建独一无二的package名称。</p>
<p>​        此技巧的第二部分是把package名称分解成你机器上的一个目录，所以当Java解释器必须要加载一个.class文件时，它能定位到.class文件所在的位置。首先，它找出环境变量CLASSPATH(通过操作系统设置，有时也能通过Java的安装程序或基于Java的工具设置)。CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。从根目录开始，Java解释器获取包名并将每个句点替换成反斜杠，生成一个基于根目录的路径名(取决于你的操作系统，包名foo.bar.baz变成foo\bar\baz或foo/bar/baz或其它)。然后这个路径与CLASSPATH的不同项连接，解释器就在这些目录中查找与你所创建的类名称相关的.class文件。</p>
<p>​        为了理解这点，例如域名为：MindviewInc.com，将之反转并全部改为小写后就是com.mindviewinc，这将作为创建一个独一无二的全局名称。然后再创建一个名为simple的类库，从而细分名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mindviewinc.simple;</span><br></pre></td></tr></table></figure>

<p>​        这个包名可以用作下面两个文件的命名空间保护伞：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com/mindviewinc/simple/Vector.java</span></span><br><span class="line"><span class="comment">// Creating a package</span></span><br><span class="line"><span class="keyword">package</span> com.mindviewinc.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;com.mindviewinc.simple.Vector&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如前所述，package语句必须是文件的第一行非注释代码。第二个文件看上去差不多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com/mindviewinc/simple/List.java</span></span><br><span class="line"><span class="comment">// Creating a package</span></span><br><span class="line"><span class="keyword">package</span> com.mindviewinc.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;com.mindview.simple.List&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这两个文件都位于我机器中的子目录下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">C:<span class="keyword">\DOC</span><span class="keyword">\Java</span><span class="keyword">\com</span><span class="keyword">\mindviewinc</span><span class="keyword">\simple</span></span><br></pre></td></tr></table></figure>

<p>​        如果你回头看这个路径，会看到com.mindviewinc.simple，但是路径的第一部分呢？CLASSPATH环境变量会处理它。我的机器上的环境变量部分如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">CLASSPATH=.;D:<span class="keyword">\JAVA</span><span class="keyword">\LIB</span>;C:<span class="keyword">\DOC</span><span class="keyword">\Java</span></span><br></pre></td></tr></table></figure>

<p>​        CLASSPATH可以包含多个不同的搜索路径。</p>
<p>​        但是在使用JAR文件时，有点不一样。你必须在类路径写清楚JAR文件的实际名称，不能仅仅是JAR文件所在的目录。因此，对于一个名为grape.jar的JAR文件，类路径应包括：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">CLASSPATH=.;D<span class="keyword">\JAVA</span><span class="keyword">\LIB</span>;C:<span class="keyword">\flavors</span><span class="keyword">\grape</span>.jar</span><br></pre></td></tr></table></figure>

<p>​        一旦设置好类路径，下面的文件就可以放在任意目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/LibTest.java</span></span><br><span class="line"><span class="comment">// Uses the library</span></span><br><span class="line"><span class="keyword">import</span> com.mindviewinc.simple.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">        List l = <span class="keyword">new</span> List();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//com.mindviewinc.simple.Vector</span></span><br><span class="line"><span class="comment">//com.mindviewinc.simple.List</span></span><br></pre></td></tr></table></figure>

<p>​        当编译器遇到导入simple库的import语句时，它首先会在CLASSPATH指定的目录中查找子目录com/mindviewinc/simple，然后从已编译的文件中找出名称相符者。注意，这两个类和其中要访问的方法都必须是public修饰的。</p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>​        若通过*导入了两个包含相同名字类名的类库，会发生什么?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mindviewinc.simple.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure>

<p>​        因为java.util也包含了Vector类，这就存在潜在的冲突。但是你只要不写导致冲突的代码，就不会有问题——这样很好，否则就得做很多类型检查工作来防止那些根本不会出现的冲突。</p>
<p>​        现在如果要创建一个Vector类，就会出现冲突：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br></pre></td></tr></table></figure>

<p>​        这里的Vector类指的是谁呢？编译器不知道，读者也不知道。所以编译器报错，强制你明确指明。对于标准的Java类Vector，你可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.Vector v = <span class="keyword">new</span> java.util.Vector();</span><br></pre></td></tr></table></figure>

<p>​        这种写法完全指明了Vector类的位置，那么就没有必要写import java.util语句，除非使用其他来自java.util中的类。或者，可以导入单个类以防冲突——只要不在同一个程序中使用有冲突的名字(若使用了有冲突的名字，必须要明确指明全名)。</p>
<h3 id="定制工具库"><a href="#定制工具库" class="headerlink" title="定制工具库"></a>定制工具库</h3><p>​        一般来说，将会使用反转后的域名来命名要创建的工具包，例如：com.mindviewinc.util，但为了简化，这里将工具包命名为onjava。例如，下面是“控制流”一章中使用到的range()方法，采用了for-in语法进行简单的遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onjava/Range.java</span></span><br><span class="line"><span class="comment">// Array creation methods that can be used without</span></span><br><span class="line"><span class="comment">// qualifiers, using static imports:</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Range</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Produce a sequence [0,n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] range(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            result[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Produce a sequence [start..end)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] range(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = end - start;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            result[i] = start + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Produce sequence [start..end) incrementing by step</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] range(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> step) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = (end - start) / step;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            result[i] = start + (i * step);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        这个文件的位置一定是在某个以一个CLASSPATH位置开始，然后接着是onjava的目录下。编译完之后，就可以在系统的任何地方使用import onjava语句来使用这些方法了。从现在开始，无论何时你创建了有用的新工具，都可以把它加入到自己的类库中。</p>
<h3 id="使用import改变行为"><a href="#使用import改变行为" class="headerlink" title="使用import改变行为"></a>使用import改变行为</h3><p>​        Java没有C的条件编译(conditional compilation)功能，该功能使你不必更改任何程序代码而能切换开关产生不同的行为。Java之所以去掉此功能，可能是因为C在绝大多数情况下使用该功能解决跨平台问题：程序代码的不同部分要根据不同的平台来编译。而Java自身就是跨平台设计的，这个功能就没有必要了。</p>
<p>​        但是，条件编译还有其他的用途。调试是一个很常见的用途，调式功能在开发过程中是开启的，在发布的产品中是禁用的。可以通过改变导入的package来实现这一目的，修改的方法是将程序中的代码从调试版改为发布版。这个技术可用于任何种类的条件代码。</p>
<h3 id="使用包的忠告"><a href="#使用包的忠告" class="headerlink" title="使用包的忠告"></a>使用包的忠告</h3><p>​        当你创建一个包时，包名就隐含了目录结构。这个包必须位于包名指定的目录中，该目录必须以CLASSPATH开始的目录中可以查询到。最初使用关键字package可能会有点不顺，因为除非遵守“包名对应目录路径”的规则，否则会收到很多意外的运行时错误信息如找不到特定的类，即使这个类就位于同一目录中。如果你收到类似信息，尝试把package语句注释掉，如果程序能够运行的话，你就知道问题出现在哪里了。</p>
<p>​        注意，编译过的代码通常位于与源代码的不同目录。这是很多工程的标准，而集成开发环境(IDE)通常会自动为我们做这些。必须保证JVM通过CLASSPATH能找到编译后的代码。</p>
<h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>​        Java访问修饰符public、protected和private位于定义的类名，属性名和方法名之前。每个访问权限修饰符只能控制它所修饰的对象。</p>
<p>​        若不提供访问修饰符，就意味着“包访问权限”。所以无论如何，万物都有某种形式的访问控制权。</p>
<h3 id="包访问权限"><a href="#包访问权限" class="headerlink" title="包访问权限"></a>包访问权限</h3><p>​        默认访问权限没有关键字，通常被称为包访问权限(package access)。这意味着当前包中的所有其它类都可以访问那个成员。对于这个包之外的类，这个成员看上去是private的。由于一个编译单元只能隶属于一个包，所以通过包访问权限，位于同一编译单元中的所有类彼此之间都是可访问的。</p>
<p>​        包访问权限可以把相关类聚到一个包下，以便它们能轻易地相互访问。包里的类赋予它们包访问权限的成员相互访问的权限，所以你“拥有”了包内的程序代码。只能通过你所拥有的代码去访问你所拥有的其他代码，这样规定很有意义。构建包访问权限机制是将类聚焦在包中的重要原因之一。</p>
<p>​        类控制着哪些代码有权限访问自己的成员。取得对成员的访问权的唯一方式是：</p>
<ul>
<li>使成员成为public。那么无论是谁，无论在哪，都可以访问它。</li>
<li>赋予成员默认包访问权限，不用加任何访问修饰符，然后将其他类放在相同的包内。这样，其它类就可以访问该成员。</li>
<li>在“复用”这一章你将看到，继承的类既可以访问public成员，也可以访问protected成员(但不能访问private成员)。只有当两个类处于同一个包内，它才可以访问包访问权限的成员。但现在不用担心继承和protected。</li>
<li>提供访问器(accessor)和修改器(mutator)(有时也称为“get/set”方法)，从而读取和改变值。</li>
</ul>
<h3 id="public-接口访问权限"><a href="#public-接口访问权限" class="headerlink" title="public:接口访问权限"></a>public:接口访问权限</h3><p>​        当你使用关键字public，就意味着紧随public后声明的成员对于每个人都是可用的。假设定义了一个包含下面编译单元的dessert包：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/dessert/Cookie.java</span></span><br><span class="line"><span class="comment">// Creates a library</span></span><br><span class="line"><span class="keyword">package</span> hiding.dessert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cookie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cookie constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bite&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        记住，Cookie.java文件产生的类文件必须位于名为dessert的子目录中，该子目录在hiding下，它必须在CLASSPATH的几个目录下。不要错误地认为Java总是会将当前目录视作查找行为的起点之一。如果你的CLASSPATH中没有.，Java就不会查找当前目录。</p>
<p>​        现在，使用Cookie创建一个程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/Dinner.java</span></span><br><span class="line"><span class="comment">// Uses the library</span></span><br><span class="line"><span class="keyword">import</span> hiding.dessert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dinner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cookie x = <span class="keyword">new</span> Cookie();</span><br><span class="line">        <span class="comment">// -x.bite(); // Can&#x27;t access</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cookie constructor</span></span><br></pre></td></tr></table></figure>

<p>​        你可以创建一个Cookie对象，因为它构造器和类都是public的。但是，在Dinner.java中无法访问到Cookie对象中的bite()方法，因为bite()只提供了包访问权限，因而在dessert包之外无法访问，编译器禁止你使用它。</p>
<h3 id="默认包"><a href="#默认包" class="headerlink" title="默认包"></a>默认包</h3><p>​        你可能惊讶地发现，一下代码尽管看上去破坏了规则，但是仍然可以编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/Cake.java</span></span><br><span class="line"><span class="comment">// Accesses a class in a separate compilation unit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pie x = <span class="keyword">new</span> Pie();</span><br><span class="line">        x.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Pie.f()</span></span><br></pre></td></tr></table></figure>

<p>​        同一目录下的第二个文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/Pie.java</span></span><br><span class="line"><span class="comment">// The other class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Pie.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        最初看上去这两个文件毫不相关，但在Cake中可以创建一个Pie对象并调用它的f()方法。(注意，你的CLASSPATH中一定得有.，这样文件才能编译)通常会认为Pie和f()具有包访问权限，因此不能被Cake访问。它们的确具有包访问权限，这是部分正确的。Cake.java可以访问它们是因为它们在相同的目录中且没有给自己设定明确的包名。Java把这样的文件看作隶属于该目录的默认包中，因此它们为该目录中所有的其他文件都提供了包访问权限。</p>
<h3 id="private-你无法访问"><a href="#private-你无法访问" class="headerlink" title="private:你无法访问"></a>private:你无法访问</h3><p>​        关键字private意味着除了包含该成员的类，其他任何类都无法访问这个成员。同一个包中的其他类无法访问private成员，因此这等于说自己隔离自己。另一方面 ，让许多人合作创建一个包也是有可能的。使用private，你可以自由地修改那个被修饰的成员，无需担心会影响同一包下的其它类。</p>
<p>​        默认的包访问权限通常提供了足够的隐藏措施；记住，使用类的客户端成员无法访问包访问权限成员。这样做很好，因为默认访问权限是一种我们常用的权限。因此，通常考虑的是把哪些成员声明为public供客户端程序员使用。所以，最初不常使用关键字private，因为程序没有它也可以照常工作。然而，使用private是非常重要的，尤其是在多线程环境中。</p>
<p>​        以下是一个使用private的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/IceCream.java</span></span><br><span class="line"><span class="comment">// Demonstrates &quot;private&quot; keyword</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sundae</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sundae</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Sundae <span class="title">makeASundae</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sundae();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- Sundae x = new Sundae();</span></span><br><span class="line">        Sundae x = Sundae.makeASundae();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        以上展示了private的用武之地：控制如何创建对象，防止别人直接访问某个特定的构造器。例子中，你无法通过构造器创建一个Sundae对象，而必须调用makeASunda()方法创建对象。</p>
<p>​        任何可以肯定只是该类的“助手”方法，都可以声明为private，以确保不会在包中的其他地方误用它，也防止了你会改变或删除它。将方法声明为private确保了你拥有这种选择权。</p>
<p>​        对于类中的private属性也是一样。除非必须公开底层实现，否则就将属性声明为private。然而，不能因为类中某个对象的引用是private，就认为其他对象也无法拥有该对象的public引用。</p>
<h3 id="protected-继承访问权限"><a href="#protected-继承访问权限" class="headerlink" title="protected:继承访问权限"></a>protected:继承访问权限</h3><p>​        关键字protected处理的是继承的概念，通过继承可以利用一个现有的类——基类，然后添加新成员到现有类中而不必碰现有类。我们还可以改变类的现有成员的行为。为了从一个类中继承，需要声明新类extends一个现有类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​        类定义的其他部分看起来是一样的。</p>
<p>​        如果你创建了一个新包，并从另一个包继承类，那么唯一能访问的就是被继承类的public成员。有时，基类的创建者会希望某个特定成员能被继承类访问，但不能被其他类访问。这时就需要使用protected。protected也提供包访问权限，也就是说，相同包内的其他类可以访问protected元素。</p>
<p>​        下面的类不能调用包访问权限的方法bite()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/ChocolateChip.java</span></span><br><span class="line"><span class="comment">// Can&#x27;t use package-access member from another package</span></span><br><span class="line"><span class="keyword">import</span> hiding.dessert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChocolateChip</span> <span class="keyword">extends</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChocolateChip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ChocolateChip constructor&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chomp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- bite(); // Can&#x27;t access bite</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChocolateChip x = <span class="keyword">new</span> ChocolateChip();</span><br><span class="line">        x.chomp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cookie constructor</span></span><br><span class="line"><span class="comment">//ChocolateChip constructor</span></span><br></pre></td></tr></table></figure>

<p>​        如果类Cookie中存在一个方法bite()，那么它的任何子类中都存在bite()。但是因为bite()具有包访问权限并且位于另一个包中，所以我们这个包中无法使用它。你可以把它声明为public，但这样一来每个人都能访问它，这可能也不是你想要的。如果你将Cookie改成如下这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/cookie2/Cookie.java</span></span><br><span class="line"><span class="keyword">package</span> hiding.cookie2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cookie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cookie constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">bite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bite&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这样，bite()对于所有继承Cookie的类，都是可访问的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/ChocolateChip2.java</span></span><br><span class="line"><span class="keyword">import</span> hiding.cookie2.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChocolateChip2</span> <span class="keyword">extends</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChocoalteChip2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ChocolateChip2 constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chomp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bite(); <span class="comment">// Protected method</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChocolateChip2 x = <span class="keyword">new</span> ChocolateChip2();</span><br><span class="line">        x.chomp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cookie constructor</span></span><br><span class="line"><span class="comment">//ChocolateChip2 constructor</span></span><br><span class="line"><span class="comment">//bite</span></span><br></pre></td></tr></table></figure>

<p>​        尽管bite()也具有包访问权限，但它不是public的。</p>
<h3 id="包访问权限VsPublic构造器"><a href="#包访问权限VsPublic构造器" class="headerlink" title="包访问权限VsPublic构造器"></a>包访问权限VsPublic构造器</h3><p>​        当你定义一个具有包访问权限的类，你可以在类中定义一个public构造器，编译器不会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/packageaccess/PublicConstructor.java</span></span><br><span class="line"><span class="keyword">package</span> hiding.packageaccess;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublicConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PublicConstructor</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        有一个Checkstyle工具，你可以运行命令gradlew hiding:checkstyleMain使用它，它会指出这种写法是虚假的，而且从技术上来说是错误的。实际上你不能从包外访问到这个public构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/CreatePackageAccessObject.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">import</span> hiding.packageaccess.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatePackageAcessObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> PublicConstructor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果你编译下这个类，会得到编译错误信息：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">CreatePackageAccessObject.java:6:error:</span><br><span class="line">PublicConstructor is not public in hiding.packageaccess;</span><br><span class="line">cannot be accessed from outside package</span><br><span class="line">new PublicConstructor();</span><br><span class="line"><span class="built_in">^</span></span><br><span class="line">1 error</span><br></pre></td></tr></table></figure>

<p>​        因此，在一个具有包访问权限的类中定义一个public的构造器并不能真的使这个构造器成为public，在声明的时候就应该标记为编译时错误。</p>
<h2 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h2><p>​        访问控制通常被称为隐藏实现(implementation hiding)。将数据和方法包装进类中并把具体实现隐藏被称作是封装(encapsulation)。其结果就是一个同时带有特征和行为的数据类型。</p>
<p>​        出于两个重要的原因，访问控制在数据类型内部划定了边界。第一个原因是确立客户端程序员可以使用和不能使用的边界。可以在结构中建立自己的内部机制而不必担心客户端程序员偶尔将内部实现作为他们可以使用的接口的一部分。</p>
<p>​        这直接引出了第二个原因：将接口与实现分离。如果在一组程序中使用接口，而客户端程序员只能向public接口发送消息的话，那么就可以自由地修改任何不是public的事物，却不会破坏客户端代码。</p>
<p>​        为了清晰起见，你可以采用一种创建类的风格：public成员放在类的开头，接着是protected成员，包访问权限成员，最后是private成员。这么做的好处是类的使用者可以从头读起，首先会看到对他们而言最重要的部分，直到遇到非public成员时停止阅读：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/OrganizedByAccess.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizedByAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pub1</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pub2</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pub3</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">priv1</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">priv2</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">priv3</span><span class="params">()</span> </span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这么做只能是程序阅读起来稍微容易一些，因为实现和接口还是混合一起。也就是说，你仍能看到源代码——部分实现，因为它就在类中。另外，javadoc提供的注释文档功能降低了程序代码的可读性对客户端程序员的重要性。将接口展现给类的使用者实际上是类浏览器的任务，类浏览器会展示给所有可用的类，并告诉你如何使用它们。在Java中，JDK文档起到了类浏览器的作用。</p>
<h2 id="类访问权限"><a href="#类访问权限" class="headerlink" title="类访问权限"></a>类访问权限</h2><p>​        访问权限修饰符也可以用于确定类库中的哪些类对于类库的使用者是可用的。如果希望某个类可以被客户端程序员使用，就把关键字public作用于整个类的定义。这甚至控制着客户端程序员能否创建类的对象。</p>
<p>​        为了控制一个类的访问权限，修饰符必须出现在关键字class之前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>​        如果你类库名是hiding，那么任何客户端程序员都可以通过如下声明访问Widget：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hiding.Widget;</span><br></pre></td></tr></table></figure>

<p>​        或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hiding.*;</span><br></pre></td></tr></table></figure>

<p>​        这里有一些额外的限制：</p>
<ul>
<li>每个编译单元中只能有一个public类。这表示，每个编译单元有一个公共的接口用public类表示。该接口可以包含许多支持包访问权限的类。一旦一个编译单元中出现一个以上的public类，编译就会报错。</li>
<li>public类的名称必须与含有编译单元的文件名相同，包括大小写。所以对于Widget来说，文件名必须是Widget.java，不能是widget.java或WIDGET.java。再次强调，如果名字不匹配，编译器会报错。</li>
<li>虽然不是很常见，但是编译单元内没有public类也是可能的。这时可以随意命名文件</li>
</ul>
<p>​        如果是一个在hiding包中的类，只用来完成Widget或hiding包下一些其他public类所要执行的任务，怎么设置它的访问权限呢？为了保留此灵活性，需要确保客户端程序员不依赖隐藏在hiding中的任何特定细节，那么把public关键字从类中去掉，给予它包访问权限，就可以了。</p>
<p>​        当你创建了一个包访问权限的类，把类中的属性声明为private仍然是有意义的——应该尽可能将所有属性都声明为private，但是通常把方法声明成与类相同的访问权限也是合理的。一个包访问权限的类只能被用于包内，除非强制将某些方法声明为public，这种情况下，编译器会告诉你。</p>
<p>​        注意，类既不能是private的，也不能是protected的。所以对于类的访问权限只有两种选择：包访问权限或public。为了防止类被外界访问，可以将所有的构造器声明为private，这样只有你自己能创建对象(在类的static成员中)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hiding/Lunch.java</span></span><br><span class="line"><span class="comment">// Demonstrates class access specifiers. Make a class</span></span><br><span class="line"><span class="comment">// effectively private with private constructors:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Soup1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Soup1 <span class="title">makeSoup</span><span class="params">()</span> </span>&#123; <span class="comment">// [1]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Soup1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Soup2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Soup2 ps1 = <span class="keyword">new</span> Soup2(); <span class="comment">// [2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Soup2 <span class="title">access</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ps1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Only one public class allowed per file:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Can&#x27;t do this! Private constructor:</span></span><br><span class="line">        <span class="comment">//- Soup1 soup = new Soup1();</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Soup1 soup = Soup1.makeSoup();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Soup2.access().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以像[1]那样通过static方法创建对象，也可以像[2]那样先创建一个静态对象，当用户需要访问它时返回对象的引用即可。</p>
<p>​        到目前为止，大部分的方法要么返回void，要么返回基本类型，所以[1]处的定义乍看之下会有困惑。方法名(makeSoup)前面的Soup1表明了方法返回的类型。到目前为止，这里经常是void，即不返回任何东西。然而也可以返回对象的引用，就像这里一样。这个方法返回了对Soup1类对象的引用。</p>
<p>​        Soup1和Soup2展示了如何通过将你所有的构造器声明为private的方式防止直接创建某个类的对象。记住，如果你不显示地创建构造器，编译器会自动为你创建一个无参构造器。如果我们编写了无参构造器，那么编译器就不会自动创建构造器了。将构造器声明为private，那么谁也无法创建该类的对象了。但是现在别人该怎么使用这个类呢？上述例子给出了两个选择。在Soup1中，有一个static方法，它的作用是创建一个新的Soup1对象并返回对象的引用。如果想要在返回引用之前在Soup1上做一些额外的操作，或是记录创建了多少个Soup1对象(可以用来限制数量)，这种做法是有用的。</p>
<p>​        Soup2用到了所谓的设计模式(design pattern)。这种模式叫做单例模式(singleton)，因为它只允许创建类的一个对象。Soup2类的对象是作为Soup2的static private成员而创建的，所以有且只有一个，你只能通过public修饰的access()方法访问到这个对象。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>《On Java 8》</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《On Java 8》--第三章 万物皆对象</title>
    <url>/2021/04/19/%E9%98%85%E8%AF%BB%E3%80%8AOn-Java-8%E3%80%8B-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h2><p>​        Java利用万物皆对象的思维和单一一致的语法方式来简化问题。虽然万物皆对象，但我们所操纵的标识符实际上只是对象的引用。</p>
<p>​        下面来创建一个String引用，用于保存单词或语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s;</span><br></pre></td></tr></table></figure>

<p>​        这里只是创建一个String对象的引用，而非对象。直接拿出来会出现错误：因为此时你并没有给变量s赋值——指向任何对象。通常更安全的做法是：创建一个引用的同时进行初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;asdf&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​        Java语法允许我们使用带双引号的文本内容来初始化字符串，同样，其他类型的对象也有相应的初始化方式。</p>
 <span id="more"></span> 

<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>​        “引用”用来关联“对象”。在Java中，通常我们使用new操作符来创建一个对象。new关键字代表：创建一个新的对象实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;asdf&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​        以上展示了字符串对象的创建过程，以及如何初始化生成字符串。除了String类型以外，Java本身带了许多现成的数据类型。除此之外，我们还可以创建自己的数据类型。</p>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>​        那么，程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有5个不同的地方可以存储数据：</p>
<ul>
<li>寄存器(Registers)：最快的存储区域，位于CPU内部。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权限，也无法在自己的程序里找到寄存器存在的踪迹。(c/c++允许开发者向编译器建议寄存器的分配)</li>
<li>栈内存(Stack)：存在于常规内存RAM(随机访问存储器，Random Access Memory)区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java系统必须知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些Java数据(如对象引用)，但Java对象本身的数据却是保存在堆内存的。</li>
<li>堆内存(Heap)：这是一种通用的内存池(也在RAM区域)，所有Java对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象，只需要new命令实例化对象即可，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间。随着时间的推移，Java的堆内存分配机制现在已经很快，因此这不是一个值得关心的问题了。</li>
<li>常量存储(Constant storage)：常量值通常直接放在程序代码里，因为它们永远不会改变。如需要严格保护，可考虑将它们置于只读存储器(ROM，Read Only Memory)中。</li>
<li>非RAM存储(Non-RAM storage)：数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：(1)序列化对象：对象被转换为字节流，通常被发送另一台机器；(2)持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于RAM的对象。Java为轻量级持久化提供了支持。而诸如JDBC和Hibernate这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。</li>
</ul>
<h3 id="基本类型的存储"><a href="#基本类型的存储" class="headerlink" title="基本类型的存储"></a>基本类型的存储</h3><p>​        有一组类型在Java中使用频率很高，它们需要特殊对待，这就是Java的基本类型。之所以这么说，是因为它们的创建不是通过new关键字来产生的。通常new出来的对象都是自动保存在堆内存中的，以此方式创建小而简单的变量往往是不划算。所以对于这些基本类型的创建方法，Java使用了和C/C++一样的策略。也就是说，不是使用new创建变量，而是使用一个“自动”变量。这个变量直接存储“值”，并置于栈内存中，因此更加高效。</p>
<p>​        Java确定了每种基本类型的内存占用大小。这些大小不会像其他一些语言那样随着机器环境的变化而变化。这种不变性也是Java更具可移植性的一个原因。</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">大小</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
<th align="center">包装类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">——</td>
<td align="center">——</td>
<td align="center">——</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16bits</td>
<td align="center">Unicode0</td>
<td align="center">Unicode$2^{16}-1$</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">8bits</td>
<td align="center">-128</td>
<td align="center">+127</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16bits</td>
<td align="center">$-2^{15}$</td>
<td align="center">$+2^{15}-1$</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32bits</td>
<td align="center">$-2^{31}$</td>
<td align="center">$+2^{31}-1$</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64bits</td>
<td align="center">$-2^{63}$</td>
<td align="center">$+2^{63}-1$</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32bits</td>
<td align="center">IEEE754</td>
<td align="center">IEEE754</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64bits</td>
<td align="center">IEEE754</td>
<td align="center">IEEE754</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">——</td>
<td align="center">——</td>
<td align="center">——</td>
<td align="center">Void</td>
</tr>
</tbody></table>
<p>​        所有的数值类型都是有正/负符号的。布尔(boolean)类型的大小没有明确规定，通常定义为字面值“true”或“false”。基本类型有有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">Character ch = <span class="keyword">new</span> Character(c);</span><br></pre></td></tr></table></figure>

<p>​        或者你也可以使用下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character ch = <span class="keyword">new</span> Character(<span class="string">&#x27;x&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>​        基本类型自动转换成包装类型(自动装箱)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character ch = <span class="string">&#x27;x&#x27;</span>;	</span><br></pre></td></tr></table></figure>

<p>​        相对应的，包装类型转换为基本类型(自动拆箱)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = ch;</span><br></pre></td></tr></table></figure>

<h3 id="高精度数值"><a href="#高精度数值" class="headerlink" title="高精度数值"></a>高精度数值</h3><p>​        在Java中有两种类型的数据可用于高精度的计算。它们是BigInteger和BigDecimal。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。</p>
<p>​        这两个类包含的方法提供的操作，与对基本类型执行的操作相似。也就是说，能对int或float做的运算，在BigDecimal和BigInteger这里也同样可以，只不过必须通过调用它们的方法来实现而非运算符。此外，由于涉及到的计算量更多，所以运行速度会慢一些。诚然，我们牺牲了速度，换取了精度。</p>
<p>​        BigInteger支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。BigDecimal支持任意精度的定点数字。例如，可用于精确的货币计算。</p>
<h3 id="数组的存储"><a href="#数组的存储" class="headerlink" title="数组的存储"></a>数组的存储</h3><p>​        许多编程语言都支持数组类型。在C和C++中使用数字是危险的，因为那些数组只是内存块。如果程序访问了内存块之外的数组或在初始化之前使用该段内存(常见编程错误)，则结果是不可预测的。</p>
<p>​        Java的设计主要目的之一是安全性。在Java中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价，但由此换来的安全性和效率的提高是值得的。</p>
<p>​        当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始化都为null。在使用该数组前，我们必须为每个引用指定一个对象。如果我们尝试使用为null的引用，则会在运行时报错。因此，在Java中就防止了数组操作的常规错误。</p>
<p>​        我们还可以创建基本类型的数组。编译器通过将该数组的内存全部置为零来保证初始化。</p>
<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><p>​        Java中有两种类型的注释。第一种是传统的C风格的注释，以/*开头，可以跨越多行，到*/结束。注意，许多程序员在多行注释的每一行开头添加*，所以你会看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*这是跨越</span></span><br><span class="line"><span class="comment">*多行的注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        第二种注释形式来自C++。它是单行注释，以//开头并一直持续到行结束。这种注释方便且常用，因为直观简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是单行注释</span></span><br></pre></td></tr></table></figure>

<h2 id="对象请理"><a href="#对象请理" class="headerlink" title="对象请理"></a>对象请理</h2><p>​        在一些编程语言中，管理变量的生命周期需要大量的工作。一个变量需要存活多久？如果我们想要销毁它，应该什么时候去做呢？变量生命周期的混乱会导致许多bug。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>​        作用域决定了在该范围内定义的变量名的可见性和生命周期。在C、C++、Java中，作用域由大括号{}的位置决定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//仅x变量可以使用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">96</span>;</span><br><span class="line">        <span class="comment">//x和q变量皆可使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅x变量可用</span></span><br><span class="line">    <span class="comment">//变量q不在作用域中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        Java的变量只有在其作用域才可用。缩进使得Java代码更易于阅读。由于Java是一种自由格式的语言，额外的空格、制表符和回车并不会影响程序的执行结构。在Java中，你不能执行以下操作，即使这这C和C++中是合法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">96</span>;<span class="comment">//Illegal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在上例中，Java编译器在提示变量x已经被定义过了。</p>
<h3 id="对象作用域"><a href="#对象作用域" class="headerlink" title="对象作用域"></a>对象作用域</h3><p>​        Java对象与基本类型具有不同的生命周期。当我们使用new关键字来创建Java对象时，它的生命周期将会超出作用域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//作用域终点</span></span><br></pre></td></tr></table></figure>

<p>​        上例中，引用s在作用域终点就结束了。但是，引用s指向的字符串对象依然还占用内存。这段代码中，我们无法在这个作用域之后访问这个对象，因为唯一对它的引用s已超出了作用域的范围。</p>
<p>​        只要你需要，new出来的对象就会一直存活下去。相比C++编码中操作内存可能会出现的诸多问题，这些困扰在Java中都不复存在了。在C++中你不仅要确保对象的内存在你的操作的范围内存在，还必须在使用完它们之后，将其销毁。</p>
<p>​        那么问题来了：我们在Java中没有主动清理这些对象，那么它是如何避免C++中出现的内存被填满从而阻塞程序的问题的呢？答案是：Java的垃圾收集器会检查所有new出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新对象使用。也就是说，我们不必再担心内存回收的问题了。你只需要简单创建对象即可。当其不再被需要时，能自行被垃圾收集器释放。垃圾回收机制有效防止了因程序员忘记释放内存而造成的“内存泄露”问题。</p>
<h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>​        通常在class关键字的后面的紧跟类的名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ATypeName</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里是类的内部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        尽管这个类只有一行注释，我们还是一样可以通过new关键字来创建这一种类型的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ATypeName a = <span class="keyword">new</span> ATypeName();</span><br></pre></td></tr></table></figure>

<p>​        我们还不能用这个对象来做什么事(即不能向它发送任何有意义的消息)，除非我们在这个类里定义一些方法。</p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>​        当我们创建好了一个类之后，我们可以往类里存放两种类型的元素：方法(method)和字段(field)。类的字段可以是基本类型，也可以是引用类型。如果类的字段是对某个对象的引用，那么必须要初始化该引用将其关联到一个实际的对象上。每个对象都有其存储其字段的空间。通常，字段不在对象间共享。下面是一个具有某些字段的类的代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataOnly</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i; </span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">boolean</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这个类除了存储数据之外什么也不能做。但是，我们仍然可以通过下面的代码来创建它的一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataOnly data = <span class="keyword">new</span> DataOnly();</span><br></pre></td></tr></table></figure>

<p>​        我们必须通过这个对象的引用来指定字段值。格式：对象名称.方法名或字段名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data.i = <span class="number">47</span>;</span><br><span class="line">data.d = <span class="number">1.1</span>;</span><br><span class="line">data.b = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>​        如果你想修改对象内包含的另外一个对象的数据，可以通过这样的格式修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myPlane.leftTank.capacity = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>​        你可以用这种方式嵌套许多对象(尽管这样的设计会带来混乱)。</p>
<h3 id="基本类型默认值"><a href="#基本类型默认值" class="headerlink" title="基本类型默认值"></a>基本类型默认值</h3><p>​        如果类的成员变量(字段)是基本类型，那么在类初始化时，这些类将会被赋予一个初始值。</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">初始值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">\u0000</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">(byte)0</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">(short)0</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0</td>
</tr>
</tbody></table>
<p>​        这些默认值仅在Java值初始化类的时候才会被赋予。这种方式确保了基本类型的字段始终能被初始化，从而减少bug的来源。但是，这些初始值对于程序来说并不一定是合法或者正确的。所以，为了安全，我们最好始终显示地初始化变量。</p>
<p>​        这种默认值的赋予并不适合用于局部变量——那些不属于类的字段的变量。因此，若在方法中定义的基本类型数据，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure>

<p>​        这里的变量x不会自动初始化为0，因而在使用变量x之前，程序员有责任主动地为其赋值。如果我们忘记了这一步，Java将会提示我们“编译时错误，该变量可能尚未被初始化”。这一点做的比C++更好，在后者中，编译器只是提示警告，而在Java中则直接报错。</p>
<h3 id="方法使用"><a href="#方法使用" class="headerlink" title="方法使用"></a>方法使用</h3><p>​        在Java中，我们使用方法(method)来表示“做某事的方式”。在Java中，方法决定对象能接受哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[返回类型][方法名](<span class="comment">/*参数列表*/</span>)&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><p>​        方法的返回类型表名了当你调用它时会返回的结果类型。参数列表则显示了可被传递到方法内部的参数类型及名称。方法名称和参数列表统称为<strong>方法签名</strong>(signature of the method)。签名作为方法的唯一标识。</p>
<p>​        Java中的方法只能作为类的一部分创建。它只能被对象所调用，并且该对象必须有权限来执行调用。若对象调用错误的方法，则程序将在编译器报错。</p>
<p>​        我们可以像下面这样调用一个对象的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[对象引用].[方法名](参数<span class="number">1</span>, 参数<span class="number">2</span>, 参数<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>​        若方法不带参数，例如一个对象引用a的方法f不带参数并返回int型结果，我们可以如下表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = a.f();</span><br></pre></td></tr></table></figure>

<p>​        上面的方法f的返回值类型必须和变量x的类型兼容。调用方法的行为有时被称为向对象发送消息。面向对象编程可以总结为：向对象发送消息。</p>
<h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><p>​        方法参数列表指定了传递给方法的信息。参数列表必须指定每个对象的类型和名称。同样，我们并没有直接处理对象，而是在传递对象引用。但是引用的类型必须是正确的。如果方法需要String参数，则必须传入String，否则编译器将会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">storage</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.length() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        此方法计算并返回某个字符串所占的字节数。参数s的类型为String。将s传递给storage()后，我们可以把它看作和任何其他对象一样，可以向它发送消息。在这里，我们调用length()方法，它是一个String方法，返回字符串中的字符数。字符串中每个字符的大小为16位或2个字节。你还看到了<strong>return</strong>关键字，它执行两项操作。首先，它意味着“方法执行结束”。其次，如果方法有返回值，那么该值就紧跟return语句之后。这里，返回值是通过计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s.length() * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>产生的。在方法中，我们可以返回任何类型的数据。如果我们不想方法返回数据，则可以通过给方法标识void来表明这是一个无需返回值的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">flag</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">naturalLogBase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2.718</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nothing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nothing2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        当返回类型为void时，return关键字仅用于退出方法，因此在方法结束处的return可以被省略。我们可以随时从方法中返回，但方法返沪类型为非void，则编译器会强制我们返回相应类型的值。</p>
<h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><h3 id="命名可见性"><a href="#命名可见性" class="headerlink" title="命名可见性"></a>命名可见性</h3><p>​        命名控制在任何一门编程语言中都是一个问题。如果你在两个模块中使用相同的命名，那么如何区分这两个名称，并防止两个名称发生“冲突”呢？</p>
<p>​        Java采取了一种新的方法避免了以上的这些问题：为一个类库生成一个明确的名称，Java创建者希望我们反向使用自己的网络域名，因为域名通常是唯一的。例如：将foibles类库命名为com.mindviewinc.utility.foibles。反转域名后，.用来代表子目录的划分。</p>
<p>​        在Java1.0和Java1.1中，扩展域名com、edu、org和net等按照惯例大写，因此类库中会出现这样类似的名称：Com.mindviewinc.utility.foibles。然而，在Java2的开发过程中，他们发现这会导致问题，所以现在整个包名都是小写的。此机制意味着所有文件都自动保存于自己的命名空间中，文件中的每个类都具有唯一标识符。这样，Java语言可以防止名称冲突。</p>
<h3 id="使用其他组件"><a href="#使用其他组件" class="headerlink" title="使用其他组件"></a>使用其他组件</h3><p>​        无论如何在程序中使用预先定义好的类，编译器都必须找到该类。最简单的情况下，该类位于被调用的源代码文件中。此时我们使用该类——即使该类在文件的后面才会被定义(Java消除了所谓的“向前引用”问题)。而如果一个类位于其他文件中，又会怎么样？你可能认为编译器足够只能去找到它，但这样是有问题的。想象一下，假如你要使用某个类，但目录中存在多个同名的类。或者更糟糕的是，假设你正在编写的程序，在构建过程中，你想要将某个新类添加到类库中，但却与已有的类名称冲突。</p>
<p>​        要解决此问题，你必须通过使用<strong>import</strong>关键字来告诉Java编译器具体要使用的类。import指示编译器导入一个包，也就是一个类库。大多时候，我们都在使用Java标准库中的组件。有了这些构件，你就不必写一长串的反转域名。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure>

<p>​        上例可以告诉编译器使用位于标准库util下的ArrayList类。但是，util中包含许多类，我们可以使用通配符*来导入其中部分类，而无需显示得逐一声明这些类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure>

<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>​        类是对象的外观及行为方式的描述。通常只有在使用new创建那个类的对象后，数据空间才会被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的：</p>
<ul>
<li>有时你只想为特定字段分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。</li>
<li>创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。</li>
</ul>
<p>​        <strong>static</strong>关键字就符合上述两点要求。当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例。即使我们从未创建过该类的对象，也可以调用其静态方法或访问其静态字段。相反，对于普通的非静态字段和方法，我们必须先要创建一个对象并使用该对象来访问字段或方法，因为非静态字段和方法必须与特定对象关联。</p>
<p>​        我们可以在类的字段或方法前添加static关键字来表示这是一个静态字段或静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        现在，即使你创建了两个StaticTest对象，但静态变量i仍只占一份存储空间。两个对象会共享相同的变量i。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StatucTest st1 = <span class="keyword">new</span> StatucTest();</span><br><span class="line">StatucTest st2 = <span class="keyword">new</span> StatucTest();</span><br></pre></td></tr></table></figure>

<p>​        st1.i和st2.i指向同一块存储空间，因此它们的值都是47。引用静态变量有两种方法。我们可以通过一个对象来定位它。我们也可以通过类名直接引用她，这种方式对于非静态成员不可行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StatucTest.i++;</span><br></pre></td></tr></table></figure>

<p>​        ++运算符将变量结果+1.此时，st1.i和st2.i的值都变成了48。</p>
<p>​        使用类名直接引用静态变量是首选方法，因为它强调了变量的静态属性。类似的逻辑也适用于静态方法。我们可以通过对象引用静态方法，就像使用任何方法一样，也可以通过特殊的语法方式Classname.method()来直接调用静态字段或方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Incrementable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StaticTest.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上例中，Incrementable的increment()通过++运算符将静态数据i加1。我们依然可以先实例化对象再调用该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Incrementable sf = <span class="keyword">new</span> Incrementable();</span><br><span class="line">sf.increment();</span><br></pre></td></tr></table></figure>

<p>​        当然了，首选的方法是直接通过类来调用它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Incrementable.increment();</span><br></pre></td></tr></table></figure>

<p>​        相比非静态的对象，static属性改变了数据创建的方式。同样，当static关键字修饰方法时，它允许我们无需创建对象就可以直接通过类的引用来调用该方法。正如我们所知的，static关键字的这些特性对于应用程序入口点的main()方法尤为重要。</p>
<h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>​        我们来编写一个完整的程序。我们使用Java标准库中Date类来展示一个字符串和日期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, it&#x27;s: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果你想在代码中使用一些额外的类库，那么就必须在程序文件的开始处使用import关键字来导入它们。之所以说是额外的，因为有一些类库已经默认自动导入到了每个文件里了。例如：java.lang包。</p>
<p>​        在Java.lang中在System类中有几个字段，如果选择了out，你会发现它是一个静态的PrintStream对象。所以，即使我们不使用new创建，out对象就已经存在并可以使用了out对象可以执行操作取决于它的类型：PrintStream。现在我们重点说的是println()这个方法，它的作用是“将信息输出到控制台，并以换行符结束”。既然如此，我们可以这样编码来输出信息到控制台。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;A String of things&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​        每个Java源文件中允许有多个类。同时，源文件的名称必须要和其中一个类名相同，否则编译器会报错。每个独立的程序应该包含一个main()方法作为程序运行的入口。其方法签名和返回类型如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        关键字public表示方法可以被外界访问到。main()方法的参数是一个字符串(String)数组。参数args并没有在当前的程序中使用到，但是Java编译器强制要求必须要有，这是因为它们被用于接收从命令行输入的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>

<p>​        上面的示例中，我们创建了一个日期(Date)类型的对象并将其转化为字符串类型，输出到控制台中。一旦这一行语句执行完毕，我们就不需要该如期对象了。这是，Java垃圾回收器就可以将其占用的内存空间回收，我们无需去主动清除它们。</p>
<h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p>​        要编译和运行代码，首先必须具有Java编程环境。</p>
<p>​        移动到子目录objects下并键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac HelloDate.java</span><br></pre></td></tr></table></figure>

<p>​        此命令不应产生任何响应。如果我们收到任何类型的错误消息，则表示未正确安装JDK，那就得检查这些问题。若此行不报错的话，此时可以键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java HelloDate</span><br></pre></td></tr></table></figure>

<p>​        我们将会得到正确的日期输出。</p>
<h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><p>​        Java编程语言编码规范(Code Conventions for the Java Programing Language)要求类名的首字母大写。如果类名是由多个单词构成的，则每个单词的首字母都应该大写(不采用下划线来分隔)例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllTheColorsOfTheRainbow</span></span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这种命名风格叫“驼峰命名法”。对于几乎所有其他方法，字段和对象引用名都采用驼峰命名的方式，但是它们的首字母不需要大写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllTheColorsOfTheRainbow</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> anIntegerRepresentingColors;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeTheHueOfTheColor</span><span class="params">(<span class="keyword">int</span> newHue)</span></span>&#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>《On Java 8》</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《On Java 8》--第五章 控制流</title>
    <url>/2021/04/23/%E9%98%85%E8%AF%BB%E3%80%8AOn-Java-8%E3%80%8B-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在Java中，涉及的关键字包括if-else、while、do-while、for、return、break和选择语句switch。Java并不支持备受诟病的goto。尽管如此，在Java中我们仍然可以进行类似的逻辑跳转，但较之经典的goto用法限制更多。</p>
 <span id="more"></span> 

<h2 id="true和false"><a href="#true和false" class="headerlink" title="true和false"></a>true和false</h2><p>​        所有的条件语句都利用条件表达式的“真”或“假”来决定执行路径。例如：a==b。它利用了条件表达式来比较a和b的值是否相等。该表达式返回true和false：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/TrueFalse.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrueFalse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span> == <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="number">1</span> == <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false </span></span><br></pre></td></tr></table></figure>

<p>​        注意：在Java中使用数值作为布尔值是非法的。如果想在布尔测试中使用一个非布尔值，那么首先需要使用条件表达式来产生boolean类型的结果，例如：if(a != 0)</p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><p>​        if-else语句是控制程序执行流程最基本的形式。其中else是可选的，因为可以有两种形式的if：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Boolean-expression) </span><br><span class="line">    “statement” </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Boolean-expression) </span><br><span class="line">    “statement”</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  “statement”</span><br></pre></td></tr></table></figure>

<p>​        布尔表达式(boolean-expression)必须生成boolean类型的结果，执行语句statement既可以是分号;结尾的一条简单语句，也可以是包含在大括号{}内的复合语句——封闭在大括号内的一组简单语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/IfElse.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfElse</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> testval, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(testval &gt; target)</span><br><span class="line">      result = +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(testval &lt; target) <span class="comment">// [1]</span></span><br><span class="line">      result = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result = <span class="number">0</span>; <span class="comment">// Match</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    test(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    test(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//-1</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>​        注意：else if 并非新关键字，它仅是else后紧跟的一条if语句。</p>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><p>​        while、do-while和for用来控制循环语句(有时也称迭代语句)。只有控制循环的布尔表达式计算结果为false，循环语句才会停止。</p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>​        while循环的形式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(Boolean-expression) </span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>​        执行语句之前在每一次循环前，判断布尔表达式返回值是否为true。下列可产生随机数，直到满足特定条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/WhileTest.java</span></span><br><span class="line"><span class="comment">// 演示 while 循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">condition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = Math.random() &lt; <span class="number">0.99</span>;</span><br><span class="line">    System.out.print(result + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(condition())</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside &#x27;while&#x27;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Exited &#x27;while&#x27;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true, Inside &#x27;while&#x27;</span></span><br><span class="line"><span class="comment">//true, Inside &#x27;while&#x27;</span></span><br><span class="line"><span class="comment">//true, Inside &#x27;while&#x27;</span></span><br><span class="line"><span class="comment">//true, Inside &#x27;while&#x27;</span></span><br><span class="line"><span class="comment">//true, Inside &#x27;while&#x27;</span></span><br><span class="line"><span class="comment">//...________...________...________...________...</span></span><br><span class="line"><span class="comment">//true, Inside &#x27;while&#x27;</span></span><br><span class="line"><span class="comment">//true, Inside &#x27;while&#x27;</span></span><br><span class="line"><span class="comment">//true, Inside &#x27;while&#x27;</span></span><br><span class="line"><span class="comment">//true, Inside &#x27;while&#x27;</span></span><br><span class="line"><span class="comment">//false, Exited &#x27;while&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​        其中condition()方法使用了Math库的静态方法random()。该方法的作用是产生0和1之间(包括0，但不包括1)的一个double值。</p>
<p>​        result的值是通过比较运算符&lt;产生的boolean类型的结果。当控制台输出boolean型值得，会自动将其转换为对应的文字形式true或false。此处while条件表达式代表：“仅在condition()返回false时体制循环”。</p>
<h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><p>​        do-while的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span>(Boolean-expression);</span><br></pre></td></tr></table></figure>

<p>​        while和do-while之间的唯一区别是：即使条件表达式返回结果为false，do-while语句也至少会执行一次。在while循环体中，如布尔表达式首次返回的结果就为false，那么循环体内的语句不会被执行。实际应用这，while形式比do-while更为常用。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>​        for循环可能是最常用的迭代形式。该循环在第一次迭代之前执行初始化。随后，它会执行布尔表达式，并在每次迭代结束时，进行某种形式的步进。for循环的形式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(initialization; Boolean-expression; step)</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure>

<p>​        初始化(initialization)表达式、布尔表达式(Boolean-expression)，或者步进(step)运算，都可以为空。每次迭代之前都会判断布尔表达式的结果是否成立。一旦计算结果为false，则跳出for循环体并继续执行后面的代码。每次循环结束时，都会执行一次步进。</p>
<p>​        for循环通常用于“计数”任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/ListCharacters.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListCharacters</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; <span class="number">128</span>; c++)</span><br><span class="line">      <span class="keyword">if</span>(Character.isLowerCase(c))</span><br><span class="line">        System.out.println(<span class="string">&quot;value: &quot;</span> + (<span class="keyword">int</span>)c +</span><br><span class="line">          <span class="string">&quot; character: &quot;</span> + c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value: 97 character: a</span></span><br><span class="line"><span class="comment">//value: 98 character: b</span></span><br><span class="line"><span class="comment">//value: 99 character: c</span></span><br><span class="line"><span class="comment">//value: 100 character: d</span></span><br><span class="line"><span class="comment">//value: 101 character: e</span></span><br><span class="line"><span class="comment">//value: 102 character: f</span></span><br><span class="line"><span class="comment">//value: 103 character: g</span></span><br><span class="line"><span class="comment">//value: 104 character: h</span></span><br><span class="line"><span class="comment">//value: 105 character: i</span></span><br><span class="line"><span class="comment">//value: 106 character: j</span></span><br><span class="line"><span class="comment">//  ...</span></span><br></pre></td></tr></table></figure>

<p>​        注意：变量c是在for循环执行时才被定义的，并不是在主方法的开头。c的作用域范围仅在for循环体内。</p>
<p>​        在Java和C++中，我们可以在整个块使用变量声明，并且可以在需要时才定义变量。</p>
<p>​        上例中使用了java.lang.Character包装类，该类不仅包含了基本类型char值，还封装了一些有用的方法。例如这里就用到了静态方法isLowerCase()来判断字符是否为小写。</p>
<h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><p>​        在Java中逗号运算符仅有一种用法：在for循环的初始化和步进控制中定义多个变量。我们可以使用逗号分隔多个语句，并顺序计算这些语句。注意：要求定义的变量类型相同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/CommaOperator.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommaOperator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = i + <span class="number">10</span>; i &lt; <span class="number">5</span>; i++, j = i * <span class="number">2</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot; j = &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i = 1 j = 11</span></span><br><span class="line"><span class="comment">//i = 2 j = 4</span></span><br><span class="line"><span class="comment">//i = 3 j = 6</span></span><br><span class="line"><span class="comment">//i = 4 j = 8</span></span><br></pre></td></tr></table></figure>

<p>​        上例中int类型声明包含了i和j。实际上，在初始化部分我们可以定义任意数量的同类型变量。注意：在Java中，仅允许for循环在控制表达式中定义变量。我们不能将此方法与其他的循环语句和选择语句中一起使用。同时，我们可以看到：无论在初始化还是在步进部分，语句都是顺序执行的。</p>
<h2 id="for-in语法"><a href="#for-in语法" class="headerlink" title="for-in语法"></a>for-in语法</h2><p>​        Java5引入了更为简洁的“增强版for循环”语法来操纵数组和集合。大部分文档也称其为for-each语法。</p>
<p>​        for-in无需你创建int变量和步进来控制循环计数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/ForInFloat.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForInFloat</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      f[i] = rand.nextFloat();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> x : f)</span><br><span class="line">      System.out.println(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0.72711575</span></span><br><span class="line"><span class="comment">//0.39982635</span></span><br><span class="line"><span class="comment">//0.5309454</span></span><br><span class="line"><span class="comment">//0.0534122</span></span><br><span class="line"><span class="comment">//0.16020656</span></span><br><span class="line"><span class="comment">//0.57799757</span></span><br><span class="line"><span class="comment">//0.18847865</span></span><br><span class="line"><span class="comment">//0.4170137</span></span><br><span class="line"><span class="comment">//0.51660204</span></span><br><span class="line"><span class="comment">//0.73734957</span></span><br></pre></td></tr></table></figure>

<p>​        上例中我们展示了传统for循环的用法。接下来再来看for-in的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> x : f) &#123;</span><br></pre></td></tr></table></figure>

<p>​        这条语句定义了一个float类型的变量x，继而将每一个f的元素赋值给它。</p>
<p>​        任何一个返回数组的方法都可以使用for-in循环语法来遍历元素。例如String类有一个方法toCharArray()，返回值类型为char数组，我们很容易地在for-in循环中遍历它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/ForInString.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForInString</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c: <span class="string">&quot;An African Swallow&quot;</span>.toCharArray())</span><br><span class="line">      System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A n   A f r i c a n   S w a l l o w</span></span><br></pre></td></tr></table></figure>

<p>​        for-in循环适用于任何可迭代(iterable)的对象。</p>
<p>​        通常，for循环语句都会在一个整型数值序列中步进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br></pre></td></tr></table></figure>

<p>​        正因如此，除非先创建一个int数组，否则我们无法使用for-in循环操作。在onjava包中封装了range()方法可以自动生成恰当的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/ForInInt.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Range.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForInInt</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : range(<span class="number">10</span>)) <span class="comment">// 0..9</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : range(<span class="number">5</span>, <span class="number">10</span>)) <span class="comment">// 5..9</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : range(<span class="number">5</span>, <span class="number">20</span>, <span class="number">3</span>)) <span class="comment">// 5..20 step 3</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : range(<span class="number">20</span>, <span class="number">5</span>, -<span class="number">3</span>)) <span class="comment">// Count down</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">//5 6 7 8 9</span></span><br><span class="line"><span class="comment">//5 8 11 14 17</span></span><br><span class="line"><span class="comment">//20 17 14 11 8</span></span><br></pre></td></tr></table></figure>

<p>​        range()方法已被重载(重载：同名方法，参数列表或类型不同)。上例中range()方法有多种重载形式：第一种产生从0至范围上限(不包含)的值；第二种产生参数一至参数二(不包含)范围内的整数值；第三种形式有一个步进值，因此它每次的增量为该值；第四种range()无参方法是该生成器最简单的版本。</p>
<p>​        for-in语法可以节省我们编写代码的时间。更重要的是，它提高了代码可读性以及更好地描述代码示意图而不是详细说明这操作细节。</p>
<h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>​        在Java中有几个关键字代表无条件分支，这意味无需任何测试即可发生。这些关键字包括return，break，continue和跳转到带标签语句的方法，类似于其它语言中的goto。</p>
<p>​        <strong>return</strong>关键字有两方面的作用：1.指定一个方法的返回值(在方法返回类型非void的情况下)；2.退出当前方法，并返回作用1中值。我们可以利用return的这些特点来改写上例IfElse.java文件中的test()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/TestWithReturn.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWithReturn</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> testval, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(testval &gt; target)</span><br><span class="line">      <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(testval &lt; target)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Match</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(test(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    System.out.println(test(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">    System.out.println(test(<span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//-1</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>​        这里不需要else，因为该方法执行到return就结束了。</p>
<p>​        如果在方法签名中定义了返回值类型为void，那么在代码执行结束时会有一个隐式的return。也就是说我们不用在总是在方法中显示地包含return语句。注意：如果你的方法声明的返回值类型为非void类型，那么则必须确保每个代码路径都返回一个值。</p>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>​        在任何迭代语句的主体内，都可以使用break和continue来控制循环的流程。其中break表示跳出当前循环体。而continue表示停止本次循环，开始下一次循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/BreakAndContinue.java</span></span><br><span class="line"><span class="comment">// Break 和 continue 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> onjava.Range.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakAndContinue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; <span class="comment">// [1]</span></span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">74</span>) <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">      <span class="keyword">if</span>(i % <span class="number">9</span> != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 下一次循环</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// 使用 for-in 循环:</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : range(<span class="number">100</span>)) &#123; <span class="comment">// [2]</span></span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">74</span>) <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">      <span class="keyword">if</span>(i % <span class="number">9</span> != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 下一次循环</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  &quot;无限循环&quot;:</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; <span class="comment">// [3]</span></span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">int</span> j = i * <span class="number">27</span>;</span><br><span class="line">      <span class="keyword">if</span>(j == <span class="number">1269</span>) <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">      <span class="keyword">if</span>(i % <span class="number">10</span> != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 循环顶部</span></span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0 9 18 27 36 45 54 63 72</span></span><br><span class="line"><span class="comment">//0 9 18 27 36 45 54 63 72</span></span><br><span class="line"><span class="comment">//10 20 30 40</span></span><br></pre></td></tr></table></figure>

<p>​        在第一个输出中，这个for循环中，i的值永远不会达到100，因为一旦i等于74，break语句就会中断循环。通常，只有在不知道中断条件何时满足时，才需要break。因为i不能被9整除，continue语句就会使循环从头开始。如果能够整除，则将值显示出来。在第二个输出中，使用for-in语法，结果相同。在第三个输出中，无限循环while循环，循环内的break语句可终止循环。注意，continue语句可将控制权移回循环的顶部，而不会执行continue之后的任何操作。因此，只有当i的值被10整除时才会输出。在输出中，显示值0，因为0%9产生0。还有一种无限循环的形式：for(;;)。它在编译器看来，与while(true)无异，使用哪种完全取决于你的编程品味。</p>
<h2 id="臭名昭著的goto"><a href="#臭名昭著的goto" class="headerlink" title="臭名昭著的goto"></a>臭名昭著的goto</h2><p>​        goto关键字很早就在程序设计语言中出现。事实上，goto起源于汇编(assembly language)语言中的程序控制：“若条件A成立，则跳到这里；否则就跳到那里”。</p>
<p>​        尽管<strong>goto</strong>仍是Java的一个保留字，但其并未被正式启用。可以说，Java中并不支持goto。然而，在break和continue这两个关键字的身上，我们仍能看出一些goto的影子。它们并不属于一次跳转，而是中断循环语句的一种方法。之所以把它纳入goto问题中一起讨论，是由于它们使用了相同的机制：标签。</p>
<p>​        “标签”是后面跟一个冒号的标识符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label1:</span><br></pre></td></tr></table></figure>

<p>​        对Java来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方——在标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环或者一个开关。这是由于break和continue关键字通常只中断当前循环，若搭配标签一起使用，它们就会中断并跳转到标签所在的地方开始执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label1:</span><br><span class="line">outer-iteration &#123; </span><br><span class="line">  inner-iteration &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">break</span>; <span class="comment">// [1] </span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">continue</span>; <span class="comment">// [2] </span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">continue</span> label1; <span class="comment">// [3] </span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">break</span> label1; <span class="comment">// [4] </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在[1]break中断内部循环，并在外部循环结束。[2]continue移回内部循环起始处。但在条件3中，continue label1却同时中断内部循环及外部循环，并移回至label1处。[3]随后，它实际是继续循环，但却从外部循环开始。[4]break label1也会中断所有循环，并回到label1处，但并不重新进入循环。也就是说，它实际是完全中止了两个循环。</p>
<p>​        下面为for循环的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/LabeledFor.java</span></span><br><span class="line"><span class="comment">// 搭配“标签 break”的 for 循环中使用 break 和 continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LabeledFor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    outer: <span class="comment">// 此处不允许存在执行语句</span></span><br><span class="line">    <span class="keyword">for</span>(; <span class="keyword">true</span> ;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">      inner: <span class="comment">// 此处不允许存在执行语句</span></span><br><span class="line">      <span class="keyword">for</span>(; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;break&quot;</span>);</span><br><span class="line">          i++; <span class="comment">// 否则 i 永远无法获得自增 </span></span><br><span class="line">               <span class="comment">// 获得自增 </span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">7</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;continue outer&quot;</span>);</span><br><span class="line">          i++;  <span class="comment">// 否则 i 永远无法获得自增 </span></span><br><span class="line">                <span class="comment">// 获得自增 </span></span><br><span class="line">          <span class="keyword">continue</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">8</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;break outer&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(k == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;continue inner&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span> inner;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在此处无法 break 或 continue 标签</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i = 0</span></span><br><span class="line"><span class="comment">//continue inner</span></span><br><span class="line"><span class="comment">//i = 1</span></span><br><span class="line"><span class="comment">//continue inner</span></span><br><span class="line"><span class="comment">//i = 2</span></span><br><span class="line"><span class="comment">//continue</span></span><br><span class="line"><span class="comment">//i = 3</span></span><br><span class="line"><span class="comment">//break</span></span><br><span class="line"><span class="comment">//i = 4</span></span><br><span class="line"><span class="comment">//continue inner</span></span><br><span class="line"><span class="comment">//i = 5</span></span><br><span class="line"><span class="comment">//continue inner</span></span><br><span class="line"><span class="comment">//i = 6</span></span><br><span class="line"><span class="comment">//continue inner</span></span><br><span class="line"><span class="comment">//i = 7</span></span><br><span class="line"><span class="comment">//continue outer</span></span><br><span class="line"><span class="comment">//i = 8</span></span><br><span class="line"><span class="comment">//break outer</span></span><br></pre></td></tr></table></figure>

<p>​        注意break会中断for循环，而且在抵达for循环的末尾之前，递增表达式不会执行。由于break跳过了递增表达式，所以递增会在i==3的情况下直接执行。在==7的情况下，continue outer语句也会到达循环顶部，而且也会跳过递增，所以它也是直接递增的。</p>
<p>​        如果没有break outer语句，就没有办法在一个内部循环里找到出外部循环的路径。这是由于break本身只能中断最内层的循环(对于continue同样如此)。当然，若想在中断循环的同时推出方法，简单地用一个return即可。</p>
<p>​        下面的例子为带标签的break以及continue语句在while循环中的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/LabeledWhile.java</span></span><br><span class="line"><span class="comment">// 带标签的 break 和 conitue 在 while 循环中的使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LabeledWhile</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    outer:</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Outer while loop&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;continue outer&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">5</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;break&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">7</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;break outer&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Outer while loop</span></span><br><span class="line"><span class="comment">//i = 1</span></span><br><span class="line"><span class="comment">//continue</span></span><br><span class="line"><span class="comment">//i = 2</span></span><br><span class="line"><span class="comment">//i = 3</span></span><br><span class="line"><span class="comment">//continue outer</span></span><br><span class="line"><span class="comment">//Outer while loop</span></span><br><span class="line"><span class="comment">//i = 4</span></span><br><span class="line"><span class="comment">//i = 5</span></span><br><span class="line"><span class="comment">//break</span></span><br><span class="line"><span class="comment">//Outer while loop</span></span><br><span class="line"><span class="comment">//i = 6</span></span><br><span class="line"><span class="comment">//i = 7</span></span><br><span class="line"><span class="comment">//break outer</span></span><br></pre></td></tr></table></figure>

<p>​        同样的规则亦适用于while：</p>
<ul>
<li>简单一个cotinue会退回最内层循环的开始(顶部)，并继续执行。</li>
<li>带有标签的cotinue会到达标签的位置，并重新进入紧接在那个标签后面的循环。</li>
<li>break会中断当前循环，并移离当前标签的末尾。</li>
<li>带标签的break会中断当前循环，并移离由那个标签指示的循环的末尾。</li>
</ul>
<p>大家要记住的重点是：在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。</p>
<p>​        break和continue标签在编码中的使用频率相对较低。</p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>​        switch有时也被规划为一种选择语句。根据整数表达式的值，switch语句可以从一系列代码中选择出一段去执行，它的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integral-selector) &#123;</span><br><span class="line">    <span class="keyword">case</span> integral-value1 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value2 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value3 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value4 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value5 : statement;    <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>: statement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        其中intergral-selector(整数选择因子)是一个能够产生整数值的表达式，switch能够将这个表达式的结果与每个integral-value(整数值)相比较。若发现相符的，就执行对应的语句(简单或复合语句，其中并不需要括号)。若没有发现相符的，就执行default语句。</p>
<p>​        在上面的定义中，大家会注意到每个case均以一个break结尾。这样可使执行流程转至switch主体的末尾。这是构建switch语句的一种传统方式，但break是可选的。若省略break，会继续执行后面的case语句的代码，直到遇到一个break为止。通常我们不想出现这种情况，但对于有经验的程序员来说，也许能够善加利用。注意最后的default语句没有break，因为执行流程已到了break的跳转目的地。当然，如果考虑编程风格方法的原因，完全可以在default语句的末尾放置一个break，尽管它并没有任何实际的作用。</p>
<p>​        switch语句是一种实现对路选择的干净利落的一种方式(比如从一些列执行路径中挑选一个)。但它要求使用一个选择因子，并且必须是int或char那样的整数值。例如，假若将一个字串或浮点数作为选择因子使用，那么它们在switch语句里是不会工作的。对于非整数类型(Java7以上版本中的String型除外)，则必须使用一些列if语句。</p>
<p>​        下面这个例子可随机生成字母，并判断它们是元音还是辅音字母：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/VowelsAndConsonants.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// switch 执行语句的演示</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VowelsAndConsonants</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = rand.nextInt(<span class="number">26</span>) + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>)c + <span class="string">&quot;, &quot;</span> + c + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">      <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>: System.out.println(<span class="string">&quot;vowel&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>: System.out.println(<span class="string">&quot;Sometimes vowel&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:  System.out.println(<span class="string">&quot;consonant&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//y, 121: Sometimes vowel</span></span><br><span class="line"><span class="comment">//n, 110: consonant</span></span><br><span class="line"><span class="comment">//z, 122: consonant</span></span><br><span class="line"><span class="comment">//b, 98: consonant</span></span><br><span class="line"><span class="comment">//r, 114: consonant</span></span><br><span class="line"><span class="comment">//n, 110: consonant</span></span><br><span class="line"><span class="comment">//y, 121: Sometimes vowel</span></span><br><span class="line"><span class="comment">//g, 103: consonant</span></span><br><span class="line"><span class="comment">//c, 99: consonant</span></span><br><span class="line"><span class="comment">//f, 102: consonant</span></span><br><span class="line"><span class="comment">//o, 111: vowel</span></span><br><span class="line"><span class="comment">//w, 119: Sometimes vowel</span></span><br><span class="line"><span class="comment">//z, 122: consonant</span></span><br><span class="line"><span class="comment">//  ...</span></span><br></pre></td></tr></table></figure>

<p>​        由于Random.nextInt(26)会产生0到25之间的一个值，所以在其上加上一个偏移量a，即可产生小写字母。在case语句中，使用单引号引起的字符也会产生用于比较的整数值。</p>
<p>​        请注意case语句能够堆叠在一起，为一段代码形成多重匹配，即只要符合多种条件的一种，就执行那段特别的代码。这时也应该注意将break语句置于特定的case末尾，否则控制流程会继续往下执行，处理后面的case：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = rand.nextInt(<span class="number">26</span>) + <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>​        此处Random.nextInt()将产生0~25之间的一个随机int值，它将被加到a上。这表示a将自动被转型为int以执行加法。为了把c当作字符da’yin，必须将其转型为char；否则，将会输出整数。</p>
<h2 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h2><p>​        Java7增加了在字符串上switch的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/StringSwitch.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSwitch</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="comment">// 老的方式: 使用 if-then 判断</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;red&quot;</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;RED&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;green&quot;</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;GREEN&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;blue&quot;</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;BLUE&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;yellow&quot;</span>.equals(color)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;YELLOW&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的方法: 字符串搭配 switch</span></span><br><span class="line">    <span class="keyword">switch</span>(color) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;RED&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;green&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;GREEN&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;blue&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;BLUE&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;yellow&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;YELLOW&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RED</span></span><br><span class="line"><span class="comment">//RED</span></span><br></pre></td></tr></table></figure>

<p>​        一旦理解了switch，你会明白这其实就是一个逻辑扩展的<strong>语法糖</strong>。新的编码方式能使得结果更清晰，更易于理解和维护。</p>
<p>​        作为switch字符串的第二个例子，我们重新访问Math.random()。它是否产生从0到1的值，包括还是不包括1呢？在数学术语中，它属于(0,1)、[0,1)、(0,1]、[0,1]中的哪种呢？</p>
<p>​        下面是一个可能提供答案的测试程序。所有命令行参数都作为String对象传递，因此我们可以switch参数来决定要做什么。那么问题来了：如果用户不提供参数，索引到args的数组就会导致程序失败。解决这个问题，我们需要预先检查数组的长度，若长度为0，则使用空字符串“”代替；否则，选择args数组中的第一个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control/RandomBounds.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.random() 会产生 0.0 和 1.0 吗？</span></span><br><span class="line"><span class="comment">// &#123;java RandomBounds lower&#125;</span></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomBounds</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> TimedAbort(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">switch</span>(args.length == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : args[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;lower&quot;</span>:</span><br><span class="line">        <span class="keyword">while</span>(Math.random() != <span class="number">0.0</span>)</span><br><span class="line">          ; <span class="comment">// 保持重试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Produced 0.0!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;upper&quot;</span>:</span><br><span class="line">        <span class="keyword">while</span>(Math.random() != <span class="number">1.0</span>)</span><br><span class="line">          ; <span class="comment">// 保持重试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Produced 1.0!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Usage:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\tRandomBounds lower&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\tRandomBounds upper&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">java RandomBounds lower </span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">java RandomBounds upper</span><br></pre></td></tr></table></figure>

<p>​        使用onjava包下的TimedAbort类可使程序在三秒后中止。从结果来看，似乎Math.random()产生的随机值里不包含0.0或1.0。这就是该测试容易混淆的地方：若要考虑0至1之间有所不同double数值的可能性，那么这个测试的耗费的时间可能超出了一个人的寿命。这里直接给出正确的结果：Math.random()的结果范围包含0.0，不包含1.0。在数学术语中，可用[0,1)来表示。由此可知，我们必须小心分析实验并了解它们的局限性。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>《On Java 8》</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《On Java 8》-- 第十章 接口</title>
    <url>/2021/05/12/%E9%98%85%E8%AF%BB%E3%80%8AOn-Java-8%E3%80%8B-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>​        接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。</p>
<p>​        这种机制在编程语言中不常见，例如C++只对这种概念有间接的支持。而在Java中存在这些关键字，说明这些思想很重要，Java为它们提供了直接支持。</p>
<p>​        首先，我们将学习抽象类，一种介于普通类和接口之间的折衷手段。尽管你的第一想法是创建接口，但是对于构建具有属性和未实现方法的类来说，抽象类也是重要且必要的工具。你不可能总是使用纯粹的接口。</p>
 <span id="more"></span> 

<h2 id="抽象类和方法"><a href="#抽象类和方法" class="headerlink" title="抽象类和方法"></a>抽象类和方法</h2><p>​        在上一章的乐器例子中，基类Instrument中的方法往往是“哑”方法。如果调用了这些方法，就会出现一些错误。这是因为接口的目的是为了它的派生类创建一个通用接口。</p>
<p>​        在那些例子中，创建这个通用接口的唯一理由是，不同的子类可以用不同的方式表示此接口。通用接口建立了一个基本形式，以此表达所有派生类的共同部分。另一种说法把Instrument称为抽象基类，或简称抽象类。</p>
<p>​        对于Instrument那样的抽象类来说，它的对象几乎总是没有意义的。创建一个抽象类是为了通过通用接口操纵一系列类。因此，Instrument只是表示接口，不是具体实现，所以创建一个Instrument的对象毫无意义，我们可能希望阻止用户这么做。通过让Instrument所有的方法产生错误，就可以达到这个目的，但是这么做会延迟到运行时才能得知错误信息，并且需要用户进行可靠、详尽的测试。最好能在编译时捕捉问题。</p>
<p>​        Java提供了一种叫做抽象方法的机制，这个方法是不完整的：它只有声明没有方法体。下面是抽象方法的声明语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>​        包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，那么类本身也必须限定为抽象的，否则，编译器会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interface/Basic.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unimplemented</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果一个抽象类不是完整的，当试图创建这个类的对象时，Java会怎么做呢？它不会创建抽象类的对象，所以我们只会得到编译器的错误信息。这样保证了抽象类的纯粹性，我们不用担心误用它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/AttemptToUseBasic.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttemptToUseBasic</span> </span>&#123;</span><br><span class="line">    Basic b = <span class="keyword">new</span> Basic();</span><br><span class="line">    <span class="comment">// error: Basic is abstract; cannot be instantiated</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果创建一个继承抽象类的新类并为之创建对象，那么就必须为基类的所有抽象方法提供方法定义。如果不这么做(可以选择不做)，新类仍然是一个抽象类，编译器会强制我们为新类加上abstract关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/Basic2.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic2</span> <span class="keyword">extends</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// unimplemented() still not implemented</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以将一个不包含任何抽象方法的类指明为abstract，在类中的抽象方法没什么意义但想阻止创建类的对象时，这么做就很有用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/AbstractWithoutAbstracts.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// No abstract methods</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractWithoutAbstracts</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Basic3 b3 = new Basic3();</span></span><br><span class="line">    <span class="comment">// error: Basic3 is abstract; cannot be instantiated</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        为了创建可初始化的类，就要继承抽象类，并提供所有抽象方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/Instantiable.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Uninstantiable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instantiable</span> <span class="keyword">extends</span> <span class="title">Uninstantiable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Uninstantiable ui = <span class="keyword">new</span> Instantiable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        留意@Override的使用。没有这个注解的话，如果你没有定义相同的方法名或签名，抽象机制会认为你没有实现抽象方法从而产生编译错误。因此，你可能认为这里的@Override是多余的。但是，@Override还提示了这个方法被覆盖——我认为这是有用的，所以我会使用@Override，不仅仅是因为当没有这个注解时，编译器会告诉我出错。</p>
<p>​        记住，事实上的访问权限是“friendly”。你很快会看到接口自动将其方法指明为public。事实上，接口只允许public方法，如果不加访问修饰符的话，接口的方法不是friendly而是public。然而，抽象类允许每件事：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/AbstractAccess.java</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// private abstract void m1a(); // illegal</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m2a</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m3a</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m4a</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        private abstract被禁止了是有意义的，因为你不可能在AbstractAccess的任何子类中合法地定义它。</p>
<p>​        上一章的Instrument类可以很轻易地转换为一个抽象类。只需要部分方法是abstract即可。将一个类指明为abstract并不强制类中的所有方法必须都是抽象方法。</p>
<p>​        下面为修改成使用抽象类和抽象方法的管弦乐器的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/music4/Music4.java</span></span><br><span class="line"><span class="comment">// Abstract classes and methods</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.music4.Music4&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.music4;</span><br><span class="line"><span class="keyword">import</span> polymorphism.music.Note;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i; <span class="comment">// Storage allocated for each</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Instrument&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wind.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Wind&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Percussion.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Percussion&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Percussion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stringed.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Stringed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Stringed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Brass.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Brass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woodwind</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woodwind.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woodwind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music4</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Doesn&#x27;t care about type, so new types</span></span><br><span class="line">    <span class="comment">// added to system still work right:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument i: e) &#123;</span><br><span class="line">            tune(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Upcasting during addition to the array:</span></span><br><span class="line">        Instrument[] orchestra = &#123;</span><br><span class="line">            <span class="keyword">new</span> Wind(),</span><br><span class="line">            <span class="keyword">new</span> Percussion(),</span><br><span class="line">            <span class="keyword">new</span> Stringed(),</span><br><span class="line">            <span class="keyword">new</span> Brass(),</span><br><span class="line">            <span class="keyword">new</span> Woodwind()</span><br><span class="line">        &#125;;</span><br><span class="line">        tuneAll(orchestra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Wind.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Percussion.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Stringed.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Brass.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Woodwind.play() MIDDLE_C</span></span><br></pre></td></tr></table></figure>

<p>​        除了Instrument，基本没区别。</p>
<p>​        创建抽象类和抽象方法是有帮助的，因为它们使得类的抽象类很明确，并能告知用户和编译器使用意图。抽象类同时也是一种有用的重构工具，使用它们使得我们很容易地将沿着继承层级结构上移公共方法。</p>
<h2 id="接口创建"><a href="#接口创建" class="headerlink" title="接口创建"></a>接口创建</h2><p>​        使用interface关键字创建接口。interface和class一样随处可见，除非特指关键字interface，其他情况下都采用正常字体书写interface。</p>
<p>​        描述Java8之前的接口更加容易，因为它们只允许抽象方法。像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/PureInterface.java</span></span><br><span class="line"><span class="comment">// Interface only looked like this before Java 8</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PureInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">m1</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们甚至不用为方法加上abstract关键字，因为方法在接口中。Java知道这些方法不能有方法体(仍然可以为方法加上abstract关键字，但是看起来像是不明白接口，徒增难堪罢了)。</p>
<p>​        因此，在Java8之前我们可以这么说：interface关键字产生一个完全抽象的类，没有提供任何实现。我们只能描述类应该像什么，做什么，但不能描述怎么做，即只能决定方法名、参数列表和返回类型，但是无法确定方法体。接口只提供形式，通常来说没有实现，尽管在某些受限制的情况下可以有实现。</p>
<p>​        一个接口表示：所有实现了该接口的类看起来都像这样。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。所以，接口被用来建立类之间的协议。</p>
<p>​        Java8中接口稍微有些变化，因为Java8允许接口包含默认方法和静态方法——基于某些重要原因。接口的基本概念仍然没有变，介于类型之上、实现之下。接口与抽象类最明显的区别可能就是使用上的管用方式。接口的典型使用是代表一个类的类型或一个形容词，如Runnable或Serializable，而抽象类通常是类层次结构的一部分或一件事物的类型，如String或ActionHero。</p>
<p>​        使用关键字interface而不是class来创建接口。和类一样，需要在关键字interface前加上public关键字，否则接口只有包访问权限，只能在接口相同的包下才能使用它。</p>
<p>​        接口同样可以包含属性，这些属性被隐式指明为static和final。</p>
<p>​        使用implements关键字使一个类遵循某个特定接口，它表示：接口只是外形，现在我要说明它是如何工作的。除此之外，它看起来像继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/ImplementingAnInterface.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Concept</span> </span>&#123; <span class="comment">// Package access</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">idea1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">idea2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation</span> <span class="keyword">implements</span> <span class="title">Concept</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">idea1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;idea1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">idea2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;idea2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        你可以选择显式地声明接口中的方法为public，但是即使你不这么做，它们也是public的。所以当实现一个接口，来自接口中的方法必须被定义为public。否则，它们只有包访问权限，这样在继承时，它们的可访问权限就被降低了，这是Java编译器所不允许的。</p>
<h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>​        Java8为关键字default增加了一个新的用途。当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用default创建的方法体。默认方法比抽象类中的方法受到更多的限制，但是非常有用，我们将在“流式编程”一章中看到。现在让我们看下如何使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/AnInterface.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AnInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们可以像这样实现接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/AnImplementation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnImplementation</span> <span class="keyword">implements</span> <span class="title">AnInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;firstMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;secondMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnInterface i = <span class="keyword">new</span> AnImplementation();</span><br><span class="line">        i.firstMethod();</span><br><span class="line">        i.secondMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//firstMethod</span></span><br><span class="line"><span class="comment">//secondMethod</span></span><br></pre></td></tr></table></figure>

<p>​        如果我们在AnInterface中增加了一个新方法newMethod()，而在Anlmplementation中没有实现它，编译器就会报错：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">AnImplementation.java:3:error: AnImplementation is not abstract and does not override abstract method newMethod() in AnInterface</span><br><span class="line">public class AnImplementation implements AnInterface &#123;</span><br><span class="line"><span class="built_in">^</span></span><br><span class="line">1 error</span><br></pre></td></tr></table></figure>

<p>​        如果我们使用关键字default()为newMethod()方法提供默认的实现，那么所有与接口有关的代码能正常工作，不受影响，而且这些代码还可以调用新的方法newMethod()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/InterfaceWithDefault.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceWithDefault</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">newMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;newMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        关键字default允许在接口中提供方法实现——在Java8之前被禁止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/Implementation2.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Implementation2</span> <span class="keyword">implements</span> <span class="title">InterfaceWithDefault</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;firstMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">secondMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;secondMethod&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InterfaceWithDefault i = <span class="keyword">new</span> Implementation2();</span><br><span class="line">        i.firstMethod();</span><br><span class="line">        i.secondMethod();</span><br><span class="line">        i.newMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//firstMethod</span></span><br><span class="line"><span class="comment">//secondMethod</span></span><br><span class="line"><span class="comment">//newMethod</span></span><br></pre></td></tr></table></figure>

<p>​        尽管Implementation2中未定义newMethod()，但是可以使用newMethod()了。</p>
<p>​        增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下，在接口中增加新的方法。默认方法有时也称为守卫方法或虚拟扩展方法。</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>​        多继承意味着一个类可能从多个父类中继承特征和特性。</p>
<p>​        Java在设计之初，C++的多继承机制饱受诟病。Java过去是一种严格要求单继承的语言：只能继承自一个类(或抽象类)，但可以实现任意多个接口。在Java8之前，接口没有包袱——它只是方法外貌的描述。</p>
<p>​        多年后的现在，Java通过默认方法具有了某种多继承的特性。结合带有默认方法的接口意味着结合了多个基类中的行为。因为接口中仍然不允许存在属性(只有静态属性，不适用)，所以属性仍然只会来自单个基类或抽象类，也就是说，不会存在状态的多继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/MultipleInheritance.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Three</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> <span class="keyword">implements</span> <span class="title">One</span>, <span class="title">Two</span>, <span class="title">Three</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleInheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MI mi = <span class="keyword">new</span> MI();</span><br><span class="line">        mi.first();</span><br><span class="line">        mi.second();</span><br><span class="line">        mi.third();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//first</span></span><br><span class="line"><span class="comment">//second</span></span><br><span class="line"><span class="comment">//third</span></span><br></pre></td></tr></table></figure>

<p>​        现在我们做些在Java8之前不可能完成的事：结合多个源的实现。只要基类方法中的方法名和参数列表不同，就能工作得很好，否则会得到编译器错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interface/MICollision.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bob1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bob1::bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bob2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">bob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bob2::bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Bob implements Bob1, Bob2 &#123;&#125;</span></span><br><span class="line"><span class="comment">/* Produces:</span></span><br><span class="line"><span class="comment">error: class Bob inherits unrelated defaults</span></span><br><span class="line"><span class="comment">for bob() from types Bob1 and Bob2</span></span><br><span class="line"><span class="comment">class Bob implements Bob1, Bob2 &#123;&#125;</span></span><br><span class="line"><span class="comment">^</span></span><br><span class="line"><span class="comment">1 error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sam1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sam1::sam&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sam2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sam</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This works because the argument lists are distinct:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sam</span> <span class="keyword">implements</span> <span class="title">Sam1</span>, <span class="title">Sam2</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Max1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Max1::max&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Max2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Max implements Max1, Max2 &#123;&#125;</span></span><br><span class="line"><span class="comment">/* Produces:</span></span><br><span class="line"><span class="comment">error: types Max2 and Max1 are imcompatible;</span></span><br><span class="line"><span class="comment">both define max(), but with unrelated return types</span></span><br><span class="line"><span class="comment">class Max implements Max1, Max2 &#123;&#125;</span></span><br><span class="line"><span class="comment">^</span></span><br><span class="line"><span class="comment">1 error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        Sam类中两个sam()方法有相同的方法名但是签名不同——方法签名包括方法名和参数类型，编译器也是用它来区分方法。但是从Max类可看出，返回类型不是方法签名的一部分，因此不能用来区分方法。为了解决这个问题，需要覆写冲突的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/Jim.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Jim1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">jim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Jim1::jim&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Jim2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">jim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Jim2::jim&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jim</span> <span class="keyword">implements</span> <span class="title">Jim1</span>, <span class="title">Jim2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jim2.<span class="keyword">super</span>.jim();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Jim().jim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Jim2::jim</span></span><br></pre></td></tr></table></figure>

<p>​        当然，你可以重新定义jim()方法，但是也能像上例中那样使用super关键字选择基类实现中的一种。</p>
<h3 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h3><p>​        Java8允许在接口中添加静态方法。这么做能恰当地把工具功能置于接口中，从而操作接口，或者成为通用的工具：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// onjava/Operations.java</span></span><br><span class="line"><span class="keyword">package</span> onjava;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runOps</span><span class="params">(Operations... ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Operations op: ops) &#123;</span><br><span class="line">            op.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这是模板方法设计模式的一个版本，runOps()是一个模板方法。runOps()使用可变参数列表，因而我们可以传入任意多的Operations参数并按顺序运行它们：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interface/Machine.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> onjava.Operations;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bing</span> <span class="keyword">implements</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Operations.show(<span class="string">&quot;Bing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crack</span> <span class="keyword">implements</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Operations.show(<span class="string">&quot;Crack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twist</span> <span class="keyword">implements</span> <span class="title">Operations</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Operations.show(<span class="string">&quot;Twist&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Machine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Operations.runOps(</span><br><span class="line">            <span class="keyword">new</span> Bing(), <span class="keyword">new</span> Crack(), <span class="keyword">new</span> Twist());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Bing</span></span><br><span class="line"><span class="comment">//Crack</span></span><br><span class="line"><span class="comment">//Twist</span></span><br></pre></td></tr></table></figure>

<p>​        这里展示了创建Operations的不同方式：一个外部类(Bing)，一个匿名类，一个方法引用和lambda表达式——毫无疑问在这里是最好的解决方法。</p>
<p>​        这个特性是一项改善，因为它允许把静态方法放在更适合的地方。</p>
<h3 id="Instrument作为接口"><a href="#Instrument作为接口" class="headerlink" title="Instrument作为接口"></a>Instrument作为接口</h3><p>​        回顾下乐器的例子，使用接口的话：</p>
<p>​        类Woodwind和Brass说明了一旦实现了某个接口，那么其实现就变成了一个普通类，可以按常规方式扩展它。</p>
<p>​        接口的工作方式使得我们不需要显式声明其中的方法为public，它们自动就是public的。play()和adjust()使用default关键字定义实现。在Java8之前，这些定义要在每个实现中重复实现，显得多余且令人烦恼。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/music5/Music5.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.music5.Music5&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.music5;</span><br><span class="line"><span class="keyword">import</span> polymorphism.music.Note;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compile-time constant:</span></span><br><span class="line">    <span class="keyword">int</span> VALUE = <span class="number">5</span>; <span class="comment">// static &amp; final</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span>  <span class="comment">// Automatically public </span></span></span><br><span class="line"><span class="function">        System.out.<span class="title">println</span><span class="params">(<span class="keyword">this</span> + <span class="string">&quot;.play() &quot;</span> + n)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Percussion&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Stringed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Brass&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woodwind</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woodwind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music5</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Doesn&#x27;t care about type, so new types</span></span><br><span class="line">    <span class="comment">// added to the system still work right:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument i: e) &#123;</span><br><span class="line">            tune(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Upcasting during addition to the array:</span></span><br><span class="line">        Instrument[] orchestra = &#123;</span><br><span class="line">            <span class="keyword">new</span> Wind(),</span><br><span class="line">            <span class="keyword">new</span> Percussion(),</span><br><span class="line">            <span class="keyword">new</span> Stringed(),</span><br><span class="line">            <span class="keyword">new</span> Brass(),</span><br><span class="line">            <span class="keyword">new</span> Woodwind()</span><br><span class="line">        &#125;</span><br><span class="line">        tuneAll(orchestra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Wind.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Percussion.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Stringed.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Brass.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Woodwind.play() MIDDLE_C</span></span><br></pre></td></tr></table></figure>

<p>​        这个版本的例子的另一个变化是：what()被修为toString()方法，因为toString()实现的正是what()方法要实现的逻辑。因为toString()是根基类Object的方法，所以它不需要出现在接口中。</p>
<p>​        注意到，无论是将其向上转型称作Instrument的普通类，或称作Instrument的抽象类，还是叫作Instrument的接口，其行为都是相同的。事实上，从tune()方法上看不出来Instrument到底是一个普通类、抽象类，还是一个接口。</p>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>​        尤其是在Java8引入default方法之后，选择用抽象类还是用接口变得 更加令人困惑。下表做了明确的区分：</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">接口</th>
<th align="center">抽象类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">组合</td>
<td align="center">新类可以组合多个接口</td>
<td align="center">只能继承单一抽象类</td>
</tr>
<tr>
<td align="center">状态</td>
<td align="center">不能包含属性(除了静态方法，不支持对象状态)</td>
<td align="center">可以包含属性，非抽象方法可能引用这些属性</td>
</tr>
<tr>
<td align="center">默认方法和抽象方法</td>
<td align="center">不需要在子类中实现默认方法。默认方法可以引用其他接口的方法</td>
<td align="center">必须在子类中实现抽象方法</td>
</tr>
<tr>
<td align="center">构造器</td>
<td align="center">没有构造器</td>
<td align="center">可以有构造器</td>
</tr>
<tr>
<td align="center">可见性</td>
<td align="center">隐式public</td>
<td align="center">可以是protected或“friendly”</td>
</tr>
</tbody></table>
<p>​        抽象类仍然是一个类，在创建新类时只能继承它一个。而创建类的过程中可以实现多个接口。</p>
<p>​        有一条实际经验：在合理的范围内尽可能地抽象。因此，更倾向使用接口而不是抽象类。只有当必要时才使用抽象类。除非必须使用，否则不要用接口和抽象类。大多数时候，普通类已经做得很好，如果不行的话，再移动到接口或抽象类中。</p>
<h2 id="完全解耦"><a href="#完全解耦" class="headerlink" title="完全解耦"></a>完全解耦</h2><p>​        每当一个方法与一个类而不是接口一起工作时(当方法的参数是类而不是接口)，你只能应用那个类或它的子类。如果你想把这方法应用到一个继承层次之外的类，是做不到的。接口在很大程度上放宽了这个限制，因而使用接口可以编写复用性更好的代码。</p>
<p>​        例如有一个类Processor有两个方法name()和process()。process()方法接收输入，修改并输出。把这个类作为基类用来创建各种不同类型的Processor。下例中，Processor的各个子类修改String对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/Applicator.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回协变类型</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// split() divides a String into pieces:</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(((String) input).split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Applicator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Processor &quot;</span> + p.name());</span><br><span class="line">        System.out.println(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;We are such stuff as dreams are made on&quot;</span>;</span><br><span class="line">        apply(<span class="keyword">new</span> Upcase(), s);</span><br><span class="line">        apply(<span class="keyword">new</span> Downcase(), s);</span><br><span class="line">        apply(<span class="keyword">new</span> Splitter(), s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Using Processor Upcase</span></span><br><span class="line"><span class="comment">//WE ARE SUCH STUFF AS DREAMS ARE MADE ON</span></span><br><span class="line"><span class="comment">//Using Processor Downcase</span></span><br><span class="line"><span class="comment">//we are such stuff as dreams are made on</span></span><br><span class="line"><span class="comment">//Using Processor Splitter</span></span><br><span class="line"><span class="comment">//[We, are, such, stuff, as, dreams, are, made, on]</span></span><br></pre></td></tr></table></figure>

<p>​        Applicator的apply()方法可以接受任何类型的Processor，并将其应用到一个Object对象上输出结果。像本例中这样，创建一个能根据传入的参数类型从而具备不同行为的方法称为策略设计模式。方法包含算法中不变的部分，策略包含变化的部分。策略就是传入的对象，它包含要执行的代码。在这里，Processor对象是策略，main()方法展示了三种不同的应用于String s上的策略。</p>
<p>​        Split() 是String类中的方法，它接收String类型的对象并以传入的参数作为分隔界限，返回一个数组String[]。在这里它是为了更快捷地创建String数组。</p>
<p>​        假设现在发现了一组电子滤波器，它们看起来好像能使用Applicator的apply()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/filters/Waveform.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waveform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Waveform &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/Filter.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/LowPass.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> cutoff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LowPass</span><span class="params">(<span class="keyword">double</span> cutoff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cutoff = cutoff;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input; <span class="comment">// Dummy processing 哑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/HighPass.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> cutoff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighPass</span><span class="params">(<span class="keyword">double</span> cutoff)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cutoff = cutoff;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/filters/BandPass.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BandPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> lowCutoff, highCutoff;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BandPass</span><span class="params">(<span class="keyword">double</span> lowCut, <span class="keyword">double</span> highCut)</span> </span>&#123;</span><br><span class="line">        lowCutoff = lowCut;</span><br><span class="line">        highCutoff = highCut;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                                           </span><br></pre></td></tr></table></figure>

<p>​        Filter类与Processor类具有相同的接口元素，但是因为它不是继承自Processor——因为Filter类的创建者根本不知道你想将它当作Processor使用——因此你不能将Applicator的apply()方法应用在Filter类上，即使这样做也能正常运行。主要是因为Applicator的apply()方法和Processor过于耦合，这阻止了Applicator的apply()方法被复用。另外要注意的一点是Filter类中process()方法的输入输出都是Waveform。</p>
<p>​        但如果Processor是一个接口，那么限制就会变得松动到足以复用Applicator的apply()方法，用来接受那个接受参数。下面是修改后的Processor和Applicator版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/interfaceprocessor/Processor.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Object <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interfaces/interfaceprocessor/Applicator.java</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Applicator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Processor &quot;</span> + p.name());</span><br><span class="line">        System.out.println(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        复用代码的第一种方式是客户端程序员遵循接口编写类，像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/interfaceprocessor/StringProcessor.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.interfaceprocessor.StringProcessor&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">StringProcessor</span> <span class="keyword">extends</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(Object input)</span></span>; <span class="comment">// [1]</span></span><br><span class="line">    String S = <span class="string">&quot;If she weighs the same as a duck, she&#x27;s made of wood&quot;</span>; <span class="comment">// [2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// [3]</span></span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> Upcase(), S);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> Downcase(), S);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> Splitter(), S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回协变类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">implements</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(((String) input).split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Using Processor Upcase</span></span><br><span class="line"><span class="comment">//IF SHE WEIGHS THE SAME AS A DUCK, SHE&#x27;S MADE OF WOOD</span></span><br><span class="line"><span class="comment">//Using Processor Downcase</span></span><br><span class="line"><span class="comment">//if she weighs the same as a duck, she&#x27;s made of wood</span></span><br><span class="line"><span class="comment">//Using Processor Splitter</span></span><br><span class="line"><span class="comment">//[If, she, weighs, the, same, as, a, duck,, she&#x27;s, made, of, wood]</span></span><br></pre></td></tr></table></figure>

<p>​        [1]该声明不是必要的，即使移除它，编译器也不会报错。但是注意这里的协变返回类型从Object变成了String。[2]S自动就是final和static的，因为它是在接口中定义的。[3]可以在接口中定义main()方法。</p>
<p>​        这种方式运作得很好，然而你经常遇到的情况是无法修改类。例如在电子滤波器的例子中，类库是被发现而不是创建的。在这些情况下，可以使用适配器设计模式。适配器允许代码接受已有的接口产生需要的接口，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/interfaceprocessor/FilterProcessor.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.interfaceprocessor.FilterProcessor&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.interfaceprocessor;</span><br><span class="line"><span class="keyword">import</span> interfaces.filters.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterAdapter</span> <span class="keyword">implements</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    Filter filter;</span><br><span class="line">    </span><br><span class="line">    FilterAdapter(Filter filter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filter = filter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filter.name();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filter.process((Waveform) input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Waveform w = <span class="keyword">new</span> Waveform();</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> LowPass(<span class="number">1.0</span>)), w);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> HighPass(<span class="number">2.0</span>)), w);</span><br><span class="line">        Applicator.apply(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> BandPass(<span class="number">3.0</span>, <span class="number">4.0</span>)), w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Using Processor LowPass</span></span><br><span class="line"><span class="comment">//Waveform 0</span></span><br><span class="line"><span class="comment">//Using Processor HighPass</span></span><br><span class="line"><span class="comment">//Waveform 0</span></span><br><span class="line"><span class="comment">//Using Processor BandPass</span></span><br><span class="line"><span class="comment">//Waveform 0</span></span><br></pre></td></tr></table></figure>

<p>​        在这种使用适配器的方式中，FilterAdapter的构造器接受已有的接口Filter，继而产生需要的Processor接口的对象。你可能还注意到FilterAdapter中使用了委托。</p>
<p>​        协变允许我们从process()方法中产生一个Waveform而非Object对象。</p>
<p>​        将接口与实现解耦使得接口可以应用于多种不同的实现，因而代码更具可复用性。</p>
<h2 id="多接口结合"><a href="#多接口结合" class="headerlink" title="多接口结合"></a>多接口结合</h2><p>​        接口没有任何实现——也就是说，没有任何与接口相关的存储——因此无法阻止结合的多借口。这是有价值的，因为你有时需要表示“一个x是一个a和b以及一个c”。</p>
<p>​        派生类并不要求必须继承自抽象或“具体的”(没有任何抽象方法)的基类。如果继承一个非接口的类，那么只能继承一个类，其余的基元素必须都是接口。需要将所有的接口名称置于implements关键字之后且用逗号分隔。可以有任意多个接口，并可以向上转型为每个接口，因为每个接口都是独立的类型。下例展示了一个由多个接口组合而成的具体类产生的新类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/Adventure.java</span></span><br><span class="line"><span class="comment">// Multiple interfaces</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionCharacter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionCharacter</span> <span class="keyword">implements</span> <span class="title">CanFight</span>, <span class="title">CanSwim</span>, <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adventure</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">(CanFight x)</span> </span>&#123;</span><br><span class="line">        x.fight();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(CanSwim x)</span> </span>&#123;</span><br><span class="line">        x.swim();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(CanFly x)</span> </span>&#123;</span><br><span class="line">        x.fly();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(ActionCharacter x)</span> </span>&#123;</span><br><span class="line">        x.fight();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">        t(h); <span class="comment">// Treat it as a CanFight</span></span><br><span class="line">        u(h); <span class="comment">// Treat it as a CanSwim</span></span><br><span class="line">        v(h); <span class="comment">// Treat it as a CanFly</span></span><br><span class="line">        w(h); <span class="comment">// Treat it as an ActionCharacter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        类Hero结合了具体类ActionCharacter和接口CanFight、CanSwim和CanFly。当通过这种方式结合具体类和接口时，需要将具体类放在前面，后面跟着接口。</p>
<p>​        接口CanFight和类ActionCharacter中的fight()方法签名相同，而在类Hero中也没有提供fight()的定义。可以扩展一个接口，但是得到的是另一个接口。当想创建一个对象时，所有的定义必须首先都存在。类Hero中没有显示地提供fight()的定义，是由于该方法在类ActionCharacter中已经定义过，这样才使得创建Hero对象成为可能。</p>
<p>​        在类Adventure中可以看到四个方法，它们把不同的接口和具体类作为参数。当创建一个Hero对象时，它可以被传入这些方法中的任意一个，意味着它可以依次向上转型为每个接口。Java中这种接口的设计方式，使得程序员不需要付出特别的努力。</p>
<p>​        记住，前面例子展示了使用接口的核心原因之一：为了能够向上转型为多个基类型。然而，使用接口的第二个原因与使用抽象基类相同：防止客户端程序员创建这个类的对象，确保这仅仅只是一个接口。这带来了一个问题：应该使用接口还是抽象类呢？如果创建不带任何方法定义或成员变量的基类，就选择接口而不是抽象类。事实上，如果知道某事物是一个基类，可以考虑用接口实现它。</p>
<h2 id="使用继承扩展接口"><a href="#使用继承扩展接口" class="headerlink" title="使用继承扩展接口"></a>使用继承扩展接口</h2><p>​        通过继承，可以很容易在接口中增加方法声明，还可以在新接口中结合多个接口。这两种情况都可以得到新接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/HorrorShow.java</span></span><br><span class="line"><span class="comment">// Extending an interface with inheritance</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DangerousMonster</span> <span class="keyword">extends</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lethal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DragonZilla</span> <span class="keyword">implements</span> <span class="title">DangerousMonster</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vampire</span> <span class="keyword">extends</span> <span class="title">DangerousMonster</span>, <span class="title">Lethal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drinkBlood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBadVampire</span> <span class="keyword">implements</span> <span class="title">Vampire</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drinkBlood</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorrorShow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">(Monster b)</span> </span>&#123;</span><br><span class="line">        b.menace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">(DangerousMonster d)</span> </span>&#123;</span><br><span class="line">        d.menace();</span><br><span class="line">        d.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">(Lethal l)</span> </span>&#123;</span><br><span class="line">        l.kill();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DangerousMonster barney = <span class="keyword">new</span> DragonZilla();</span><br><span class="line">        u(barney);</span><br><span class="line">        v(barney);</span><br><span class="line">        Vampire vlad = <span class="keyword">new</span> VeryBadVampire();</span><br><span class="line">        u(vlad);</span><br><span class="line">        v(vlad);</span><br><span class="line">        w(vlad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        接口DangerousMonster是Monster简单扩展的一个新接口，类DragonZilla实现了这个接口。</p>
<p>​        Vampire中使用的语法仅适用于接口继承。通常来说，extends只能用于单一类，但是在构建接口时可以引用多个基类接口。注意到，接口名之间用逗号分隔。</p>
<h3 id="结合接口时的命名冲突"><a href="#结合接口时的命名冲突" class="headerlink" title="结合接口时的命名冲突"></a>结合接口时的命名冲突</h3><p>​        当实现多个接口时可能会存在一个小陷阱。在前面的例子中，CanFight和ActionCharacter具有完全相同的fight()方法。完全相同的方法没有问题，但是如果它们的签名或返回类型不同会怎么样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/InterfaceCollision.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 重载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 完全相同，没问题</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法的返回类型不同</span></span><br><span class="line"><span class="comment">//- class C5 extends C implements I1 &#123;&#125;</span></span><br><span class="line"><span class="comment">//- interface I4 extends I1, I3 &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>​        覆写、实现和重载令人不快地搅和在一起带来了困难。同时，重载方法仅根据返回类型是区分不了的。当不注释最后两行时，报错信息如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">error: C5 is not abstract and does not override abstract</span><br><span class="line">method f() in I1</span><br><span class="line">class C5 extends C implements I1 &#123;&#125;</span><br><span class="line">error: types I3 and I1 are incompatible; both define f(),</span><br><span class="line">but with unrelated return types</span><br><span class="line">interfacce I4 extends I1, I3 &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​        当打算组合接口时，在不同的接口中使用相同的方法名通常会造成代码可读性的混乱、尽量避免这种情况。</p>
<h2 id="接口适配"><a href="#接口适配" class="headerlink" title="接口适配"></a>接口适配</h2><p>​        接口最吸引人的原因之一是相同的接口可以有多个实现。在简单情况下体现在一个方法接受接口作为参数，该接口的实现和传递对象则取决于方法的使用者。</p>
<p>​        因此，接口的一种常见用法是前面提到的策略设计模式。编写一个方法执行某些操作并接受一个指定的接口作为参数。可以说：“只要对象遵循接口，就可以调用方法”，这使得方法更加灵活、通用、并更具可复用性。</p>
<p>​        例如，类Scanner的构造器接受一个Readable接口。你会发现Readable没有用作Java标准库中其他任何方法的参数——它是单独为Scanner创建的，因此Scanner没有将其参数限制为某个特定类。通过这种方式，Scanner可以与更多的类协作。如果你创建了一个新类并想让Scanner作用于它，就让它实现Readable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/RandomStrings.java</span></span><br><span class="line"><span class="comment">// Implementing an interface to conform to a method</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomStrings</span> <span class="keyword">implements</span> <span class="title">Readable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] CAPITALS = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>.toCharArray();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] LOWERS = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>.toCharArray();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] VOWELS = <span class="string">&quot;aeiou&quot;</span>.toCharArray();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//产生随机字符串的个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomStrings</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(CharBuffer cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count-- == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// indicates end of input</span></span><br><span class="line">        &#125;</span><br><span class="line">        cb.append(CAPITALS[rand.nextInt(CAPITALS.length)]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            cb.append(VOWELS[rand.nextInt(VOWELS.length)]);</span><br><span class="line">            cb.append(LOWERS[rand.nextInt(LOWERS.length)]);</span><br><span class="line">        &#125;</span><br><span class="line">        cb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>; <span class="comment">// Number of characters appended</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> RandomStrings(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">while</span> (s.hasNext()) &#123;</span><br><span class="line">            System.out.println(s.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Yazeruyac</span></span><br><span class="line"><span class="comment">//Fowenucor</span></span><br><span class="line"><span class="comment">//Goeazimom</span></span><br><span class="line"><span class="comment">//Raeuuacio</span></span><br><span class="line"><span class="comment">//Nuoadesiw</span></span><br><span class="line"><span class="comment">//Hageaikux</span></span><br><span class="line"><span class="comment">//Ruqicibui</span></span><br><span class="line"><span class="comment">//Numasetih</span></span><br><span class="line"><span class="comment">//Kuuuuozog</span></span><br><span class="line"><span class="comment">//Waqizeyoy</span></span><br></pre></td></tr></table></figure>

<p>​        Readable接口只需要实现read()方法，在read()方法里，将输入内容添加到CharBuffer参数中，或在没有输入时返回-1。</p>
<p>​        假设你有一个类没有实现Readable接口，怎么才能让Scanner作用于它呢？下面是一个产生随机浮点数的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/RandomDoubles.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomDoubles</span> </span>&#123;</span><br><span class="line">    Random RAND = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RAND.nextDouble();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomDoubles rd = <span class="keyword">new</span> RandomDoubles()&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            System.out.println(rd.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0.7271157860730044 </span></span><br><span class="line"><span class="comment">//0.5309454508634242 </span></span><br><span class="line"><span class="comment">//0.16020656493302599 </span></span><br><span class="line"><span class="comment">//0.18847866977771732 </span></span><br><span class="line"><span class="comment">//0.5166020801268457 </span></span><br><span class="line"><span class="comment">//0.2678662084200585 </span></span><br><span class="line"><span class="comment">//0.2613610344283964</span></span><br></pre></td></tr></table></figure>

<p>​        我们可以再次使用适配器模式，但这里适配类可以实现两个接口。因此，通过关键字interface提供的多继承，我们可以创建一个既是RandomDoubles，又是Readable的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/AdaptedRandomDoubles.java</span></span><br><span class="line"><span class="comment">// creating an adapter with inheritance</span></span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptedRandomDoubles</span> <span class="keyword">implements</span> <span class="title">RandomDoubles</span>, <span class="title">Readable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptedRandomDoubles</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(CharBuffer cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count-- == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String result = Double.toString(next()) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cb.append(result);</span><br><span class="line">        <span class="keyword">return</span> result.length();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> AdaptedRandomDoubles(<span class="number">7</span>));</span><br><span class="line">        <span class="keyword">while</span> (s.hasNextDouble()) &#123;</span><br><span class="line">            System.out.print(s.nextDouble() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0.7271157860730044 0.5309454508634242 </span></span><br><span class="line"><span class="comment">//0.16020656493302599 0.18847866977771732 </span></span><br><span class="line"><span class="comment">//0.5166020801268457 0.2678662084200585 </span></span><br><span class="line"><span class="comment">//0.2613610344283964</span></span><br></pre></td></tr></table></figure>

<p>​        因为你可以以这种方式在已有类中增加新接口，所以这就意味着一个接受接口类型的方法提供了一种让任何类都可以与该方法进行适配的方式。这就是使用接口而不是类的强大之处。</p>
<h2 id="接口字段"><a href="#接口字段" class="headerlink" title="接口字段"></a>接口字段</h2><p>​        因为接口中的字段都是static和final的，所以接口就成为了创建一组常量的方便工具。在Java5之前，这是产生与C和C++中的enum(枚举类型)具有相同效果的唯一方式。所以你可能在Java5之前的代码中看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/Months.java</span></span><br><span class="line"><span class="comment">// Using interfaces to create groups of constants</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Months</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> </span><br><span class="line">    JANUARY = <span class="number">1</span>, FEBRUARY = <span class="number">2</span>, MARCH = <span class="number">3</span>,</span><br><span class="line">    APRIL = <span class="number">4</span>, MAY = <span class="number">5</span>, JUNE = <span class="number">6</span>, JULY = <span class="number">7</span>,</span><br><span class="line">    AUGUST = <span class="number">8</span>, SEPTEMBER = <span class="number">9</span>, OCTOBER = <span class="number">10</span>,</span><br><span class="line">    NOVEMBER = <span class="number">11</span>, DECEMBER = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        注意Java中使用大写字母的风格定义具有初始化值的static final变量。接口中的字段自动是public的，所以没有显示指明这点。</p>
<p>​        自Java5开始，我们有了更强大和灵活的关键字enum，那么在接口中定义常量组就显得没什么意义了。然而当你阅读遗留的代码时，在很多场合你还会碰到这种旧的习惯用法。</p>
<h3 id="初始化接口中的字段"><a href="#初始化接口中的字段" class="headerlink" title="初始化接口中的字段"></a>初始化接口中的字段</h3><p>​        接口中定义的字段不能是“空final”，但是可以用非常量表达式初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/RandVals.java</span></span><br><span class="line"><span class="comment">// Initializing interface fields with</span></span><br><span class="line"><span class="comment">// non-constant initializers</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandVals</span> </span>&#123;</span><br><span class="line">    Random RAND = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">int</span> RANDOM_INT = RAND.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">long</span> RANDOM_LONG = RAND.nextLong() * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">float</span> RANDOM_FLOAT = RAND.nextLong() * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> RANDOM_DOUBLE = RAND.nextDouble() * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        因为字段是static的，所以它们在类第一次被加载时初始化，这发生在任何字段首次被访问时。下面是个简单的测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/TestRandVals.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRandVals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(RandVals.RANDOM_INT);</span><br><span class="line">        System.out.println(RandVals.RANDOM_LONG);</span><br><span class="line">        System.out.println(RandVals.RANDOM_FLOAT);</span><br><span class="line">        System.out.println(RandVals.RANDOM_DOUBLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8</span></span><br><span class="line"><span class="comment">//-32032247016559954</span></span><br><span class="line"><span class="comment">//-8.5939291E18</span></span><br><span class="line"><span class="comment">//5.779976127815049</span></span><br></pre></td></tr></table></figure>

<p>​        这些字段不是接口的一部分，它们的值被存储在接口的静态存储区域中。</p>
<h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>​        接口可以嵌套在类或其他接口中。下面揭示一些有趣的特性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/nesting/NestingInterfaces.java</span></span><br><span class="line"><span class="comment">// &#123;java interfaces.nesting.NestingInterfaces&#125;</span></span><br><span class="line"><span class="keyword">package</span> interfaces.nesting;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp2</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CImp2</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp</span> <span class="keyword">implements</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DImp2</span> <span class="keyword">implements</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> D <span class="title">getD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DImp2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> D dRef;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(D d)</span> </span>&#123;</span><br><span class="line">        dRef = d;</span><br><span class="line">        dRef.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">G</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Redundant &quot;public&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">H</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// Cannot be private within an interface</span></span><br><span class="line">    <span class="comment">//- private interface I &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestingInterfaces</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CImp</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Cannot implements a private interface except</span></span><br><span class="line">    <span class="comment">// within that interface&#x27;s defining class:</span></span><br><span class="line">    <span class="comment">//- class DImp implements A.D &#123;</span></span><br><span class="line">    <span class="comment">//- public void f() &#123;&#125;</span></span><br><span class="line">    <span class="comment">//- &#125;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EImp</span> <span class="keyword">implements</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EGImp</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EImp2</span> <span class="keyword">implements</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EG</span> <span class="keyword">implements</span> <span class="title">E</span>.<span class="title">G</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">// Can&#x27;t access to A.D:</span></span><br><span class="line">        <span class="comment">//- A.D ad = a.getD();</span></span><br><span class="line">        <span class="comment">// Doesn&#x27;t return anything but A.D:</span></span><br><span class="line">        <span class="comment">//- A.DImp2 di2 = a.getD();</span></span><br><span class="line">        <span class="comment">// cannot access a member of the interface:</span></span><br><span class="line">        <span class="comment">//- a.getD().f();</span></span><br><span class="line">        <span class="comment">// Only another A can do anything with getD():</span></span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">        a2.receiveD(a.getD());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在类中嵌套接口的语法是相当显而易见的。就像非嵌套接口一样，它们具有public或包访问权限的可见性。</p>
<p>​        作为一种新添加的方式，接口也可以是private的，例如A.D。那么private嵌套接口有什么好处呢？你可能猜测它只是被用来实现一个private内部类，就像DImp。然而A.DImp2展示了它可以被实现为public类，但是A.DImp2只能被自己使用，你无法说它实现了private接口D，所以实现private接口是一种可以强制该接口中的方法定义不会添加任何类型信息(即不可以向上转型)的方式。</p>
<p>​        getD()方法产生了一个与private接口有关的窘境。它是一个public方法却返回了对private接口的引用。能对这个返回值做些什么呢？main()方法里进行了一些使用返回值的尝试但都失败了。返回值必须交给有权使用它的对象，本例中另一个A通过receiveD()方法接受了它。</p>
<p>​        接口E说明了接口之间也能嵌套。然而，作用于接口的规则——尤其是，接口中的元素必须是public的——在此都会被严格执行，所以嵌套在另一个接口中的接口自动就是public的，不能指明为private。</p>
<p>​        类NestingInterfaces展示了嵌套接口的不同实现方式。尤其是当实现某个接口时，并不需要实现嵌套在其内部的接口。同时，private接口不能在定义它的类之外被实现。</p>
<p>​        添加这些特性的最初原因看起来像是出于对严格的语法一致性的考虑，但是我通常认为，一旦你了解某种特性，就总能找到其用武之地。</p>
<h2 id="接口和工厂方法模式"><a href="#接口和工厂方法模式" class="headerlink" title="接口和工厂方法模式"></a>接口和工厂方法模式</h2><p>​        接口是多实现的途径，而生成符合某个接口的对象的典型方式是工厂方法设计模式。不同于直接调用构造器，只需调用工厂对象中的创建方法就能生成对象的实现——理论上，通过这种方式可以将接口与实现的代码完全分离，使得可以透明地将某个实现替换为另一个实现。这里是一个展示工厂方法结构的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/Factories.java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service1</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    Service1() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service1 method1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service1 method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service1Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Service1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service2</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    Service2() &#123;&#125; <span class="comment">// Package access</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service2 method1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service2 method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service2Factory</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Service2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factories</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory fact)</span> </span>&#123;</span><br><span class="line">        Service s = fact.getService();</span><br><span class="line">        s.method1();</span><br><span class="line">        s.method2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> Service1Factory());</span><br><span class="line">        <span class="comment">// Services are completely interchangeable:</span></span><br><span class="line">        serviceConsumer(<span class="keyword">new</span> Service2Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Service1 method1</span></span><br><span class="line"><span class="comment">//Service1 method2</span></span><br><span class="line"><span class="comment">//Service2 method1</span></span><br><span class="line"><span class="comment">//Service2 method2</span></span><br></pre></td></tr></table></figure>

<p>​        如果没有工厂方法，代码就必须在某处指定将要创建的Service的确切类型，从而调用恰当的构造器。</p>
<p>​        为什么要添加额外的间接层呢？一个常见的原因是创建框架，假设你正在创建一个游戏系统；例如，在相同的棋盘下国际象棋和西洋跳棋：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces/Games.java</span></span><br><span class="line"><span class="comment">// A Game framework using Factory Methods</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Game <span class="title">getGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkers</span> <span class="keyword">implements</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVES = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Checkers move &quot;</span> + moves);</span><br><span class="line">        <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckersFactory</span> <span class="keyword">implements</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Checkers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">implements</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVES = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Chess move &quot;</span> + moves);</span><br><span class="line">        <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChessFactory</span> <span class="keyword">implements</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Chess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Games</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">(GameFactory factory)</span> </span>&#123;</span><br><span class="line">        Game s = factory.getGame();</span><br><span class="line">        <span class="keyword">while</span> (s.move()) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        playGame(<span class="keyword">new</span> CheckersFactory());</span><br><span class="line">        playGame(<span class="keyword">new</span> ChessFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Checkers move 0</span></span><br><span class="line"><span class="comment">//Checkers move 1</span></span><br><span class="line"><span class="comment">//Checkers move 2</span></span><br><span class="line"><span class="comment">//Chess move 0</span></span><br><span class="line"><span class="comment">//Chess move 1</span></span><br><span class="line"><span class="comment">//Chess move 2</span></span><br><span class="line"><span class="comment">//Chess move 3</span></span><br></pre></td></tr></table></figure>

<p>​        如果类Games表示一段很复杂的代码，那么这种方式意味着你可以在不同类型的游戏里复用这段代码。你可以再想象一些能够从这个模式中收益的更加精巧的游戏。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>《On Java 8》</tag>
      </tags>
  </entry>
  <entry>
    <title>高级排序</title>
    <url>/2020/12/29/%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h1><hr>
<p>之前的简单排序，包括冒泡排序、选择排序、插入排序，并且对他们在最坏情况下的时间复杂度做了分析，发现都是$O(N^2)$，复杂度为平方阶的会随着输入规模的增大，时间成本急剧上升，所以这些基本排序方法不能处理更大规模的问题，接下来将会使用一些高级的排序算法，争取降低算法的时间复杂度最高阶次幂。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是插入排序的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版本。</p>
 <span id="more"></span> 

<p><strong>需求：</strong></p>
<ul>
<li>排序前：{9，1，2，5，7，4，8，6，3，5}</li>
<li>排序后：{1，2，3，4，5，5，6，7，8，9}</li>
</ul>
<p><strong>排序原理：</strong></p>
<ul>
<li>选择一个增量h，按照增长量h作为数据分组的依据，对数据进行分组；</li>
<li>对分好组的每一组数据完成插入排序；</li>
<li>减小增长量，最小减为1，重复第二步操作。</li>
</ul>
<table>
<thead>
<tr>
<th>初始</th>
<th>{9，1，2，5，7，4，8，6，3，5}</th>
</tr>
</thead>
<tbody><tr>
<td>h=5</td>
<td>{4，1，2，3，5，9，8，6，5，7}</td>
</tr>
<tr>
<td>h=2</td>
<td>{2，1，4，3，5，6，5，7，8，9}</td>
</tr>
<tr>
<td>h=1</td>
<td>{1，2，3，4，5，5，6，7，8，9}</td>
</tr>
</tbody></table>
<p><strong>增长量h的确定：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(h &lt; 数组长度/<span class="number">2</span>)&#123;</span><br><span class="line">    h = <span class="number">2</span>*h + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环结束后就可以确定h的最大值</span></span><br><span class="line"><span class="comment">//h的减小规则为：</span></span><br><span class="line">h = h / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>希尔排序的API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Shell</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Shell()</td>
</tr>
<tr>
<td>成员方法</td>
<td>public static void sort(Comparable[] a)</td>
</tr>
<tr>
<td></td>
<td>private static boolean greater(Comparable m, Comparable w)</td>
</tr>
<tr>
<td></td>
<td>private static void exch(Comparable[] a, int i, int j)</td>
</tr>
</tbody></table>
<p><strong>希尔排序的代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据数组a的长度，确定增长量h的初始值；</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h &lt; (a.length / <span class="number">2</span>))&#123;</span><br><span class="line">            h = <span class="number">2</span> * h + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//希尔排序</span></span><br><span class="line">        <span class="keyword">while</span>(h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//找到待插入元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; a.length; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= h; j-=h)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(greater(a[j-h],a[j]))&#123;</span><br><span class="line">                        exch(a,j-h,j);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(Comparable m, Comparable w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.compareTo(w) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Shell.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>希尔排序的时间复杂度分析：</strong></p>
<p>在希尔排序中，增长量h并没有固定的规则，有很多论文研究了各种不同的递增序列，但都无法证明某个序列是最好的，对于希尔排序的时间复杂度分析，在这里不做分析了。</p>
<p>我们可以使用事后分析法对希尔排序和插入排序做性能比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortCompare</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用不同的测试方法，完成测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ArrayList集合，保存读取出来的数据</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建缓存读取流BufferedReader，读取数据，并存储到ArrayList中</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(SortCompare.class.getclassLoader().getResourceAsStream(<span class="string">&quot;reverse_arr.test&quot;</span>)));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//line是字符串</span></span><br><span class="line">           	<span class="comment">//把line转换成Integer，存储到集合中</span></span><br><span class="line">            <span class="keyword">int</span> i = Integer.parseInt(line);</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="comment">//把ArrayList集合转换成数据</span></span><br><span class="line">        Integer[] a = <span class="keyword">new</span> Integer[list.size()];</span><br><span class="line">        list.toArray(a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用测试代码</span></span><br><span class="line">        testInsertion(a);</span><br><span class="line">        testShell(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testShell</span><span class="params">(Integer[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取执行之间的时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Shell.sort(a);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;希尔排序执行的时间为&quot;</span>+ (end -start) + <span class="string">&quot;ms!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInsertion</span><span class="params">(Integer[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Insertion.sort(a);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;插入排序执行的时间为&quot;</span>+ (end -start) + <span class="string">&quot;ms!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p><strong>定义：</strong>定义方法时，在方法内部调用方法本身，称之为递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用：</strong></p>
<p>它通常把一个大型复杂的问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的程序就可以描述出解题过程所需要的多次重复计算，大大的减少了程序的代码量。</p>
<p><strong>注意事项：</strong></p>
<p>在递归调用中，不能无限制的调用自己，必须要有边界条件，能够让递归结束，因为每一次递归调用都会在栈内存开辟新的空间，重新执行方法，如果递归的层级太深，很容易造成占内存溢出。</p>
<p><strong>需求：</strong></p>
<p>请定义一个方法，使用递归完成求$N$的阶乘。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = factorial(<span class="number">5</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<p><strong>需求：</strong></p>
<ul>
<li>排序前：{8，4，5，7，1，3，6，2}</li>
<li>排序后：{1，2，3，4，5，6，7，8}</li>
</ul>
<p><strong>排序原理：</strong></p>
<ul>
<li>1.尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数1为止；</li>
<li>2.将相邻的两个子组进行合并成一个有序的大组；</li>
<li>不断重复步骤2，直到最终只有一个组为止。</li>
</ul>
<p><strong>归并排序的API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Merge</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Merge()</td>
</tr>
<tr>
<td>成员方法</td>
<td>public static void sort(Comparable[] a)</td>
</tr>
<tr>
<td></td>
<td>private static void sort(Comparable[] a, int lo, int hi)</td>
</tr>
<tr>
<td></td>
<td>private static void merge(Comparable[] a, int lo, int mid, int hi)</td>
</tr>
<tr>
<td></td>
<td>private static boolean less(Comparable v, Comparable w)</td>
</tr>
<tr>
<td></td>
<td>private static void exch(Comparable[] a, int i, int j)</td>
</tr>
<tr>
<td>成员变量</td>
<td>private static Comparable[] assist</td>
</tr>
</tbody></table>
<p><strong>归并排序的代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] assist;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化辅助数组assist</span></span><br><span class="line">        assist = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        <span class="comment">//定义一个lo变量和hi变量，分别记录数组中最小的索引和最大的索引</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//调用sort重载方法完成数组a中从索引lo到hi的元素排序</span></span><br><span class="line">        sort(a,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//安全性校验</span></span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//对lo到hi中的数据分两个组</span></span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//分别对每一组数据进行排序</span></span><br><span class="line">        sort(a,lo,mid);</span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">        <span class="comment">//再把两个组中的数据进行归并</span></span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo ,<span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义三个指针</span></span><br><span class="line">        <span class="keyword">int</span> p1 = lo, p2 = mid + <span class="number">1</span>, i = lo;</span><br><span class="line">        <span class="comment">//遍历，移动p1指针和p2指针，比较对应索引处的值，找出小的那个，放到辅助数组的对应索引处</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">if</span>(less(a[p1],a[p2]))&#123;</span><br><span class="line">                assist[i++] = a[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                assist[i++] = a[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历，如果p1指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数组的对应索引处</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">            assist[i++] = a[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同理p2指针同样</span></span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= hi)&#123;</span><br><span class="line">            assist[i++] = a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把辅助数组中的元素拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = lo; index &lt;= hi; index++)&#123;</span><br><span class="line">            a[index] = assist[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>归并排序时间复杂度分析：</strong></p>
<p>归并排序是分治思想的最典型的例子，上面的算法中，对$a[lo…hi]$进行排序，先将它分为$a[lo…mid]和a[mid+1…hi]$两部分，分别通过递归调用将他们单独排序，最后将有序的子数组归并为最终的排序结果。该递归的出口在于如果一个数组不能再被分为两个子数组，那么就会执行merge进行归并，在归并的时候判断元素的大小进行排序。</p>
<p>用树状图来描述归并，如果一个数组有8个元素，那么它将每次除以2找最小的子数组，共拆$log8$次，值为3，所以树共有三层，那么自顶向下第$k$层有$2^k$个子数组，每个数组的长度为$2^{3-k}$，归并最多需要$2^{3-k}$次比较。因此每层的比较次数为$2^k<em>2^{3-k} = 2^3$，那么3层总共为$3</em>2^3$。</p>
<p>假设元素的个数为$n$，那么使用归并排序拆分的次数为$log_2(n)$，所以共$log_2(n)$层，归并排序的时间复杂度为：$O(nlogn)$。</p>
<p><strong>归并排序的缺点：</strong></p>
<p>需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的造作。</p>
<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两个部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p><strong>需求：</strong></p>
<ul>
<li>排序前：{6，1，2，7，9，3，4，5，8}</li>
<li>排序后：{1，2，3，4，5，6，7，8，9}</li>
</ul>
<p><strong>排序原理：</strong></p>
<ul>
<li>1.首先设定一个分界值，通过该分界值将数组分成左右两个部分;</li>
<li>2.将大于或等于分界值的数据放到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值；</li>
<li>3.然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</li>
<li>4.重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。</li>
</ul>
<p><strong>快速排序API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Quick</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Quick()</td>
</tr>
<tr>
<td>成员方法</td>
<td>public static void sort(Comparable[] a)</td>
</tr>
<tr>
<td></td>
<td>private static void sort(Comparable[] a, int lo, int hi)</td>
</tr>
<tr>
<td></td>
<td>public static int partition(Comparable[] a, int lo, int hi)</td>
</tr>
<tr>
<td></td>
<td>private static boolean less(Comparable v, Comparable w)</td>
</tr>
<tr>
<td></td>
<td>private static void exch(Comparable[] a, int i ,int j)</td>
</tr>
</tbody></table>
<p><strong>切分原理：</strong></p>
<ul>
<li>找一个基准值，用两个指针分别指向数组的头部和尾部；</li>
<li>先从尾部向头部开始搜索一个比基准值小的元素，搜索到停止，并记录指针的位置；</li>
<li>再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置；</li>
<li>交换当前左边指针位置和右边指针位置的元素；</li>
<li>重复步骤2，3，4直到左边指针的值大于右边指针的值停止。</li>
</ul>
<p><strong>快速排序的代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = a.length - <span class="number">1</span>;</span><br><span class="line">        sort(a,lo,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//安全性校验</span></span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//需要对数组中lo索引到hi索引处的元素进行分组：左子组和右子组</span></span><br><span class="line">        <span class="keyword">int</span> partition = partition(a,lo,hi);<span class="comment">//返回的是分组的分界值所在的索引</span></span><br><span class="line">        <span class="comment">//让左子组有序</span></span><br><span class="line">        sort(a,lo,partition - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//让右子组有序</span></span><br><span class="line">        sort(a,partition + <span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确定分界值</span></span><br><span class="line">        Comparable key = a[lo];</span><br><span class="line">        <span class="comment">//定义两个指针：分别指向待切分元素的最小索引处和最大索引处的下一个位置</span></span><br><span class="line">        <span class="keyword">int</span> left = lo, right = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//先从右向左扫描，移动right指针，找到一个比分界值小的元素，停止</span></span><br><span class="line">            <span class="keyword">while</span>(less(key,a[--right]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(right == lo)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再从左往右扫描，移动left指针，找到一个比分界值大的元素，停止</span></span><br><span class="line">            <span class="keyword">while</span>(less(a[++left],key))&#123;</span><br><span class="line">                <span class="keyword">if</span>(left == hi)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断left》=right，如果是，结束循环；如果不是则交换元素</span></span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                exch(a,left,right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a,lo,right);<span class="comment">//交换分界值</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序和归并排序的区别：</strong></p>
<p>快速排序是另一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都是有序时，整个数组中自然就有序了。在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。</p>
<p><strong>快速排序时间复杂度分析：</strong></p>
<p>快速排序的一次切分从两头开始交替搜索，直到left和right重合，因此，一次切分算法的时间复杂度为$O(n)$，但整个快速排序的时间复杂度和切分的次数相关。</p>
<p>最优情况：每一次切分选择的基准数字刚好使将当前序列等分。其时间复杂度为$O(nlogn)$。</p>
<p>最坏情况：每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总共切分n次，所以最坏情况下其时间复杂度为$O(n^2)$。</p>
<p>平均情况：每一次切分选择的基准数字不是最大值和最小值，也不是中值。其时间复杂度为$O(nlogn)$。</p>
<hr>
<h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p><strong>稳定性的定义：</strong></p>
<p>数组$arr$中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法后，能够保证A元素依然在B元素的前面，可以说这个算法是稳定的。</p>
<p><strong>稳定性的意义：</strong></p>
<p>如果一组数据只需要一次排序，则稳定性一般没有意义，如果一组数据需要多次排序，稳定性是有意义的。例如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。</p>
<p><strong>常见排序算法的稳定性：</strong></p>
<ul>
<li>冒泡排序：只有当$arr[i] &gt; arr[i + 1]$的时候，才会交换元素位置，而相等的时候不会交换位置，所以冒泡排序是一种稳定排序算法。</li>
<li>选择排序：选择排序是给每一个位置选择当前元素最小的，例如有数据为：$5(1),8,5(2),2,9$，第一遍选择的最小元素为2，所以5(1)会和2进行位置交换，此时5(1)到了5(2)后面，破坏了稳定性，所以选择排序算法是一种不稳定的排序算法。</li>
<li>插入排序：比较是从有序序列的末尾开始，也就是想要插入的元素和已经存在的最大者开始比起，如果比大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好后的顺序，所以插入排序是稳定的。</li>
<li>希尔排序：希尔排序是按照不同步长对元素进行插入排序，虽然一次插入排序是稳定的，不会改变相同元素的相对位置，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不稳定的。</li>
<li>归并排序：归并排序在归并过程中，只有$arr[i] &lt; arr[i+1]$的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，归并排序是稳定的。</li>
<li>快速排序：快速排序需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值左侧找一个比基准值大的元素，然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种不稳定的算法。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基本使用</title>
    <url>/2021/04/19/Spring%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h2><p>​        目前是JavaEE开发的灵魂框架，它可以简化JavaEE的开发，可以非常方便整合其他框架，无侵入的进行功能的增强。</p>
<p>​        Spring的核心就是控制反转(IOC)和面向切面(AOP)。</p>
 <span id="more"></span> 

<h2 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>控制反转，之前对象的控制权在类上，现在反转到Spring手上。</p>
<h3 id="SpringIOC快速入门"><a href="#SpringIOC快速入门" class="headerlink" title="SpringIOC快速入门"></a>SpringIOC快速入门</h3><p>①导入依赖</p>
<p>导入SpringIOC相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--pom.xml--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②编写配置文件</p>
<p>在resources目录下创建applicationContext.xml文件，文件名可以任意取</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.dao.impl.StudentDaoImpl&quot;</span> <span class="attr">id</span>=<span class="string">&quot;studentDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>class：配置类的全类名；id：配置一个唯一标识</p>
<p>③创建容器从容器中获取对象并测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建容器</span></span><br><span class="line">        ClassPathXmlApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        StudentDao studentDao = (StudentDao) app.getBean(<span class="string">&quot;studentDao&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(studentDao.getStudentById(<span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bean标签的常用属性配置"><a href="#bean标签的常用属性配置" class="headerlink" title="bean标签的常用属性配置"></a>bean标签的常用属性配置</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>​        bean的唯一标识，同一个Spring容器中不允许重复</p>
<h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><p>​        全类名，用于反射创建对象</p>
<h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p>​        scope主要有两种：singleton和prototype。在没有配置时默认为单例(singleton)</p>
<ul>
<li>如果设置为singleton：则一个容器只会有这一个bean对象。默认容器创建的时候就会创建该对象</li>
<li>如果设置为prototype：则一个容器中会有多个该bean对象。每次调用getBean方法获取时都会创建一个新对象。</li>
</ul>
<h2 id="DI依赖注入概念"><a href="#DI依赖注入概念" class="headerlink" title="DI依赖注入概念"></a>DI依赖注入概念</h2><p>依赖注入可以理解为IOC的一种应用场景，反转的是对象间依赖关系维护权。</p>
<h3 id="set方法注入"><a href="#set方法注入" class="headerlink" title="set方法注入"></a>set方法注入</h3><p>​        在要注入属性的bean标签中进行配置，前提是该类有提供属性对应的set()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.domain.Student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wk&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.domain.Dog&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小白&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.domain.Student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wk&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="有参构造注入"><a href="#有参构造注入" class="headerlink" title="有参构造注入"></a>有参构造注入</h3><p>​        在要注入属性的bean标签中进行配置。前提是要有该类有提供对应的有参构造。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.domain.Student&quot;</span> <span class="attr">id</span>=<span class="string">&quot;student2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wk1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;21&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="复杂类型属性注入"><a href="#复杂类型属性注入" class="headerlink" title="复杂类型属性注入"></a>复杂类型属性注入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Phone phone;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Phone&gt; phones;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Phone&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.domain.Phone&quot;</span> <span class="attr">id</span>=<span class="string">&quot;phone&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;iphone&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3999&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;path&quot;</span> <span class="attr">value</span>=<span class="string">&quot;qwe&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.domain.Phone&quot;</span> <span class="attr">id</span>=<span class="string">&quot;phone1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;iphone&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3999&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;path&quot;</span> <span class="attr">value</span>=<span class="string">&quot;qwe&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.domain.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wk1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;phone&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>95<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>576<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;phones&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;phone&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;phone1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>set1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>set2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;wk1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;phone&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;wk2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;phone1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arr&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;wk1&quot;</span>&gt;</span>v1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;wk1&quot;</span>&gt;</span>v2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Lombok插件"><a href="#Lombok插件" class="headerlink" title="Lombok插件"></a>Lombok插件</h2><p>帮助生成set get方法，构造器，hashCode，equals，toString等的方法</p>
<h2 id="SPEL"><a href="#SPEL" class="headerlink" title="SPEL"></a>SPEL</h2><p>可以在配置文件中使用SPEL表达式。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;3888+111&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;phone&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>SPEL需要写道value属性中，不能写道ref属性中。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="读取properties文件"><a href="#读取properties文件" class="headerlink" title="读取properties文件"></a>读取properties文件</h3><p>我们可以让Spring读取properties文件的key/value，然后使用其中的值。</p>
<p>①设置读取properties</p>
<p>在Spring配置文件中加入如下标签：指定要读取的文件的路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中的classpath表示类加载路径下。<br>我们也会用到如下的写法classpath:*.properties</p>
<p>②使用配置文件中的值</p>
<p>在我们需要的时候可以使用${key}来表示具体的值。注意要在value属性中的使用才可以。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jdbc.properties --&gt;</span></span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis_db?useSSL=false</span><br><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123456</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="引入Spring配置文件"><a href="#引入Spring配置文件" class="headerlink" title="引入Spring配置文件"></a>引入Spring配置文件</h3><p>​        我们可以在主的配置文件中通过import标签的resource属性，引入其他的xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--applicationContext.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:jdbc.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="bean的配置"><a href="#bean的配置" class="headerlink" title="bean的配置"></a>bean的配置</h2><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>​        我们可以用name属性来给bean取名，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.domain.Dog&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dog1, dog2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小白&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        获取的时候可以使用这个名字来获取。</p>
<h3 id="lazy-init属性"><a href="#lazy-init属性" class="headerlink" title="lazy-init属性"></a>lazy-init属性</h3><p>​        可以控制bean的创建时间，如果设置为true就是在第一次获取该对象的时候才去创建。</p>
<h3 id="init-method属性"><a href="#init-method属性" class="headerlink" title="init-method属性"></a>init-method属性</h3><p>​        可以用来设置初始化方法，设置完后容器创建完对象就会自动帮我们调用对应的方法。<br>​        <strong>注意：配置的初始化方法只能是空参的。</strong></p>
<h3 id="destory-method属性"><a href="#destory-method属性" class="headerlink" title="destory-method属性"></a>destory-method属性</h3><p>​        可以用来设置销毁前调用的方法，设置完后容器销毁对象前就会自动帮我们调用对应的方法</p>
<h3 id="factory-bean-amp-factory-method属性"><a href="#factory-bean-amp-factory-method属性" class="headerlink" title="factory-bean&amp;factory-method属性"></a>factory-bean&amp;factory-method属性</h3><p>​        当我们需要Spring容器使用工厂类来创建对象放入Spring容器的时候可以使用factory-bean&amp;factory-method属性</p>
<p><strong>配置实例工厂创建对象</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建实例工厂类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.factory.CarFactory&quot;</span> <span class="attr">id</span>=<span class="string">&quot;carFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用实例工厂创建Car放入容器--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--factory-bean用来指定使用哪个工厂对象--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--factory-method 用来指定使用哪个工厂方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">factory-bean</span>=<span class="string">&quot;carFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getCar&quot;</span> <span class="attr">id</span>=<span class="string">&quot;car&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathXmlApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">Car c = (Car) app.getBean(<span class="string">&quot;car&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>配置静态工厂创建对象</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建静态工厂类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.factory.CarStaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getCar&quot;</span> <span class="attr">id</span>=<span class="string">&quot;car2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Spring注解开发"><a href="#Spring注解开发" class="headerlink" title="Spring注解开发"></a>Spring注解开发</h2><p>​        为了简化配置，Spring支持使用注解代替xml配置。</p>
<h3 id="注解开发准备工作"><a href="#注解开发准备工作" class="headerlink" title="注解开发准备工作"></a>注解开发准备工作</h3><p>​        如果要使用注解开发必须要开启组件扫描，这样加了注解的类才会被识别出来。Spring才能去解析其中的注解。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--applicationContext.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xiaohupao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        启动组件扫描，扫描对应扫描的包路径，该包及其子包下所有的类都会被扫描，加载包含指定注解的类。</p>
<h3 id="IOC相关注解"><a href="#IOC相关注解" class="headerlink" title="IOC相关注解"></a>IOC相关注解</h3><h4 id="Component，-Controller，-Service，-Repository"><a href="#Component，-Controller，-Service，-Repository" class="headerlink" title="@Component，@Controller，@Service，@Repository"></a>@Component，@Controller，@Service，@Repository</h4><p>​        上述四个类都是加到类上的。它们都可以起到类似bean标签的作用。可以把加了该注解类的对象放入Spring容器中。实际上在使用的时候选择任意一个都可以。但是后三个注解是语义注解。如果是Service类要求使用@Service；如果是Dao类要求使用@Repository；如果是Controller类(SpringMVC中)要求使用@Controller；如果是其它类可以使用@Component。</p>
<h3 id="DI相关注解"><a href="#DI相关注解" class="headerlink" title="DI相关注解"></a>DI相关注解</h3><p>​        如果一个bean已经放入Spring容器中了。那么我们可以使用下列注解实现属性注入，让Spring容器帮我们完成属性赋值。</p>
<h4 id="Vaule"><a href="#Vaule" class="headerlink" title="@Vaule"></a>@Vaule</h4><p>​        主要用于String，Integer等可以直接赋值的属性注入。不依赖于setter方法，支持SPEL表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Value(&quot;199&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="meta">@Value(&quot;xiaohupao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;19+2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired"></a>@AutoWired</h4><p>​        Spring会给加了该注解的属性自动注入数据类型相同的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Value(&quot;199&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="meta">@Value(&quot;xiaohupao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;19+2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AutoWired中的属性介绍</strong><br>@Autowired(required=false)不注入也可以，表示不是必须的。</p>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><p>​        如果相同类型的bean在容器中有多个，单独使用@AutoWired就不能满足要求，这时候可以再加上@Qualifier来指定bean的名字从容器中获取bean的注入。</p>
<p>注意事项：该注解不能单独使用。</p>
<h3 id="xml配置文件相关注解"><a href="#xml配置文件相关注解" class="headerlink" title="xml配置文件相关注解"></a>xml配置文件相关注解</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><p>​        标注在类上，表示当前类是一个配置类，我们可以用注解完全替换掉xml配置文件。</p>
<p>​        注意：如果使用配置类替换了xml配置，spring容器要使用：AnnotationConfigApplicationContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;cn.xiaohupao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext app = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationConfig.class);</span><br><span class="line">        UserService userService = (UserService) app.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        System.out.println(userService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>​        可以用来代替context:component-scan标签来配置组件扫描。</p>
<h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><p>​        可以用来代替bean标签，主要用于第三方类的注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;cn.xiaohupao&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  DruidDataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_db?useSSL=false&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        注意事项：如果同一种类型的对象在容器中只有一个，我们可以不设置bean的名称。</p>
<h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4><p>​        可以用来替换context:property-placeholder，让Spring读取指定的properties文件。然后使用@Value来获取读取到的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;cn.xiaohupao&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  DruidDataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis_db?useSSL=false</span><br><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123456</span><br></pre></td></tr></table></figure>

<p>​        注意事项：在使用@Value注解获取值时要使用${key}来获取。</p>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><ul>
<li>SSM：项目中的类和IOC和DI都使用注解，对第三方jar包中的类，配置组件扫描时使用xml进行配置</li>
<li>SpringBoot：纯注解开发</li>
</ul>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>​        AOP为Aspect Oriented Programming的缩写，意为：面向切面编程。是一种可以在不修改原来的核心代码的情况下给程序动态统一进行增强的一种技术。</p>
<p>​        SpringAOP：批量对Spring容器中bean的方法做增强，并且这种增强不会与原来方法中的代码耦合。</p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>需求让service包下所有类的所有方法在调用前都输出：方法被调用了</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>①添加依赖</p>
<p>需要添加SpringIOC相关依赖和AOP相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②相关bean要注入容器中</p>
<p>开启组件扫描；加@Service注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PhoneService中deleteAll的核心代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserService中deleteAll的核心代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h4><p>①开启AOP注解支持</p>
<p>使用aop:sapectj-autoproxy标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者在配置类上使用@EnableAspectJAutoProxy注解</p>
<p>②创建切面类</p>
<p>创建一个类，在类上加上@Component和@Aspect</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* cn.xiaohupao.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodbefore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法被调用了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@Pointcut注解来指定要被增强的方法；@Before注解来给我们的增强代码所在的方法进行标识，并且指定了增强代码是在被增强方法执行之前执行的。</p>
<p>③测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建容器</span></span><br><span class="line">        AnnotationConfigApplicationContext app = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        PhoneService phoneService = app.getBean(PhoneService.class);</span><br><span class="line">        phoneService.deleteAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><ul>
<li>joinpoint(连接点)：所谓的连接点就是指那些可以被增强到的点。在spring中，这些点指的是方法，因为spring只支持方法类型的连接点。</li>
<li>Pointcut(切入点)：所谓切入点是指被增强的连接点(方法)</li>
<li>Advice(通知/增强)：所谓通知是具体增强的代码</li>
<li>Target(目标对象)：被增强的对象就是目标对象</li>
<li>Aspect(切面)：是切入点和通知(介入)的结合</li>
<li>Proxy(代理)：一个类被AOP增强后，就产生一个结果代理类</li>
</ul>
<h3 id="切点确定"><a href="#切点确定" class="headerlink" title="切点确定"></a>切点确定</h3><h4 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h4><p>可以使用切点表达式来表示要对哪些方法进行增强。</p>
<p>写法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))</p>
<ul>
<li>访问修饰符可以省略，大部分情况下可以省略</li>
<li>返回值类型、包名、类名、方法名可以使用星号*代表任意</li>
<li>包名与类名之间一个点.代表当前包下的类，两个点表示当前包及其子包下的类</li>
<li>参数列表可以使用两个点表示任意个数，任意参数类型的参数列表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* cn.xiaohupao.service.*.*(..)) <span class="comment">//表示cn.xiaohupao.service包下任意类，方法名任意，参数列表任意，返回值类型任意</span></span><br><span class="line">execution(* cn.xiaohupao.service..*.*(..))<span class="comment">//表示cn.xiaohupao.service包下及其子包下任意类，方法名任意，参数列表任意，返回值类型任意</span></span><br><span class="line">execution(* cn.xiaohupao.service.*.*())<span class="comment">//表示cn.xiaohupao.service包下任意类，方法名任意，参数列表为空参，返回值类型任意</span></span><br><span class="line">execution(* cn.xiaohupao.service.*.delete*(..))<span class="comment">//表示cn.xiaohupao.service包下任意类，方法名要求以delete开头，参数列表为空参，返回值类型任意</span></span><br></pre></td></tr></table></figure>

<h4 id="切点函数-annotation"><a href="#切点函数-annotation" class="headerlink" title="切点函数@annotation"></a>切点函数@annotation</h4><p>我们也可以在要增强的方法上加上注解。然后使用@annotation来表示对加了什么注解的方法进行增强。</p>
<p>①自定义一个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InvokeLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②给需要增强的方法增加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InvokeLog</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PhoneService中deleteAll的核心代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③自切面类这使用@annotation来确定增强的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(cn.xiaohupao.aspect.InvokeLog)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodbefore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法被调用了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通知分类"><a href="#通知分类" class="headerlink" title="通知分类"></a>通知分类</h3><ul>
<li>@Before：前置通知，在目标方法执行前执行</li>
<li>@AfterReturning：返回后通知，在目标方法执行后执行，如果出现异常不会执行</li>
<li>@After：后置通知，在目标方法返回结果之后执行，无论是否出现异常都会执行</li>
<li>@AfterThrowing：异常通知，在目标方法抛出异常后执行</li>
<li>@Around：环绕通知，围绕着方法执行</li>
</ul>
<p>理解不同通知执行时机。(利用伪代码来理解单个通知的执行时机，不能用来理解多个通知情况下的执行顺序。如果需要配置多个通知我们会选择使用Around通知，更加清晰并且好用)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    before();<span class="comment">//@Before前置通知</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Object ret = 目标方法();<span class="comment">//目标方法调用</span></span><br><span class="line">        afterReturing();<span class="comment">//@AfterReturning返回后通知</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable throwable)&#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">        afterThrowing();<span class="comment">//@AafterThrowing异常通知</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        after();<span class="comment">//@After后置通知</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>环绕通知非常特殊，它可以对目标方法进行全方位的增强。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(cn.xiaohupao.aspect.InvokeLog)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAround</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目标方法前!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pjp.proceed();<span class="comment">//目标方法执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;目标方法后!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;出现异常通知!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally中的通知！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取被增强方法相关信息"><a href="#获取被增强方法相关信息" class="headerlink" title="获取被增强方法相关信息"></a>获取被增强方法相关信息</h3><p>​        我们对实际对方法进行增强时往往还需要获取到被增强代码的相关信息，比如方法名，参数，返回值，异常对象等。</p>
<p>​        我们可以在除了环绕通知外的所有通知方法中增加一个joinPoint类型的参数。这个参数封装了被增强方法的相关信息。<strong>注意：</strong>我们可以通过这个参数获取到除了异常对象和返回值之外的所有信息。无法获取返回值和异常对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pt1()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    Object[] args = joinPoint.getArgs();<span class="comment">//方法调用时传入的参数</span></span><br><span class="line">    Object target = joinPoint.getTarget();<span class="comment">//被代理对象</span></span><br><span class="line">    MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">    Method method = signature.getMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;方法被调用了!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果需要获取被增强方法中的异常对象或者返回值则需要在方法参数上增加一个对应类型的参数，并且使用注解的属性进行配置。这样Spring会把你想获取的数据赋值给对应的方法参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value = &quot;pt1()&quot;,throwing = &quot;e&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable e)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;AfterThrowable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上面的获取方式特别麻烦难以理解。就可以使用下面这种万能的方法。<br>​        直接在环绕通知方法中增加一个ProceedingJoinPoint类型的参数。这个参数封装了被增强方法的相关信息。该参数的proceed()方法被调用相当于被增强方法被执行，调用后的返回值就相当于被增强方法的返回值。</p>
<h3 id="AOP应用案例"><a href="#AOP应用案例" class="headerlink" title="AOP应用案例"></a>AOP应用案例</h3><h4 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h4><p>现有AI核心功能代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIController</span></span>&#123;</span><br><span class="line">    <span class="comment">//AI自动回答</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAnswer</span><span class="params">(String question)</span></span>&#123;</span><br><span class="line">        String str = question.replace(<span class="string">&quot;吗&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        str = str.replace(<span class="string">&quot;?&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fortuneTelling</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;风来吴山&quot;</span>, <span class="string">&quot;玉泉鱼跃&quot;</span>, <span class="string">&quot;夕照雷锋&quot;</span>, <span class="string">&quot;云飞玉皇&quot;</span>, <span class="string">&quot;梦泉虎跑&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = name.hashCode() % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> strs[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//AI自动回答</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAnswer</span><span class="params">(String question)</span></span>&#123;</span><br><span class="line">        String str = question.replace(<span class="string">&quot;吗&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        str = str.replace(<span class="string">&quot;?&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fortuneTelling</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;风来吴山&quot;</span>, <span class="string">&quot;玉泉鱼跃&quot;</span>, <span class="string">&quot;夕照雷锋&quot;</span>, <span class="string">&quot;云飞玉皇&quot;</span>, <span class="string">&quot;梦泉虎跑&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = name.hashCode() % <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> strs[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建容器</span></span><br><span class="line">        AnnotationConfigApplicationContext app = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationConfig.class);</span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        AIController aiController = app.getBean(AIController.class);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        String answer = aiController.getAnswer(<span class="string">&quot;你好吗?&quot;</span>);</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">        String wk = aiController.fortuneTelling(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        System.out.println(wk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        现在为了保证数据的安全性，要求调用的方法时fortuneTelling传入姓名是经过加密的。我们需要对传入参数进行解密后才能时候。并且要对该方法的返回值进行加密后返回。(后期也可能让其他方法进行相应的加密处理)</p>
<p>​        字符串加密解密直接使用下面的工具类即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AES = <span class="string">&quot;AES&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> keysizeAES = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String charset = <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseByte2HexStr</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span> buf[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.length; i++) &#123;</span><br><span class="line">            String hex = Integer.toHexString(buf[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">            <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">                hex = <span class="string">&#x27;0&#x27;</span> + hex;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(hex.toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] parseHexStr2Byte(<span class="keyword">final</span> String hexStr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hexStr.length() &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[hexStr.length() / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; hexStr.length()/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> high = Integer.parseInt(hexStr.substring(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">1</span>), <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">int</span> low = Integer.parseInt(hexStr.substring(i * <span class="number">2</span> + <span class="number">1</span>, i * <span class="number">2</span> + <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">            result[i] = (<span class="keyword">byte</span>) (high * <span class="number">16</span> + low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">keyGeneratorES</span><span class="params">(<span class="keyword">final</span> String res, <span class="keyword">final</span> String algorithm, <span class="keyword">final</span> String key, <span class="keyword">final</span> Integer keysize, <span class="keyword">final</span> Boolean bEncode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> KeyGenerator g = KeyGenerator.getInstance(algorithm);</span><br><span class="line">            <span class="keyword">if</span> (keysize == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] keyBytes = charset == <span class="keyword">null</span> ? key.getBytes() : key.getBytes(charset);</span><br><span class="line">                g.init(<span class="keyword">new</span> SecureRandom(keyBytes));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                g.init(keysize);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] keyBytes = charset == <span class="keyword">null</span> ? key.getBytes() : key.getBytes(charset);</span><br><span class="line">                SecureRandom random = SecureRandom.getInstance(<span class="string">&quot;SHA1PRNG&quot;</span>);</span><br><span class="line">                random.setSeed(keyBytes);</span><br><span class="line">                g.init(keysize, random);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> SecretKey sk = g.generateKey();</span><br><span class="line">            <span class="keyword">final</span> SecretKeySpec sks = <span class="keyword">new</span> SecretKeySpec(sk.getEncoded(), algorithm);</span><br><span class="line">            <span class="keyword">final</span> Cipher cipher = Cipher.getInstance(algorithm);</span><br><span class="line">            <span class="keyword">if</span> (bEncode) &#123;</span><br><span class="line">                cipher.init(Cipher.ENCRYPT_MODE, sks);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">byte</span>[] resBytes = charset == <span class="keyword">null</span>? res.getBytes() : res.getBytes(charset);</span><br><span class="line">                <span class="keyword">return</span> parseByte2HexStr(cipher.doFinal(resBytes));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cipher.init(Cipher.DECRYPT_MODE, sks);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String(cipher.doFinal(parseHexStr2Byte(res)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">AESencode</span><span class="params">(<span class="keyword">final</span> String res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keyGeneratorES(res, AES, <span class="string">&quot;aA11*-%&quot;</span>, keysizeAES, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">AESdecode</span><span class="params">(<span class="keyword">final</span> String res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keyGeneratorES(res, AES, <span class="string">&quot;aA11*-%&quot;</span>, keysizeAES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">&quot;加密后:&quot;</span> + AESencode(<span class="string">&quot;将要加密的明文&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">&quot;解密后:&quot;</span> + AESdecode(<span class="string">&quot;730CAE52D85B372FB161B39D0A908B8CC6EF6DA2F7D4E595D35402134C3E18AB&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Crypt &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CryptAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定切点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(cn.xiaohupao.aspect.Crypt)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pt</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义通知</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;pt()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">crypt</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取目标方法调用的参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">//对参数进行解密，解密后传入目标方法，执行</span></span><br><span class="line">        String arg1 = (String) args[<span class="number">0</span>];</span><br><span class="line">        String s = CryptUtil.AESdecode(arg1);<span class="comment">//解密</span></span><br><span class="line">        args[<span class="number">0</span>] = s;</span><br><span class="line">        Object proceed = <span class="keyword">null</span>;</span><br><span class="line">        String ret = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceed = pjp.proceed(args);</span><br><span class="line">            <span class="comment">//目标方法执行后需要获取返回值</span></span><br><span class="line">            ret = (String) proceed;</span><br><span class="line">            <span class="comment">//对返回值进行加密后，进行返回</span></span><br><span class="line">            ret = CryptUtil.AESencode(ret);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建容器</span></span><br><span class="line">        AnnotationConfigApplicationContext app = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationConfig.class);</span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        AIController aiController = app.getBean(AIController.class);</span><br><span class="line"></span><br><span class="line">        String name = CryptUtil.AESencode(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        String wk = aiController.fortuneTelling(name);</span><br><span class="line">        System.out.println(wk);</span><br><span class="line">        <span class="comment">//System.out.println(CryptUtil.AESdecode(wk));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用xml方式配置AOP"><a href="#使用xml方式配置AOP" class="headerlink" title="使用xml方式配置AOP"></a>使用xml方式配置AOP</h3><p>①定义切面类</p>
<p>②目标类和切面类注入到容器中</p>
<p>③配置AOP</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义切点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.xiaohupao.service..*.*(..))&quot;</span>&gt;</span>	<span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt2&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;@annotation(cn.xiaohupao.aspect.InvokeLog)&quot;</span></span></span><br><span class="line">    &lt;!--配置切面 --&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:befor</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:befor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturning&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">returning</span>=<span class="string">&#x27;ret&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-fef</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;e&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="多切面顺序问题"><a href="#多切面顺序问题" class="headerlink" title="多切面顺序问题"></a>多切面顺序问题</h3><p>​        在默认情况下Spring有它自己的排序规则。(按类名排序)默认排序规则往往不符合我们的要求，我们需要进行特殊控制。如果是注解方式配置的AOP可以在切面类上加@Order注解来控制顺序。@Order中的属性越小，其优先级别越高。如果是XML方式配置的AOP，通过配置顺序来控制。</p>
<h3 id="AOP原理-动态代理"><a href="#AOP原理-动态代理" class="headerlink" title="AOP原理-动态代理"></a>AOP原理-动态代理</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>​        实际上Spring的AOP其实底层就是使用动态代理来完成的，并且使用了两种动态代理分别是JDK动态代理和Cglib动态代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AIController aiController = <span class="keyword">new</span> AIControllerImpl();</span><br><span class="line">        <span class="comment">/*String answer = aiController.getAnswer(&quot;你好吗?&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(answer);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用动态代理增强这个方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用JDK动态代理</span></span><br><span class="line">        ClassLoader classLoader = Demo.class.getClassLoader();</span><br><span class="line">        <span class="comment">//参数1 类加载器；参数2 被代理类所实现接口的字节码对象数组；参数3 InvocationHandler实现类</span></span><br><span class="line">        AIController o = (AIController) Proxy.newProxyInstance(classLoader, AIControllerImpl.class.getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用代理对象的方法时，会调用invoke</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method 当前被调用的方法封装的</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args 调用方法时传入的参数</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断当前调用的是否是getAnswer方法</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;getAnswer&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;增强！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//调用被代理对象的对应方法</span></span><br><span class="line">                Object ret = method.invoke(aiController, args);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        String answer1 = o.getAnswer(<span class="string">&quot;你好吗?&quot;</span>);</span><br><span class="line">        System.out.println(answer1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cglib动态代理"><a href="#Cglib动态代理" class="headerlink" title="Cglib动态代理"></a>Cglib动态代理</h4><p>​        使用的是org.springframework.cglib.proxy.Enhancer类进行实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(AIControllerImpl.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor()&#123;</span><br><span class="line">           <span class="comment">//使用代理对象执行方法是都会调用intercept方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;getAnswer&quot;</span>.equals(method.getName()))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;增强了!&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                Object ret = methodProxy.invokeSuper(o, objects);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        AIContrillerImpl proxy = (AIContrillerImpl)enhancer.create();</span><br><span class="line">        System.out.println(proxy.fortuneTelling(<span class="string">&quot;你好吗?&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>​        JDK动态代理要求被代理的类必须有接口，生成的代理对象是被代理对象的兄弟关系，或者说是代理接口的实现类。Cglib的动态代理不要求被代理的类实现接口，生成的代理对象相当于被代理对象的子类。</p>
<p>​        Spring的AOP默认情况下优先使用的是JDK的动态代理，如果使用不了JDK的动态代理才会使用Cglib的动态代理。</p>
<h3 id="切换默认动态代理方式"><a href="#切换默认动态代理方式" class="headerlink" title="切换默认动态代理方式"></a>切换默认动态代理方式</h3><p>​        如果我们是采用注解方式配置AOP的话：设置aop:aspectj-autoproxy标签的proxy-target-class属性为true，代理方式就会修改成Cglib。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​        如果我们采用xml方式配置AOP的话：设置aop:config标签的proxy-taget-class属性为true，代理方式就会修改为Cglib</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h3><p>①导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②编写测试类</p>
<p>在测试类上加上@RunWith(SpringJUnit4ClassRunner.class)注解，指定让测试运行于Spring环境<br>@ContextConfiguration注解，指定Spring容器创建需要的配置文件或配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = ApplicationConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJunit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③注入对象进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = ApplicationConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJunit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Value(&quot;199&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="meta">@Value(&quot;xiaohupao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;19+2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询数据库，展示查询到的数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring整合Mybatis"><a href="#Spring整合Mybatis" class="headerlink" title="Spring整合Mybatis"></a>Spring整合Mybatis</h3><p>①导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;cn.xiaohupao.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询数据库，展示查询到的数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User1&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;User1&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis_db?useSSL=false</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p>②往容器中注入整合相关</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--读取properties文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--创建连接池注入容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Mybatis配置文件的路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Mapper扫描器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.xiaohupao.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring声明式事务"><a href="#Spring声明式事务" class="headerlink" title="Spring声明式事务"></a>Spring声明式事务</h3><h4 id="事务回顾"><a href="#事务回顾" class="headerlink" title="事务回顾"></a>事务回顾</h4><p><strong>事务的概念</strong></p>
<p>保证一组数据库的操作，要么同时成功，要么同时失败。</p>
<p><strong>四大特性</strong></p>
<ul>
<li>隔离性：多个事务之间要相互隔离，不能互相干扰</li>
<li>原子性：事务是一个不可分隔的整体，类似于一个不可分割的原子</li>
<li>一致性：事务前后这组数据的状态是一致的，要么都成功，要么都失败</li>
<li>持久性：事务一旦被提交，这组操作就真的发生了变化。即使数据库故障也不应该对其有影响</li>
</ul>
<h4 id="声明式事务的概念"><a href="#声明式事务的概念" class="headerlink" title="声明式事务的概念"></a>声明式事务的概念</h4><p>​        只要简单的加个注解就可以实现事务控制，不需要事务控制的时候只需要去掉相应的注解即可。</p>
<h4 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h4><p>①配置事务管理器和事务注解驱动</p>
<p>在spring的配置文件中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务管理器注入spring容器，需要配置一个连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启事务注解驱动，配置使用的事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>②添加注解</p>
<p>在需要进行事务控制的方法或者类上添加@Transactional注解就可以实现事务控制。</p>
<p>注意：如果加在类上，这个类的所有方法都会受事务控制，如果加在方法上，就是那一个方法受事务控制。</p>
<h4 id="xml方式实现"><a href="#xml方式实现" class="headerlink" title="xml方式实现"></a>xml方式实现</h4><h4 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h4><p>事务传播行为propagation</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED(必须要有)</td>
<td>外层方法有事务，内层方法就加入，外层没有，内层就新建。</td>
</tr>
<tr>
<td>REQUIRED_NEW(必须有新事物)</td>
<td>外层方法有事务，内层方法新建。外层没有，内层也新建。</td>
</tr>
<tr>
<td>SUPPORTS(支持有)</td>
<td>外层方法有事务，内层方法就加入。外层没有，内层也就没有。</td>
</tr>
<tr>
<td>NOT_SUPPORTED(支持没有)</td>
<td>外层方法有事务，内层方法没有。外层没有，内层也没有。</td>
</tr>
<tr>
<td>MANDATORY(强制要求有)</td>
<td>外层方法有事务，内层方法加入。外层没有，内层就报错。</td>
</tr>
<tr>
<td>NEVER(绝不允许有)</td>
<td>外层方法有，内层方法就报错。外层没有，内层也就没有。</td>
</tr>
</tbody></table>
<p><strong>隔离级别isolation</strong></p>
<p>Isolation.DEFAULT 使用数据库默认隔离级别</p>
<p>Isolation.READ_UNCOMMITTED</p>
<p>Isolation.READ_COMMITTED</p>
<p>Isolation.REPEATABLE_READ</p>
<p>Isolation.SERIALIZABLE</p>
<p><strong>readOnly</strong></p>
<p>如果事务中的操作都是读操作，没有涉及到对数据库的写操作可以设置readOnly为true。这样可以提高效率。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="算法与算法分析"><a href="#算法与算法分析" class="headerlink" title="算法与算法分析"></a>算法与算法分析</h2><ul>
<li>算法效率以下两个方面来考虑：<ul>
<li><strong>时间效率</strong>：指的是算法所耗费的时间</li>
<li><strong>空间效率</strong>：指的是算法执行过程中所消耗的存储空间</li>
</ul>
</li>
<li><strong>时间效率和空间效率有时候是矛盾的</strong></li>
</ul>
 <span id="more"></span> 

<h3 id="算法时间效率度量"><a href="#算法时间效率度量" class="headerlink" title="算法时间效率度量"></a>算法时间效率度量</h3><ul>
<li>算法时间效率可以依据该算法编制的程序在计算机上执行所消耗的时间来度量</li>
<li>两种度量方式<ul>
<li>事后统计<ul>
<li>将算法实现，测算其时间和空间开销</li>
<li>缺点：编写程序实现算法将花费较多的时间和精力；所得实验结果依赖于计算机得软硬件等环境因素，掩盖算法本身的优劣</li>
</ul>
</li>
<li>事前分析<ul>
<li>对算法所消耗资源的一种估算方法</li>
<li>一个算法的运行时间是指一个算法在计算机上运行所消耗的时间大致可以等于计算机执行一种简单的操作所需的时间与算法中进行的简单操作次数乘积。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>算法的运行时间 = 一个简单操作所需的时间 x 简单操作次数</strong><br><strong>算法的运行时间 = $\sum$每条语句执行的次数 x 该语句执行一次所需要的时间</strong><br><strong>算法的运行时间 = $\sum$每条语句频度 x 该语句执行一次所需要的时间</strong></p>
<p>​        每条语句执行的一次所需要的时间，一般是随机器而异的。取决于机器的指令性能、速度以及编码的代码质量。是由机器本身软硬件环境决定的，它与算法无关。<br>​        所以，我们可以假设执行每条语句所需要的时间均为单位时间。此时对算法的运行时间的讨论就可以转化为该算法中所有语句的执行次数，即频度之和。<br>​        这就可以独立于不同机器的软硬件环境来分析算法的时间性能了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//矩阵乘法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] MatrixMultiplication(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//n+1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;<span class="comment">//n(n+1)次</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;<span class="comment">//n*n(n+1)次</span></span><br><span class="line">                c[i][j] += a[i][k] * b[k][j];<span class="comment">//n*n*n次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们把算法所消耗的时间定义为该算法中每条语句的频度之和，则上述算法的时间消耗T(n)为：$2n^3+3n^2+2n+1$</p>
<p><strong>算法时间复杂度的渐进表示法</strong></p>
<ul>
<li>为了便于比较不同算法的时间效率，我们仅比较它们的数量级。</li>
<li>若有某个辅助函数f(n)，使得当n趋近于无穷大时，$T(n)/f(n)$的极限为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作$T(n)=O(f(n))$，称$O(f(n))$为算法的渐进时间复杂度(O是数量级的符号)，简称时间复杂度。</li>
<li>一般情况下，不必计算所有操作的执行次数，而只考虑算法中基本操作执行的次数，它是问题规模n的某个函数，用$T(n)$表示。</li>
</ul>
<p>上述矩阵相乘问题的时间复杂度为$O(n^3)$</p>
<h3 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h3><p>​        算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度记为：$T(n)=O(f(n))$</p>
<h3 id="分析算法时间复杂度的基本方法"><a href="#分析算法时间复杂度的基本方法" class="headerlink" title="分析算法时间复杂度的基本方法"></a>分析算法时间复杂度的基本方法</h3><p>定理1.1 若$f(n)=a_mn^m+a_{m-1}n^{m-1}+…+a_1n+a_0$是m次多项式，则$T(n)=O(n^m)$</p>
<ul>
<li>找出语句频度最大的那条语句作为基本语句</li>
<li>计算基本语句的频度得到问题规模n的某个函数$f(n)$</li>
<li>取其数量级用符号“O”表示</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        c[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">            c[i][j] = c[i][j]+a[i][k] * b[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>\sum_{i=1}^{n}\sum_{j=1}^{n}\sum_{k=1}^n1=\sum_{i=1}^{n}\sum_{j=1}^{n}n=\sum_{i=1}^{n}n^2=n^3<br>$$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">1</span>;k &lt;= j; k++)</span><br><span class="line">            x=x+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>$$<br>\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^j1=\sum_{i=1}^n\sum_{j=1}^ij=\sum_{i=1}^n\frac{(1+i)i}{2}=\frac{1}{2}(\sum_{i=1}^ni^2+\sum_{i=1}^ni)=(\frac{1}{2})(\frac{n(n+1)(2n+1)}{6}+\frac{n(n+1)}{2})=\frac{n(n+1)(n+2)}{6}<br>$$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例3</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">    i = i * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>$$<br>2^{f(n)} &lt;= n;f(n)&lt;=log_2n;T(n)=log_2n<br>$$</p>
<h3 id="算法时间复杂度计算"><a href="#算法时间复杂度计算" class="headerlink" title="算法时间复杂度计算"></a>算法时间复杂度计算</h3><p>​        请注意：有的情况下，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]==e) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>最好情况：1次</li>
<li>最坏情况：n次</li>
<li>平均时间复杂度为：$O(n)$</li>
</ul>
<p>最坏时间复杂度：指在最坏情况下，算法的时间复杂度<br>平均时间复杂度：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间<br>最好时间复杂度：指在最好情况下，算法的时间复杂度</p>
<p>​        一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p>
<p>​        对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大O加法法则和乘法法则，计算算法的时间复杂度：<br>​        加法规则：$T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))$<br>​        乘法法则：<br>$T(n)=T_1(n)\times T_2(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$</p>
<h3 id="算法时间效率的比较"><a href="#算法时间效率的比较" class="headerlink" title="算法时间效率的比较"></a>算法时间效率的比较</h3><p>​        当n取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊。</p>
<p><strong>时间复杂度$T(n)$按数量级递增顺序</strong></p>
<p>​        常数阶-&gt; 对数阶 -&gt; 线性阶 -&gt; 线性对数阶 -&gt; 平方阶 -&gt; 立方阶 -&gt; … -&gt;K方阶 -&gt; 指数阶。</p>
<h3 id="渐进空间复杂度"><a href="#渐进空间复杂度" class="headerlink" title="渐进空间复杂度"></a>渐进空间复杂度</h3><p>​        空间复杂度：算法所需要存储空间的度量，记作：$S(n)=O(f(n))$，其中n为问题的规模大小。<br>​        算法要占据的空间：算法本身要占据的空间，输入/输出，指令，常数，变量等；算法要使用的<strong>辅助空间</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code1</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    t=a[i];</span><br><span class="line">    a[i]=a[n-i<span class="number">-1</span>];</span><br><span class="line">    a[n-i<span class="number">-1</span>]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//code2</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    b[i]=a[n-i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    a[i]=b[i];</span><br></pre></td></tr></table></figure>

<p>​        code1中$S(n)=O(1)$原地工作，code2中$S(n)=O(n)$。</p>
<h3 id="设计好算法的过程"><a href="#设计好算法的过程" class="headerlink" title="设计好算法的过程"></a>设计好算法的过程</h3><p>抽象数据类型=数据的逻辑结构+抽象运算<br>        数据的逻辑结构可以有多种数据的存储结构；基于不同的数据存储结构可以有不同的算法；不同的算法考虑其渐进的时间复杂度和渐进的空间复杂度；最后得出好的算法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[数据结构]--&gt;B[数据的逻辑结构]</span><br><span class="line">A[数据结构]--&gt;C[数据的存储结构]</span><br><span class="line">A[数据结构]--&gt;D[数据的运算]</span><br><span class="line">B[数据的逻辑结构]--&gt;E[线性结构]</span><br><span class="line">B[数据的逻辑结构]--&gt;F[非线性结构]</span><br><span class="line">E[线性结构]--&gt;G[线性表]</span><br><span class="line">E[线性结构]--&gt;H[栈--特殊的线性表]</span><br><span class="line">E[线性结构]--&gt;I[队列--特殊的线性表]</span><br><span class="line">E[线性结构]--&gt;J[字符串-数组-广义表]</span><br><span class="line">F[非线性结构]--&gt;K[树形结构]</span><br><span class="line">F[非线性结构]--&gt;L[图形结构]</span><br><span class="line">C[数据的存储结构]--&gt;M[顺序存储]</span><br><span class="line">C[数据的存储结构]--&gt;N[链式存储]</span><br><span class="line">D[数据的运算]--&gt;O[检索-排序-插入-删除-修改]</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h3><ul>
<li>线性表(Linear List)：由$n(n&gt;=0)$个数据元素(结点)$a_1,…,a_n$组成的有限序列</li>
<li>其中数据元素的个数为n定义为表的长度</li>
<li>当n=0时称为空表</li>
<li>将非空的线性表(n&gt;0)记作：$(a_1,a_2,…,a_n)$</li>
<li>这里的数据元素$a_i(1&lt;=i&lt;=n)$只是一个抽象的符号，其具体含义在不同的情况下可以不同</li>
</ul>
<p>同一线性表中的元素必定具有相同特性，数据元素间的关系是线性关系。</p>
<p><strong>线性表的逻辑特征</strong></p>
<ul>
<li>从非空的线性表，有且仅有一个开始结点$a_1$，它没有直接前驱，而仅有一个直接后继$a_2$；</li>
<li>有且仅有一个终端结点$a_n$，它没有直接后继，而仅有一个直接前驱$a_{n-1}$</li>
<li>其余的内部结点$a_i(2&lt;=i&lt;=n-1)$都有仅有一个直接前驱$a_{i-1}$和一个直接后继$a_{i+1}$。</li>
</ul>
<p><strong>线性表是一种典型的线性结构。</strong></p>
<h3 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a>案例引入</h3><p>​        <strong>一元多项式的运算：实现两个多项式加、减、乘运算</strong></p>
<p>$P_n(x)=p_0+p_1x+p_2x^2+…+p_nx^n$</p>
<p>例如：$P(x)=10+5z-4x^2+3x^3+2x^4$用数组来表示[10, 5, -4, 3, 2]</p>
<p>$R_n(x)=P_n(x)+Q_m(x)$-&gt;线性表$R=(p_0+q_0,p_1+q_1,…,p_m+q_m,p_{m+1},…p_n)$</p>
<p>​        <strong>稀疏多项式的运算：</strong></p>
<p>$S(x)=1+3x^{10000}+2x^{20000}$</p>
<p>例如：$A(x)=7+3x+9x^8+5z^{17}$$B(X)=8x+22x^7-9x^8$</p>
<p>线性表$A=((7,0),(3,1),(9,8),(5,17))$；线性表$B=((8,1),(22,7),(-9,8))$</p>
<p>$P_n(x)=p_1x^{e1}+p_2x^{e2}+…+p_mx^{em}$-&gt;线性表$P=((p_1,e_1),(p_2,e_2),…,(p_m,e_m))$</p>
<p>​        <strong>图书信息管理系统：</strong>需要的功能：查找、插入、删除、修改、排序、计数</p>
<p><strong>总结</strong></p>
<p>​        线性表中数据元素的类型可以为简单类型，也可以为复杂类型。许多实际应用问题所涉及的基本操作有很大相似性，不应为每个具体应用单独编写一个程序。从具体应用中抽象出共性的逻辑结构和基本操作(抽象数据类型)，然后实现其存储结构和基本操作。</p>
<h3 id="线性的类型定义"><a href="#线性的类型定义" class="headerlink" title="线性的类型定义"></a>线性的类型定义</h3><p><strong>基本操作</strong></p>
<ul>
<li>InitList(&amp;L)：构造一个空的线性表L</li>
<li>DestroyList(&amp;L)：销毁线性表L</li>
<li>ClearList(&amp;L)：将线性表L重置为空表</li>
<li>ListEmpty(&amp;L)：若线性表L为空表，则返回true；否则返回false</li>
<li>ListLength(&amp;L)：返回线性表L中的数据元素个数</li>
<li>GetElem(L,i,&amp;e)：用e返回线性表L中第i个数据元素的值</li>
<li>LocateElem(L,e,compare())：返回L中第一个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0。</li>
<li>PriorElem(L,cur_e,&amp;pre_e)：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义</li>
<li>NextElem(L,cur_e,&amp;next_e)：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败；next_e无意义</li>
<li>ListInsert(&amp;L,i,e)：在L的第i个位置之前插入新的数据元素e，L的长度+1</li>
<li>ListDelete(&amp;L,i,&amp;e)：删除L的第i个数据元素，并用e返回其值，L的长度-1</li>
<li>ListTraverse(&amp;L,visited())：依次对线性表中每个元素调用visited()</li>
</ul>
<p>以上所提及的运算是逻辑结构上定义的运算。只要给出这些运算的功能是“做什么”，至于“如何做”等实现细节，只有待确定了存储结构之后才考虑。</p>
<h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><p><strong>顺序存储结构</strong></p>
<p>​        线性表的顺序表示又称为顺序存储结构或顺序映像。<br>​        <strong>顺序存储定义</strong>：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。线性表顺序存储结构占用一片连续的存储空间。知道某个元素的存储位置就可以计算其他元素的存储位置。</p>
<p><strong>顺序表中元素存储位置的计算</strong></p>
<p>​        假设线性表的每个元素需占l个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系：$LOC(a_{i+1})=LOC(a_i) + l$。由此，所有数据元素的存储位置均可由第一个数据元素的存储位置得到：$LOC(a_i)=LOC(a_1) +(i-1)\times l$</p>
<p>​        顺序表的特点：以物理位置相邻表示逻辑关系。任一元素均可随机存取。</p>
<p><strong>顺序表的顺序存储表示</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType elem[LIST_INIT_SIZE];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>多项式的顺序存储结构类型定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> p;<span class="comment">//系数</span></span><br><span class="line">    <span class="keyword">int</span> e;<span class="comment">//指数</span></span><br><span class="line">&#125;Polynomial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Polynomial *elem;<span class="comment">//存储空间基地址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//多项式中当前项的个数</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p><strong>顺序表基本操作的实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.elem= <span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.elem) <span class="keyword">delete</span> L.elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(SqList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SqList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序表的取值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=L.elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机存取</span></span><br></pre></td></tr></table></figure>

<p><strong>顺序表的查找</strong></p>
<p>​        在线性表L中查找与指定值e相同的数据元素的位置；从表的一端开始，逐个进行记录关键字和给定值的比较。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(L.elem[i] == e) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最坏时间复杂度：O(N);空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>

<p>​        平均查找长度ASL(Average Search Length)：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值叫做查找算法的平均查找长度。<br>$$<br>ASL=\sum_{i=1}^n P_iC_i<br>$$<br>若每个记录的查找概率相等则：<br>$$<br>ASL=\sum_{i=1}^n\frac{1}{n}C_i=\frac{1}{n}\frac{(1+n)n}{2}=\frac{n+1}{2}<br>$$<br>顺序表的平均查找时间复杂度为O(n)</p>
<p><strong>顺序表的插入</strong></p>
<p>插入不同的位置：插入位置在最后，插入位置在中间，插入位置在最前面。</p>
<p>算法思想：①判断插入位置是否合理；②判断顺序表存储空间是否满，若已满返回ERROR；③将第n至第i位的元素依次向后移动一个位置，空出第i个位置；④将要插入的新元素e放入第i个位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(L.length==MAXSIZE) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span>(j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">        L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line">    L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序表的插入算法分析：</strong></p>
<ul>
<li>若插入在尾节点之后，则根本无需移动</li>
<li>若插入在首结点之前，则表中元素全部后移</li>
<li>考虑在各种位置插入的平均移动次数为：</li>
</ul>
<p>$$<br>E_{ins}=\frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac{1}{n+1}\frac{n(n+1)}{2}=\frac{n}{2}<br>$$</p>
<p>顺序表插入算法的平均时间复杂度为O(n)</p>
<p><strong>顺序表的删除</strong></p>
<p>删除不同的位置：删除位置在最后，删除位置在中间，删除位置在最前面</p>
<p>算法思想：①判断删除位置i是否合法；②将删除的元素保留；③将第i+1至第n位的元素依次向前移动一个位置；④表长减一，删除成功返回OK</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListRemove_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span>(j=i; j&lt;=L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        L.elem[j<span class="number">-1</span>]=L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序表的删除算法分析：</strong></p>
<ul>
<li>若删除尾节点，则根本无序移动</li>
<li>若删除首结点，则表中n-1个元素全部前移</li>
<li>若要考虑在各种位置上的平均移动次数为：</li>
</ul>
<p>$$<br>E_{del}=\frac{1}{n}\sum_{i=1}^n(n-i)=\frac{1}{n}\frac{(0+n-1)n}{2}=\frac{n-1}{2}<br>$$</p>
<p>顺序表的删除算法的平均时间复杂度为：O(n)</p>
<p><strong>总结：</strong></p>
<p>​        顺序表的特点：①利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致；②在访问线性表时，可以快速计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等。这种存取元素的方法被称为随机存取法。</p>
<p>​        顺序表的操作算法分析：<br>时间复杂度：插入、查找、删除算法的平均时间复杂度为O(n)<br>空间复杂度：显然，顺序表操作算法的空间复杂度S(n)=O(1)</p>
<p>顺序表的优点：</p>
<ul>
<li>存储密度大(结点本身所占存储量/结点结构所占存储量)</li>
<li>可以随机存取表中任一元素</li>
</ul>
<p>顺序表的缺点：</p>
<ul>
<li>在插入、删除某一个元素时，需要移动大量元素</li>
<li>浪费存储空间</li>
<li>属于静态存储形式，数据元素的个数不能自由扩张</li>
</ul>
<h3 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h3><p><strong>链式存储结构</strong></p>
<p>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻<br>线性表的链式表示又称为非顺序映像或链式映像。</p>
<ul>
<li>用一组物理位置任意的存储单元来存放线性表的数据元素。</li>
<li>这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上的。</li>
<li>链表中元素的逻辑次序和物理次序不一定相同。</li>
</ul>
<p><strong>与链式存储有关的术语</strong></p>
<ul>
<li>结点：数据元素的存储映像。由数据域和指针域两部分组成</li>
<li>链表：n个结点由指针链组成的一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构。</li>
</ul>
<p><strong>单链表、双链表、循环链表：</strong></p>
<ul>
<li>结点只有一个指针域的链表，称为单链表或线性链表</li>
<li>结点有两个指针域的链表，称为双链表</li>
<li>首尾相接的链表称为循环链表</li>
</ul>
<p><strong>头指针、头结点和首元结点：</strong></p>
<ul>
<li>头指针：是指向链表中第一个结点的指针</li>
<li>首元结点：是指链表中存储第一个数据元素$a_1$的结点</li>
<li>头结点：是在链表的首元结点之前附设的一个结点</li>
</ul>
<p><strong>链表的存储结构示意图有以下两种形式：</strong></p>
<ul>
<li>不带头结点</li>
<li>带头结点</li>
</ul>
<p><strong>如何表示空表？</strong></p>
<p>无头结点时，头指针为空时表示空表；有头结点时，当头结点的指针域为空表示空表。</p>
<p><strong>链表中设置头结点有什么好处？</strong></p>
<ul>
<li>便于首元结点的处理：首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理。</li>
<li>便于空表和非空表的统一处理：无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。</li>
</ul>
<p><strong>头结点的数据域内装的是什么？</strong></p>
<p>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。</p>
<p><strong>链表(链式存储结构)的特点：</strong></p>
<ul>
<li>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻</li>
<li>访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等</li>
</ul>
<h4 id="单链表的定义和表示"><a href="#单链表的定义和表示" class="headerlink" title="单链表的定义和表示"></a>单链表的定义和表示</h4><p>单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名若头指针名是L，则把链表称为表L。</p>
<p><strong>单链表的存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">next</span>;</span><span class="comment">//结点的指针域</span></span><br><span class="line">&#125;Lnode, *LinkList;</span><br></pre></td></tr></table></figure>

<p>例如，存储学生学号、姓名、成绩的单链表结点类型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Struct student&#123;</span><br><span class="line">    <span class="keyword">char</span> num[<span class="number">8</span>];<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">8</span>];<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> score;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;Lnode, *LinkList;</span><br></pre></td></tr></table></figure>

<p><strong>单链表基本操作的实现</strong></p>
<p><strong>单链表的初始化：</strong>构造一个空表<br>算法步骤：①生成新结点作为头结点，用头指针L指向头结点；②将头结点的指针域置空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断链表是否为空：</strong><br>算法思路：判断头结点指针域是否为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单链表的销毁：</strong>链表销毁后不存在<br>算法思路：从头指针开始，依次释放所有结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    Lnode *p;</span><br><span class="line">    <span class="keyword">while</span>(L)&#123;</span><br><span class="line">        p=L;</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>清空链表：</strong>链表仍存在，但链表中无元素，成为空链表(头指针和头结点仍然在)<br>算法思路：依次释放所有结点，并将头结点指针域设置为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">clearList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    Lnode *p, *q;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>求单链表的表长</strong><br>算法思路：从首元结点开始，依次计数所有结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取值</strong>——取单链表中的第i个元素的内容<br>算法思路：从链表的头指针出发，顺着链域next逐个结点向下搜索，直到搜索到第i哥结点为止。因此，链表不是随机存取结构。<br>算法步骤：①从第一个结点顺链扫描，用指针p指向当前扫描到的结点，p初值p=L-&gt;next；②j做计数器，累计当前扫描过的结点数，j初值为1；③当p指向扫描到的下一结点，计数器j+1；④当j==i时，p所指的结点就是要找的第i个结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">getElem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>, j&lt;i &amp;&amp; p; j++)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找：</strong>①按值查找，根据指定数据获取该数据所在的位置；②按值查找，根据指定数据获取该数据所在的位置序号。</p>
<p>按值查找：<br>算法步骤：①从第一个结点起，依次和e相比较；②如果找到一个其值与e相等的数据元素，则返回其在链表中的“位置”或地址；③如果查遍整个链表都没有找到其值和e相等的元素，则返回0或“NULL”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Lnode *<span class="title">LocateElem_L</span><span class="params">(LinkList L, Elemtype e)</span></span>&#123;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp;p-&gt;data!=e)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateELem_L</span><span class="params">(LinkList L, Elemtype e)</span></span>&#123;</span><br><span class="line">    p=L-&gt;next;j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data!=e)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p) <span class="keyword">return</span> j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入</strong>—在第i个结点前插入值为e的新结点</p>
<p>算法步骤：①首先找到$a_{i-1}$的存储位置p；②生成一个数据域为e的新结点s；③插入新结点：(1)新结点的指针域指向结点$a_i$【s-&gt;next=p-&gt;next】；(2)结点$a_{i-1}$的指针域指向新结点【p-&gt;next = s】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    p=L;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">    s=<span class="keyword">new</span> LNode;</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong>——删除第i个结点<br>算法步骤：①首先找到$a_{i-1}$的存储位置p，保存要删除的$a_i$的值；②令p-&gt;next指向$a_{i+1}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    p=L;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next  &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ==j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="number">-1</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    e=q-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单链表的查找、插入、删除算法时间效率分析</strong></p>
<p>查找：O(n)；插入和删除：O(1)，但是，如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n)。</p>
<p><strong>单链表的建立</strong></p>
<p>头插法：每次把新元素插在链表头部，也叫前插法。</p>
<p>算法步骤：①从一个空表开始，重复读入数据；②生成新结点，将读入数据存放到新结点的数据域中；③从最后一个结点开始，依次将各结点插入到链表的前端</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_H</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">        p=<span class="keyword">new</span> LNode;</span><br><span class="line">        cin&gt;&gt;p-&gt;data;</span><br><span class="line">        p-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为：O(n)</p>
<p>尾插法：元素插入在链表尾部，也叫后插法。</p>
<p>算法步骤：①从一个空表L开始，将新结点逐个插入到链表的尾部，尾指针r指向链表的尾节点；②初始化，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾节点后，r指向新结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_R</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r=L;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        p=<span class="keyword">new</span> LNode;</span><br><span class="line">        cin&gt;&gt;p-&gt;data;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next=p;</span><br><span class="line">        r=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环链表</strong></p>
<p>​        循环链表是一种头尾相接的链表。</p>
<p>优点：从表中的任一结点出发均可以找到表中其他结点。</p>
<p>注意：由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p-&gt;next是否为空，而是判断它们是否等于头指针。</p>
<p><strong>带尾指针的循环链表的合并</strong></p>
<p>分析操作：p存表头结点、Tb表头链接到Ta表尾，释放Tb表头结点，修改指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Connect</span><span class="params">(LinkList Ta, Linklist Tb)</span></span>&#123;</span><br><span class="line">    p=Ta-&gt;next;</span><br><span class="line">    Ta-&gt;next=Tb-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> Tb-&gt;next;</span><br><span class="line">    Tb-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> Tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为：O(1)</p>
<p><strong>双向链表</strong></p>
<p>双向链表：在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了有两个方向不同的链，故称为双向链表。</p>
<p>双向链表的结构定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure>

<p><strong>双向循环链表</strong></p>
<p>和单链表的循环链表类似，双向链表也可以有循环表：让头结点的前驱指针指向链表的最后一个结点；让最后一个结点的后继指针指向头结点。</p>
<p>双向链表结构的对称性：p-&gt;prior-&gt;next=p=p-&gt;next-&gt;prior</p>
<p>在双向链表中有些操作(如：ListLength、GetElem等)，因仅涉及一个方向的指针，故它们的算法与线性链表的相同。但在插入、删除时，则需要同时修改两个方向上的指针，两者的操作的时间复杂度均为O(n)。</p>
<p><strong>双向链表的插入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L, Int i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(p=<span class="built_in">GetElemp_DuL</span>(L,i))) ERROR;</span><br><span class="line">    s=<span class="keyword">new</span> DuLNode;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;prior=p-&gt;prior;</span><br><span class="line">    s-&gt;next=p;</span><br><span class="line">    p-&gt;prior-&gt;next=s;</span><br><span class="line">    p-&gt;prior=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双向链表的删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDelete_DuL</span><span class="params">(DuLink &amp;L, Int i, Elemtyle &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(p=<span class="built_in">GetElemP_DuL</span>(L,i))) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单链表、循环链表、双向链表的时间效率比较</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>查找表头结点(首元结点)</th>
<th>查找表尾结点</th>
<th>查找结点*p的前驱结点</th>
</tr>
</thead>
<tbody><tr>
<td>带头结点的单链表L</td>
<td>L-&gt;next时间复杂度O(1)</td>
<td>从L-&gt;next依次向后遍历时间复杂度O(n)</td>
<td>通过p-&gt;next无法找到其前驱</td>
</tr>
<tr>
<td>带头结点仅设头指针L的循环单链表</td>
<td>L-&gt;next时间复杂度O(1)</td>
<td>从L-&gt;next依次向后遍历时间复杂度O(n)</td>
<td>通过p-&gt;next可以找到其前驱时间复杂度O(n)</td>
</tr>
<tr>
<td>带头结点仅设尾指针R的循环单链表</td>
<td>R-&gt;next时间复杂度O(1)</td>
<td>R时间复杂度为O(1)</td>
<td>通过p-&gt;next可以找到其前驱时间复杂度O(n)</td>
</tr>
<tr>
<td>带头结点的双向循环链表L</td>
<td>L-&gt;next时间复杂度O(1)</td>
<td>L-&gt;prior时间复杂度O(1)</td>
<td>p-&gt;prior时间复杂度O(1)</td>
</tr>
</tbody></table>
<h3 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h3><ul>
<li>链式存储结构的优点：<ul>
<li>结点空间可以动态申请和释放</li>
<li>数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素</li>
</ul>
</li>
<li>链式存储的缺点：<ul>
<li>存储密度小，每个结点的指针域需要额外占用存储空间。当每个结点的数据域所占字节不多时，指针域所占存储空间的必重显得很大。<ul>
<li>存储密度：是指结点数据本身所占的存储量和整个结点结构中所占的存储量之比。</li>
</ul>
</li>
<li>链式存储结构是非随机存取结构。对任一结点的操作都要从头指针依指针链查找到该结点，这增加了散发的复杂度。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>比较项目</th>
<th>存储结构</th>
<th>顺序表</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>空间</td>
<td>存储空间</td>
<td>预先分配，会导致空间闲置或溢出现象</td>
<td>动态分配，不会出现存储空间闲置或溢出现象</td>
</tr>
<tr>
<td></td>
<td>存储密度</td>
<td>不用为表示结点间的逻辑关系而增加额外的存储开销，存储密度等于1</td>
<td>需要借助指针来体现元素间的逻辑关系，存储密度小于1</td>
</tr>
<tr>
<td>时间</td>
<td>存取元素</td>
<td>随机存取，按位置访问元素的时间复杂度为O(1)</td>
<td>顺序存取，按位置访问元素时间复杂度为O(n)</td>
</tr>
<tr>
<td></td>
<td>插入和删除</td>
<td>平均移动约表中一半元素，时间复杂度为O(n)</td>
<td>不需要移动元素，确定插入、删除位置后，时间复杂度为O(1)</td>
</tr>
<tr>
<td>适用情况</td>
<td></td>
<td>表长变化不大，且能事先确定变化的范围；很少进行插入或删除操作，经常按元素位置序号访问数据元素</td>
<td>长度变化较大；频繁进行插入或删除操作</td>
</tr>
</tbody></table>
<h3 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h3><p><strong>线性表的合并</strong></p>
<p>假设利用两个线性表La和Lb分别表示两个集合A和B，现要求一个新的集合A=AUB</p>
<p>算法步骤：依次取出Lb中的元素，执行以下操作：在La中查找该元素；如果找不到，则将其插入到La的最后</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(List &amp;La, List Lb)</span></span>&#123;</span><br><span class="line">    La_len=<span class="built_in">ListLength</span>(La);</span><br><span class="line">    Lb_len=<span class="built_in">ListLength</span>(Lb);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=Lb_len;i++)&#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(Lb,i,e);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(La,e))</span><br><span class="line">            <span class="built_in">ListInsert</span>(&amp;La, ++La_len,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有序表的合并</strong></p>
<p>一致线性表La和Lb中的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc，且Lc中的数据元素按值非递减有序排列。</p>
<p>算法步骤：创建一个空表Lc；依次从La或Lb中摘取元素较小的结点插入到Lc表的最后，直至其中一个表空为止；继续将La或Lb其中一个表中的剩余结点插入在Lc表的最后。</p>
<p><strong>顺序表的实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList LA, SqList LB, SqList &amp;LC)</span></span>&#123;</span><br><span class="line">    pa=LA.elem;</span><br><span class="line">    pb=LB.elem;</span><br><span class="line">    LC.length=LA.length+LB.length;</span><br><span class="line">    LC.elem=<span class="keyword">new</span> ElemTupe[LC.length];</span><br><span class="line">    pc=LC.elem;</span><br><span class="line">    pa_last=LA.elem+LA.length<span class="number">-1</span>;</span><br><span class="line">    pb_last=LB.elem+LB.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pa &lt;=pa_last &amp;&amp; pb &lt;= pb_last)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*pa &lt;= *pb) *pc++ = *pa++;</span><br><span class="line">        <span class="keyword">else</span> *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pa &lt;= pa_last) *pc++ = *pa++;</span><br><span class="line">    <span class="keyword">while</span>(pb &lt;= pb_last) *pc++ = *pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为：O(ListLength(La) + ListLength(Lb))；算法的空间复杂度是：O(ListLength(La) + ListLength(Lb))</p>
<p><strong>链表的实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">    pa=La-&gt;next;</span><br><span class="line">    pb=Lb-&gt;next;</span><br><span class="line">    pc=Lc=La;</span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class="line">            pc-&gt;next=pa;</span><br><span class="line">            pc=pa;</span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pc-&gt;next=pb;</span><br><span class="line">            pc=pb;</span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next=pa ? pa : pb;</span><br><span class="line">    <span class="keyword">delete</span> Lb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法的时间复杂度为O(ListLength(La) + ListLength(Lb))；空间复杂度为：O(1)。</p>
<h3 id="案例分析与实现"><a href="#案例分析与实现" class="headerlink" title="案例分析与实现"></a>案例分析与实现</h3><h4 id="一元多项式的运算：实现两个多项式加、减、乘运算"><a href="#一元多项式的运算：实现两个多项式加、减、乘运算" class="headerlink" title="一元多项式的运算：实现两个多项式加、减、乘运算"></a>一元多项式的运算：实现两个多项式加、减、乘运算</h4><p>例如：$P_a(x)=10+5x-4x^2+3x^3+2x^4,P_b(x)=-3+8x+4x^2-5x^4+7x^5-2x^6$</p>
<h4 id="稀疏多项式的运算"><a href="#稀疏多项式的运算" class="headerlink" title="稀疏多项式的运算"></a>稀疏多项式的运算</h4><p>例如：$A(x)=7+3x+9x^8+5x^{17}, B(X)=8x+22x^7-9x^8$<br>线性表A=((7,0), (3,1), (9,8), (5,17))；线性表B=((8,1), (22,7), (-9,8))</p>
<p>顺序存储结构实现：<br>算法步骤：创建一个新数组c；分别从头遍历比较a和b的每一项：指数相同，对应系数相加，若其和不为零，则在c中增加一个新项，指数不相同，则将指数较小的项复制到C中；一个多项式已遍历完毕，将另一个剩余项依次复制到c中即可。</p>
<p>链式存储结构实现：<br>算法步骤：①创建一个只有头结点的空链表；②根据多项式的项的个数n，循环n次执行以下操作：1.生成一个新结点*s；2.输入多项式当前项的系数和指数赋给新结点的*s的数据域；设置一个前驱指针pre，用于指向待找到的第一个大于输入项指数的结点的前驱，pre初值指向头结点；3.指针q初始化，指向首元结点；4.顺链向下逐个比较链中当前结点与输入项指数，找到第一个大于输入项指数的结点*q；5.将输入项结点*s插入到结点*q之前。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePolyn</span><span class="params">(Polynomial &amp;p, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    P= <span class="keyword">new</span> PNode;</span><br><span class="line">    P-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s=<span class="keyword">new</span> PNode;</span><br><span class="line">        cin&gt;&gt;s-&gt;coef&gt;&gt;s-&gt;expn;</span><br><span class="line">        pre=P;</span><br><span class="line">        q=P-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q&amp;&amp;q-&gt;expn&lt;s-&gt;expn)&#123;</span><br><span class="line">            pre=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;next=q;</span><br><span class="line">        pre-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相加算法步骤：①指针p1和p2初始化，分别指向pa和pb的首元结点；②p3指向多项式的当前结点，初值为pa的头结点；③当指针p1和p2均未到达相应表尾时，则循环比较p1和p2所指结点对应的指数值，有下列3种情况：(1)当p1-&gt;expn==p2-&gt;expn时，则将两个结点中的系数相加，若和不为零，则修改p1所指结点的系数值，同时删除p2所指结点，若和为零，则删除p1和p2所指结点；当p1-&gt;expn &lt; p2-&gt;expn时，则应摘取p1所指结点插入到“和多项式”链表中去；当p1-&gt;expn &gt; p2-&gt;expn时，则应摘取p2所指结点插入到“和多项式”链表中去；④将非空多项式的剩余段插入到p3所指结点之后；⑤释放Pb的头结点。</p>
<hr>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈和队列的定义和特点"><a href="#栈和队列的定义和特点" class="headerlink" title="栈和队列的定义和特点"></a>栈和队列的定义和特点</h3><ul>
<li>栈和队列是两种常用、重要的数据结构</li>
<li>栈和队列是限定插入和删除只能在表的“端点”进行的线性表</li>
<li>栈和队列是线性表的子集(是插入和删除位置受限的线性表)</li>
</ul>
<p><strong>栈</strong></p>
<p>​        由于栈的操作具有后进先出的固有特性，使得栈成为程序设计中的有用工具。另外，若问题求解的过程具有“后进先出”的天然特性的话，则求解的算法中也必然需要利用“栈”。</p>
<p><strong>栈的定义和特点</strong></p>
<p>​        栈(Stack)是一个特殊的线性表，是限定仅在一端(通常是表尾)进行插入和删除操作的线性表。又称为后进先出(Last In First Out)的线性表，简称LIFO结构。</p>
<p>​        栈是仅在表尾进行插入、删除操作的线性表。表尾称为栈顶Top；表头称为栈底Base。插入元素到栈顶的操作，称为入栈。从栈顶删除最后一个元素的操作，称为出栈。</p>
<p><strong>队列</strong></p>
<p>​        由于队列的操作具有先进先出的特性，使得队列称为程序设计中解决类似排队问题的有用工具。</p>
<p><strong>队列的定义和特点</strong></p>
<p>​        队列(queue)是一种先进先出(First In First Out，FIFO)的线性表。在表一端插入(表尾)，在另一端(表头)删除。</p>
<h3 id="案例引入-1"><a href="#案例引入-1" class="headerlink" title="案例引入"></a>案例引入</h3><p><strong>进制转换</strong></p>
<p>十进制整数N向其它进制数d(二、八、十六)的转换是计算机实现计算的基本问题。</p>
<p>例如：把十进制数159转换成八进制数。</p>
<p><strong>括号匹配的检验</strong></p>
<p>假设表达式中允许包含两种括号：圆括号和方括号；其嵌套的顺序随意。</p>
<p>算法思路：可以利用一个栈结构保存每个出现的左括号，当遇到右括号时，从栈中弹出左括号，检验其匹配情况；在检验过程中，若遇到以下几种情况之一，就可以得出括号不匹配的结论：(1)当遇到某一个右括号时，栈已空，说明到目前为止，右括号多于左括号；(2)从栈中弹出的左括号与当前检验的右括号类型不同，说明出现了括号交叉情况；(3)算数表达式输入完毕，但栈中还没没有匹配的左括号，说明左括号多于右括号。</p>
<p><strong>表达式求值</strong></p>
<p>表达式求值是程序设计语言中一个最基本的问题，它的实现也需要运用栈。这里介绍的算法是由运算符优先级确定运算顺序的对表达式求值算法。</p>
<p>算法思路：为了实现表达式求值。需要两个栈：一个是算符栈OPTR，用于寄存运算符；另一个称为操作数OPND，用于寄存运算数和运算结果。</p>
<p>求值的处理过程是自左向右扫描表达式的每一个字符：</p>
<ul>
<li>当扫描到的是运算数，则将其压入栈OPND</li>
<li>当扫描到的是运算符时<ul>
<li>若这个运算符比OPTR栈顶运算符的优先级高，则入栈OPTP，继续向后处理</li>
<li>若这个运算符比ORTR栈顶运算符优先级低，则从OPND栈中弹出两个运算数，从栈OPTR中弹出栈顶运算符进行运算，并将运算结果压入栈OPND。</li>
</ul>
</li>
<li>继续处理当前字符，知道遇到结束符为止。</li>
</ul>
<p><strong>舞伴问题</strong></p>
<p>​        首先构造两个队列；依次将头元素出队配成舞伴；某队为空，则另外一队等待着则是下一舞曲第一个可获得舞伴的人。</p>
<h3 id="栈的表示和操作的实现"><a href="#栈的表示和操作的实现" class="headerlink" title="栈的表示和操作的实现"></a>栈的表示和操作的实现</h3><ul>
<li>InitStack(&amp;s)初始化操作：构造一个空栈S</li>
<li>DestroyStack(&amp;S)销毁栈操作：栈S被销毁</li>
<li>StackEmpty(S)判定S是否为空战</li>
<li>StackLength(S)求栈的长度</li>
<li>GetTop(S, &amp;e)取栈顶元素</li>
<li>ClearStack(&amp;S)栈置空操作</li>
<li>Push(&amp;S, e)入栈操作</li>
<li>Pop(&amp;S, &amp;e)出栈操作</li>
</ul>
<p><strong>栈的表示和实现</strong></p>
<p>​        由于栈本身就是线性表，于是栈也有顺序存储和链式存储两种实现方式。栈的顺序存储——顺序栈；栈的链式存储——链栈。</p>
<h4 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a>顺序栈的表示和实现</h4><p>​        存储方式：同一般线性表的顺序存储结构完全相同，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。栈底一般在低地址段。</p>
<p>​        附设top指针，指示栈顶元素在顺序栈中的位置(但是，为了方便操作，通常top指示真正的栈顶元素之上的下标地址)；另设base指针，指示栈底元素在顺序栈中的位置。另外，用stacksize表示栈可使用的最大容量。</p>
<p>​        使用数组作为顺序栈存储方式的特点：简单，方便，但易产生溢出(数组大小固定)。上溢(overflow)：栈已经满，又要压入元素；下溢(underflow)：栈已经空，还要弹出元素。注：上溢是一种错误，使问题的处理无法进行；而下溢一般认为是一种结束条件，即问题处理结束。</p>
<p><strong>顺序栈的表示</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;<span class="comment">//栈底指针</span></span><br><span class="line">    SElemType *top;<span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;<span class="comment">//栈可用最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<p><strong>顺序栈的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base = <span class="keyword">new</span> SElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!S.base)<span class="built_in">exit</span> (OVERFLOW);</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序栈判断栈是否为空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>求顺序栈的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stacklength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top - S.base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>清空顺序栈</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base) S.top = S.base;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>销毁顺序栈</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base)&#123;</span><br><span class="line">        <span class="keyword">delete</span> S.base;</span><br><span class="line">        S.stacksize=<span class="number">0</span>;</span><br><span class="line">        S.base = S.top = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序栈的入栈</strong></p>
<p>判断是否满栈，若满则出错；元素e压入栈顶；栈顶指针+1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base == S.stacksize)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序栈的出栈</strong></p>
<p>判断是否栈空，若空则出错；获取栈顶元素e；栈顶指针-1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a>链栈的表示和实现</h4><p>链栈是运算受限的单链表，只能在链表头部进行操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStack;</span><br><span class="line">LinkStack S;</span><br></pre></td></tr></table></figure>

<p>​        链表的头指针就是栈顶；不需要头结点；基本不存在栈满的情况；空栈相当于头指针指向空；插入和删除仅在栈顶处执行。</p>
<p><strong>链栈的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断链栈是否为空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链栈的入栈</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> StackNode;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S;</span><br><span class="line">    S=p;</span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链栈的出栈</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S, SElemtype &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    p=S;</span><br><span class="line">    S=S-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取栈顶元素</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h3><p>递归的定义：</p>
<ul>
<li><p>若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的；</p>
</li>
<li><p>若一个过程直接地或间接地调用自己，则称这个过程是递归的过程。</p>
<ul>
<li>递归求n的阶乘：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fact</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * <span class="built_in">Fact</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>以下三种情况常常用到递归方法：</strong></p>
<ul>
<li>递归定义的数学函数：<ul>
<li>阶乘函数</li>
<li>2阶Fibonaci数列：</li>
</ul>
</li>
<li>具有递归特性的数据结构：<ul>
<li>二叉树</li>
<li>广义表</li>
</ul>
</li>
<li>可递归求解的问题<ul>
<li>迷宫问题</li>
<li>Hanoi塔问题</li>
</ul>
</li>
</ul>
<p><strong>递归问题——用分治法求解</strong><br>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解。</p>
<p>必备的三个条件：</p>
<ul>
<li>能将一个问题转变成一个新的问题，而新的问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的。</li>
<li>可以通过上述转化而使问题简化</li>
<li>必须有一个明确的递归出口，或者递归的边界</li>
</ul>
<p><strong>分治法求解递归问题算法的一般形式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(参数列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(递归结束条件)	可直接求解步骤;</span><br><span class="line">        <span class="keyword">else</span> p(较小的参数);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数调用的过程：</strong></p>
<p>调用前，系统完成：</p>
<ul>
<li>将实参、返回地址等传递给被调用函数</li>
<li>为被调用函数的局部变量分配存储区</li>
<li>将控制转移到被调用函数的入口</li>
</ul>
<p>调用后，系统完成：</p>
<ul>
<li>保存被调用函数的计算结果</li>
<li>释放被调用函数的数据区</li>
<li>依照被调用函数保存的返回地址将控制转移到调用函数</li>
</ul>
<p>当多个函数构成嵌套调用时：遵循后调用的先返回。</p>
<p>递归的优缺点：</p>
<ul>
<li>优点：结构清晰，程序易读</li>
<li>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销较大。</li>
</ul>
<p>递归-&gt;非递归：</p>
<ul>
<li><p>方法1：尾递归、单项递归-&gt;循环结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fact</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n *<span class="built_in">Fact</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fact</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) t=t*i;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fib</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Fib</span>(n<span class="number">-1</span>)  +<span class="built_in">Fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fib</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t1 = <span class="number">1</span>;t2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">3</span> i &lt;= n; i++)&#123;</span><br><span class="line">            t3 = t1+t2;</span><br><span class="line">            t1 = t2; t2=t3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自用栈模拟系统的运行时栈</p>
</li>
</ul>
<h3 id="队列的表示和操作的实现"><a href="#队列的表示和操作的实现" class="headerlink" title="队列的表示和操作的实现"></a>队列的表示和操作的实现</h3><p><strong>相关术语</strong></p>
<ul>
<li>队列(Queue)是仅在表尾进行插入操作，在表头进行删除操作的线性表。</li>
<li>表尾即$a_n$端，称为队尾；表头即$a_1$端，称为队头。</li>
<li>它是一种先进先出(FIFO)的线性表。</li>
<li>插入元素称为入队；删除元素称为出队。</li>
<li>队列的存储结构为链队或顺序队(常用循环顺序队)</li>
</ul>
<p><strong>队列的相关概念</strong></p>
<ul>
<li>定义：只能在表的一端进行插入运算，在表的另一端进行删除运算的线性表。</li>
<li>逻辑结构：与同线性表相同，仍为一对一关系。</li>
<li>存储结构：顺序队和链队。</li>
<li>运算规则：只能在队首和队尾运算，且访问结点时依照先进先出(FIFO)的原则。</li>
<li>实现方式：关键是掌握入队和出队操作，具体实现依照顺序队和链队的不同而不同。</li>
</ul>
<p><strong>队列的常见应用</strong></p>
<ul>
<li>脱机打印输出：按申请的先后顺序依次输出</li>
<li>多用户系统中，多个用户排成队，分时地循环使用CPU和主存</li>
<li>按用户的优先级排成多个队，每个优先级一个队列</li>
<li>实时控制系统中，信号按接收的先后顺序依次处理</li>
<li>网络电文传输，按到达的时间先后顺序依次进行</li>
</ul>
<p><strong>队列的抽象数据类型定义</strong></p>
<p><strong>队列的顺序表示</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 100</span></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QElemType *base;<span class="comment">//初始化的动态分配存储空间</span></span><br><span class="line">    <span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<p>存在的问题：</p>
<p>设数组大小为MAXQSIZE，当rear=MAXQSIZE时，发生溢出；若front=0，rear=MAXQSIZE时再入队，则发生真溢出；当front$\neq 0$，rear=MAXQSIZE时，再入队，则发生假溢出。</p>
<p>解决假上溢的方法：</p>
<p>1.将队中元素依次向队头方向移动。缺点：浪费时间。每移动一次，队中元素都要移动</p>
<p>2.将队空间设想成一个循环的表即分配给队列的m个存储单元可以循环使用，当rear为maxqsize时，若向量的开始端空着，又可以从头使用空着空间。当front为maxqsize时，也是一样。</p>
<p>队空队满的判断：1.另外设一个标志以区别队空、队满；2.另一个变量，记录元素个数；3.少用一个元素空间</p>
<p>少用一个元素空间：队空：front==rear；队满：(rear+1)%MAXQSIZE==front</p>
<p><strong>循环队列的操作——队列的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.base = <span class="keyword">new</span> QElemType[MAXQSIZE];<span class="comment">//分配数组空间</span></span><br><span class="line">    <span class="keyword">if</span>(!Q.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">    Q.front=Q.rear = <span class="number">0</span>;<span class="comment">//头指针尾指针置为0，队列为空</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>求队列的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环队列入队</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, QElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MAXQSIZE == Q.front) <span class="keyword">return</span> ERROR;<span class="comment">//队满</span></span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear+<span class="number">1</span>)%MAXQSIZE;<span class="comment">//队尾指针+1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环队列出队</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.front == Q.rear)) <span class="keyword">return</span> ERROR;<span class="comment">//队空</span></span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取队头元素</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetHead</span><span class="params">(SqQuere Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front != Q.rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> Q.base[Q.front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>队列的链式表示和实现</strong></p>
<p>若用户无法估计所用队列的长度，则宜采用链队列</p>
<p><strong>链队列的类型定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span>&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QuenePtr;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QuenePtr front;<span class="comment">//队头指针</span></span><br><span class="line">    QuenePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<p><strong>链队列初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>销毁链队列</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(Q.front)&#123;</span><br><span class="line">        p = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q.front);</span><br><span class="line">        Q.front = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将元素e入队</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span>&#123;</span><br><span class="line">    p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    P-&gt;data = e;</span><br><span class="line">    p-&gt;next=null;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链队列出队</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    P = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)</span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链队列的队头元素</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q, QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = Q.front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="串、数组和广义表"><a href="#串、数组和广义表" class="headerlink" title="串、数组和广义表"></a>串、数组和广义表</h2><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h4><p>串(String)——零个或多个任意字符串组成的有限序列</p>
<p>字串：串中任意个连续字符组成的子序列称为该串的子串。真子串是指不包含自身的所有子串。</p>
<p>主串：包含子串的串相应地称为主串</p>
<p>字符位置：字符在序列中的序号为该字符在串中的位置</p>
<p>字串位置：子串第一个字符在主串中的位置</p>
<p>空格串：由一个或多个空格串组成的串</p>
<p>串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。所有的空串都是相等的。</p>
<h4 id="案例引入-2"><a href="#案例引入-2" class="headerlink" title="案例引入"></a>案例引入</h4><p>串的应用非常广泛，计算机上的非数值处理的对象大部分是字符串数据，例如：文字编辑、符号处理、各种信息处理系统等等。</p>
<p>案例：病毒感染检测</p>
<p>研究者将人的DNA和病毒DNA均表示成由一些字母组成的字符串序列。然后检测某种病毒DNA序列是否在患者的DNA序列中出现过，如果出现过，则此人感染了该病毒，否则没有感染。</p>
<p>例如：假设病毒的DNA序列为baa，患者1的DNA序列为aaabbba，则感染，患者2的DNA序列为babbba，则未感染。(注意，人的DNA序列是线性的，而病毒的DNA序列是环状的)</p>
<h4 id="串的类型定义、存储结构及运算"><a href="#串的类型定义、存储结构及运算" class="headerlink" title="串的类型定义、存储结构及运算"></a>串的类型定义、存储结构及运算</h4><p>串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构。</p>
<p><strong>串的顺序存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN+<span class="number">1</span>];<span class="comment">//存储串的一维数组</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//串的当前长度长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>

<p><strong>串的链式存储结构</strong></p>
<p>优点：操作方便；缺点：存储密度较低。【存储密度=串所占的存储/实际分配的存储】</p>
<p>可以将多个字符存放在一个结点中，以克服其缺点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Chunk *head, *tail;<span class="comment">//串的头指针和尾指针</span></span><br><span class="line">    <span class="keyword">int</span> curlen;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;LString;<span class="comment">//字符串的块链结构</span></span><br></pre></td></tr></table></figure>

<p><strong>串的模式匹配算法</strong></p>
<p>算法的目的：确定主串中所含子串(模式串)第一次出现的位置</p>
<p>算法应用：搜索引擎、拼写检查、语言翻译、数据压缩</p>
<p>算法种类：BF算法(Brute-Force，又称古典的、经典的、朴素的、穷举的)、KMP算法(特点：速度快)</p>
<p><strong>BF算法</strong></p>
<p>Brute-Force简称为BF算法，亦称简单匹配算法。采用穷举法的思路。</p>
<p>算法设计思想：将主串中的第pos个字符和模式串的第一个字符比较；若相等，继续逐个比较后续字符；若不相等，从主串的下一字符起，重新与模式串的第一个字符比较。直到主串中的第一个连续子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。否则，匹配失败，返回值0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(SString S, SString T, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=pos, j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == t.ch[j])&#123;<span class="comment">//主串和子串依次匹配字符</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//主串和子串指针回溯重新开始下一次匹配</span></span><br><span class="line">            i = i-(j<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; S.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> j-i+<span class="number">1</span>;<span class="comment">//返回匹配的第一个字符的下标</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//模板匹配不成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BF算法的时间复杂度：若n为主串长度，m为子串长度；最好的情况：比较m此；最坏情况：主串前面n-m个位置都部分匹配到子串的最后一位，(n-m)*m+m=(n-m+1)*m，若n&gt;&gt;m，则算法复杂度为O(n*m)。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章 泛型程序设计</title>
    <url>/2020/11/09/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第八章-泛型程序设计"><a href="#第八章-泛型程序设计" class="headerlink" title="第八章 泛型程序设计"></a>第八章 泛型程序设计</h1><h2 id="8-1-为什么要使用泛型程序设计"><a href="#8-1-为什么要使用泛型程序设计" class="headerlink" title="8.1 为什么要使用泛型程序设计"></a>8.1 为什么要使用泛型程序设计</h2><p>泛型程序设计(generic programming)意味着编写的代码可以对多种不同类型的对象重用。例如，你并不希望为收集String和File对象分别编写不同的类。实际上，也不需要这样做，因为一个ArrayList类就可以收集任何类的对象。这就是泛型程序设计的一个例子。</p>
<p>实际上 ，在Java有泛型类之前已经有一个ArrayList类。下面来研究泛型程序设计的机制是如何演变的，另外还会介绍这对用户和实现者来说意味着什么。</p>
<h3 id="8-1-1-类型参数的好处"><a href="#8-1-1-类型参数的好处" class="headerlink" title="8.1.1 类型参数的好处"></a>8.1.1 类型参数的好处</h3><p>在Java中增加泛型类之前，泛型程序设计是用继承实现的。ArrayList类只维护一个Object引用的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方法存在两个问题。当获取一个值时必须进行强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList files = <span class="keyword">new</span> ArrayList();</span><br><span class="line">String filename = (String)files.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>此外，这里没有错误检查。可以向数组列表中添加任何类的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">files.add(<span class="keyword">new</span> File(<span class="string">&quot;...&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>对于这个调用，编译器和运行都不会错。不过在其他地方，如果将get的结果强制类型转换转换为String类型，就会产生一个错误。</p>
<p>泛型提供了一个更好的解决方案：参数类型(type parameter)。ArrayList类有一个类型参数用来指示元素的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; files = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>这使得代码具有更好的可读性。人们一看就知道这个数组列表中包含的是String对象。</p>
<p>编译器也可以充分利用这个类型信息。调用get的时候，不需要进行强制类型转换。编译器知道返回值类型为String，而不是Object：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String filename = files.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>编译器还知道ArrayList&lt;String&gt;的add方法有一个类型为String的参数，这比有一个Object类型的参数要安全得多。现在，编译器可以检查，防止你插入错误类型得对象。例如，以下语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">files.add(<span class="keyword">new</span>(File(<span class="string">&quot;...&quot;</span>)));<span class="comment">//can only add String objects to an Arraylist&lt;String&gt;</span></span><br></pre></td></tr></table></figure>

<p>是无法通过编译得。不过，出现编译错误要比运行时出现类得强制类型转换异常好得多。</p>
<p>这正是类型参数得魅力所在：他们会让你的程序更易读，也更安全。</p>
 <span id="more"></span> 

<h3 id="8-1-2-谁想成为泛型程序员"><a href="#8-1-2-谁想成为泛型程序员" class="headerlink" title="8.1.2 谁想成为泛型程序员"></a>8.1.2 谁想成为泛型程序员</h3><p>下面是让标准类库得设计者们饱受折磨得一个典型问题。ArrayList类有一个方法addAll，用来添加另一个集合得全部元素。一个程序员可能想要将一个ArrayList&lt;Manager&gt;中得所有元素添加到一个ArrayList&lt;Employee&gt;中去。不过，当然反过来就不行了。如何允许前一个调用，而不允许后一个调用呢？Java语言得设计者发明了一个具有独创性得新概念来解决这个问题，即通配符类型(wildcard type)。通配符类型非常抽象，不过，利用通配符类型，构建类库得程序员可以编写出尽可能灵活得方法。</p>
<h2 id="8-2-定义简单泛型类"><a href="#8-2-定义简单泛型类" class="headerlink" title="8.2 定义简单泛型类"></a>8.2 定义简单泛型类</h2><p>泛型类(generic class)就是一个或多个类型变量的类。本章使用一个简单的Pair类作为例子。这个类是我们可以可以只关注泛型，而不用为数据存储的细节而分心。。下面是泛型Pair类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        first = <span class="keyword">null</span>; </span><br><span class="line">        second = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        first = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        second = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pair类引入了一个类型变量T，用尖括号&lt;&gt;括起来，放在类名后面。泛型类可以有多个类型变量。例如，可以定义Pair类，其中第一个字段和第二个字段使用不同的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>类型变量在整个类定义中用于指定方法的返回类型以及字段和局部变量的类型。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T first;</span><br></pre></td></tr></table></figure>

<p>可以使用具体的类型替换类型变量来实例化(instantiate)泛型类型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt;</span><br></pre></td></tr></table></figure>

<p>可以把结果想象成一个普通类，它有以下构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt;()</span><br><span class="line">Pair&lt;String&gt;(String,String)</span><br></pre></td></tr></table></figure>

<p>以及以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">getSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(String)</span></span></span><br></pre></td></tr></table></figure>

<p>换句话说，泛型类相当于普通类的工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pair1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairTest1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] words = &#123;<span class="string">&quot;Mary&quot;</span>,<span class="string">&quot;had&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;little&quot;</span>,<span class="string">&quot;lamb&quot;</span>&#125;;</span><br><span class="line">        Pair&lt;String&gt; mm = ArrayAlg.minmax(words);</span><br><span class="line">        System.out.println(<span class="string">&quot;min=&quot;</span> + mm.getFirst());</span><br><span class="line">        System.out.println(<span class="string">&quot;max=&quot;</span> + mm.getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;String&gt; <span class="title">minmax</span><span class="params">(String[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String min = a[<span class="number">0</span>];</span><br><span class="line">        String max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (min.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i];</span><br><span class="line">            <span class="keyword">if</span> (max.compareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;String&gt;(min,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-泛型方法"><a href="#8-3-泛型方法" class="headerlink" title="8.3 泛型方法"></a>8.3 泛型方法</h2><p>上一节已经介绍如何定义一个泛型类。还可以定义一个带有类型参数的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T...a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是在普通类中定义的，而不是在泛型类中。不过，这是一个泛型方法，可以从尖括号和类型变量看出这一点。注意，类型变量放在修饰符(这里的修饰符就是public static)的后面，并在返回类型的前面。</p>
<p>泛型方法可以在普通类中定义，也可以在泛型类中定义。当调用一个泛型方法时，可以把具体类型的包括在尖括号中，放在方法名前面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;Q.&quot;</span>,<span class="string">&quot;Public&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在这种情况下(实际也是大多数情况下)，方法调用中可以省略&lt;String&gt;类型参数。编译器有足够的信息推断出你想要的方法。它将参数的类型与泛型类型T进行匹配，推断出T一定是String。也就是说，可以简单地调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String middle = ArrayAlg.getMiddle(<span class="string">&quot;john&quot;</span>,<span class="string">&quot;Q.&quot;</span>,<span class="string">&quot;Public&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>几乎所有的情况下，泛型方法的类型推导能正常工作。偶尔，编译器也会提示错误，此时你就需要解译错误报告。考虑下面这个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> middle = ArrayAlg.getMiddle(<span class="number">3.14</span>,<span class="number">1729</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>错误消息以晦涩的方式指出：解释这个代码有两种方式，而且这两种方式都是合法的。简单地说，编译器将把参数自动装箱为1个Double和2个Integer对象，然后寻找这些类的共同超类型。事实上，它找到了2个超类型：Number和Comparable接口，Comparable接口本身也是一个泛型类型。在这种情况下，可以采取的补救措施是将所有的参数都写为double值。</p>
<h2 id="8-4-类型变量的限定"><a href="#8-4-类型变量的限定" class="headerlink" title="8.4 类型变量的限定"></a>8.4 类型变量的限定</h2><p>有时，类或方法需要对类型变量加以约束。下面是是一个典型的例子。我们要计算数组中的最小元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        T smallest = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(smallest.compareTo(a[i]) &gt; <span class="number">0</span>) smallest = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> smallest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这里有一个问题。请看min方法的代码。变量smallest的类型为T，这意味着它可以是任何一个类的对象。如何知道T所属的类有一个compareTo方法呢？</p>
<p>解决这个问题的办法是限制T只能是实现了Comparable接口的类。可以通过对类型变量T设置一个限定(bound)来实现这一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span>...</span></span><br></pre></td></tr></table></figure>

<p>实际上Comparable接口本身就是一个泛型类型。目前，我们忽略其复杂性以及编译器产生的警告。8.8节中会讨论如何在Comparable接口中适当地使用类型参数。</p>
<p>现在，泛型方法min只能在实现了Comparable接口类(如String、LocalDate等)的数组上调用。由于Rectangle类没有实现Comparable接口，所以在Rectangle数组上调用min将会产生一个编译错误。</p>
<p>你或许会感觉到奇怪——在这里我们为什么使用关键字extends而不是implements?毕竟Comparable是一个接口。下面的记法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T extends BoudingType&gt;</span><br></pre></td></tr></table></figure>

<p>表示T应该是限定类型(bounding type)的子类型(subtype)。T和限定类型可以是类，也可以是接口。选择关键字extends的原因是它更接近子类型的概念，并且Java的设计者也不打算在语言中添加一个新的关键字(如sub)。</p>
<p>一个类型变量或通配符可以有多个限定，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T extends Comparable &amp; Serializable</span><br></pre></td></tr></table></figure>

<p>限定类型用“&amp;”分割，而逗号用来分隔类型变量。</p>
<p>在Java的继承中，可以根据需要拥有多个接口超类型，但最多有一个限定可以是类。如果有一个类作为限定，它必须是限定列表中的第一个限定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pair2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairTest2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LocalDate[] birthdays = &#123;</span><br><span class="line">                LocalDate.of(<span class="number">1906</span>,<span class="number">12</span>,<span class="number">9</span>),</span><br><span class="line">                LocalDate.of(<span class="number">1815</span>,<span class="number">12</span>,<span class="number">10</span>),</span><br><span class="line">                LocalDate.of(<span class="number">1903</span>,<span class="number">12</span>,<span class="number">3</span>),</span><br><span class="line">                LocalDate.of(<span class="number">1910</span>,<span class="number">6</span>,<span class="number">22</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        Pair&lt;LocalDate&gt; mm = ArrayAlg.minmax(birthdays);</span><br><span class="line">        System.out.println(<span class="string">&quot;min=&quot;</span> + mm.getFirst());</span><br><span class="line">        System.out.println(<span class="string">&quot;max=&quot;</span> + mm.getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">Pair&lt;T&gt; <span class="title">minmax</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        T min = a[<span class="number">0</span>];</span><br><span class="line">        T max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (min.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i];</span><br><span class="line">            <span class="keyword">if</span> (max.compareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(min,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-5-泛型代码和虚拟机"><a href="#8-5-泛型代码和虚拟机" class="headerlink" title="8.5 泛型代码和虚拟机"></a>8.5 泛型代码和虚拟机</h2><p>虚拟机没有泛型类型对象——所有对象都属于普通类。在泛型实现的早期版本中，甚至能够将使用泛型的程序编译为1.0虚拟机上运行的类文件！在下面的小节中你会看到编译器如何“擦除”类型参数，以及这个过程对Java程序员有什么影响。</p>
<h3 id="8-5-1-类型擦除"><a href="#8-5-1-类型擦除" class="headerlink" title="8.5.1 类型擦除"></a>8.5.1 类型擦除</h3><p>无论何时定义一个泛型类型，都会自动提供一个相应的原始类型(raw type)。这个原始类型的名字就是去掉类型参数后的泛型类型名。类型变量会擦除(erased)，并替换为其限定类型(或者，对于无限的变量则替换为Object)</p>
<p>例如，Pair&lt;T&gt;的原始类型如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Objetc newValue)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.second = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为T是一个无限定的变量，所以直接用Object替换。</p>
<p>结果是一个普通的类，就好像Java语言中引入泛型之前实现的类一样</p>
<p>在程序中可以包含不同类型的Pair，例如，Pair&lt;String&gt;或Pair&lt;LocalDate&gt;，不过擦除类型后，他们都会变成原始的Pair类型。</p>
<p>原始类型用第一个限定来替换变量类型，或者，如果没有给限定，就替换为Object。例如，类Pair&lt;T&gt;中的类型变量没有显式的限定，因此，原始类型用Object替换T。假定我们声明了一个稍有不同的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt;<span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T lower;</span><br><span class="line">    <span class="keyword">private</span> T upper;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(T firtst, T second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first.compareTo(second) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lower = first;</span><br><span class="line">            upper = second;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            lower = second;</span><br><span class="line">            upper = first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始类型Interval如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable lower;</span><br><span class="line">    <span class="keyword">private</span> Comparable upper;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(Comparable first, Comparable second)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-5-2-转换泛型表达式"><a href="#8-5-2-转换泛型表达式" class="headerlink" title="8.5.2 转换泛型表达式"></a>8.5.2 转换泛型表达式</h3><p>编写一个泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换。例如，对于下面这个语句列，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Employee&gt;buddies = ...;</span><br><span class="line">Employee buddy = buddies.getFirst();</span><br></pre></td></tr></table></figure>

<p>getFirst擦除类型后的返回类型是Object。编译器自动插入转换到Employee的强制类型转换。也就是说，编译器把这个方法调用转换为两条虚拟机指令：</p>
<ul>
<li>对原始方法Pair.getFirst的调用；</li>
<li>将返回的Object类型强制转换为Employee。</li>
</ul>
<p>当访问一个泛型字段时也要插入强制类型转换。假设Pair类的first字段和second字段都是公共的。表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee buddy = buddies.first;</span><br></pre></td></tr></table></figure>

<p>也会在结果字节码中插入强制类型转换。</p>
<h3 id="8-5-3-转换泛型方法"><a href="#8-5-3-转换泛型方法" class="headerlink" title="8.5.3 转换泛型方法"></a>8.5.3 转换泛型方法</h3><p>类型擦除也会出现在泛型方法中。程序员通常认为类似下面的泛型方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></span><br></pre></td></tr></table></figure>

<p>是整个一组方法，而擦除类型之后，只剩下一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Comparable[] a)</span></span></span><br></pre></td></tr></table></figure>

<p>注意，类型参数T已经被擦除了，只留下了限定类型Comparable。</p>
<p>方法的擦除带来了两个复杂的问题。看一看下面这个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LoclaDtae</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(second.compareTo(getFirst()) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">super</span>.setSecond(second);</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日期区间是一对LocalDate对象，而且我们需要覆盖这个方法来确保第二个值永远不小于第一个值。这个类擦除后变成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span></span>&#123;...&#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>令人奇怪的是，还有一个从Pair继承的setSecond方法，即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span></span><br></pre></td></tr></table></figure>

<p>这显然是一个不同的方法，因为它有一个不同的参数类型——Object，而不是LocalDate。不过，不应该不一样。考虑从下面的语句序列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateInterval interval = <span class="keyword">new</span> DateInterval(...);</span><br><span class="line">Pair&lt;LoclaDtae&gt; pair = interval;</span><br><span class="line">pair.setSecond(aDate);</span><br></pre></td></tr></table></figure>

<p>这里，我们希望setSecond调用具有多态性，会调用最合适的那个方法。由于pair引用一个DateInterval对象，所以应该调用DateInterval.setSecond。问题在于类类型擦除与多态发生了冲突。为了解决这个问题，编译器在DateInterval类中生成了一个桥方法(bridge method)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setSecond((LocalDate) second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要了解为什么这样可行，请仔细跟踪以下语句执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pair.setSecond(aDate)</span><br></pre></td></tr></table></figure>

<p>变量pair已经声明为类型Pair&lt;LocalDate&gt;，并且这个类型只有一个名为setSecond的方法，即setSecond(Object)。虚拟机在pair引用的对象上调用这个方法。这个对象是DateInterval类型，因而将会调用DateInterval.setSecond(Object)方法。这个方法是合成的桥方法。它会调用DateInterval.setSecond(LocalDate)，这正是我们想要的。</p>
<p>桥方法可能会变得更奇怪。假设DateInterval类也覆盖了getSecond方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (LocalDate) <span class="keyword">super</span>.getSecond();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DateInterval类中，有两个getSecond方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">LocalDate <span class="title">getSecond</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">getSecond</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>不能这样编写Java代码(两个方法有相同的参数类型是不合法的，在这里，两个方法都没有参数)。但是，在虚拟机中，会由参数类型和返回值类型共同指定一个方法。因此，编译器可以为两个仅返回类型不同的方法生成字节码，虚拟机能够正确地处理这种情况。</p>
<p>总之，对于Java泛型的转换，需要记住以下几个事实：</p>
<ul>
<li>虚拟机中没有泛型，只有普通的类和方法。</li>
<li>所有的类型参数都会替换为他们的限定类型。</li>
<li>会生成桥方法来保持多态。</li>
<li>为保持类型安全性，必要时会插入强制类型转换。</li>
</ul>
<h3 id="8-5-4-调用遗留代码"><a href="#8-5-4-调用遗留代码" class="headerlink" title="8.5.4 调用遗留代码"></a>8.5.4 调用遗留代码</h3><h2 id="8-6-限制与局限性"><a href="#8-6-限制与局限性" class="headerlink" title="8.6 限制与局限性"></a>8.6 限制与局限性</h2><p>在下面几节中，我们将讨论使用Java泛型时需要考虑的一些限制。大多数限制都是由类型擦除引起的。</p>
<h3 id="8-6-1-不能用基本类型实例化类型参数"><a href="#8-6-1-不能用基本类型实例化类型参数" class="headerlink" title="8.6.1 不能用基本类型实例化类型参数"></a>8.6.1 不能用基本类型实例化类型参数</h3><p>不能用基本类型代替类型参数。因此，没有Pair&lt;double&gt;。当然，其原因就在于类型擦除。擦除之后，Pair类含有Object类型的字段，而Object不能存储double值。</p>
<p>这的确令人烦恼。但是，这样做与Java语言中基本类型的独立状态相一致。这并不是一个致命的缺陷——只有8种基本类型，而且即使不能接受包装器类型(wrapper type)，也可以使用单独的类和方法来处理。</p>
<h3 id="8-6-2-运行时类型查询只适用于原始类型"><a href="#8-6-2-运行时类型查询只适用于原始类型" class="headerlink" title="8.6.2 运行时类型查询只适用于原始类型"></a>8.6.2 运行时类型查询只适用于原始类型</h3><p>虚拟机中的对象总有一个特定的非泛型类型。因此，所有的类型查询只产生原始类型。</p>
<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;)<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>实际上仅仅测试a是否是任意类型的一个Pair。下面的测试同样如此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;T&gt;)<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>或强制类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a;<span class="comment">//warning--can only test that a is a Pair</span></span><br></pre></td></tr></table></figure>

<p>为提醒这一风险，如果试图查询一个对象是否属于某个泛型类型，你会得到一个编译器错误(使用instanceof时)，或者得到一个警告(使用instanceof时)，或者得到一个警告(使用强制类型转换时)。同样的道理，getClass方法总是返回原始类型。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = ...;</span><br><span class="line">Pair&lt;Employee&gt; employeePair = ...;</span><br><span class="line"><span class="keyword">if</span>(stringPair.getClass() == employeePair.getClass())<span class="comment">//they are equal</span></span><br></pre></td></tr></table></figure>

<p>其比较的结果是true，这是因为两次getClass调用都返回Pair.class。</p>
<h3 id="8-6-3-不能创建参数化类型的数组"><a href="#8-6-3-不能创建参数化类型的数组" class="headerlink" title="8.6.3 不能创建参数化类型的数组"></a>8.6.3 不能创建参数化类型的数组</h3><p>不能实例化参数化类型的数组，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>这有什么问题呢？擦除之后，table的类型是Pair[ ]。可以把它转换为Object[ ]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] objarray = table;</span><br></pre></td></tr></table></figure>

<p>数组会记住它的元素类型，如果试图存储其他类型的元素，就会抛出一个ArrayStoreException异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objarray[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span>;<span class="comment">//ERROR--component type is Pair</span></span><br></pre></td></tr></table></figure>

<p>不过对于泛型类型，擦除会使这种机制无效。以下赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objarray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>

<p>尽管能够通过数组存储的检查，但仍会导致一个类型错误。出于这个原因，不允许创建参数化类型的数组。</p>
<p>需要说明的是，只是不允许创建这些数组，而声明类型为Pair&lt;String&gt;[ ]的变量仍是合法的。不过不能用new Pair&lt;String&gt;[10]初始化这个变量。</p>
<h3 id="8-6-4-Varargs警告"><a href="#8-6-4-Varargs警告" class="headerlink" title="8.6.4 Varargs警告"></a>8.6.4 Varargs警告</h3><p>上一节了解到，Java不支持泛型类型的数组。这一节我们再来讨论一个相关的问题：向参数个数可变的方法传递一个泛型类型的实例。</p>
<p>考虑下面这个简单的方法，它的参数个数是可变的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll, T... ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t:ts)</span><br><span class="line">        coll.add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回忆一下，实际上参数ts是一个数组，包含提供的所有实参。</p>
<p>现在考虑以下调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;Pair&lt;String&gt;&gt; table = ...;</span><br><span class="line">Pair&lt;String&gt; pair1 = ...;</span><br><span class="line">Pair&lt;String&gt; pair2 = ...;</span><br><span class="line">addAll(table,pair1,pair2);</span><br></pre></td></tr></table></figure>

<p>为了调用这个方法，Java虚拟机必须建立一个Pair&lt;String&gt;数组，这就违反了前面的规则。不过，对于这种情况，规则有所放松，你只会得到一个警告，而不是错误。</p>
<p>可以采用两种方式来抑制这个警告。一种方法是为包含addAll调用的方法增加注解@SuppressWarnings(“unchecked”)。或者在Java7中，还可以用@SafeVarargs直接注解addAll方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll, T... ts)</span></span></span><br></pre></td></tr></table></figure>

<p>现在就可以提供泛型类型来调用这个方法了。对于任何只需要读取参数数组元素的方法，都可以使用这个注解。</p>
<p>@SafeVarargs 只能用于声明为static、final或private的构造器和方法。所有其他方法都可能被覆盖，使得这个注解没有什么意义。</p>
<h3 id="8-6-5-不能实例化类型变量"><a href="#8-6-5-不能实例化类型变量" class="headerlink" title="8.6.5 不能实例化类型变量"></a>8.6.5 不能实例化类型变量</h3><p>不能在类似new T(…)的表达式中使用类型变量。例如，下面的pair&lt;T&gt;构造器就是非法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    first = <span class="keyword">new</span> T();</span><br><span class="line">    second = <span class="keyword">new</span> T();</span><br><span class="line">&#125;<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>类型擦除将T变成Object，而你肯定不希望调用 new Object()。</p>
<p>在java8之后，最好的解决办法是让调用者提供一个构造器表达式。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>makePair方法接受一个Supplier&lt;T&gt;，这是一个函数式接口，这是一个函数式接口，表示一个无参数而且返回值类型为T的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(constr.get(),constr.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较传统的解决方法是通过反射调用Constructor.newInstance方法来构造泛型对象。遗憾的是，细节有点复杂。不能调用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first = T.class.getConstructor().newInstance();<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>表达式T.class是不合法的，因为他会擦为Object.class。必须适当地设计API以便得到一个Class对象，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; cl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(cl.getConstructor().newInstance(),cl.getConstructor().newInstance());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法可以如下调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</span><br></pre></td></tr></table></figure>

<p>注意，Class类本身是泛型的。例如String.class是一个Class&lt;String&gt;的实例。因此，makePair方法能够推断出所建立的对组(pair)的类型。</p>
<h3 id="8-6-6-不能构造泛型数组"><a href="#8-6-6-不能构造泛型数组" class="headerlink" title="8.6.6 不能构造泛型数组"></a>8.6.6 不能构造泛型数组</h3><p>就像不能实例化泛型实例一样，也不能实例化数组。不过原因有所不同，毕竟数组可以填充nul值，看上去好像可以安全地构造。不过，数组本身也带有类型，用来监控虚拟机中的数组存储。这个类型会被擦除。例如，考虑下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] ninmax(T...a)</span><br><span class="line">&#123;</span><br><span class="line">    T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>];<span class="comment">//Error</span></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型擦除会让这个方法总是构造Comparable[2]数组。</p>
<p>如果数组仅仅作为一个类的私有实例字段，那么可以将这个数组的元素类型声明为擦除的类型并使用强制类型转换。例如，ArrayList类可以如下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="meta">@SuppressWaring(&quot;unchecked&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> (E)elements[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n, E e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        elements[n] = e;</span><br><span class="line">    &#125;<span class="comment">// no cast needed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但实际的实现没有这么清晰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E[] elements;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        elements = (E[]) <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，强制类型转换E[ ]是一个假象，而类型擦除使其无法察觉。</p>
<p>这个技术并不适合我们的minmax方法，因为ninmax方法返回一个T[ ]数组，如果类型不对，就会得到运行时错误结果。假设实现以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T... a)</span><br><span class="line">&#123;</span><br><span class="line">    Comparable result = <span class="keyword">new</span> Comparable[<span class="number">2</span>];</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> (T[]) result;<span class="comment">//compiles with warning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = ArrayAlg.ninmax(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Dick&quot;</span>,<span class="string">&quot;Harry&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译时不会有任何警告。当方法返回Comparable[ ]引用强制转换为String[ ]时，将会出现ClassCastException异常。</p>
<p>在这种情况下，最好让用户提供一个数组构造器表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = ArrayAlg.minmax(String[]::<span class="keyword">new</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Dick&quot;</span>,<span class="string">&quot;Harry&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>构造器表达式String::new 指示一个函数，给定所需的长度，会构造一个指定长度的String数组。</p>
<p>ninmax方法使用这个参数生成了一个有正确类型的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(IntFunction&lt;T[]&gt; constr,T... a)</span><br><span class="line">&#123;</span><br><span class="line">    T[] result = constr.apply(<span class="number">2</span>);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较老式的方法是利用反射，并调用Array.newInstance:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T... a)</span><br><span class="line">&#123;</span><br><span class="line">    T[] result = (T[]) Array.newInstance(a.getClass().getComponentType(),<span class="number">2</span>);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList类的toArray方法就没有这么幸运。他需要生成一个T[ ]数组，但没有元素类型。因此，有下面两种不同的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] toArray()</span><br><span class="line">T[] toArray(T[] result)</span><br></pre></td></tr></table></figure>

<p>第二个方法接受一个数组参数。如果数组足够大，就使用这个数组。否则，用result的元素类型构造一个足够大的新数组。</p>
<h3 id="8-6-7-泛型类的静态上下文中类型变量无效"><a href="#8-6-7-泛型类的静态上下文中类型变量无效" class="headerlink" title="8.6.7 泛型类的静态上下文中类型变量无效"></a>8.6.7 泛型类的静态上下文中类型变量无效</h3><h3 id="8-6-8-不能抛出或捕获泛型类的实例"><a href="#8-6-8-不能抛出或捕获泛型类的实例" class="headerlink" title="8.6.8 不能抛出或捕获泛型类的实例"></a>8.6.8 不能抛出或捕获泛型类的实例</h3><h3 id="8-6-9-可以取消对检查型异常的检查"><a href="#8-6-9-可以取消对检查型异常的检查" class="headerlink" title="8.6.9 可以取消对检查型异常的检查"></a>8.6.9 可以取消对检查型异常的检查</h3><h3 id="8-6-10-注意擦除后的冲突"><a href="#8-6-10-注意擦除后的冲突" class="headerlink" title="8.6.10 注意擦除后的冲突"></a>8.6.10 注意擦除后的冲突</h3><h2 id="8-7-泛型类型的继承规则"><a href="#8-7-泛型类型的继承规则" class="headerlink" title="8.7 泛型类型的继承规则"></a>8.7 泛型类型的继承规则</h2><p>在使用泛型类时，需要了解有关继承和子类型的一些规则。下面先从许多程序员感觉不太直观的情况开始介绍。考虑一个类和一个子类，如Employee和Manager。Pair&lt;Manager&gt;是Pair&lt;Employee&gt;的一个子类吗？或许人们会感到奇怪，答案是：不是。</p>
<p>无论S与T有什么关系，通常，Pair&lt;S&gt;与Pair&lt;T&gt;都没有任何关系。</p>
<p>最后，泛型类可以扩展或实现其他的泛型类。就这一点而言，它们与普通的类没有什么区别。例如，ArrayList&lt;T&gt;类实现了List&lt;T&gt;接口。这意味着，一个ArrayList&lt;Manager&gt;不是一个ArrayList&lt;Employee&gt;或List&lt;Employee&gt;。</p>
<h2 id="8-8-通配符类型"><a href="#8-8-通配符类型" class="headerlink" title="8.8 通配符类型"></a>8.8 通配符类型</h2><h3 id="8-8-1-通配符概念"><a href="#8-8-1-通配符概念" class="headerlink" title="8.8.1 通配符概念"></a>8.8.1 通配符概念</h3><p>在通配符类型中，允许类型参数发生变化。例如，通配符类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;? extends Employee&gt;</span><br></pre></td></tr></table></figure>

<p>表示任何泛型Pair类型，它的类型参数是Employee的子类，如Pair&lt;Manager&gt;，但不是Pair&lt;String&gt;</p>
<p>假设要编写一个打印员工对的方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(pair&lt;Employee&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee firtst = p.getFirst();</span><br><span class="line">    Employee second = p.getSecond();</span><br><span class="line">    System.out.println(first.getName() + <span class="string">&quot;and&quot;</span> + second.getName() + <span class="string">&quot;are buddies.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如前面讲到的，不能将Pair&lt;Manager&gt;传递给这个方法，这一点很有限制。不过解决的方法很简单：可以使用通配符类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span></span></span><br></pre></td></tr></table></figure>

<p>类型Pair&lt;Manager&gt;是Pair&lt;? extends Employee&gt;的子类型。</p>
<p>使用通配符会通过Pair&lt;? extends Employee&gt;的引用破坏Pair&lt;Manager&gt;吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Manager&gt; managerBuddies = <span class="keyword">new</span> Pair&lt;Manager&gt;(ceo,cfo);</span><br><span class="line">Pair&lt;? extends Employee&gt; wildcardBuddies = managerBuddies;<span class="comment">//ok</span></span><br><span class="line">wildcardBuddies.setFirst(lowlyEmployee);<span class="comment">//compile-tine error</span></span><br></pre></td></tr></table></figure>

<p>这不可能引起破坏。对setFirst的调用有一个类型错误。要了解其中的缘由，请仔细看一看类型Pair&lt;? extends Employee&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">? <span class="function">extends Employee <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? extends Employee)</span></span></span><br></pre></td></tr></table></figure>

<p>这样讲不可能调用setFirst方法。编译器只知道需要Employee的某个子类型，但不知道具体是什么类型它拒绝传递特定的类型。毕竟？不能匹配。</p>
<p>使用getFirst就不存在这个问题：将getFirst的返回值赋给一个Employee引用是完全合法的。</p>
<p>这就是引入有限定的通配符的关键之处。现在已经有办法区分安全的访问器方法和不安全的更改器方法了</p>
<h3 id="8-8-2-通配符的超类型限定"><a href="#8-8-2-通配符的超类型限定" class="headerlink" title="8.8.2 通配符的超类型限定"></a>8.8.2 通配符的超类型限定</h3><p>通配符限定与类型变量限定十分类似，但是，还有一个附加的能力，即可以指定一个超类型限定(supertype bound)，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">? <span class="keyword">super</span> Manager</span><br></pre></td></tr></table></figure>

<p>这个通配符限制为Manager的所有超类。</p>
<p>为什么要这样做呢？带有超类型限定的通配符的行为与8.8节介绍的相反。可以为方法提供参数，但不能使用返回值。例如，Pair&lt;? super Manager&gt;有如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(? <span class="keyword">super</span> Manager)</span></span></span><br><span class="line"><span class="function">? <span class="keyword">super</span> Manager <span class="title">getFierst</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>这不是真正的Java语法，但是可以看出编译器知道什么。编译器无法知道setFirst方法的具体类型，因此不能接受参数类型为Employee或Object的方法调用。只能传递Manager类型的对象，或者某个子类型对象。另外，如果调用getFirst，不能保证返回对象的类型。只能把它赋给一个Object。</p>
<p>下面是一个典型示例。我们有一个经理数组，并且想把奖金最高和最低的经理放在一个Pair对象中，Pair的类型是什么？在这里，Pair&lt;Employee&gt;是合理的，Pair&lt;Object&gt;也是合理的。下面的方法将接受任何适合Pair：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minmaxBonus</span><span class="params">(Manager[] a, Pair&lt;? <span class="keyword">super</span> Manager&gt; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    Manager min = a[<span class="number">0</span>];</span><br><span class="line">    Manager max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(min.getBonus() &gt; a[i].getBonus()) min = a[i];</span><br><span class="line">        <span class="keyword">if</span>(max.getBonus() &lt; a[i].getBonus()) max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    result.setFirst(min);</span><br><span class="line">    result.setSecond(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直观地将，带有超类型限定的通配符允许你写入一个泛型对象，而带有子类型限定的通配符允许你读取一个泛型对象。</p>
<p>下面是超类型限定的另一个应用。Comparable接口本身就是一个泛型类型。声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，类型变量指示了other参数的类型。例如String类实现了Comparable&lt;String&gt;，它的compareTo方法声明为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Stirng other)</span></span></span><br></pre></td></tr></table></figure>

<p>这很好，显式的参数有一个正确的类型。接口是泛型接口之前，other是一个Object，这个方法的实现中必须有一个强制类型转换。</p>
<p>由于Comparable是一个泛型类型，也许可以把ArrayAlg类的min方法做得更好一些？可以这样声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></span><br></pre></td></tr></table></figure>

<p>看起来，这样写比只使用T extends Coparable更彻底，并且对于许多类来讲，这样工作得更好。例如，如果计算一个String数组得最小值，T就是类型String，而String是Comparable&lt;String&gt;的一个子类。但是，处理一个LocalDate对象的数组时，我们会遇到一个问题。LocalDate实现了ChronoLocalDate，而ChronoLocalDate扩展了Comparable&lt;ChronoLocalDate&gt;。因此，LocalDate实现的是Coparable&lt;ChronoLocalDate&gt;而不是Coparable&lt;LocalDate&gt;。</p>
<p>在这种情况下，可以利用超类型来解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span>...</span></span><br></pre></td></tr></table></figure>

<p>现在compareTo方法写成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(? <span class="keyword">super</span> T)</span></span></span><br></pre></td></tr></table></figure>

<p>它可以声明为使用类型T的对象，或者也可以是使用T的一个超类型的对象。无论如何，向compareTo方法传递一个T类型的对象是安全的。</p>
<p>对于初学者来说，类似&lt;T extends Comparable&lt;? super T&gt;&gt;的声明看起来有些吓人。很遗憾，因为这个声明的本意是帮助应用程序去除对调用参数的不必要的限制。对泛型没有兴趣的应用程序员可能很快就会略过这些声明，想当然地认为库程序员做的都是正确的，如果你是一名库程序员，一定要熟悉通配符，否则，就会受到用户的责备，他们还要在代码中随机地添加强制类型转换直至代码可以编译。</p>
<h3 id="8-8-3-无限定通配符"><a href="#8-8-3-无限定通配符" class="headerlink" title="8.8.3 无限定通配符"></a>8.8.3 无限定通配符</h3><p>还可以使用根本无限定的通配符，例如，Pair&lt;?&gt;。初看起来，这好像与原始的Pair类型一样。实际上，这两种类型有很大的不同。类型Pair&lt;?&gt;有以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">? getFirst()</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(?)</span></span></span><br></pre></td></tr></table></figure>

<p>getFirst()的返回值只能赋给一个Object。setFirst方法不能被调用，甚至不能用Object调用。Pair&lt;?&gt;和Pair本质的不同在于：可以用任意Object对象调用原始Pair类的setFirst方法。</p>
<p>为什么要使用这样一个脆弱的类型？他对于很多简单操作非常有用。例如，下面这个方法可用来测试一个对组是否包含一个null引用，它不需要实际的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="keyword">null</span> || p.getSecond() == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过将hasNulls转换成泛型方法，可以避免使用通配符类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;T&gt; p)</span></span></span><br></pre></td></tr></table></figure>

<p>但是，带有通配符的版本可读性更好。</p>
<h3 id="8-8-4-通配符捕获"><a href="#8-8-4-通配符捕获" class="headerlink" title="8.8.4 通配符捕获"></a>8.8.4 通配符捕获</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pair3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = LocalDate.of(year,month,day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pair3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,salary,year,month,day);</span><br><span class="line">        bonus = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();</span><br><span class="line">        <span class="keyword">return</span> baseSalary + <span class="keyword">this</span>.bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bonus = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBonus</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pair3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T first)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pair3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairTest3</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Manager ceo = <span class="keyword">new</span> Manager(<span class="string">&quot;Gus Greedy&quot;</span>,<span class="number">800000</span>,<span class="number">2003</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">        Manager cfo = <span class="keyword">new</span> Manager(<span class="string">&quot;Sid Sneaky&quot;</span>,<span class="number">600000</span>,<span class="number">2003</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">        Pair&lt;Manager&gt; buddies = <span class="keyword">new</span> Pair&lt;&gt;(ceo,cfo);</span><br><span class="line">        printBuddies(buddies);</span><br><span class="line"></span><br><span class="line">        ceo.setBonus(<span class="number">1000000</span>);</span><br><span class="line">        cfo.setBonus(<span class="number">500000</span>);</span><br><span class="line">        Manager[] managers = &#123;ceo,cfo&#125;;</span><br><span class="line"></span><br><span class="line">        Pair&lt;Employee&gt; result = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">        minmaxBonus(managers,result);</span><br><span class="line">        System.out.println(<span class="string">&quot;first:&quot;</span> + result.getFirst().getName() + <span class="string">&quot;second:&quot;</span> + result.getSecond().getName());</span><br><span class="line"></span><br><span class="line">        maxminBonus(managers,result);</span><br><span class="line">        System.out.println(<span class="string">&quot;first:&quot;</span> + result.getFirst().getName() + <span class="string">&quot;second:&quot;</span> + result.getSecond().getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee first = p.getFirst();</span><br><span class="line">        Employee second = p.getSecond();</span><br><span class="line">        System.out.println(first.getName() + <span class="string">&quot;and&quot;</span> +second.getName() + <span class="string">&quot;are buddies.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minmaxBonus</span><span class="params">(Manager[] a, Pair&lt;? <span class="keyword">super</span> Manager&gt; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        Manager min = a[<span class="number">0</span>];</span><br><span class="line">        Manager max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (min.getBonus() &gt; a[i].getBonus()) min = a[i];</span><br><span class="line">            <span class="keyword">if</span> (max.getBonus() &lt; a[i].getBonus()) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        result.setFirst(min);</span><br><span class="line">        result.setSecond(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxminBonus</span><span class="params">(Manager[] a, Pair&lt;? <span class="keyword">super</span> Manager&gt; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        minmaxBonus(a,result);</span><br><span class="line">        PairAlg.swapHelper(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirst() == <span class="keyword">null</span> || p.getSecond() == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair&lt;?&gt; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        swapHelper(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T t = p.getFirst();</span><br><span class="line">        p.setFirst(p.getSecond());</span><br><span class="line">        p.setSecond(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-9-反射和泛型"><a href="#8-9-反射和泛型" class="headerlink" title="8.9 反射和泛型"></a>8.9 反射和泛型</h2><p>反射允许你在运行时分析任意对象。如果对象是泛型类的实例，关于泛型类型参数你将得不到太多信息，因为它们已经被擦除了。在下面的小节中，我们将学习利用反射可以获得泛型类的哪些信息。</p>
<h3 id="8-9-1-泛型Class类"><a href="#8-9-1-泛型Class类" class="headerlink" title="8.9.1 泛型Class类"></a>8.9.1 泛型Class类</h3><p>现在，Class类是泛型的。例如，String.class实际上是一个Class&lt;String&gt;类的对象。</p>
<p>类型参数十分有用，这是因为它允许Class&lt;T&gt;方法的返回类型更加具有特定性。Class&lt;T&gt;的以下方法就是用了类型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">T <span class="title">cast</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">T[] <span class="title">getEnumConstants</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Class&lt;? <span class="keyword">super</span> T&gt; <span class="title">getSuperclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="8-9-2-使用Class-lt-T-gt-参数进行类型匹配"><a href="#8-9-2-使用Class-lt-T-gt-参数进行类型匹配" class="headerlink" title="8.9.2 使用Class&lt;T&gt;参数进行类型匹配"></a>8.9.2 使用Class&lt;T&gt;参数进行类型匹配</h3><p>匹配泛型方法中Class&lt;T&gt;参数的类型变量有时会很有用。下面是一个标准的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> InstantiationException,IllegalAccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(c.newInstance(),c.newInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">makePair(Employee.class)</span><br></pre></td></tr></table></figure>

<p>Employee.class将是一个Class&lt;Employee&gt;类型的对象。makePair方法的类型参数T同Employee匹配，编译器可以推断出这个方法将返回一个Pair&lt;Employee&gt;。</p>
<h3 id="8-9-3-虚拟机中的泛型类型信息"><a href="#8-9-3-虚拟机中的泛型类型信息" class="headerlink" title="8.9.3 虚拟机中的泛型类型信息"></a>8.9.3 虚拟机中的泛型类型信息</h3><p>Java泛型的突出特性之一是在虚拟机中擦除泛型类型。令人奇怪的是，擦除的类仍然保留原先泛型的微弱记忆。例如，原始Pair类知道它源于泛型类Pair&lt;T&gt;，尽管一个Pair类型的对象无法区分它是构造为Pair&lt;String&gt;还是Pair&lt;Employee&gt;。</p>
<p>类似地，考虑以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">min</span><span class="params">(Comparable[] a)</span></span></span><br></pre></td></tr></table></figure>

<p>这是擦除以下泛型方法得到的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></span><br></pre></td></tr></table></figure>

<p>可以使用反射API来确定：</p>
<ul>
<li>这个泛型方法有一个名为T的类型参数。</li>
<li>这个类型参数有一个子类型限定，其自身又是一个泛型类型。</li>
<li>这个限定类型有一个通配符参数。</li>
<li>这个通配符参数有一个超类型限定。</li>
<li>这个泛型方法有一个泛型数组参数。</li>
</ul>
<p>换句话说，你可以重新构造实现者声明的泛型类和方法的所有有关内容。但是，你不会知道对于特定的对象或方法调用会如何解析类型参数。</p>
<p>为了表述泛型类型声明，可以使用java.lang.reflect包中的接口Type。这个接口包含以下子类型：</p>
<ul>
<li>Class类，描述具体类型</li>
<li>TypeVariable接口，描述类型变量(如 T extends Comparable&lt;? super T&gt;)</li>
<li>wildcardType接口，描述通配符(如？super T)</li>
<li>ParameterizedType接口，描述泛型类或接口类型(如Comparable&lt;? super T&gt;)</li>
<li>GenericArrayType接口，描述泛型数组(如 T[ ])</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> genericReflection;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericReflectionTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) name = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> (Scanner sc = <span class="keyword">new</span> Scanner(System.in))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Enter class name (e.g., java.util.Collections):&quot;</span>);</span><br><span class="line">                name = sc.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; cl = Class.forName(name);<span class="comment">//获取一个Class对象</span></span><br><span class="line">            printClass(cl);<span class="comment">//调用打印类</span></span><br><span class="line">            <span class="keyword">for</span> (Method m : cl.getDeclaredMethods())</span><br><span class="line">            &#123;</span><br><span class="line">                printMethod(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClass</span><span class="params">(Class&lt;?&gt; cl)</span><span class="comment">//传入泛型的Class对象</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(cl);</span><br><span class="line">        printTypes(cl.getTypeParameters(),<span class="string">&quot;&lt;&quot;</span>,<span class="string">&quot;,&quot;</span>,<span class="string">&quot;&gt;&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        Type sc = cl.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (sc != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;extends&quot;</span>);</span><br><span class="line">            printType(sc,<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printTypes(cl.getGenericInterfaces(),<span class="string">&quot;implements&quot;</span>,<span class="string">&quot;,&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethod</span><span class="params">(Method m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String name = m.getName();</span><br><span class="line">        System.out.print(Modifier.toString(m.getModifiers()));</span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        printTypes(m.getTypeParameters(),<span class="string">&quot;&lt;&quot;</span>,<span class="string">&quot;,&quot;</span>,<span class="string">&quot;&gt;&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        printType(m.getGenericReturnType(),<span class="keyword">false</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.print(name);</span><br><span class="line">        System.out.print(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        printTypes(m.getGenericParameterTypes(),<span class="string">&quot;&quot;</span>,<span class="string">&quot;,&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTypes</span><span class="params">(Type[] types, String pre, String sep, String suf, <span class="keyword">boolean</span> isDefinition)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.equals(<span class="string">&quot;extends&quot;</span>) &amp;&amp; Arrays.equals(types,<span class="keyword">new</span> Type[] &#123;Object.class&#125;)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (types.length &gt; <span class="number">0</span>) System.out.print(pre);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; types.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) System.out.print(sep);</span><br><span class="line">            printType(types[i],isDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (types.length &gt; <span class="number">0</span>) System.out.print(suf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printType</span><span class="params">(Type type,<span class="keyword">boolean</span> isDefinition)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span> Class)<span class="comment">//描述具体类型</span></span><br><span class="line">        &#123;</span><br><span class="line">            Class&lt;?&gt; t = (Class&lt;?&gt;) type;</span><br><span class="line">            System.out.print(t.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> TypeVariable)<span class="comment">//描述类型变量</span></span><br><span class="line">        &#123;</span><br><span class="line">            TypeVariable&lt;?&gt; t = (TypeVariable&lt;?&gt;) type;</span><br><span class="line">            System.out.print(t.getName());</span><br><span class="line">            <span class="keyword">if</span> (isDefinition) printTypes(t.getBounds(), <span class="string">&quot;extends&quot;</span>, <span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span>  WildcardType)<span class="comment">//描述通配符</span></span><br><span class="line">            &#123;</span><br><span class="line">                WildcardType t = (WildcardType)type;</span><br><span class="line">                System.out.print(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">                printTypes(t.getUpperBounds(),<span class="string">&quot;extends&quot;</span>,<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">                printTypes(t.getLowerBounds(),<span class="string">&quot;extends&quot;</span>,<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType)<span class="comment">//描述泛型类或接口类型</span></span><br><span class="line">            &#123;</span><br><span class="line">                ParameterizedType t = (ParameterizedType)type;</span><br><span class="line">                Type owner = t.getOwnerType();</span><br><span class="line">                <span class="keyword">if</span>(owner != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    printType(owner,<span class="keyword">false</span>);</span><br><span class="line">                    System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                printType(t.getRawType(),<span class="keyword">false</span>);</span><br><span class="line">                printTypes(t.getActualTypeArguments(),<span class="string">&quot;&lt;&quot;</span>,<span class="string">&quot;,&quot;</span>,<span class="string">&quot;&gt;&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType)</span><br><span class="line">            &#123;</span><br><span class="line">                GenericArrayType t = (GenericArrayType)type;</span><br><span class="line">                System.out.print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                printType(t.getGenericComponentType(),isDefinition);</span><br><span class="line">                System.out.print(<span class="string">&quot;[]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-9-4类型字面量"><a href="#8-9-4类型字面量" class="headerlink" title="8.9.4类型字面量"></a>8.9.4类型字面量</h3>]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2021/01/03/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><hr>
<p>线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是$n$个具有相同特性的数据元素的有限序列。</p>
 <span id="more"></span> 

<p><strong>前驱元素：</strong>若A元素在B元素的前面，则称A为B的前驱元素。</p>
<p><strong>后继元素：</strong>若B元素在A元素的后面，则称B为A的后继元素。</p>
<p><strong>线性表的特征：</strong>数据元素之间具有一种“一对一”的逻辑关系。</p>
<ul>
<li>第一个数据元素没有前驱，这个元素被称为头结点；</li>
<li>最后一个数据元素没有后继，这个元素被称为尾结点；</li>
<li>除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。</li>
</ul>
<p>如果把线性表用数学语言来定义，则可以表示为$(a_1,a_2…a_i,a_{i+1}…a_n)$，称$a_{i-1}$是$a_i$的前驱元素，$a_{i+1}$是$a_i$的后继元素。</p>
<p><strong>线性表的分类：</strong></p>
<p>线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序表和链表。</p>
<hr>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中在逻辑结构上相应的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。</p>
<p><strong>顺序表的API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>SequenceList&lt;T&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>SequenceList(int capacity)</td>
</tr>
<tr>
<td>成员方法</td>
<td>public void clear()</td>
</tr>
<tr>
<td></td>
<td>public boolean isEmpty()</td>
</tr>
<tr>
<td></td>
<td>public int length()</td>
</tr>
<tr>
<td></td>
<td>public T get(int i)</td>
</tr>
<tr>
<td></td>
<td>public void insert(int i, T t)</td>
</tr>
<tr>
<td></td>
<td>public void insert(T t)</td>
</tr>
<tr>
<td></td>
<td>public T remove(int i)</td>
</tr>
<tr>
<td></td>
<td>public int indexOf(T t)</td>
</tr>
<tr>
<td>成员变量</td>
<td>private T[] eles</td>
</tr>
<tr>
<td></td>
<td>private int N</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceList</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> T[] eles;</span><br><span class="line">    <span class="comment">//记录当前顺序表中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequenceList</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">this</span>.eles = (T[])<span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="comment">//初始化长度</span></span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将一个线性表置空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前线性表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前线性表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取指定位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eles[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向线性表中添加元素t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        eles[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在i元素处插入元素t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, T t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先把i索引处及其后面的元素依次向后移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = N; index &gt; i; index--)&#123;</span><br><span class="line">            eles[index] = eles[index - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把t元素放到i索引处</span></span><br><span class="line">        eles[i] = t;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定位置i处的元素，并返回该元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录索引i处的指</span></span><br><span class="line">        T current = eles[i];</span><br><span class="line">        <span class="comment">//索引i后面的元素依次向前移动一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i; index &lt; N -<span class="number">1</span>; index++)&#123;</span><br><span class="line">            eles[index] = eles[index + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找t元素第一次出现的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(eles[i].equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceListTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建顺序表对象</span></span><br><span class="line">        SequenceList&lt;String&gt; sl = <span class="keyword">new</span> SequenceList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//测试插入</span></span><br><span class="line">        sl.insert(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        sl.insert(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">        sl.insert(<span class="number">1</span>,<span class="string">&quot;zxc&quot;</span>);</span><br><span class="line">        <span class="comment">//获取测试</span></span><br><span class="line">        String result = sl.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">//测试删除</span></span><br><span class="line">        String removeResult = sl.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(removeResult);</span><br><span class="line">        <span class="comment">//测试清空</span></span><br><span class="line">        sl.clear();</span><br><span class="line">        System.out.println(sl.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序表的遍历：</strong></p>
<p>一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。在Java中，遍历集合的方式一般都是$foreach$循环，如果想让我们的$SequenceList$也能支持$foreach$循环，则需要做如下操作：</p>
<ul>
<li>让$SequenceList$实现$Iterable$接口，重写iterator方法；</li>
<li>让$SequenceList$内部提供一个内部类$SIterator$，实现$Iterator$接口，重写$hasNext$方法和$next$方法；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> T[] eles;</span><br><span class="line">    <span class="comment">//记录当前顺序表中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequenceList</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">this</span>.eles = (T[])<span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="comment">//初始化长度</span></span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将一个线性表置空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前线性表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前线性表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取指定位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eles[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向线性表中添加元素t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        eles[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在i元素处插入元素t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, T t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先把i索引处及其后面的元素依次向后移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = N; index &gt; i; index--)&#123;</span><br><span class="line">            eles[index] = eles[index - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把t元素放到i索引处</span></span><br><span class="line">        eles[i] = t;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定位置i处的元素，并返回该元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录索引i处的指</span></span><br><span class="line">        T current = eles[i];</span><br><span class="line">        <span class="comment">//索引i后面的元素依次向前移动一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i; index &lt; N -<span class="number">1</span>; index++)&#123;</span><br><span class="line">            eles[index] = eles[index + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找t元素第一次出现的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(eles[i].equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cusor;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cusor = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.cusor &lt; N;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> eles[cusor++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序表的容量可变：</strong></p>
<p>在之前的实现中，当我们使用$SequenceList$时，先$new SequenceLsit(5)$创建一个对象，创建对象时就需要指定容器大小，初始化指定大小的数组来存储元素，当我们插入元素时，如果已经插入了5个元素，还要继续插入数据，就会报错，就不能插入了。这种设计不符合容器的设计理念，因此我们在设计顺序表时，应该它的容量的伸缩性。</p>
<ul>
<li>添加元素时：添加元素时，应该检查当前数组的大小是否能够容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我们这里创建一个是原数组两倍容量的新数组存储元素。</li>
<li>移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存空间的浪费，应该创建一个容器更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1/4，则创建一个是原数组容量的1/2的新数组存储元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> T[] eles;</span><br><span class="line">    <span class="comment">//记录当前顺序表中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequenceList</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">this</span>.eles = (T[])<span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="comment">//初始化长度</span></span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将一个线性表置空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前线性表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前线性表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取指定位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eles[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向线性表中添加元素t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.N == eles.length)&#123;</span><br><span class="line">            resize(<span class="number">2</span> * eles.length);</span><br><span class="line">        &#125;</span><br><span class="line">        eles[N++] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在i元素处插入元素t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N==eles.length)&#123;</span><br><span class="line">            resize(<span class="number">2</span> * eles.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先把i索引处及其后面的元素依次向后移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = N; index &gt; i; index--)&#123;</span><br><span class="line">            eles[index] = eles[index - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把t元素放到i索引处</span></span><br><span class="line">        eles[i] = t;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除指定位置i处的元素，并返回该元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录索引i处的指</span></span><br><span class="line">        T current = eles[i];</span><br><span class="line">        <span class="comment">//索引i后面的元素依次向前移动一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i; index &lt; N -<span class="number">1</span>; index++)&#123;</span><br><span class="line">            eles[index] = eles[index + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(N &lt; (eles.length / <span class="number">4</span>))&#123;</span><br><span class="line">            resize(eles.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找t元素第一次出现的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(eles[i].equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据参数newSize，重置eles的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newSize)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义一个临时数组，指向原数组</span></span><br><span class="line">        T[] temp = <span class="keyword">this</span>.eles;</span><br><span class="line">        <span class="comment">//创建新数组</span></span><br><span class="line">        eles = (T[])<span class="keyword">new</span> Object[newSize];</span><br><span class="line">        <span class="comment">//把原数组的数据拷贝到新数组即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            eles[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cusor;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cusor = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.cusor &lt; N;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> eles[cusor++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序表的时间复杂度：</strong></p>
<ul>
<li>$get(i)$：不难看出，不论数据元素量N有多大，只需要$eles[i]$就可以获取到对应的元素，所以时间复杂度为$O(1)$；</li>
<li>$insert(int i, T t)$：每一次插入，都需要把$i$位置后面的元素移动一次，随着元素数量$N$的增大，移动的元素也越多，时间复杂度为$O(n)$；</li>
<li>$remove(int i)$：每一次删除，都需要把$i$位置后面的元素移动一次，随着元素数量$N$的增大，移动的元素也越多，时间复杂度为$O(n)$；</li>
</ul>
<p>由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容处的节点处，耗时会突增，尤其是元素越多，这个问题越明显。</p>
<p><strong>Java中$ArrayList$实现：</strong></p>
<p>Java中$ArrayList$集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。</p>
<hr>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>前面已经使用顺序存储结构实现了线性表，我们可以发现虽然顺序表的查询很快，时间复杂度为$O(1)$，但是增删的效率是比较低的，因为每一次增删操作都伴随着大量的数据元素移动。</p>
<p>链表是一种物理存储单元非连续、非顺序的存储结构，其物理结构不能只管的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的结点(链表中的每一个元素称为结点)组成，结点可以在运行时动态生成。</p>
<p><strong>结点API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Node&lt;T&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(T t, Node next)</td>
</tr>
<tr>
<td>成员变量</td>
<td>T item</td>
</tr>
<tr>
<td></td>
<td>Node next</td>
</tr>
</tbody></table>
<p><strong>结点类的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T item;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生成链表：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//构建结点</span></span><br><span class="line">    Node&lt;Integer&gt; first = <span class="keyword">new</span> Node&lt;Integer&gt;(<span class="number">11</span>,<span class="keyword">null</span>);</span><br><span class="line">    Node&lt;Integer&gt; second = <span class="keyword">new</span> Node&lt;Integer&gt;(<span class="number">13</span>,<span class="keyword">null</span>);</span><br><span class="line">    Node&lt;Integer&gt; third = <span class="keyword">new</span> Node&lt;Integer&gt;(<span class="number">12</span>,<span class="keyword">null</span>);</span><br><span class="line">    Node&lt;Integer&gt; fourth = <span class="keyword">new</span> Node&lt;Integer&gt;(<span class="number">8</span>,<span class="keyword">null</span>);</span><br><span class="line">    Node&lt;Integer&gt; fifth = <span class="keyword">new</span> Node&lt;Integer&gt;(<span class="number">9</span>,<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//生成链表</span></span><br><span class="line">    first.next = second;</span><br><span class="line">    second.next = third;</span><br><span class="line">    third.next = fourth;</span><br><span class="line">    fourth.next = fifth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。</p>
<p><strong>单向链表的API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>LinkList&lt;T&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>LinkList()</td>
</tr>
<tr>
<td>成员方法</td>
<td>public void clear()</td>
</tr>
<tr>
<td></td>
<td>public boolean isEmpty()</td>
</tr>
<tr>
<td></td>
<td>public int length()</td>
</tr>
<tr>
<td></td>
<td>public T get(int i)</td>
</tr>
<tr>
<td></td>
<td>public void insert(T t)</td>
</tr>
<tr>
<td></td>
<td>public void insert(int i, T t)</td>
</tr>
<tr>
<td></td>
<td>public T remove(int i)</td>
</tr>
<tr>
<td></td>
<td>public int indexOf(T t)</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node&lt;T&gt;</td>
</tr>
<tr>
<td>成员变量</td>
<td>private Node head</td>
</tr>
<tr>
<td></td>
<td>private int N</td>
</tr>
</tbody></table>
<p><strong>单向链表的代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//记录头结点</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">//记录链表长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="comment">//结点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="comment">//存储数据</span></span><br><span class="line">        T item;</span><br><span class="line">        <span class="comment">//下一结点</span></span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化头结点</span></span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//初始化元素个数</span></span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取指定位置i处的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过循环，从头结点往后找，依次找i次</span></span><br><span class="line">        Node n = head.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; i; index++)&#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向链表中插入元素t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到当前最后一个结点</span></span><br><span class="line">        Node n = head;</span><br><span class="line">        <span class="keyword">while</span>(n.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建新结点，保存元素t</span></span><br><span class="line">        n.next = <span class="keyword">new</span> Node(t,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//让当前最后一个节点指向新节点</span></span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在指定的位置i处，添加元素t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, T t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到i位置前一个结点</span></span><br><span class="line">        Node pre = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; i; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i位置的结点</span></span><br><span class="line">        <span class="comment">//创建新结点，并且新结点需要指向原来i位置的结点</span></span><br><span class="line">        pre.next = <span class="keyword">new</span> Node(t,pre.next);</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除指定位置i处的元素，并返回被删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到i位置的前一个结点</span></span><br><span class="line">        Node pre = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; i; index++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i位置的结点</span></span><br><span class="line">        Node curr = pre.next;</span><br><span class="line">        <span class="comment">//找到i位置的下一个结点</span></span><br><span class="line">        Node nextNode = curr.next;</span><br><span class="line">        <span class="comment">//前一结点指向下一结点</span></span><br><span class="line">        pre.next = nextNode;</span><br><span class="line">        <span class="comment">//元素个数-1</span></span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> curr.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找元素t在链表中第一次出现的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; temp != <span class="keyword">null</span>;i++)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span>(temp.item.equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LIterator()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node temp;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.temp = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> temp.next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">return</span> temp.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域合和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向后继结点，另一个指针用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针值为null，指向后继结点的指针域指向第一个真正存储数据的结点。</p>
<p><strong>结点API的设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Node&lt;T&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Node(T t, Node pre, Node next)</td>
</tr>
<tr>
<td>成员变量</td>
<td>T item</td>
</tr>
<tr>
<td></td>
<td>Node next</td>
</tr>
<tr>
<td></td>
<td>Node pre</td>
</tr>
</tbody></table>
<p><strong>双向链表API的设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>TowWayLinkList&lt;T&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>TowWayLinkList()</td>
</tr>
<tr>
<td>成员方法</td>
<td>public void clear()</td>
</tr>
<tr>
<td></td>
<td>public boolean isEmpty()</td>
</tr>
<tr>
<td></td>
<td>public int length()</td>
</tr>
<tr>
<td></td>
<td>public void insert(T t)</td>
</tr>
<tr>
<td></td>
<td>public void insert(int i, T t)</td>
</tr>
<tr>
<td></td>
<td>public T remove(int i)</td>
</tr>
<tr>
<td></td>
<td>public int indexOf(T t)</td>
</tr>
<tr>
<td></td>
<td>public T getFirst()</td>
</tr>
<tr>
<td></td>
<td>public T getLast()</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node&lt;T&gt;</td>
</tr>
<tr>
<td>成员变量</td>
<td>private Node first</td>
</tr>
<tr>
<td></td>
<td>private Node last</td>
</tr>
<tr>
<td></td>
<td>private int N</td>
</tr>
</tbody></table>
<p><strong>双向链表代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TowWayLinkList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//首结点</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">//尾结点</span></span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="comment">//链表长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="comment">//结点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node pre;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node pre, Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.pre = pre;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TowWayLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化头结点和尾结点</span></span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//初始化元素个数</span></span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.head.pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.head.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取第一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取最后一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入元素t</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果链表为空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty)&#123;</span><br><span class="line">            last = <span class="keyword">new</span> Node(t,head,<span class="keyword">null</span>);</span><br><span class="line">            head.next = last;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            last.next = <span class="keyword">new</span> Node(t,last,<span class="keyword">null</span>);</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在指定位置i处插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, T t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到i位置前一个结点</span></span><br><span class="line">        Node pre = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; i; index++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到当前结点</span></span><br><span class="line">        Node curr = pre.next;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(t,pre,curr);</span><br><span class="line">        pre.next = newNode;</span><br><span class="line">        curr.pre = newNode;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取指定位置i处的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; i; index++)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到元素t在链表中第一次出现的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; temp.next != <span class="keyword">null</span>; i++)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span>(temp.item.equals(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除位置i处的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到i位置的前一个结点</span></span><br><span class="line">        Node pre = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; i; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到i位置的结点</span></span><br><span class="line">        Node curr = pre.next;</span><br><span class="line">        <span class="comment">//找到i位置的下一个结点</span></span><br><span class="line">        Node nextNode = curr.next;</span><br><span class="line">        <span class="comment">//让i位置的前一个结点的下一个结点变为i位置的下一个结点</span></span><br><span class="line">        pre.next = nextNode;</span><br><span class="line">        nextNode.pre = pre;</span><br><span class="line">        N--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Titerator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node n;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n = head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n.next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> n.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java中LinkedList实现：</strong></p>
<p>java中LinkedList集合也是使用双向链表实现，并提供了增删改查等相关方法。</p>
<p><strong>链表的复杂度分析：</strong></p>
<ul>
<li>$get(int i)$：每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较元素越多，时间复杂度为$O(n)$。</li>
<li>$insert(int i, T t)$：每一插入，需要找到i位置的前一个元素，然后完成插入操作，随着元素数量N的增多，查找的元素越多，时间复杂度为$O(n)$。</li>
<li>$remove(int i)$：每一次移除，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为$O(n)$。</li>
</ul>
<p>相比较顺序表，链表插入和删除的时间复杂度虽然一样，然仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预定指定存储空间大小，或者在存储过程中涉及到扩容等操作，同时它并没有涉及到元素的交换。</p>
<p>相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。</p>
<h3 id="链表反转："><a href="#链表反转：" class="headerlink" title="链表反转："></a>链表反转：</h3><p><strong>需求：</strong></p>
<ul>
<li>原链表中数据为：1-&gt;2-&gt;3-&gt;4</li>
<li>反转后链表中数据为：4-&gt;3-&gt;2-&gt;1</li>
</ul>
<p><strong>反转API：</strong></p>
<ul>
<li>public void reverse()：对整个链表反转</li>
<li>public Node reverse(Node curr)：反转链表中某个节点curr，并把反转后的curr结点返回</li>
</ul>
<p>使用递归可以完成反转，递归反转其实就是从原链表的第一个存放数据的结点开始，依次递归调用反转每一个节点，直到把最后一个结点反转完毕，整个链表就反转完毕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(head.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverse</span><span class="params">(Node curr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        head.next = curr;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">    Node pre = reverse(curr.next);</span><br><span class="line">    pre.next = curr;</span><br><span class="line">    curr.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快慢指针："><a href="#快慢指针：" class="headerlink" title="快慢指针："></a>快慢指针：</h3><p>快慢指针的定义是，这两个指针的移动速度一快一慢，以此来制造出自己想要的差值，这个差值可以让我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍。</p>
<p><strong>中间值问题：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMid</span><span class="params">(Node&lt;String&gt; first)</span></span>&#123;</span><br><span class="line">    Node&lt;String&gt; fast = first;</span><br><span class="line">    Node&lt;String&gt; slow = first;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单向链表是否有环问题：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCircle</span><span class="params">(Node first)</span></span>&#123;</span><br><span class="line">    Node fast = first;</span><br><span class="line">    Node slow = first;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast = slow)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有环链表入口问题：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getEntrance</span><span class="params">(Node first)</span></span>&#123;</span><br><span class="line">    Node fast = first;</span><br><span class="line">    Node slow = first;</span><br><span class="line">    Node temp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">            temp = first;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span>(temp == slow)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环链表："><a href="#循环链表：" class="headerlink" title="循环链表："></a>循环链表：</h3><p>链表整体要形成一个圆环状。在单向链表中，最后一个结点的指针为null，不指向任何结点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个结点的指针指向头结点即可。</p>
<h3 id="约瑟夫问题："><a href="#约瑟夫问题：" class="headerlink" title="约瑟夫问题："></a>约瑟夫问题：</h3><p>41个人坐一圈，第一个人编号为1，第二个编号为2，第n个人编号为n。编号为1的人开始报数，依次向后，报数为3的那个人退出圈；自退出那个人开始的下一个人再次从1开始报数，以此类推；求出最后退出的那个人的编号。</p>
<p><strong>解题思路：</strong></p>
<p>构建含有41个结点的单向循环链表，分别存储1~41的值，代表这41个人；使用计数器count，记录当前报数的值；遍历链表，每循环一次，count++；判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JosephTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Node&lt;Integer&gt; first = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;Integer&gt; pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">41</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                first = <span class="keyword">new</span> Node&lt;&gt;(i,<span class="keyword">null</span>);</span><br><span class="line">                pre = first;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;Integer&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(i,<span class="keyword">null</span>);</span><br><span class="line">            pre.next = newNode;</span><br><span class="line">            pre = newNode;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">41</span>)&#123;</span><br><span class="line">                pre.next = first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Node&lt;Integer&gt; temp = first;</span><br><span class="line">        Node&lt;Integer&gt; before = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp != temp.next)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">3</span>)&#123;</span><br><span class="line">                before.next = temp.next;</span><br><span class="line">                System.out.println(temp.item);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                before = temp;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        T item;</span><br><span class="line">        Node next;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种基于先进后出(FILO)的数据结构，是一种只能进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据(最后一个数据被第一个读出来)。</p>
<p>我们称数据进入到栈的动作为压栈，数据从栈中出去的动作为弹栈。</p>
<p><strong>栈的API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Stack&lt;T&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Stack()</td>
</tr>
<tr>
<td>成员方法</td>
<td>public boolean isEmpty()</td>
</tr>
<tr>
<td></td>
<td>public int size()</td>
</tr>
<tr>
<td></td>
<td>public T pop()</td>
</tr>
<tr>
<td></td>
<td>public void push(T t)</td>
</tr>
<tr>
<td>成员变量</td>
<td>private Node head</td>
</tr>
<tr>
<td></td>
<td>private int N</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node</td>
</tr>
</tbody></table>
<p><strong>栈的代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到首结点指向第一个结点</span></span><br><span class="line">        Node oldFirst = head.next;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(t,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//让新结点指向原来的第一个结点</span></span><br><span class="line">        head.next = newNode;</span><br><span class="line">        newNode.next = oldForst;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到首结点指向的第一个结点</span></span><br><span class="line">        Node oldFirst = head.next;</span><br><span class="line">        <span class="keyword">if</span>(oldFirst == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让首结点指向原来的第一个结点的下一个结点</span></span><br><span class="line">        head.next = oldFirst.next;</span><br><span class="line">        <span class="comment">//元素个数-1</span></span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> oldFirst.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SIterator()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node temp;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.temp = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> temp.next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">return</span> temp.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="括号匹配问题："><a href="#括号匹配问题：" class="headerlink" title="括号匹配问题："></a>括号匹配问题：</h3><p><strong>问题描述：</strong></p>
<p>给定一个字符串，里面可能包含“()”小括号和其他字符，通过程序检查该字符串中的小括号是否成对出现。</p>
<p>例如：</p>
<ul>
<li>“(上海)(长安)”正确匹配</li>
<li>“(上海((长安))”正确匹配</li>
<li>“上海(长安(北京)(深圳)南京)”正确匹配</li>
<li>“上海(长安))”匹配错误</li>
<li>“((上海)长安”匹配错误</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BracketsMatchTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;(上海(长安)())&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> match = isMatch(str);</span><br><span class="line">        System.out.println(match);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建栈对象，用来存储左括号</span></span><br><span class="line">        Stack&lt;String&gt; chars = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//从左往右遍历字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            String currChar = str.charAt(i) +<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(currChar.equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                chars.push(currChar);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(currChar.equals(<span class="string">&quot;)&quot;</span>))&#123;</span><br><span class="line">                String pop = chars.pop();</span><br><span class="line">                <span class="keyword">if</span>(pop == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前字符是否为左括号，如果是，则把字符放入栈中</span></span><br><span class="line">        <span class="comment">//继续判断当前字符是否有括号，如果是，则从栈中弹出一个左括号，并判断弹出的结果为null，如果为null证明没有匹配的左括号，如果不为null，则证明有匹配的左括号</span></span><br><span class="line">        <span class="comment">//判断栈中还有没有剩余的左括号</span></span><br><span class="line">        <span class="keyword">if</span>(chars.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逆波兰表达式求值问题"><a href="#逆波兰表达式求值问题" class="headerlink" title="逆波兰表达式求值问题"></a>逆波兰表达式求值问题</h3><p><strong>中缀表达式：</strong></p>
<p>中缀表达式就是生活中使用的表达式，例如：$1+3*2,2-(1+3)$等等，中缀表达式的特点是：二元运算符总是置于两个操作数中间。中缀表达式是人们最喜欢的表达方式，因为简单。但对于计算机来说就不是这样了，因为中缀表达式的运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做大量的优先级相关操作。</p>
<p><strong>逆波兰表达式(后缀表达式)：</strong></p>
<p>逆波兰表达式是波兰逻辑学家J·卢卡西维兹于1929年提出的一种表达式的表示方法，后缀表达式的特点：运算符总是放在跟它相关的操作数之后。</p>
<table>
<thead>
<tr>
<th>中缀表达式</th>
<th>逆波兰表达式</th>
</tr>
</thead>
<tbody><tr>
<td>a+b</td>
<td>ab+</td>
</tr>
<tr>
<td>a+(b-c)</td>
<td>abc-+</td>
</tr>
<tr>
<td>a+(b-c)*d</td>
<td>abc-d*+</td>
</tr>
<tr>
<td>a*(b-c)+d</td>
<td>abc-*d+</td>
</tr>
</tbody></table>
<p><strong>需求：</strong></p>
<p>给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方法，求出该逆波兰表达式的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePolishNotationTest</span></span>&#123;</span><br><span class="line">    <span class="comment">//(3*(17-15)+18/6)</span></span><br><span class="line">    String[] notation=&#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;17&quot;</span>,<span class="string">&quot;15&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;18&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;+&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = caculate(notation);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">caculate</span><span class="params">(String[] notation)</span></span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; oprands = <span class="keyword">new</span> Stack&lt;Integer&gt;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; notation.length; i++)&#123;</span><br><span class="line">            String curr = notation[i];</span><br><span class="line">            Integer o1,o2,result;</span><br><span class="line">            <span class="keyword">switch</span>(curr)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    o2 = oprands.pop();<span class="comment">//注意弹栈的顺序</span></span><br><span class="line">                    o1 = oprands.pop();</span><br><span class="line">                    result = o1+o2;</span><br><span class="line">                    oprands.push(result);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    o2 = oprands.pop();</span><br><span class="line">                    o1 = oprands.pop();</span><br><span class="line">                    result = o1-o2;</span><br><span class="line">                    oprands.push(result);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    o2 = oprands.pop();</span><br><span class="line">                    o1 = oprands.pop();</span><br><span class="line">                    result = o1*o2;</span><br><span class="line">                    oprands.push(result);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    o2 = oprands.pop();</span><br><span class="line">                    o1 = oprands.pop();</span><br><span class="line">                    result = o1/o2;</span><br><span class="line">                    oprands.push(result);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    oprands.push(Integer.parseInt(curr));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = oprands.pop();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>创建一个栈对象oprands存储操作数</li>
<li>从左向右依次遍历逆波兰表达式，拿到每一个字符</li>
<li>判断字符串是否为运算符？如果不是，把该操作数压入栈中</li>
<li>如果是运算符，则从栈中弹出两个操作数</li>
<li>使用该运算符计算得到结果</li>
<li>把该结果压入栈中</li>
<li>遍历结束后，拿出栈中的结果返回</li>
</ul>
<hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入，在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先被读出来。</p>
<p><strong>队列的API设计：</strong></p>
<table>
<thead>
<tr>
<th>类名</th>
<th>Queue</th>
</tr>
</thead>
<tbody><tr>
<td>构造方法</td>
<td>Queue()</td>
</tr>
<tr>
<td>成员方法</td>
<td>public boolean isEmpty()</td>
</tr>
<tr>
<td></td>
<td>public int size()</td>
</tr>
<tr>
<td></td>
<td>public T dequeue()</td>
</tr>
<tr>
<td></td>
<td>public void enqueue(T t)</td>
</tr>
<tr>
<td>成员变量</td>
<td>private Node head</td>
</tr>
<tr>
<td></td>
<td>private int N</td>
</tr>
<tr>
<td></td>
<td>private Node last</td>
</tr>
<tr>
<td>成员内部类</td>
<td>private class Node</td>
</tr>
</tbody></table>
<p><strong>队列的代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    priavte <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> T item;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T item, Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.item = item;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.N = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(last == <span class="keyword">null</span>)&#123;</span><br><span class="line">            last = <span class="keyword">new</span> Node(t,<span class="keyword">null</span>);</span><br><span class="line">            head.next = last;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Node oldlast = last;</span><br><span class="line">            last = <span class="keyword">new</span> Node(t,<span class="keyword">null</span>);</span><br><span class="line">            oldlast.next = last;</span><br><span class="line">        &#125;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node oldFirst = head.next;</span><br><span class="line">        head.next = oldFirst.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldFirst.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    priavte <span class="class"><span class="keyword">class</span> <span class="title">QIterator</span> <span class="keyword">implements</span> <span class="title">iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node temp;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QIterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.temp = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> temp.next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">return</span> temp.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《On Java 8》-- 第九章 多态</title>
    <url>/2021/05/11/%E9%98%85%E8%AF%BB%E3%80%8AOn-Java-8%E3%80%8B-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>​        多态是面向对象编程语言中，继数据抽象和继承之外的第三个重要特性。</p>
<p>​        多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做。多态不仅能改善代码的组织，提高代码的可读性，而且能创建有扩展性的程序——无论在最初创建项目还是在添加新特性时都可以“生长”的程序。</p>
<p>​        封装通过合并特征和行为来创建新的数据类型。隐藏实现通过将细节私有化把接口与实现分离。这种类型的组织机制对于有面向过程编程背景的人来说，更容易理解。而多态是消除类型之间的耦合。在上一章中，继承允许把一个对象视为它本身的类型或它的基类类型。这样就能把很多派生自一个基类的类型当作同一类型处理，因而一段代码就可以无差别地运行在所有不同的类型上了。多态方法调用允许一种类型表现出与相似类型的区别，只要这些类型派生自一个基类。这种区别是当你通过基类调用时，由方法的不同行为表现出来的。</p>
 <span id="more"></span> 

<h2 id="向上转型回顾"><a href="#向上转型回顾" class="headerlink" title="向上转型回顾"></a>向上转型回顾</h2><p>​        在上一章，你看到了如何把一个对象视作它的自身类型或它的基类类型。这种把一个对象引用当作它的基类引用的做法称为向上转型，因为继承图中基类一般位于最上方。</p>
<p>​        同样你也在下面的音乐乐器例子中发现了问题。既然几个例子都要演奏乐符(Note)，首先我们先在包中单独创建一个Note枚举类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Note.java</span></span><br><span class="line"><span class="comment">// Notes to play on musical instruments</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Note</span> </span>&#123;</span><br><span class="line">    MIDDLE_C, C_SHARP, B_FLAT; <span class="comment">// Etc.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这里，Wind是一种Instrument；因此，Wind继承Instrument：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Instrument.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Instrument.play()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// polymorphism/music/Wind.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"><span class="comment">// Wind objects are instruments</span></span><br><span class="line"><span class="comment">// because they have the same interface:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Redefine interface method:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wind.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        Music的方法tune()接收一个Instrument引用，同时也接受任何派生自Instrument的类引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Music.java</span></span><br><span class="line"><span class="comment">// Inheritance &amp; upcasting</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.music.Music&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        tune(flute); <span class="comment">// Upcasting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Wind.play() MIDDLE_C</span></span><br></pre></td></tr></table></figure>

<p>​        在main()中你看到了tune()方法传入了一个Wind引用，而没有做类型转换。这样做是允许的——Instrument的接口一定存在于Wind中，因此Wind继承了Instrument。从Wind向上转型为Instrument可能“缩小”接口，但不会比Instrument的全部接口更少。</p>
<h3 id="忘掉对象类型"><a href="#忘掉对象类型" class="headerlink" title="忘掉对象类型"></a>忘掉对象类型</h3><p>​        Music.java看起来似乎有点奇怪。为什么所有人都故意忘记掉对象类型呢？当向上转型时，就会发生这种情况，而且看起来如果tune()接受的参数是一个Wind引用会更为直观。这会带来一个重要问题：如果你那么做，就要为系统内Instrument的每种类型都编写一个新的tune()方法。假设按照这种推理，再增加Stringed和Brass这两种Instrument：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music/Music2.java</span></span><br><span class="line"><span class="comment">// Overloading instead of upcasting</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.music.Music2&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stringed.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Brass.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Wind i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Stringed i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Brass i)</span> </span>&#123;</span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        Stringed violin = <span class="keyword">new</span> Stringed();</span><br><span class="line">        Brass frenchHorn = <span class="keyword">new</span> Brass();</span><br><span class="line">        tune(flute); <span class="comment">// No upcasting</span></span><br><span class="line">        tune(violin);</span><br><span class="line">        tune(frenchHorn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Wind.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Stringed.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Brass.play() MIDDLE_C</span></span><br></pre></td></tr></table></figure>

<p>​        这样行的通，但是有一个主要缺点：必须为添加的每个新的Instrument类编写特定的方法。这意味着开始时就需要更多的编程，而且以后如果添加类似tune()的新方法或Instrument的新类型时，还有大量的工作要做。考虑到如果你忘记重载某个方法，编译器也不会提示你，这会造成类型的整个处理过程变得难以管理。</p>
<p>​        如果只写一个方法以基类作为参数，而不用管是哪个具体派生类，这样会变得更好吗？也就是说，如果忘掉派生类，编写的代码只与基类打交道，会不会更好呢？</p>
<p>​        这正是多态所允许的。但是大部分拥有面向过程编程背景的程序员会对多态的运作方式感到一些困惑。</p>
<h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>​        运行程序后会看到Music.java的难点。Wind.play()的输出结果正是我们期望的，然后它看起来似乎不应该得出这样的结果。观察tune()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    i.play(Note.MIDDLE_C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        它接受一个Instrument引用。那么编译器是如何知道这里的Instrument引用指向的是Wind，而不是Brass或Stringed呢？编译器无法得知。为了深入理解这个问题，有必要研究一下绑定这个主题。</p>
<h3 id="方法调用绑定"><a href="#方法调用绑定" class="headerlink" title="方法调用绑定"></a>方法调用绑定</h3><p>​        将一个方法调用和一个方法主体关联起来称作绑定。若绑定发生在程序运行前(如果有的话，由编译器和链接器实现)，叫做前期绑定。你可能从来没有听说这个术语，因为它是面向过程语言不需选择的绑定方式，例如在C语言中就只有前期绑定这一种方法调用。</p>
<p>​        上述程序让人困惑的地方在于前期绑定，因为编译器只知道一个Instrument引用，它无法得知究竟会调用哪个方法。</p>
<p>​        解决方法就是后期绑定，意味着在运行时根据对象的类型进行绑定。后期绑定也称为动态绑定或运行时绑定。当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器仍然不知道对象的类型，但是方法调用机制能找到正确的方法体并调用。每种语言的后期绑定机制不同，但是可以想到，对象中一定存在某种类型信息。</p>
<p>​        Java中除了static和final方法(private方法也是隐式的final)外，其它所有方法都是后期绑定。这意味着通常情况下，我们不需要判断后期绑定是否会发生——它自动发生。</p>
<p>​        为什么将一个对象指明为final？正如前一章所述，它可以防止方法被重写。但更重要的一点可能是，它有效地“关闭了”动态绑定，或者说告诉编译器不需要对其进行动态绑定。这可以让编译器为final方法生成更高效的代码。然而，大部分情况下这样做不会对程序的整体性能带来什么改变，因此最好是为了设计使用final，而不是为了提升性能而使用。</p>
<h3 id="产生正确的行为"><a href="#产生正确的行为" class="headerlink" title="产生正确的行为"></a>产生正确的行为</h3><p>​        一旦当你知道Java中所有方法都是通过后期绑定来实现多态时，就可以编写只与基类打交道的代码，而且代码对于派生类来说都能正常地工作。或者换种说法，你向对象发送一条消息，让对象自己做正确的事。</p>
<p>​        在形状的例子中，有一个基类称为Shape，多个不同的派生类型分别是：Circle、Square、Triangle等等。</p>
<p>​        向上转型就像下面这么简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shape s = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure>

<p>​        这会创建一个Circle对象，引用被赋值给Shape类型的变量s，这看似错误(将一种类型赋值给另一种类型)，然而是没问题的，因此从继承上认为圆(Circle)就是一个形状(Shape)。因此编译器认可了赋值语句，没有报错。</p>
<p>​        假设你调用了一个基类方法(在各个派生类中都被重写)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s.draw()</span><br></pre></td></tr></table></figure>

<p>​        你可能再次认为Shape的draw()方法被调用，因为s是一个Shape引用——编译器怎么可能知道要做其它的事呢？然而，由于后期绑定(多态)被调用的是Circle的draw()方法，这是正确的。</p>
<p>​        下面的例子稍微有些不同。首先让我们创建一个可复用的Shape类库，基类Shape为它的所有子类建立了公共接口——所有形状都可以被绘画和擦除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/shape/Shape.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        派生类通过重写这些方法为每个具体的形状提供独一无二的方法行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/shape/Circle.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle.erase()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// polymorphism/shape/Square.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square.erase()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// polymorphism/shape/Triangle.java</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Triangle.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Triangle.erase()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        RandomShapes是一种工厂，每当我们调用get()方法时，就会产生一个指向随机创建的Shape对象的引用。注意，向上转型发生在return语句中，每条return语句取得一个指向某个Circle，Square或Triangle的引用，并将其以Shape类型从get()方法发送出去。因此无论何时调用get()方法，你都无法知道具体的类型是什么，因为你总是得到一个简单的Shape引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/shape/RandomShapes.java</span></span><br><span class="line"><span class="comment">// A &quot;factory&quot; that randomly creates shapes</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.shape;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomShapes</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(rand.nextInt(<span class="number">3</span>)) &#123;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">new</span> Triangle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Shape[] array(<span class="keyword">int</span> sz) &#123;</span><br><span class="line">        Shape[] shapes = <span class="keyword">new</span> Shape[sz];</span><br><span class="line">        <span class="comment">// Fill up the array with shapes:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shapes.length; i++) &#123;</span><br><span class="line">            shapes[i] = get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shapes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        array()方法分配并填充了Shape数组，这里使用了for-in表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Shapes.java</span></span><br><span class="line"><span class="comment">// Polymorphism in Java</span></span><br><span class="line"><span class="keyword">import</span> polymorphism.shape.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RandomShapes gen = <span class="keyword">new</span> RandomShapes();</span><br><span class="line">        <span class="comment">// Make polymorphic method calls:</span></span><br><span class="line">        <span class="keyword">for</span> (Shape shape: gen.array(<span class="number">9</span>)) &#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Triangle.draw()</span></span><br><span class="line"><span class="comment">//Triangle.draw()</span></span><br><span class="line"><span class="comment">//Square.draw()</span></span><br><span class="line"><span class="comment">//Triangle.draw()</span></span><br><span class="line"><span class="comment">//Square.draw()</span></span><br><span class="line"><span class="comment">//Triangle.draw()</span></span><br><span class="line"><span class="comment">//Square.draw()</span></span><br><span class="line"><span class="comment">//Triangle.draw()</span></span><br><span class="line"><span class="comment">//Circle.draw()</span></span><br></pre></td></tr></table></figure>

<p>​        main()方法中包含了一个Shape引用组成的数组，其中每个元素通过调用RandomShapes类的get()方法生成。现在你知道拥有一些形状，但除此之外一无所知。然而当遍历这个数组为每个元素调用draw()方法时，从运行程序的结果中可以看到，与类型有关的特定行为奇迹般地发生了。</p>
<p>​        随机生成形状是为了让大家理解：在编译时，编译器不需要知道任何具体信息以进行正确的调用。所有对方法draw()的调用都是通过动态绑定进行的。</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>​        现在让我们回头看音乐乐器的例子。由于多态机制，你可以向系统中添加任意多的新类型，而不需要修改tune()方法。在一个设计良好的面向对象程序中，许多方法将会遵循tune()的模型，只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类派生出新的数据类型，从而添加新的功能。那些操纵基类接口的方法不需要改动就可以应用于新类。</p>
<p>​        考虑一下乐器的例子，如果在基类中添加更多的方法，并加入一些新类，将会发生什么呢：</p>
<p>​        所有的新类都可以和原有类正常运行，不需要改动tune()方法。即使tune()方法单独存放在某个文件中，而且向Instrument接口中添加了新的方法，tune()方法也无需再编译就能正确运行。下面为类图的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/music3/Music3.java</span></span><br><span class="line"><span class="comment">// An extensible program</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.music3.Music3&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism.music3;</span><br><span class="line"><span class="keyword">import</span> polymorphism.music.Note;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Instrument.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Instrument&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Instrument&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wind.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Wind&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Percussion</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Percussion.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Percussion&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Percussion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stringed.play() &quot;</span> + n);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Stringed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Stringed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Brass.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adjusting Brass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woodwind</span> <span class="keyword">extends</span> <span class="title">Wind</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woodwind.play() &quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woodwind&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Doesn&#x27;t care about type, so new types</span></span><br><span class="line">    <span class="comment">// added to the system still work right:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play(Note.MIDDLE_C);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tuneAll</span><span class="params">(Instrument[] e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Instrument i: e) &#123;</span><br><span class="line">            tune(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Upcasting during addition to the array:</span></span><br><span class="line">        Instrument[] orchestra = &#123;</span><br><span class="line">            <span class="keyword">new</span> Wind(),</span><br><span class="line">            <span class="keyword">new</span> Percussion(),</span><br><span class="line">            <span class="keyword">new</span> Stringed(),</span><br><span class="line">            <span class="keyword">new</span> Brass(),</span><br><span class="line">            <span class="keyword">new</span> Woodwind()</span><br><span class="line">        &#125;;</span><br><span class="line">        tuneAll(orchestra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Wind.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Percussion.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Stringed.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Brass.play() MIDDLE_C</span></span><br><span class="line"><span class="comment">//Woodwind.play() MIDDLE_C</span></span><br></pre></td></tr></table></figure>

<p>​        新方法what()返回一个带有类描述的String引用，adjust()提供一些乐器调音的方法。</p>
<p>​        在main()方法中，当向orchestra数组添加元素时，元素会自动向上转型为Instrument。</p>
<p>​        tune()方法可以忽略周围所有代码发生的变化，仍然可以正常运转。这正是我们期待多态能提供的特性。代码中的修改不会破坏程序中其它不应受到影响的部分。换句话说，多态是一项“将改变的事物与不变的事务分离”的重要技术。</p>
<h3 id="陷阱：“重写”私有方法"><a href="#陷阱：“重写”私有方法" class="headerlink" title="陷阱：“重写”私有方法"></a>陷阱：“重写”私有方法</h3><p>​        你可能天真地试图像下面这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/PrivateOverride.java</span></span><br><span class="line"><span class="comment">// Trying to override a private method</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.PrivateOverride&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateOverride</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrivateOverride po = <span class="keyword">new</span> Derived();</span><br><span class="line">        po.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">PrivateOverride</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;public f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//private f()</span></span><br></pre></td></tr></table></figure>

<p>​        你可能期望输出是public f()，然而private方法可以当作final的，对于派生类来说是隐蔽的。因此，这里Derived的f()是一个全新的方法；因为基类版本的f()屏蔽了Derived，因此它都不算是重写方法。</p>
<p>​        结论是只有非private方法才能被重写，但是得小心重写private方法的现象，编译器不报错，但不会按我们所预期的执行。为了清晰起见，派生类中的方法名与基类中private方法名不同的命名。</p>
<p>​        如果使用了@Override注解，就能检测出问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/PrivateOverride2.java</span></span><br><span class="line"><span class="comment">// Detecting a mistaken override using @Override</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateOverride2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrivateOverride2 po = <span class="keyword">new</span> Derived2();</span><br><span class="line">        po.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> <span class="keyword">extends</span> <span class="title">PrivateOverride2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;public f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//error: method does not override or</span></span><br><span class="line"><span class="comment">//implement a method from a supertype</span></span><br></pre></td></tr></table></figure>

<h3 id="陷阱：属性与静态方法"><a href="#陷阱：属性与静态方法" class="headerlink" title="陷阱：属性与静态方法"></a>陷阱：属性与静态方法</h3><p>​        一旦学会了多态，就可以以多态的思维方式考虑每件事。然而，只有普通的方法调用可以是多态的。例如，如果你直接访问一个属性，该访问会在编译时解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/FieldAccess.java</span></span><br><span class="line"><span class="comment">// Direct field access is determined at compile time</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSuperField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Super sup = <span class="keyword">new</span> Sub(); <span class="comment">// Upcast</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sup.field = &quot;</span> + sup.field + </span><br><span class="line">                          <span class="string">&quot;, sup.getField() = &quot;</span> + sup.getField());</span><br><span class="line">        Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">        System.out.println(<span class="string">&quot;sub.field = &quot;</span> + sub.field + </span><br><span class="line">                          <span class="string">&quot;, sub.getField() = &quot;</span> + sub.getField()</span><br><span class="line">                          + <span class="string">&quot;, sub.getSuperField() = &quot;</span> + sub.getSuperField())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sup.field = 0, sup.getField() = 1</span></span><br><span class="line"><span class="comment">//sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0</span></span><br></pre></td></tr></table></figure>

<p>​        当Sub对象向上转型为Super引用，任何属性访问都被编译器解析，因此不是多态的。在这个例子中，Super.field和Sub.field被分配了不同的存储空间，因此，Sub实际上包含了两个称为field的属性：它自己的和来自Super的。然而，在引用Sub的field属性时，默认的field属性并不是Super版本的field属性。为了获取Super的field属性，需要显示地指明super.field。</p>
<p>​        尽管这看起来是个令人困惑的问题，实际上基本不会发生。首先，通常会将所有的属性都声明为private，因此不能直接访问它们，只能通过方法来访问。此外，你可能也不会给基类属性和派生类属性起相同的名字，这样做会令人困惑。</p>
<p>​        如果是一个方法是静态(static)的，它的行为就不具有多态性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/StaticPolymorphism.java</span></span><br><span class="line"><span class="comment">// static methods are not polymorphic</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base staticGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dynamicGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base dynamicGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSub</span> <span class="keyword">extends</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Derived staticGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dynamicGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Derived dynamicGet()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticPolymorphism</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticSuper sup = <span class="keyword">new</span> StaticSub(); <span class="comment">// Upcast</span></span><br><span class="line">        System.out.println(StaticSuper.staticGet());</span><br><span class="line">        System.out.println(sup.dynamicGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Base staticGet()</span></span><br><span class="line"><span class="comment">//Derived dynamicGet()</span></span><br></pre></td></tr></table></figure>

<p>​        静态的方法只与类关联，与单个的对象无关。</p>
<h2 id="构造器和多态"><a href="#构造器和多态" class="headerlink" title="构造器和多态"></a>构造器和多态</h2><p>​        通常，构造器不同于其它类型的方法。在涉及多态时也是如此。尽管构造器不具有多态性(事实上人们会把它看作是隐式声明的静态方法)，但是理解构造器在复杂层次结构中运作多态还是非常重要的。理解这个可以帮助你避免一些不愉快的困扰。</p>
<h3 id="构造器调用顺序"><a href="#构造器调用顺序" class="headerlink" title="构造器调用顺序"></a>构造器调用顺序</h3><p>​        在“初始化和清理”和“复用”两章中已经简单地介绍过构造器的调用顺序，但那时还没有介绍多态。</p>
<p>​        在派生类的构造过程中总会调用基类的构造器。初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。这么做是有意义的，因为构造器有着特殊的任务：检查对象是否被正确地构造。由于属性通常声明为private，你必须假定派生类只能访问自己的成员而不能访问基类的成员。只有基类的构造器拥有恰当的知识和权限来初始化自身的元素。因此，必须得调用所有构造器；否则就不能构造完整的对象。这就是为什么编译器会强制调用每个派生类中的构造器的原因。如果在派生类的构造器主体中没有显示地调用基类构造器，编译器就会默默地调用无参构造器。如果没有无参构造器，编译器就会报错(当类中不含有构造器时，编译器会自动合成一个无参构造器)。</p>
<p>​        下面的例子展示了组合、继承和多态在构建顺序上的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Sandwich.java</span></span><br><span class="line"><span class="comment">// Order of constructor calls</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.Sandwich&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    Meal() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meal()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> </span>&#123;</span><br><span class="line">    Bread() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bread()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span> </span>&#123;</span><br><span class="line">    Cheese() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cheese()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lettuce</span> </span>&#123;</span><br><span class="line">    Lettuce() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lettuce()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> <span class="keyword">extends</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    Lunch() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lunch()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PortableLunch</span> <span class="keyword">extends</span> <span class="title">Lunch</span> </span>&#123;</span><br><span class="line">    PortableLunch() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PortableLunch()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sandwich</span> <span class="keyword">extends</span> <span class="title">PortableLunch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Bread b = <span class="keyword">new</span> Bread();</span><br><span class="line">    <span class="keyword">private</span> Cheese c = <span class="keyword">new</span> Cheese();</span><br><span class="line">    <span class="keyword">private</span> Lettuce l = <span class="keyword">new</span> Lettuce();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sandwich</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sandwich()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Sandwich();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Meal()</span></span><br><span class="line"><span class="comment">//Lunch()</span></span><br><span class="line"><span class="comment">//PortableLunch()</span></span><br><span class="line"><span class="comment">//Bread()</span></span><br><span class="line"><span class="comment">//Cheese()</span></span><br><span class="line"><span class="comment">//Lettuce()</span></span><br><span class="line"><span class="comment">//Sandwich()</span></span><br></pre></td></tr></table></figure>

<p>​        这个例子用其他类创建了一个复杂的类。每个类都在构造器中声明自己。重要的类是Sandwich，它反映了三层继承(如果算上Object的话，就是四层)，包含了三个成员对象。</p>
<p>​        从创建Sandwich对象的输出中可以看出对象的构造器调用顺序如下：</p>
<ul>
<li>基类构造器被调用。这个步骤被递归地重复，这样一来类层次的顶级父类会被最先构造，然后是它的派生类，以此类推，直到最顶层的派生类。</li>
<li>按声明顺序初始化成员。</li>
<li>调用派生类构造器的方法体。</li>
</ul>
<p>​        构造器的调用顺序很重要。当使用继承时，就已经知道了基类的一切，并可以访问基类中任意public和protected的成员。这意味着在派生类中可以假定所有基类成员都是有效的。在一个标准方法中，构造动作已经发生过，对象其它部分的所有成员都已经创建好。</p>
<p>​        在构造器中必须确保所有的成员都已经构建完。唯一能保证这点的方法就是首先调用基类的构造器。接着，在派生类的构造器中，所有你可以访问的基类成员都已经初始化。另一个在构造器中能知道所有成员都是有效的理由的是：无论何时有可能的话，你应该在所有成员对象(通过组合将对象置于类中)定义处初始化它们。如果遵循这条实践，就可以帮助确保所有的基类成员和当前对象的成员对象都已经初始化。</p>
<p>​        不幸的是，这不能处理所有情况，在下一节会看到。</p>
<h3 id="继承和清理"><a href="#继承和清理" class="headerlink" title="继承和清理"></a>继承和清理</h3><p>​        在使用组合和继承创建新类时，大部分时候你无需关心清理。子对象通常会留给垃圾收集器处理。如果你存在清理问题，那么必须用心地为新类创建一个dispose()方法(这里用的是我选择的名称，你可以使用更好的名称)。由于继承，如果有其它特殊的清理工作的话，就必须在派生类中重写dispose()方法。当重写dispose()方法时，记得调用基类的dispose()方法，否则基类的清理工作不会发生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Frog.java</span></span><br><span class="line"><span class="comment">// Cleanup and inheritance</span></span><br><span class="line"><span class="comment">// &#123;java polymorphism.Frog&#125;</span></span><br><span class="line"><span class="keyword">package</span> polymorphism;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Characteristic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    </span><br><span class="line">    Characteristic(String s) &#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating Characteristic &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;disposing Characteristic &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Description</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    </span><br><span class="line">    Description(String s) &#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating Description &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;disposing Description &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LivingCreature</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">&quot;is alive&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">&quot;Basic Living Creature&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    LivingCreature() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LivingCreature()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LivingCreature dispose&quot;</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">LivingCreature</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">&quot;has heart&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">&quot;Animal not Vegetable&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Animal() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal dispose&quot;</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">&quot;can live in water&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">&quot;Both water and land&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Amphibian() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Amphibian()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Amphibian dispose&quot;</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">extends</span> <span class="title">Amphibian</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">&quot;Croaks&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">&quot;Eats Bugs&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Frog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Frog()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Frog dispose&quot;</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frog frog = <span class="keyword">new</span> Frog();</span><br><span class="line">        System.out.println(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">        frog.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Creating Characteristic is alive</span></span><br><span class="line"><span class="comment">//Creating Description Basic Living Creature</span></span><br><span class="line"><span class="comment">//LivingCreature()</span></span><br><span class="line"><span class="comment">//Creating Characteristiv has heart</span></span><br><span class="line"><span class="comment">//Creating Description Animal not Vegetable</span></span><br><span class="line"><span class="comment">//Animal()</span></span><br><span class="line"><span class="comment">//Creating Characteristic can live in water</span></span><br><span class="line"><span class="comment">//Creating Description Both water and land</span></span><br><span class="line"><span class="comment">//Amphibian()</span></span><br><span class="line"><span class="comment">//Creating Characteristic Croaks</span></span><br><span class="line"><span class="comment">//Creating Description Eats Bugs</span></span><br><span class="line"><span class="comment">//Frog()</span></span><br><span class="line"><span class="comment">//Bye!</span></span><br><span class="line"><span class="comment">//Frog dispose</span></span><br><span class="line"><span class="comment">//disposing Description Eats Bugs</span></span><br><span class="line"><span class="comment">//disposing Characteristic Croaks</span></span><br><span class="line"><span class="comment">//Amphibian dispose</span></span><br><span class="line"><span class="comment">//disposing Description Both wanter and land</span></span><br><span class="line"><span class="comment">//disposing Characteristic can live in water</span></span><br><span class="line"><span class="comment">//Animal dispose</span></span><br><span class="line"><span class="comment">//disposing Description Animal not Vegetable</span></span><br><span class="line"><span class="comment">//disposing Characteristic has heart</span></span><br><span class="line"><span class="comment">//LivingCreature dispose</span></span><br><span class="line"><span class="comment">//disposing Description Basic Living Creature</span></span><br><span class="line"><span class="comment">//disposing Characteristic is alive</span></span><br></pre></td></tr></table></figure>

<p>​        层级结构中的每个类都有Characteristic和Description两个类型的成员对象，它们必须得被销毁。销毁得顺序应该与初始化的顺序相反，以访一个对象依赖另一个对象。对于属性来说，就意味着与声明的顺序相反(因为属性是按照声明顺序初始化的)。对于基类，首先进行派生类的清理工作，然后才是基类的清理。这是因为派生类的清理可能调用基类的一些方法，所以基类组件这时得存活，不能过早地被销毁。输出显示了，Frog对象的所有部分都是按照创建的逆序销毁的。</p>
<p>​        尽管通常不必进行清理工作，但万一需要时，就得谨慎小心地执行。</p>
<p>​        Frog对象拥有自己的成员对象，它创建了这些成员对象，并且知道它们能存活多久，所以它知道何时调用dispose()方法。然而，一旦某个成员对象被其它一个或多个对象共享时，问题就变得复杂了，不能简单地调用dispose()。这里，也许就必须使用引用计数来跟踪仍然访问着共享对象数量，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/ReferenceCounting.java</span></span><br><span class="line"><span class="comment">// Cleaning up shared member objects</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    </span><br><span class="line">    Shared() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        refcount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (--refcount == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Disposing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Shared &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Shared shared;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    </span><br><span class="line">    Composing(Shared shared) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.shared = shared;</span><br><span class="line">        <span class="keyword">this</span>.shared.addRef();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;disposing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        shared.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Composing &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCounting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shared shared = <span class="keyword">new</span> Shared();</span><br><span class="line">        Composing[] composing = &#123;</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">            <span class="keyword">new</span> Composing(shared),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (Composing c: composing) &#123;</span><br><span class="line">            c.dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Creating Shared 0</span></span><br><span class="line"><span class="comment">//Creating Composing 0</span></span><br><span class="line"><span class="comment">//Creating Composing 1</span></span><br><span class="line"><span class="comment">//Creating Composing 2</span></span><br><span class="line"><span class="comment">//Creating Composing 3</span></span><br><span class="line"><span class="comment">//Creating Composing 4</span></span><br><span class="line"><span class="comment">//disposing Composing 0</span></span><br><span class="line"><span class="comment">//disposing Composing 1</span></span><br><span class="line"><span class="comment">//disposing Composing 2</span></span><br><span class="line"><span class="comment">//disposing Composing 3</span></span><br><span class="line"><span class="comment">//disposing Composing 4</span></span><br><span class="line"><span class="comment">//Disposing Shared 0</span></span><br></pre></td></tr></table></figure>

<p>​        static long counter跟踪所创建的Shared实例数量，还提供了id的值。counter的类型是long而不是int，以防溢出。id是final的，因为它的值在初始化时确定后不应该变化。</p>
<p>​        在将一个shared对象附着在类上时，必须记住调用addRef()，而dispose()方法会跟踪引用数，以确定在何时真正地执行清理工作。使用这种技巧需要加倍小心，但是如果需要清理正在共享的对象，你没有太多选择。</p>
<h3 id="构造器内部多态方法的行为"><a href="#构造器内部多态方法的行为" class="headerlink" title="构造器内部多态方法的行为"></a>构造器内部多态方法的行为</h3><p>​        构造器调用的层次结构带来了一个困境。如果在构造器中调用了正在构造的对象的动态绑定方法，会发生什么？</p>
<p>​        在普通的方法中，动态绑定的调用是在运行时解析的，因为对象不知道它属于方法所在的类还是类的派生类。</p>
<p>​        如果在构造器中调用了动态绑定方法，就会用到那个方法的重写定义。然而，调用的结果难以预料因为被重写的方法在对象被完全构造出来之前已经被调用，这使得一些bug很隐蔽，难以发现。</p>
<p>​        从概念上将，构造器的工作就是创建对象。在构造器内部，整个对象可能只是部分形成——只知道基类对象已经初始化。如果构造器只是构造对象过程中的一个步骤，且构造器的对象所属的类是从构造器所属的类派生的，那么派生部分在当前构造器被调用时还没有初始化。然而，一个动态绑定的方法调用向外深入到继承层次结构中，它可以调用派生类的方法。如果你在构造器中这么做，就可能调用一个方法，该方法操作的成员可能还没有初始化——这肯定会带来灾难：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/PolyConstructors.java</span></span><br><span class="line"><span class="comment">// Constructors and polymorphism</span></span><br><span class="line"><span class="comment">// don&#x27;t produce what you might expect</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Glyph.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Glyph() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Glyph() before draw()&quot;</span>);</span><br><span class="line">        draw();</span><br><span class="line">        System.out.println(<span class="string">&quot;Glyph() after draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    RoundGlyph(<span class="keyword">int</span> r) &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">        System.out.println(<span class="string">&quot;RoundGlyph.RoundGlyph(), radius = &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RoundGlyph.draw(), radius = &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> RoundGlyph(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Glyph() before draw()</span></span><br><span class="line"><span class="comment">//RoundGlyph.draw(), radius = 0</span></span><br><span class="line"><span class="comment">//Glyph() after draw()</span></span><br><span class="line"><span class="comment">//RoundGlyph.RoundGlyph(), radius = 5</span></span><br></pre></td></tr></table></figure>

<p>​        Glyph()的draw()被设计为可重写，在RoundGlyph这个方法被重写。但是Glyph的构造器里调用了这个方法，结果调用了RoundGlyph的draw()方法，这看起来正是我们的目的。输出结果表明，当Glyph构造器调用了draw()时，radius的值不是默认初始值1而是0。这可能会导致在屏幕上只画了一个点或干脆什么都不画，于是我们只能干瞪眼，试图找到程序不工作的原因。</p>
<p>​        前一小节描述的初始化顺序并不十分完整，而这正是解决谜团的关键所在。初始化过程是：</p>
<ul>
<li>在所有事发生前，分配给对象的存储空间会被初始化为二进制0。</li>
<li>如前所述调用基类构造器。此时调用重写后的draw()方法(是的，在调用RoundGraph构造器之前调用)，由步骤1可知，radius的值为0。</li>
<li>按声明顺序初始化成员。</li>
<li>最终调用派生类的构造器。</li>
</ul>
<p>​        这么做有个优点：所有事物至少初始化为0(或某些特殊数据类型与0等价的值)，而不是仅仅留作垃圾。这包括了通过组合嵌入类中的对象引用，被赋予null。如果忘记初始化该引用，就会在运行时出现异常。观察输出结果，就会发现所有事物都是0。</p>
<p>​        另一方面，应该震惊于输出结果。逻辑方面我们已经做得非常完美，然而行为让不可思议的错了，编译器也没有报错。像这样的bug很容易被忽略，需要花很长时间才能发现。</p>
<p>​        因此，编写构造器有一条良好规范：做尽量少的事让对象进入良好的状态。如果有可能的话，尽量不要调用类中的任何方法。在基类的构造器中能安全调用的只有基类的final方法(这也适用于可被看作是final的private方法)。这些方法不能被重写，因此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。</p>
<h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2><p>​        Java5中引入了协变返回类型，这表示派生类的被重写方法可以返回基类方法返回类型的派生类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/CovariantReturn.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Grain&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheat</span> <span class="keyword">extends</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wheat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">    <span class="function">Grain <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Grain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WheatMill</span> <span class="keyword">extends</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Wheat <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wheat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mill m = <span class="keyword">new</span> Mill();</span><br><span class="line">        Grain g = m.process();</span><br><span class="line">        System.out.println(g);</span><br><span class="line">        m = <span class="keyword">new</span> WheatMill();</span><br><span class="line">        g = m.process();</span><br><span class="line">        System.out.println(g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Grain</span></span><br><span class="line"><span class="comment">//Wheat</span></span><br></pre></td></tr></table></figure>

<p>​        关键区别在于Java5之前的版本强制要求被重写的process()方法必须返回Grain而不是Wheat，即使Wheat派生自Grain，因而也应该是一种合法的返沪类型。协变返回类型允许返回更具体的Wheat类型。</p>
<h2 id="使用继承设计"><a href="#使用继承设计" class="headerlink" title="使用继承设计"></a>使用继承设计</h2><p>​        学习过多态之后，一切看似都可以被继承，因为多态是如此巧妙的工具。这会给设计带来负担。事实上，如果利用已有类创建新类首先选择继承的话，事情会变得莫名的复杂。</p>
<p>​        更好的方法是首先选择组合，特别是不知道该使用哪种方法时。组合不会强制设计是继承层次结构，而且组合更加灵活，因为可以动态地选择类型，而继承要求必须在编译时知道确切类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/Transmogrify.java</span></span><br><span class="line"><span class="comment">// Dynamically changing the behavior of an object</span></span><br><span class="line"><span class="comment">// via composition (the &quot;State&quot; design pattern)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HappyActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HappyActor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SadActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">act</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SadActor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Actor actor = <span class="keyword">new</span> HappyActor();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        actor = <span class="keyword">new</span> SadActor();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        actor.act();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmogrify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stage stage = <span class="keyword">new</span> Stage();</span><br><span class="line">        stage.performPlay();</span><br><span class="line">        stage.change();</span><br><span class="line">        stage.performPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HappyActor</span></span><br><span class="line"><span class="comment">//SadActor</span></span><br></pre></td></tr></table></figure>

<p>​        Stage对象中包含了Actor引用，改引用被初始化指向一个HappyActor对象，这意味着performPlay()会产生一个特殊行为。但是既然引用可以在运行时与其它不同的对象绑定，那么它就可以被替换成SadActor的引用，performPlay()的行为随之改变。这样你就获得了运行时的灵活性(这被称为状态模式)。与之相反，我们无法在运行时才决定继承不同的对象；那在编译时就完全决定好了。</p>
<p>​        有一条通用准则：使用继承表达行为的差异，使用属性表达状态的变化。在上个例子中，两者都用到了。通过继承得到的两个类在act()方法中表达了不同的行为，Stage通过组合使自己的状态发生变化。这里状态的改变产生了行为的改变。</p>
<h3 id="替代-vs-扩展"><a href="#替代-vs-扩展" class="headerlink" title="替代 vs 扩展"></a>替代 vs 扩展</h3><p>​        采用“纯粹”的方式创建继承层次结构看上去是最清晰的方法。即只有基类的方法才能在派生类中被重写。</p>
<p>​        这被称作纯粹的“is-a”关系，因为类的接口已经确定了它是什么。继承可以确保任何派生类都拥有基类的接口，绝对不会少。如果按上面这么做，派生类将只拥有基类的接口。</p>
<p>​        纯粹的替代意味着派生类可以完美地替代基类，当使用它们时，完全不需要知道这些子类的信息。也就是说，基类可以接受任意发送给派生类的消息，因为它们具有完全相同的接口。只需将派生类向上转型，不要关注对象的具体类型。所有一切都可以通过多态处理。</p>
<p>​        按这种方式思考，似乎只有纯粹的“is-a”关系才是唯一明智的做法，其他任何设计只会导致混乱且注定失败。这其实也是个陷阱。一旦按这种方式开始思考，就会转而发现继承扩展接口(遗憾的是，extends关键字似乎怂恿我们这么做)才是解决特定问题的完美方案。这可以称为“is-like-a”关系，因为派生类就像是基类——它有着相同的基本接口，但还具有需要额外方法实现的其他特性：</p>
<p>​        虽然这是一种有用且明智的方法，但是也存在缺点。派生类中接口的扩展部分在基类中不存在，因此一旦向上转型，就不能通过基类调用这些新方法：</p>
<p>​        如果不向上转型，就不会遇到这个问题。但通常情况下，我们需要重新查明对象的确切类型，从而能够访问该类型中的扩展方法。</p>
<h3 id="向下转型与运行时类型信息"><a href="#向下转型与运行时类型信息" class="headerlink" title="向下转型与运行时类型信息"></a>向下转型与运行时类型信息</h3><p>​        由于向上转型会丢失具体的类型信息，那么为了重新获取类型信息，就需要在继承层次中向下移动，使用向下转型。</p>
<p>​        向上转型永远是安全的，因为基类不会具有比派生类更多的接口。因此，每条发送给基类接口的消息都能被接收。但对于向下转型，你无法知道一个形状是圆，它有可能是三角形、正方形或其他一些类型。</p>
<p>​        为了解决这个问题，必须得有某种方法确保向下转型是正确的，防止意外转型到一个错误类型，进而发送对象无法接收的消息。这么做是不安全的。</p>
<p>​        在某些语言中(如C++)，必须执行一个特殊的操作来获得安全的向下转型，但是在Java中，每次转型都会被检查！所以即使只是进行一次普通的加括号形式的类型转换，在运行时这个转换仍会被检查，以确保它的确是希望的那种类型。如果不是，就会得到ClassCastException(类转型异常)。这种在运行时检查类型的行为称作运行时类型信息。下面的例子展示了RTTI的行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// polymorphism/RTTI.java</span></span><br><span class="line"><span class="comment">// Downcasting &amp; Runtime type information (RTTI)</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Useful</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoreUseful</span> <span class="keyword">extends</span> <span class="title">Useful</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RTTI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Useful[] x = &#123;</span><br><span class="line">            <span class="keyword">new</span> Useful(),</span><br><span class="line">            <span class="keyword">new</span> MoreUseful()</span><br><span class="line">        &#125;;</span><br><span class="line">        x[<span class="number">0</span>].f();</span><br><span class="line">        x[<span class="number">1</span>].g();</span><br><span class="line">        <span class="comment">// Compile time: method not found in Useful:</span></span><br><span class="line">        <span class="comment">//- x[1].u();</span></span><br><span class="line">        ((MoreUseful) x[<span class="number">1</span>]).u(); <span class="comment">// Downcast/RTTI</span></span><br><span class="line">        ((MoreUseful) x[<span class="number">0</span>]).u(); <span class="comment">// Exception thrown</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot;</span></span><br><span class="line"><span class="comment">//java.lang.ClassCastException: Useful cannot be cast to</span></span><br><span class="line"><span class="comment">//MoreUseful</span></span><br><span class="line"><span class="comment">//at RTTI.main</span></span><br></pre></td></tr></table></figure>

<p>​        MoreUseful扩展了Useful的接口。而MoreUseful也继承了Useful。在main()方法中可以看到这种情况的发生。因为两个对象都是Useful类型，所以对它们都可以调用f()和g()方法。如果试图调用u()方法，就会得到编译时错误信息。</p>
<p>​        为了访问MoreUseful对象接口的扩展接口，就得尝试向下转型。如果转型为正确的类型，就转型成功。否则，就会得到ClassCastException异常。你不必为这个异常编写任何特殊代码，因为它指出了程序员的任何地方都可能犯的错误。{ThrowsException}注释标签告知：在运行程序时，预期抛出一个异常。</p>
<p>​        RTTI不仅仅包括简单的转型。例如，它还提供了一种方法，使你可以在试图向下转型前检查所要处理的类型。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>《On Java 8》</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《On-Java-8》-第八章-复用</title>
    <url>/2021/05/07/%E9%98%85%E8%AF%BB%E3%80%8AOn-Java-8%E3%80%8B-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>​        如何在不污染代码的前提下使用现存代码是需要技巧的。在本章，将学习到两种方式来达到这个目的：</p>
<ul>
<li>第一种方式直接了当。在新类中创建现有类的对象。这种方式叫做“组合”(Composition)，通过这种方式复用代码的功能，而非其形式。</li>
<li>第二种方式更为微秒。创建现有类类型的新类。照字面理解：采用现有类形式，又无需在编码时改动其代码，这种方式就叫做“继承”(Inheritance)，编译器会做大部分的工作。继承是面向对象编程(OOP)的重要基础之一。</li>
</ul>
 <span id="more"></span> 

<h2 id="组合语法"><a href="#组合语法" class="headerlink" title="组合语法"></a>组合语法</h2><p>​        在前面的学习中，“组合”(Composition)已经被多次使用。你仅需要把对象的引用(object references)放置在一个新的类里，这里使用了组合。例如，假设你需要一个对象，其中内置了几个String对象，两个基本类型(primitives)的属性字段，一个其他类的对象。对于非基本类型对象，将引用直接放置在新类中，对于基本类型属性字段则仅进行声明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/SprinklerSystem.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Composition for code reuse</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterSource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String s;</span><br><span class="line">  WaterSource() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;WaterSource()&quot;</span>);</span><br><span class="line">    s = <span class="string">&quot;Constructed&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SprinklerSystem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String valve1, valve2, valve3, valve4;</span><br><span class="line">  <span class="keyword">private</span> WaterSource source = <span class="keyword">new</span> WaterSource();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span> f;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      <span class="string">&quot;valve1 = &quot;</span> + valve1 + <span class="string">&quot; &quot;</span> +</span><br><span class="line">      <span class="string">&quot;valve2 = &quot;</span> + valve2 + <span class="string">&quot; &quot;</span> +</span><br><span class="line">      <span class="string">&quot;valve3 = &quot;</span> + valve3 + <span class="string">&quot; &quot;</span> +</span><br><span class="line">      <span class="string">&quot;valve4 = &quot;</span> + valve4 + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot; &quot;</span> + <span class="string">&quot;f = &quot;</span> + f + <span class="string">&quot; &quot;</span> +</span><br><span class="line">      <span class="string">&quot;source = &quot;</span> + source; <span class="comment">// [1]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SprinklerSystem sprinklers = <span class="keyword">new</span> SprinklerSystem();</span><br><span class="line">    System.out.println(sprinklers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">WaterSource()</span></span><br><span class="line"><span class="comment">valve1 = null valve2 = null valve3 = null valve4 = null</span></span><br><span class="line"><span class="comment">i = 0 f = 0.0 source = Constructed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        这两个类中定义的一个方法是特殊的：toString()。每个非基本类型对象都有一个toString()方法，在编译器需要字符串但它有对象的特殊情况下调用该方法。因此，在[1]中，编译器看到你试图“添加”一个WaterSource类型的字符串对象。因为字符串只能拼接另一个字符串，所以它就会调用toString()将source转换成一个字符串。然后，它可以拼接这两个字符串并将结果字符串传递给System.out.println()。要创建的任何类允许这种行为，只需要编写一个toString()方法。在toString()上使用@Override注解来告诉编译器，以确保正确地覆盖。@Override是可选的，但它有助于验证你没有拼写错误。类中的基本类型字段自动初始化为零，正如object Everywhere一章中所述。但是对象引用被初始化为null，如果你尝试调用其任何一个方法，你将得到一个异常。方便的是，打印null引用却不会得到异常。</p>
<p>​        编译器不会为每个引用创建一个默认对象，这是有意义的，因为在许多情况下，这会导致不必要的开销。初始化引用有四种方法：</p>
<ul>
<li>当对象被定义时。这意味着它们总是在调用构造函数之前初始化。</li>
<li>在该类的构造函数中。</li>
<li>在实际使用对象之前。这通常称为延迟初始化。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销。</li>
<li>使用实例初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/Bath.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Constructor initialization with composition</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String s;</span><br><span class="line">  Soap() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Soap()&quot;</span>);</span><br><span class="line">    s = <span class="string">&quot;Constructed&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bath</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String <span class="comment">// Initializing at point of definition:</span></span><br><span class="line">    s1 = <span class="string">&quot;Happy&quot;</span>,</span><br><span class="line">    s2 = <span class="string">&quot;Happy&quot;</span>,</span><br><span class="line">    s3, s4;</span><br><span class="line">  <span class="keyword">private</span> Soap castille;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span> toy;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Bath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Inside Bath()&quot;</span>);</span><br><span class="line">    s3 = <span class="string">&quot;Joy&quot;</span>;</span><br><span class="line">    toy = <span class="number">3.14f</span>;</span><br><span class="line">    castille = <span class="keyword">new</span> Soap();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Instance initialization:</span></span><br><span class="line">  &#123; i = <span class="number">47</span>; &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s4 == <span class="keyword">null</span>) <span class="comment">// Delayed initialization:</span></span><br><span class="line">      s4 = <span class="string">&quot;Joy&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      <span class="string">&quot;s1 = &quot;</span> + s1 + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;s2 = &quot;</span> + s2 + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;s3 = &quot;</span> + s3 + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;s4 = &quot;</span> + s4 + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;toy = &quot;</span> + toy + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;castille = &quot;</span> + castille;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bath b = <span class="keyword">new</span> Bath();</span><br><span class="line">    System.out.println(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Inside Bath()</span></span><br><span class="line"><span class="comment">Soap()</span></span><br><span class="line"><span class="comment">s1 = Happy</span></span><br><span class="line"><span class="comment">s2 = Happy</span></span><br><span class="line"><span class="comment">s3 = Joy</span></span><br><span class="line"><span class="comment">s4 = Joy</span></span><br><span class="line"><span class="comment">i = 47</span></span><br><span class="line"><span class="comment">toy = 3.14</span></span><br><span class="line"><span class="comment">castille = Constructed</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        在Bath构造函数中，有一个代码块在所有初始化发生前就已执行了。当你不在定义初始化时，仍然不能保证在向对象引用发送消息之前执行任何初始化——如果你试图对未初始化的引用调用方法，则未初始化的引用将产生运行时异常。</p>
<p>​        当调用toString()时，它将赋值s4，以便在使用字段的时候所有的属性都已被初始化。</p>
<h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><p>​        继承是所有面向对象语言的一个组成部分。事实证明，在创建类时总要继承，因为除非显式地继承其它类，否则就隐式地继承Java的标准根类对象(Object)。</p>
<p>​        组合的语法很明显，但是继承使用了一种特殊的语法。当你继承时，你说，这个新类与那个旧类类似。你可以在类主体的左括号前的代码中声明这一点，使用关键字<strong>extends</strong>后跟基类的名称。当你这样做时，你将自动获取基类中的所有字段和方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/Detergent.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Inheritance syntax &amp; properties</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cleanser</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String s = <span class="string">&quot;Cleanser&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String a)</span> </span>&#123; s += a; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dilute</span><span class="params">()</span> </span>&#123; append(<span class="string">&quot; dilute()&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123; append(<span class="string">&quot; apply()&quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span><span class="params">()</span> </span>&#123; append(<span class="string">&quot; scrub()&quot;</span>); &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cleanser x = <span class="keyword">new</span> Cleanser();</span><br><span class="line">    x.dilute(); x.apply(); x.scrub();</span><br><span class="line">    System.out.println(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Detergent</span> <span class="keyword">extends</span> <span class="title">Cleanser</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Change a method:</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    append(<span class="string">&quot; Detergent.scrub()&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span>.scrub(); <span class="comment">// Call base-class version</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Add methods to the interface:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foam</span><span class="params">()</span> </span>&#123; append(<span class="string">&quot; foam()&quot;</span>); &#125;</span><br><span class="line">  <span class="comment">// Test the new class:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Detergent x = <span class="keyword">new</span> Detergent();</span><br><span class="line">    x.dilute();</span><br><span class="line">    x.apply();</span><br><span class="line">    x.scrub();</span><br><span class="line">    x.foam();</span><br><span class="line">    System.out.println(x);</span><br><span class="line">    System.out.println(<span class="string">&quot;Testing base class:&quot;</span>);</span><br><span class="line">    Cleanser.main(args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Cleanser dilute() apply() Detergent.scrub() scrub() foam()</span></span><br><span class="line"><span class="comment">Testing base class:</span></span><br><span class="line"><span class="comment">Cleanser dilute() apply() scrub()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        首先，在Cleanser的append()方法中，使用+=操作符将字符串连接到s，这是Java设计人员“重载”来处理字符串的操作符之一。</p>
<p>​        第二，Cleanser和Detergent都包含了一个main()方法。你可以为每个类创建一个main()；这允许对每个类进行简单的测试。当你完成测试时，不需要删除main()；你可以将其留在以后的测试中。即使程序中有很类都有main()方法，唯一运行的只有在命令行上调用的main()。这里，当你使用java Detergent时候，就调用了Detergent.main()。但是你也可以使用java.Cleanser来调用Cleanser.main()，即使Cleanser不是一个公共类。即使类只具有包访问权限，也可以访问public main()。</p>
<p>​        在这里，Detergent.main()显式地调用Cleanser.main()，从命令行传递相同的参数。</p>
<p>​        Cleanser中的所有方法都是公开的。请记住，如果不使用任何访问修饰符，则成员默认为包访问权限，这只允许包内成员访问。因此，如果没有访问修饰符，那么包内的任何人都可以使用这些方法。例如，Detergent就没有问题。但是，如果其他包中的类继承Cleanser，则该类只能访问Cleanser的公共成员。因此，为了允许继承，一般规则是所有字段为私有，所有方法为公共。在特定的情况下，你必须进行调整，但这是一个有用的指南。</p>
<p>​        Cleanser的接口中有一组方法：append()、dilute()、apply()、scrub()和toString()。因为Detergent是从Cleanser派生的，所以它会在接口中自动获取所有这些方法，即使你没有在Detergent中看到所有这些方法的显示定义。那么，可以把继承看作是复用类。如在scrub()中所见，可以使用基类中定义的方法并修改它。在这里，你可以在新类中调用基类的该方法。但是在scrub()内部，不能简单地调用scrub()，因为这会产生递归调用。为了解决这个问题，Java的<strong>super</strong>关键字引用了当前类继承的“超类”。因此表达式super.scrub()调用方法scrub()的基类版本。</p>
<p>​        继承时，你不受限于使用基类的方法。你还可以像向类添加任何方法一样向派生类添加新方法：只需定义它。方法foam()就是一个例子。Detergent.main()中可以看到，对于Detergent对象，你可以调用Cleanser和Detergent中可用的所有方法。</p>
<h3 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h3><p>​        现在涉及到两个类：基类和派生类。想象派生类生成的结果对象可能会让人感到困惑。从外部看，新类和基类具有相同的接口，可能还有一些额外的方法和字段。但是继承并不只是复制基类的接口。当你创建派生类的对象时，它包含基类的子对象。这个子对象与你自己创建基类的对象是一样的。只是从外部看，基类的子对象被包装在派生类的对象中。</p>
<p>​        必须正确初始化基类子对象，而且只有一种方法可以保证这一点：通过调用基类构造函数在构造函数中执行初始化，该构造函数具有执行基类初始化所需的所有适当信息和特权。Java自动在派生类构造函数中插入对基类构造函数的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/Cartoon.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Constructor calls during inheritance</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Art</span> </span>&#123;</span><br><span class="line">  Art() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Art constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Art</span> </span>&#123;</span><br><span class="line">  Drawing() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Drawing constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cartoon</span> <span class="keyword">extends</span> <span class="title">Drawing</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cartoon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cartoon constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cartoon x = <span class="keyword">new</span> Cartoon();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Art constructor</span></span><br><span class="line"><span class="comment">Drawing constructor</span></span><br><span class="line"><span class="comment">Cartoon constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        构造从基类“向外”进行，因此基类在派生类构造函数能够访问它之前进行初始化。即使不为Cartoon创建构造函数，编译器也会为你合成一个无参构造函数，调用基类构造函数。</p>
<h3 id="带参数的构造函数"><a href="#带参数的构造函数" class="headerlink" title="带参数的构造函数"></a>带参数的构造函数</h3><p>​        上面的所有例子中构造函数都是无参数的；编译器很容易调用这些构造函数，因为不需要参数。如果没有无参数的基类构造器，或者必须调用具有参数的基类构造函数，则必须使用super关键字和适当的参数列表显示地编写对基类构造函数的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/Chess.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Inheritance, constructors and arguments</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">  Game(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Game constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoardGame</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">  BoardGame(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;BoardGame constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">extends</span> <span class="title">BoardGame</span> </span>&#123;</span><br><span class="line">  Chess() &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">11</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Chess constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Chess x = <span class="keyword">new</span> Chess();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Game constructor</span></span><br><span class="line"><span class="comment">BoardGame constructor</span></span><br><span class="line"><span class="comment">Chess constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        如果没有BoardGame构造函数中调用基类构造函数，编译器就会报错找不到Game()的构造函数。此外，对基类构造函数的调用必须是派生类构造函数中的第一个操作。</p>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>​        Java不直接支持的第三种重用关系称为委托。这介于继承和组合之间，因为你将一个成员对象放在正在构建的类中，但同时又在新类中公开来自成员对象的所有方法。例如，宇宙飞船需要一个控制模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/SpaceShipControls.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipControls</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        建造宇宙飞船的一种方法是使用继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/DerivedSpaceShip.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">DerivedSpaceShip</span> <span class="keyword">extends</span> <span class="title">SpaceShipControls</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DerivedSpaceShip</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DerivedSpaceShip protector =</span><br><span class="line">        <span class="keyword">new</span> DerivedSpaceShip(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        然而，DerivedSpaceShip并不是真正的“一种”SpaceShipControls，即使你“告诉”DerivedSpaceShip调用forward()。更准确地说，一艘宇宙飞船包含了SpaceShipControls，同时SpaceShipControls中的所有方法都暴露在宇宙飞船中。委托解决了这个难题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/SpaceShipDelegation.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShipDelegation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> SpaceShipControls controls =</span><br><span class="line">    <span class="keyword">new</span> SpaceShipControls();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SpaceShipDelegation</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Delegated methods:</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.back(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.down(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.forward(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.left(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.right(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turboBoost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    controls.turboBoost();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> velocity)</span> </span>&#123;</span><br><span class="line">    controls.up(velocity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpaceShipDelegation protector =</span><br><span class="line">      <span class="keyword">new</span> SpaceShipDelegation(<span class="string">&quot;NSEA Protector&quot;</span>);</span><br><span class="line">    protector.forward(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        方法被转发到底层control对象，因此接口与继承的接口是相同的。但是，你对委托有更多的控制，因为你可以选择只在成员对象中提供方法的子集。虽然Java语言不支持委托，但是开发工具常常支持。</p>
<h2 id="结合组合与继承"><a href="#结合组合与继承" class="headerlink" title="结合组合与继承"></a>结合组合与继承</h2><p>​        你经常同时使用组合和继承。下面的例子展示了使用继承和组合创建类，以及必要的构造函数初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/PlaceSetting.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Combining composition &amp; inheritance</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span> </span>&#123;</span><br><span class="line">  Plate(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Plate constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DinnerPlate</span> <span class="keyword">extends</span> <span class="title">Plate</span> </span>&#123;</span><br><span class="line">  DinnerPlate(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;DinnerPlate constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">  Utensil(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Utensil constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spoon</span> <span class="keyword">extends</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">  Spoon(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;Spoon constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fork</span> <span class="keyword">extends</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">  Fork(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;Fork constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knife</span> <span class="keyword">extends</span> <span class="title">Utensil</span> </span>&#123;</span><br><span class="line">  Knife(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;Knife constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A cultural way of doing something:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Custom</span> </span>&#123;</span><br><span class="line">  Custom(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Custom constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceSetting</span> <span class="keyword">extends</span> <span class="title">Custom</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Spoon sp;</span><br><span class="line">  <span class="keyword">private</span> Fork frk;</span><br><span class="line">  <span class="keyword">private</span> Knife kn;</span><br><span class="line">  <span class="keyword">private</span> DinnerPlate pl;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PlaceSetting</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(i + <span class="number">1</span>);</span><br><span class="line">    sp = <span class="keyword">new</span> Spoon(i + <span class="number">2</span>);</span><br><span class="line">    frk = <span class="keyword">new</span> Fork(i + <span class="number">3</span>);</span><br><span class="line">    kn = <span class="keyword">new</span> Knife(i + <span class="number">4</span>);</span><br><span class="line">    pl = <span class="keyword">new</span> DinnerPlate(i + <span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;PlaceSetting constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PlaceSetting x = <span class="keyword">new</span> PlaceSetting(<span class="number">9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Custom constructor</span></span><br><span class="line"><span class="comment">Utensil constructor</span></span><br><span class="line"><span class="comment">Spoon constructor</span></span><br><span class="line"><span class="comment">Utensil constructor</span></span><br><span class="line"><span class="comment">Fork constructor</span></span><br><span class="line"><span class="comment">Utensil constructor</span></span><br><span class="line"><span class="comment">Knife constructor</span></span><br><span class="line"><span class="comment">Plate constructor</span></span><br><span class="line"><span class="comment">DinnerPlate constructor</span></span><br><span class="line"><span class="comment">PlaceSetting constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        尽管编译器强制你初始化基类，并要求你在构造函数的开头就初始化基类，但它并不监视你以确保你初始化了成员对象。注意类是如何干净地分离的。你甚至不需要方法重用代码的源代码。你最多只导入一个包。</p>
<h3 id="保证适当的清理"><a href="#保证适当的清理" class="headerlink" title="保证适当的清理"></a>保证适当的清理</h3><p>​        Java没有C++中析构函数的概念，析构函数是在对象被销毁时自动调用的方法。原因可能是，在Java中，通常是忘掉而不是销毁对象，从而允许垃圾收集器根据需要回收内存。通常这是可以的，但是有时你的类可能在其生命周期中执行一些需要清理的活动。初始化和清理章节提到，你无法知道垃圾收集器何时会被调用，甚至它是否会被调用。因此，如果你想为类清理一些东西，必须显示地编写一个特殊的方法来完成它，并确保客户端程序员知道他们必须调用这个方法。最重要的是——正如“异常”章节中描述的——你必须通过在finally子句中放置此类清理来防止异常。</p>
<p>​        请考虑一个在屏幕上绘制图片的计算机辅助设计系统的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/CADSystem.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Ensuring proper cleanup</span></span><br><span class="line"><span class="comment">// &#123;java reuse.CADSystem&#125;</span></span><br><span class="line"><span class="keyword">package</span> reuse;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Shape(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Shape constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Shape dispose&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Circle(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;Drawing Circle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Erasing Circle&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  Triangle(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    System.out.println(<span class="string">&quot;Drawing Triangle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Erasing Triangle&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> start, end;</span><br><span class="line">  Line(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">    <span class="keyword">super</span>(start);</span><br><span class="line">    <span class="keyword">this</span>.start = start;</span><br><span class="line">    <span class="keyword">this</span>.end = end;</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;Drawing Line: &quot;</span> + start + <span class="string">&quot;, &quot;</span> + end);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">      <span class="string">&quot;Erasing Line: &quot;</span> + start + <span class="string">&quot;, &quot;</span> + end);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CADSystem</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Circle c;</span><br><span class="line">  <span class="keyword">private</span> Triangle t;</span><br><span class="line">  <span class="keyword">private</span> Line[] lines = <span class="keyword">new</span> Line[<span class="number">3</span>];</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CADSystem</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lines.length; j++)</span><br><span class="line">      lines[j] = <span class="keyword">new</span> Line(j, j*j);</span><br><span class="line">    c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line">    t = <span class="keyword">new</span> Triangle(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Combined constructor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;CADSystem.dispose()&quot;</span>);</span><br><span class="line">    <span class="comment">// The order of cleanup is the reverse</span></span><br><span class="line">    <span class="comment">// of the order of initialization:</span></span><br><span class="line">    t.dispose();</span><br><span class="line">    c.dispose();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lines.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      lines[i].dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CADSystem x = <span class="keyword">new</span> CADSystem(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Code and exception handling...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      x.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Drawing Line: 0, 0</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Drawing Line: 1, 1</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Drawing Line: 2, 4</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Drawing Circle</span></span><br><span class="line"><span class="comment">Shape constructor</span></span><br><span class="line"><span class="comment">Drawing Triangle</span></span><br><span class="line"><span class="comment">Combined constructor</span></span><br><span class="line"><span class="comment">CADSystem.dispose()</span></span><br><span class="line"><span class="comment">Erasing Triangle</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">Erasing Circle</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">Erasing Line: 2, 4</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">Erasing Line: 1, 1</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">Erasing Line: 0, 0</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">Shape dispose</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        这个系统中的所有东西都是某种Shape。除了使用Super调用该方法的基类版本外，每个类还覆盖dispose()方法。特定的Shape类——Circle、Triangle和Line，都有“draw”构造函数，尽管在对象的生命周期中调用的任何方法都可以负责做一些需要清理的事情。每个类都有自己的dispose()方法来将非内存的内容恢复到对象存在之前的状态。</p>
<p>​        在main()中，有两个关键字是你以前没有见过的，在“异常”一章之前不会详细解释：<strong>try</strong>和<strong>finally</strong>。try关键字表示后面的块是一个受保护的区域，这意味着它得到了特殊处理。其中一个特殊处理是，无论try块如何退出，在这个保护区域之后的finally子句中的代码总是被执行的。这里，finally子句的意思是，“无论发生什么，始终调用x.dispose()。”</p>
<p>​        在清理方法中，还必须注意基类和成员对象清理方法的调用顺序，已防一个子对象依赖于另一个子对象。首先，按与创建的相反顺序执行特定于类的所有清理工作。然后调用基类清理方法。</p>
<p>​        在很多情况下，清理问题不是问题；你只需要让垃圾收集器来完成这项工作。但是，当你必须执行显式清理时，就需要多做努力，更加细心，因为在垃圾收集方面没有什么可以依赖的。可能永远不会调用垃圾收集器。如果调用，它可以按照它想要的任何顺序回收对象。除了内存回收外，你不能依赖垃圾收集器来做任何事情。如果希望进行清理，可以使用自己的清理方法，不要使用finalize()。</p>
<h3 id="名称隐藏"><a href="#名称隐藏" class="headerlink" title="名称隐藏"></a>名称隐藏</h3><p>​        如果Java基类的方法名多次重载，则在派生类中重新定义该方法名不会隐藏任何基类版本。不管方法是在这个级别定义的，还是在基类中定义的，重载都会起作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/Hide.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// Overloading a base-class method name in a derived</span></span><br><span class="line"><span class="comment">// class does not hide the base-class versions</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Homer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">doh</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;doh(char)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">float</span> <span class="title">doh</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;doh(float)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Milhouse</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bart</span> <span class="keyword">extends</span> <span class="title">Homer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doh</span><span class="params">(Milhouse m)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;doh(Milhouse)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hide</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Bart b = <span class="keyword">new</span> Bart();</span><br><span class="line">    b.doh(<span class="number">1</span>);</span><br><span class="line">    b.doh(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    b.doh(<span class="number">1.0f</span>);</span><br><span class="line">    b.doh(<span class="keyword">new</span> Milhouse());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">doh(float)</span></span><br><span class="line"><span class="comment">doh(char)</span></span><br><span class="line"><span class="comment">doh(float)</span></span><br><span class="line"><span class="comment">doh(Milhouse)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        Homer的所有重载方法在Bart中都是可用的，尽管Bart引入了一种新的重载方法。</p>
<p>​        你已经看到Java5 @Override注解，它不是关键字，但是可以像使用关键字一样使用它。当你打算重写一个方法时，你可以选择添加这个注解，如果你不小心用了重载而不是重写，编译器会产生一个错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/Lisa.java</span></span><br><span class="line"><span class="comment">// (c)2017 MindView LLC: see Copyright.txt</span></span><br><span class="line"><span class="comment">// We make no guarantees that this code is fit for any purpose.</span></span><br><span class="line"><span class="comment">// Visit http://OnJava8.com for more book information.</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lisa</span> <span class="keyword">extends</span> <span class="title">Homer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">doh</span><span class="params">(Milhouse m)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;doh(Milhouse)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        {WillNotCompile}表示该文件排除在Gradle构建之外，但是若手工编译它，你将看到：method does not override a mthod from its superclass方法不会重写超类中的方法，@Override注解能防止你意外地重载。</p>
<h2 id="组合与继承的选择"><a href="#组合与继承的选择" class="headerlink" title="组合与继承的选择"></a>组合与继承的选择</h2><p>​        组合和继承都允许在新类中放置子对象(组合是显式的，而继承是隐式的)。</p>
<p>​        当你想在新类中包含了一个已有类的功能时，使用组合，而非继承。也就是说，在新类中嵌入一个对象(通常是私有的)，以实现其功能。新类的使用者看到的是你所定义的新类的接口，而非嵌入对象的接口。</p>
<p>​        有时让类的用户直接访问到新类中的组合成分是有意义的。只需要成员对象声明为public即可(可以把这当做“半委托”的一种)。成员对象隐藏了具体实现，所以这是安全的。当用户知道你正在组装一组部件时，会使得接口更加容易理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/Car.java</span></span><br><span class="line"><span class="comment">// Composition with public objects</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> psi)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rolldown</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Window window = <span class="keyword">new</span> Window();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Engine engine = <span class="keyword">new</span> Engine();</span><br><span class="line">    <span class="keyword">public</span> Wheel[] wheel = <span class="keyword">new</span> Wheel[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">public</span> Door left = <span class="keyword">new</span> Door(), right = <span class="keyword">new</span> Door(); <span class="comment">// 2-door</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            wheel[i] = <span class="keyword">new</span> Wheel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        car.left.window.rollup();</span><br><span class="line">        car.wheel[<span class="number">0</span>].inflate(<span class="number">72</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        因为在这个例子中car的组合也是问题分析的一部分，所以声明成员为public有助于客户端程序员理解如何使用类，且降低了类创建者面临的代码复杂度。但是，记住这是一个特例，属性还是应该声明为private。</p>
<p>​        当使用继承时，使用一个现有类并开发出它的新版本。通常意味着使用一个通用类，并为了某个特殊需求将其特殊化。稍微思考下，你就会发现，用一个交通工具对象来组成一部车是毫无意义的——车不包含交通工具。这种“是一个”的关系是用继承来表达的，而“有一个”的关系则用组合来表达。</p>
<h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>​        在理想世界中，仅靠关键字private就足够了。在实际项目中，却经常想把一个事务尽量对外界隐藏，而允许派生类的成员访问。</p>
<p>​        关键字protected就起这个作用。它表示“就类的用户而言，这是private的。但对于任何继承它的子类或在同一包中的类，它是可访问的。”(protected也提供了包访问权限)</p>
<p>​        尽管可以创建protected属性，但是最好的方式是将属性声明为private以一直保留更改底层实现的权利。然后通过protected控制类的继承者的访问权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/Orc.java</span></span><br><span class="line"><span class="comment">// The protected keyword</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Villain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String nm)</span> </span>&#123;</span><br><span class="line">        name = nm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Villain(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a Villain and my name is &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orc</span> <span class="keyword">extends</span> <span class="title">Villain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> orcNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Orc</span><span class="params">(String name, <span class="keyword">int</span> orcNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.orcNumber = orcNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String name, <span class="keyword">int</span> orcNumber)</span> </span>&#123;</span><br><span class="line">        set(name); <span class="comment">// Available because it&#x27;s protected</span></span><br><span class="line">        <span class="keyword">this</span>.orcNumber = orcNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Orc &quot;</span> + orcNumber + <span class="string">&quot;: &quot;</span> + <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Orc orc = <span class="keyword">new</span> Orc(<span class="string">&quot;Limburger&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(orc);</span><br><span class="line">        orc.change(<span class="string">&quot;Bob&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        System.out.println(orc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Orc 12: I&#x27;m a Villain and my name is Limburger</span></span><br><span class="line"><span class="comment">//Orc 19: I&#x27;m a Villain and my name is Bob</span></span><br></pre></td></tr></table></figure>

<p>​        change()方法可以访问set()方法，因为set()方法是protected。注意到。类Orc的toString()方法也使用了基类的版本。</p>
<h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>​        继承最重要的方面不是为新类提供方法。它是新类与基类的一种关系，这种关系可以表述为“新类是已有类的一种类型”。</p>
<p>​        这种描述并非是解释继承的一种花哨方式，这是直接由语言支持的。例如，假设有一个基类Instrument代表音乐乐器和一个派生类Wind。因为继承保证了基类的所有方法在派生类中也是可用的，所以任意发送给基类的消息也能发送给派生类。如果Instrument有一个play()方法，那么Wind也有该方法。这意味着你可以准确地说Wind对象也是一种类型的Instrument：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/Wind.java</span></span><br><span class="line"><span class="comment">// Inheritance &amp; upcasting</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        i.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wind objects are instruments</span></span><br><span class="line"><span class="comment">// because they have the same interface:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        Instrument.tune(flute); <span class="comment">// Upcasting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        tune()方法接受了一个Instrument类型的引用。但是，在Wind的main()方法里，tune()方法却传入了一个Wind引用。鉴于Java对类型检查十分严格，一个接收一种类型的方法接收了另一种类型看起来很奇怪，除非你意识到Wind对象同时也是一个Instrument对象，而且Instrument的tune方法一定存在于Wind中。在tune()中，代码对Instrument和所有Instrument的派生类起作用，这种把Wind引用转换为Instrument引用的行为称作向上转型。</p>
<p>​        该术语是基于传统的类继承图：图最上面是根，然后向下铺展。</p>
<p>​        继承图中派生类转型为基类是向上的，所以通常称作向上转型。因为从一个更具体的类转化为一个更一般的类，所以向上转型永远是安全的，也就是说，派生类是基类的一个超集。它可能比基类包含更多的方法，但它必须至少具有与基类一样的方法。在向上转型期间，类接口只可能失去方法，不会增加方法。这就是为什么编译器在没有任何明确转型或其他特殊标记的情况下，仍然允许向上转型的原因。</p>
<p>​        也可以执行与向上转型相反的向下转型，但会有问题。</p>
<h3 id="再论组合和继承"><a href="#再论组合和继承" class="headerlink" title="再论组合和继承"></a>再论组合和继承</h3><p>​        在面向对象编程中，创建和使用代码最有可能的方法是将数据和方法一起打包到类中，然后使用该类的对象。也可以使用已有的类通过组合来创建新类。继承其实不太常用。因此尽管在教授OOP的过程中我们多次强调继承，但这并不意味着要尽可能使用它。恰恰相反，尽量少使用它，除非确实使用继承有帮助的。一种判断使用组合还是继承的最清晰的方法是问一问自己是否需要把新类向上转型为基类。如果必须向上转型，那么继承就是必要的，但如果不需要，则进一步考虑是否该采用继承。“多态”一章提出了一个使用向上转型的最有力的理由，但是只要记住问一问“我需要向上转型吗？”，就能在这两者中作出较好的选择。</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>​        根据上下文环境，Java的关键字<strong>final</strong>的含义有些稍微不同，但通常它指的是“这是不能被改变的”。防止改变有两个原因：设计或效率。因为这两个原因相差很远，所以有可能误用关键字final。</p>
<p>​        以下几节讨论了可能使用final的三个地方：数据、方法和类。</p>
<h3 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h3><p>​        许多编程语言都有某种方法告诉编译器有一块数据是恒定不变的。恒定是有用的，如：</p>
<ul>
<li>一个永不改变的编译时常量</li>
<li>一个在运行时初始化就不会改变的值。</li>
</ul>
<p>​        对于编译时常量这种情况，编译器可以把常量带入计算中；也就是说，可以在编译时计算，减少了一些运行时的负担。在Java中，这类常量必须是基本类型，而且用关键字final修饰。你必须在定义常量的时候进行赋值。</p>
<p>​        一个被static和final同时修饰的属性只会占用一段不能改变的存储空间。</p>
<p>​        当用final修饰对象引用而非基本类型时，其含义会有一点困惑。对于基本类型，final使数值恒定不变，而对于对象引用，final使引用恒定不变。一旦引用被初始化指向了某个对象，它就不能改为指向其他对象。但是，对象本身是可以修改的，Java没有提供将任意对象设置为常量的方法。这一限制同样适用数组，数组也是对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/FinalData.java</span></span><br><span class="line"><span class="comment">// The effect of final on fields</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// package access</span></span><br><span class="line">    </span><br><span class="line">    Value(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalData</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Can be compile-time constants:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> valueOne = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE_TWO = <span class="number">99</span>;</span><br><span class="line">    <span class="comment">// Typical public constant:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE_THREE = <span class="number">39</span>;</span><br><span class="line">    <span class="comment">// Cannot be compile-time constants:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i4 = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_5 = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">private</span> Value v1 = <span class="keyword">new</span> Value(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Value v2 = <span class="keyword">new</span> Value(<span class="number">22</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Value VAL_3 = <span class="keyword">new</span> Value(<span class="number">33</span>);</span><br><span class="line">    <span class="comment">// Arrays:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">&quot;: &quot;</span> + <span class="string">&quot;i4 = &quot;</span> + i4 + <span class="string">&quot;, INT_5 = &quot;</span> + INT_5;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FinalData fd1 = <span class="keyword">new</span> FinalData(<span class="string">&quot;fd1&quot;</span>);</span><br><span class="line">        <span class="comment">//- fd1.valueOne++; // Error: can&#x27;t change value</span></span><br><span class="line">        fd1.v2.i++; <span class="comment">// Object isn&#x27;t constant</span></span><br><span class="line">        fd1.v1 = <span class="keyword">new</span> Value(<span class="number">9</span>); <span class="comment">// OK -- not final</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fd1.a.length; i++) &#123;</span><br><span class="line">            fd1.a[i]++; <span class="comment">// Object isn&#x27;t constant</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//- fd1.v2 = new Value(0); // Error: Can&#x27;t</span></span><br><span class="line">        <span class="comment">//- fd1.VAL_3 = new Value(1); // change reference</span></span><br><span class="line">        <span class="comment">//- fd1.a = new int[3];</span></span><br><span class="line">        System.out.println(fd1);</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating new FinalData&quot;</span>);</span><br><span class="line">        FinalData fd2 = <span class="keyword">new</span> FinalData(<span class="string">&quot;fd2&quot;</span>);</span><br><span class="line">        System.out.println(fd1);</span><br><span class="line">        System.out.println(fd2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fd1: i4 = 15, INT_5 = 18</span></span><br><span class="line"><span class="comment">//Creating new FinalData</span></span><br><span class="line"><span class="comment">//fd1: i4 = 15, INT_5 = 18</span></span><br><span class="line"><span class="comment">//fd2: i4 = 13, INT_5 = 18</span></span><br></pre></td></tr></table></figure>

<p>​        因为valueOne和Value_TWO都是带有编译时值的final基本类型，它们都可用作编译时常量，没有多大区别。VALUE_THREE是一种更加典型的常量定义的方法：public意味着可以在包外访问，static强调只有一个，final说明是一个常量。</p>
<p>​        按照惯例，带有恒定初始值的final static基本变量命名全部使用大写，单词之间用下划线分隔。</p>
<p>​        我们不能因为某数据被final修饰就认为在编译时可以知道它的值，由上例的i4和INT_5可以看出，它们在运行时才会赋值随机数。示例部分也展示了将final值定义为static和非static的区别。此区别只有当值在运行时被初始化时才会显示，因为编译器对编译时数值一视同仁。当运行程序时就能看到这个区别。注意到fd1和fd2的i4值不同，但INT_5的值并没有因为创建了第二个FinalData对象而改变，这因为它是static的，在加载时已经被初始化，并不是每次创建新对象时都初始化。</p>
<p>​        v1到VAL_3变量说明了final引用的意义。正如你在main()中所见，v2是final的并不意味着你不能修改它的值。因为它是引用，所以只是说明它不能指向一个新的对象。这对于数组具有同样的意义，数组只不过是另一种引用。看起来，声明引用为final没有声明基本类型final有用。</p>
<h3 id="空白final"><a href="#空白final" class="headerlink" title="空白final"></a>空白final</h3><p>​        空白final指的是没有初始化值的final属性。编译器确保空白final在使用前必须被初始化。这样既能使一个类的每个对象的final属性值不同，也能保持它的不变性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/BlankFinal.java</span></span><br><span class="line"><span class="comment">// &quot;Blank&quot; final fields</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poppet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    Poppet(<span class="keyword">int</span> ii) &#123;</span><br><span class="line">        i = ii;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFinal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// Initialized final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> j; <span class="comment">// Blank final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Poppet p; <span class="comment">// Blank final reference</span></span><br><span class="line">    <span class="comment">// Blank finals MUST be initialized in constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j = <span class="number">1</span>; <span class="comment">// Initialize blank final</span></span><br><span class="line">        p = <span class="keyword">new</span> Poppet(<span class="number">1</span>); <span class="comment">// Init blank final reference</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankFinal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        j = x; <span class="comment">// Initialize blank final</span></span><br><span class="line">        p = <span class="keyword">new</span> Poppet(x); <span class="comment">// Init blank final reference</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BlankFinal();</span><br><span class="line">        <span class="keyword">new</span> BlankFinal(<span class="number">47</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        你必须在定义时或在每个构造器中执行final变量的赋值操作。这保证了final属性在使用前已经被初始化过了。</p>
<h3 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h3><p>​        在参数列表中，将参数声明为final意味着在方法中不能改变参数指向的对象或基本类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/FinalArguments.java</span></span><br><span class="line"><span class="comment">// Using &quot;final&quot; with method arguments</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gizmo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">with</span><span class="params">(<span class="keyword">final</span> Gizmo g)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//-g = new Gizmo(); // Illegal -- g is final</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">without</span><span class="params">(Gizmo g)</span> </span>&#123;</span><br><span class="line">        g = <span class="keyword">new</span> Gizmo(); <span class="comment">// OK -- g is not final</span></span><br><span class="line">        g.spin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//void f(final int i) &#123; i++; &#125; // Can&#x27;t change</span></span><br><span class="line">    <span class="comment">// You can only read from a final primitive</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FinalArguments bf = <span class="keyword">new</span> FinalArguments();</span><br><span class="line">        bf.without(<span class="keyword">null</span>);</span><br><span class="line">        bf.with(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        方法f()和g()展示了final基本类型参数的使用情况。你只能读取而不能修改参数。这个特性主要用于传递数据给匿名内部类。</p>
<h3 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h3><p>​        使用final方法的原因有两个。第一个原因是给方法上锁，防止子类通过覆写改变方法行为。这是处于继承的考虑，确保方法的行为不会因继承而改变。</p>
<p>​        过去建议使用final方法的第二个原因是效率。在早期的Java实现中，如果将一个方法指明为final，就是同意编译器把该方法的调用转化为内嵌调用。当编译器遇到final方法的调用时，就会很小心地跳过普通的插入代码以执行方法的调用机制，而用方法体内实际代码的副本替代方法调用。这消除了方法调用的开销。但是如果一个方法很大代码膨胀，你也许就看不到内嵌带来的性能提升，因为内嵌调用带来的性能提高被花费在方法里的时间抵消了。</p>
<p>​        在最近的Java版本中，虚拟机可以探测到这些情况(尤其是hotspot技术)，并优化去掉这些效率反而降低的内嵌调用方法。有很长一段时间，使用final来提高效率都被阻止。你应该让编译器和JVM处理性能问题，只有在为了明确禁止覆写方法时才使用final。</p>
<h3 id="final与private"><a href="#final与private" class="headerlink" title="final与private"></a>final与private</h3><p>​        类中所有的private方法都隐式地指定为final。因为不能访问private方法，所以不能覆写它。可以给private方法添加final修饰，但是并不能给方法方法带来额外的含义。</p>
<p>​        以下情况会令人困惑，当你试图覆写一个private方法时，看上去奏效，而且编译器不会给出错误信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/FinalOverridingIllusion.java</span></span><br><span class="line"><span class="comment">// It only looks like you can override</span></span><br><span class="line"><span class="comment">// a private or private final method</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithFinals</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Identical to &quot;private&quot; alone:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WithFinals.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Also automatically &quot;final&quot;:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WithFinals.g()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingPrivate</span> <span class="keyword">extends</span> <span class="title">WithFinals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate.g()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingPrivate2</span> <span class="keyword">extends</span> <span class="title">OverridingPrivate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate2.f()&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OverridingPrivate2.g()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalOverridingIllusion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverridingPrivate2 op2 = <span class="keyword">new</span> OverridingPrivate2();</span><br><span class="line">        op2.f();</span><br><span class="line">        op2.g();</span><br><span class="line">        <span class="comment">// You can upcast:</span></span><br><span class="line">        OverridingPrivate op = op2;</span><br><span class="line">        <span class="comment">// But you can&#x27;t call the methods:</span></span><br><span class="line">        <span class="comment">//- op.f();</span></span><br><span class="line">        <span class="comment">//- op.g();</span></span><br><span class="line">        <span class="comment">// Same here:</span></span><br><span class="line">        WithFinals wf = op2;</span><br><span class="line">        <span class="comment">//- wf.f();</span></span><br><span class="line">        <span class="comment">//- wf.g();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//OverridingPrivate2.f()</span></span><br><span class="line"><span class="comment">//OverridingPrivate2.g()</span></span><br></pre></td></tr></table></figure>

<p>​        “覆写”只发生在方法是基类的接口时。也就是说，必须能将一个对象向上转型为基类并调用相同的方法。如果是一个方法是private的，它就不是基类接口的一部分。它只是隐藏在类内部的代码，且恰好有相同的命名而已。但是如果你在派生类中以相同的命名创建了public、protected或包访问权限的方法，这些方法与基类中的方法没有联系，你没有覆写方法，而是创建新的方法而已。由于private方法无法触及且能有效隐藏，除了把它看作类中的一部分，其它任何事务都不需要考虑它。</p>
<h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>​        当说一个类是final(final关键字在类定义之前)，就意味着它不能被继承。之所以这么做，是因为类的设计就是永远不需要改动，或者处于安全考虑不希望它有子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/Jurassic.java</span></span><br><span class="line"><span class="comment">// Making an entire class final</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallBrain</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dinosaur</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    SmallBrain x = <span class="keyword">new</span> SmallBrain();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- class Further extends Dinosaur &#123;&#125;</span></span><br><span class="line"><span class="comment">// error: Cannot extend final class &#x27;Dinosaur&#x27;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jurassic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dinosaur n = <span class="keyword">new</span> Dinosaur();</span><br><span class="line">        n.f();</span><br><span class="line">        n.i = <span class="number">40</span>;</span><br><span class="line">        n.j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        final类的属性可以根据个人选择是或不是final。同样，非final类的属性也可以根据个人选择是或不是final。然而，由于final类禁止继承，类中所有的方法都被隐式地指定为final，所以没有办法覆写它们。你可以在final类中的方法加上final修饰符，但不会增加任何意义。</p>
<h3 id="final忠告"><a href="#final忠告" class="headerlink" title="final忠告"></a>final忠告</h3><p>​        在设计类时将一个方法指明为final看上去是明智的。你可能会觉得没人会覆写那个方法。有时是对的。</p>
<p>​        但请留意你的假设。通常来说，预见一个类如何被复用是很困难的，特别是通用类。如果将一个方法指定为final，可能会防止其他程序员的项目中通过继承来复用你的类，而这仅仅是因为你没有想到它被以那种方式使用。</p>
<p>​        Java标准类库就是一个很好的例子。尤其是Java1.0/1.1的Vector类被广泛地使用，然而它的所有方法出于“效率”考虑(然而并没有提升效率)全被指定为final，如果不指定final的话，可能会更加有用。很容易想到，你可能会继承并覆写这么一个基础类，但是设计者们认为这么做不合适。有两个讽刺的原因：第一，Stack继承自Vector，就是说Stack是个Vector，但从逻辑上来说不对。尽管如此，Java设计者们仍然这么做，在用这种方式创建Stack时，他们应该意识到了final方法过于约束。</p>
<p>​        第二，Vector中的很多重要方法，比如说addElement()和elementAt()方法都是同步的。在“并发编程”一章中看到同步会导致很大的执行开销，可能会抹煞final带来的好处。这加强了程序员永远无法正确猜到优化应该发生在何处的观点。如此笨拙的设计却出现在每个人都要使用的标准库中，太糟糕了。庆幸的是，现代Java容器用ArrayList代替了Vector，它的行为要合理得多。不幸的是，仍然有很多新代码使用旧的集合类库，其中就包括Vector。</p>
<p>​        Java1.0/1.1标准类库中另一个重要的类是Hashtable(后来被HashMap取代)，它不含任何final方法。Hashtable就比Vector中的方法名简洁得多。对于类库的使用者来说，这是一个本不应该如此草率的事情。这种不规则的情况造成用户需要做更多的工作——这是对粗糙的设计和代码的又一讽刺。</p>
<h2 id="类初始化和加载"><a href="#类初始化和加载" class="headerlink" title="类初始化和加载"></a>类初始化和加载</h2><p>​        在许多传统语言中，程序在启动时一次性全部加载。接着初始化，然后程序开始运行。必须仔细控制这些语言的初始化过程，以确保static初始化的顺序不会造成麻烦。</p>
<p>​        Java中不存在这样的问题，因为它采用了一种不同的方式加载。因为Java中万物皆对象，所以加载活动就容易得多。记住每个类的编译代码都存在于它自己独立的文件中，该文件只有在使用程序代码时才会被加载。一般来说“类的代码在首次使用时加载”，这通常是指创建类的第一个对象，或者是访问了类的static属性或方法。构造器也是一个static方法尽管它的static关键字是隐式的。因此，准确地说，一个类当它任意一个static成员被访问时，就会被加载。</p>
<p>​        首次使用时就是static初始化发生时。所有的static对象和static代码块在加载时按照文本的顺序依次初始化。static变量只被初始化依次。</p>
<h3 id="继承和初始化"><a href="#继承和初始化" class="headerlink" title="继承和初始化"></a>继承和初始化</h3><p>​        了解包括继承在内的整个初始化过程是有帮助的，这样可以对所发生的一切有全局性的把握：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reuse/Beetle.java</span></span><br><span class="line"><span class="comment">// The full process of initialization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> j;</span><br><span class="line">    </span><br><span class="line">    Insect() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">        j = <span class="number">39</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x1 = printInit(<span class="string">&quot;static Insect.x1 initialized&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">printInit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beetle</span> <span class="keyword">extends</span> <span class="title">Insect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k = printInit(<span class="string">&quot;Beetle.k.initialized&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Beetle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;k = &quot;</span> + k);</span><br><span class="line">        System.out.println(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x2 = printInit(<span class="string">&quot;static Beetle.x2 initialized&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Beetle constructor&quot;</span>);</span><br><span class="line">        Beetle b = <span class="keyword">new</span> Beetle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//static Insect.x1 initialized</span></span><br><span class="line"><span class="comment">//static Beetle.x2 initialized</span></span><br><span class="line"><span class="comment">//Beetle constructor</span></span><br><span class="line"><span class="comment">//i = 9, j = 0</span></span><br><span class="line"><span class="comment">//Beetle.k initialized</span></span><br><span class="line"><span class="comment">//k = 47</span></span><br><span class="line"><span class="comment">//j = 39</span></span><br></pre></td></tr></table></figure>

<p>​        当执行java Beetle，首先会试图访问Be’etle类的main()方法(一个静态方法)，加载器启动并找出Beetle类的编译代码(在名为Beetle.class的文件中)。在加载过程中，编译器注意到有一个基类，于是继续加载基类。不论是否创建了基类的对象，基类都会被加载。</p>
<p>​        如果基类还存在自身的基类，那么第二个基类也将被加载，以此类推。接下来，根基类(例子中根基类是Insect)的static的初始化开始执行，接着是派生类，依次类推。这点很重要，因为派生类中的static的初始化可能依赖基类成员是否被正确地初始化。</p>
<p>​        至此，必要的类都加载完毕，对象可以被创建了。首先，对象中的所有基本类型变量都被置为默认值，对象引用置为null——这是通过对象内存设为二进制零值一举生成的。接着会调用基类的构造器。本例中是自动调用的，但是你也可以使用super调用指定的基类构造器(在beetle构造器中的第一步操作)。基类构造器和派生类构造器一样以相同的顺序经历相同的过程。当基类构造器完成之后，实例变量按文本顺序初始化。最终，构造器的剩余部分被执行。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>《On Java 8》</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《On-Java-8》--第四章 运算符</title>
    <url>/2021/04/21/%E9%98%85%E8%AF%BB%E3%80%8AOn-Java-8%E3%80%8B-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>​        运算符接收一个或多个参数并生成新值。这个参数与普通方法调用的形式不同，但效果相同。所有运算符都能根据自己的运算对象生成一个值。除此之外，一些运算符可以改变运算对象的值，这叫作“副作用”(Side Effect)。运算符最常见的用途就是修改自己的运算对象，从而产生副作用。但要注意生成的值亦可由没有副作用的运算符生成。</p>
<p>​        几乎所有的运算符只能操作基本类型(Primitives)。唯一例外的是=、==、!=，它能操作所有对象。除此之外String类支持“+”和“+=”。</p>
 <span id="more"></span> 

<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>​        运算符的优先级决定了存在多个运算符时一个表达式各部分的运算顺序。Java对运算顺序作出了特别的规定。其中，最简单的就是乘法和除法在加法和减法之前完成。程序员经常都会忘记其他优先规则，所以应该用括号明确规定运算顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Precedence</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x + y - <span class="number">2</span> / <span class="number">2</span> + z;<span class="comment">//5</span></span><br><span class="line">        <span class="keyword">int</span> b = x + (y - <span class="number">2</span>) / (<span class="number">2</span> + z)<span class="comment">//1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这些语句看起来大致相同，但从输出中可以看出它们具有非常不同的含义，具体取决于括号的使用。注意到，在System.out.println()语句中使用了+运算符。但在这里+代表的意思是字符串连接符。编译器会将+连接的非字符串尝试转化为字符串。上例中的输出结果说明了a和b都已经被转化成了字符串。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>​        运算符的赋值是由符号=完成的。它代表着获取=右边的值并赋给左边的变量。右边可以是任何常量、变量或者可产生一个返回值的表达式。但左边必须是一个明确的、已命名的变量。也就是说，必须要有一个物理空间来存放右边的值。举个例子，可以将常数赋给一个变量(A=4)，但不可以将任何东西赋给一个常数(4=A)。</p>
<p>​        基本类型的赋值都是直接的，而不像对象，赋予的只是其内存的引用。举个例子，a=b，如果b是基本类型，那么赋值操作会将b的值复制一份给变量a，此后若a的值发生改变是不会影响到b的。</p>
<p>​        如果是为对象赋值，那么结果就不一样了。对一个对象进行操作时，我们实际上操作的是它的引用。所以我们将右边的对象赋予给左边时，赋予的只是该对象的引用。此时，两者指向的堆中的对象还是同一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Assignment</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Tank t1 = <span class="keyword">new</span> Tank();</span><br><span class="line">        Tank t2 = <span class="keyword">new</span> Tank();</span><br><span class="line">        t1.level = <span class="number">9</span>;</span><br><span class="line">        t2.level = <span class="number">47</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1: t1.level:&quot;</span> + t1.level + <span class="string">&quot;, t2.level:&quot;</span> + t2.level);</span><br><span class="line">        t1 = t2;</span><br><span class="line">        System.out.println(<span class="string">&quot;1: t1.level:&quot;</span> + t1.level + <span class="string">&quot;, t2.level:&quot;</span> + t2.level);</span><br><span class="line">        t1.level = <span class="number">27</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1: t1.level:&quot;</span> + t1.level + <span class="string">&quot;, t2.level:&quot;</span> + t2.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1: t1.level: 9, t2.level: 47</span></span><br><span class="line"><span class="comment">//1: t1.level: 47, t2.level: 47</span></span><br><span class="line"><span class="comment">//1: t1.level: 27, t2.level: 27</span></span><br></pre></td></tr></table></figure>

<p>​        这是一个简单的Tank类，在main()方法创建了两个实例对象。两个对象的level属性分别被赋予不同的值。然后，t2的值被赋予给t1。在Java中，由于赋予的只是对象的引用，改变t1也就改变t2.这是因为t1和t2此时指向的是堆中同一个对象。</p>
<p>​        这种现象通常称为别名(aliasing)，这是Java处理对象的一种基本方式。但是你若不想出现这里的别名引起混淆的话，你可以这么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1.level = t2.level;</span><br></pre></td></tr></table></figure>

<p>​        这样做保留了两个单独的的对象，而不是丢弃一个并将t1和t2绑定到同一个对象。</p>
<h3 id="方法调用中的别名现象"><a href="#方法调用中的别名现象" class="headerlink" title="方法调用中的别名现象"></a>方法调用中的别名现象</h3><p>​        当我们把对象传递给方法时，会发生别名现象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Letter</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassObject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Letter y)</span></span>&#123;</span><br><span class="line">        y.c = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Letter x = <span class="keyword">new</span> Letter();</span><br><span class="line">        x.c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1: x.c:&quot;</span> + x.c);</span><br><span class="line">        f(x);</span><br><span class="line">        System.out.println(<span class="string">&quot;2: x.c:&quot;</span> + x.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1: x.c: a</span></span><br><span class="line"><span class="comment">//1: x.c: z</span></span><br></pre></td></tr></table></figure>

<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>​        Java的基本运算符与其他大多编程语言是相同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/MathOps.java</span></span><br><span class="line"><span class="comment">// The mathematical operators</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathOps</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a seeded random number generator:</span></span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="comment">// Choose value from 1 to 100:</span></span><br><span class="line">        j = rand.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;j : &quot;</span> + j);</span><br><span class="line">        k = rand.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;k : &quot;</span> + k);</span><br><span class="line">        i = j + k;</span><br><span class="line">        System.out.println(<span class="string">&quot;j + k : &quot;</span> + i);</span><br><span class="line">        i = j - k;</span><br><span class="line">        System.out.println(<span class="string">&quot;j - k : &quot;</span> + i);</span><br><span class="line">        i = k / j;</span><br><span class="line">        System.out.println(<span class="string">&quot;k / j : &quot;</span> + i);</span><br><span class="line">        i = k * j;</span><br><span class="line">        System.out.println(<span class="string">&quot;k * j : &quot;</span> + i);</span><br><span class="line">        i = k % j;</span><br><span class="line">        System.out.println(<span class="string">&quot;k % j : &quot;</span> + i);</span><br><span class="line">        j %= k;</span><br><span class="line">        System.out.println(<span class="string">&quot;j %= k : &quot;</span> + j);</span><br><span class="line">        <span class="comment">// 浮点运算测试</span></span><br><span class="line">        <span class="keyword">float</span> u, v, w; <span class="comment">// Applies to doubles, too</span></span><br><span class="line">        v = rand.nextFloat();</span><br><span class="line">        System.out.println(<span class="string">&quot;v : &quot;</span> + v);</span><br><span class="line">        w = rand.nextFloat();</span><br><span class="line">        System.out.println(<span class="string">&quot;w : &quot;</span> + w);</span><br><span class="line">        u = v + w;</span><br><span class="line">        System.out.println(<span class="string">&quot;v + w : &quot;</span> + u);</span><br><span class="line">        u = v - w;</span><br><span class="line">        System.out.println(<span class="string">&quot;v - w : &quot;</span> + u);</span><br><span class="line">        u = v * w;</span><br><span class="line">        System.out.println(<span class="string">&quot;v * w : &quot;</span> + u);</span><br><span class="line">        u = v / w;</span><br><span class="line">        System.out.println(<span class="string">&quot;v / w : &quot;</span> + u);</span><br><span class="line">        <span class="comment">// 下面的操作同样适用于 char, </span></span><br><span class="line">        <span class="comment">// byte, short, int, long, and double:</span></span><br><span class="line">        u += v;</span><br><span class="line">        System.out.println(<span class="string">&quot;u += v : &quot;</span> + u);</span><br><span class="line">        u -= v;</span><br><span class="line">        System.out.println(<span class="string">&quot;u -= v : &quot;</span> + u);</span><br><span class="line">        u *= v;</span><br><span class="line">        System.out.println(<span class="string">&quot;u *= v : &quot;</span> + u);</span><br><span class="line">        u /= v;</span><br><span class="line">        System.out.println(<span class="string">&quot;u /= v : &quot;</span> + u);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//j : 59</span></span><br><span class="line"><span class="comment">//k : 56</span></span><br><span class="line"><span class="comment">//j + k : 115</span></span><br><span class="line"><span class="comment">//j - k : 3</span></span><br><span class="line"><span class="comment">//k / j : 0</span></span><br><span class="line"><span class="comment">//k * j : 3304</span></span><br><span class="line"><span class="comment">//k % j : 56</span></span><br><span class="line"><span class="comment">//j %= k : 3</span></span><br><span class="line"><span class="comment">//v : 0.5309454</span></span><br><span class="line"><span class="comment">//w : 0.0534122</span></span><br><span class="line"><span class="comment">//v + w : 0.5843576</span></span><br><span class="line"><span class="comment">//v - w : 0.47753322</span></span><br><span class="line"><span class="comment">//v * w : 0.028358962</span></span><br><span class="line"><span class="comment">//v / w : 9.940527</span></span><br><span class="line"><span class="comment">//u += v : 10.471473</span></span><br><span class="line"><span class="comment">//u -= v : 9.940527</span></span><br><span class="line"><span class="comment">//u *= v : 5.2778773</span></span><br><span class="line"><span class="comment">//u /= v : 9.940527</span></span><br></pre></td></tr></table></figure>

<p>​        为了生成随机数，程序先创建一个Random对象。不带参数的Random对象会利用当前时间用作随机数生成器的“种子”(seed)，从而为程序的每次执行成不同的输出。为了每个示例末尾的输出尽可能一致，以便可以使用外部工具进行验证。所以我们在创建Random对象时提供种子(随机数生成器的初始值，其始终为特定种子值产生相同的序列)，让程序每次执行都生成相同的随机数，如此以来输出结果就是可验证的。若需要生成随机值，可以删除种子参数。该对象通过调用方法nextInt()和nextFloat()(还可以调用nextLong()或nextDouble())，使用Random对象生成许多不同类型的随机数。nextInt()的参数设置生成的数字的上限，下限为零，为了避免零除的可能性，结果偏移1。</p>
<h3 id="一元加减运算符"><a href="#一元加减运算符" class="headerlink" title="一元加减运算符"></a>一元加减运算符</h3><p>​        一元加+减-运算符的操作和二元是相同的。编译器可自动识别使用任何方式解析运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = -a;</span><br><span class="line">x = a * -b;</span><br><span class="line">x = a * (-b);</span><br></pre></td></tr></table></figure>

<p>​        一元减号可以得到数据的负值。一元加号的作用相反，不过它唯一能影响的就是把较小的数值类型自动转换为int类型。</p>
<h2 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h2><p>​        其中递增++和递减- -，意为“增加或减少一个单位”。举个例子来说，假设a是一个int类型的值，则表达式++a就等价于a=a+1。递增和递减运算符不仅可以修改变量，还可以生成变量的值。</p>
<p>​        每种类型的运算符，都有两个版本可供选择；通常将其称为“前缀”和“后缀”。“前递增”表示++运算符位于变量或表达式前面；而“后递增”表示++运算符位于变量的后面。类似地，“前递减”意味着- -运算符位于变量的前面；而“后递减”意味着 - -运算符位于变量的后面。对于前递增和前递减(如++a或- - a)，先会执行递增/减运算，再返回值。而对于后递增和后递减(如a++或a - -)，会先返回值，再执行递增/减运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/AutoInc.java</span></span><br><span class="line"><span class="comment">// 演示 ++ 和 -- 运算符</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoInc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;i: &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;++i: &quot;</span> + ++i); <span class="comment">// 前递增</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i++: &quot;</span> + i++); <span class="comment">// 后递增</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i: &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;--i: &quot;</span> + --i); <span class="comment">// 前递减</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i--: &quot;</span> + i--); <span class="comment">// 后递减</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i: &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i: 1</span></span><br><span class="line"><span class="comment">//++i: 2</span></span><br><span class="line"><span class="comment">//i++: 2</span></span><br><span class="line"><span class="comment">//i: 3</span></span><br><span class="line"><span class="comment">//--i: 2</span></span><br><span class="line"><span class="comment">//i-- : 2</span></span><br><span class="line"><span class="comment">//i: 1</span></span><br></pre></td></tr></table></figure>

<p>​        对于前缀形式，我们将在执行递增/减操作后获取值；使用后缀形式，我们将在执行递增/减操作之前获取值。它们是唯一具有“副作用”的运算符(除那些涉及赋值的以外)——它们修改了操作数的值。</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>​        关系运算符==和!=同样适用于所有对象之间的比较，但它们比较的内容却经常困扰Java初学者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/Equivalence.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equivalence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer n1 = <span class="number">47</span>;</span><br><span class="line">        Integer n2 = <span class="number">47</span>;</span><br><span class="line">        System.out.println(n1 == n2);</span><br><span class="line">        System.out.println(n1 != n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>​        表达式System.out.println(n1 == n2)将会输出比较的结果。因为两个Integer对象相同，所以先输出true，再输出false。但是，尽管对象的内容一样，对象的引用却不一样。==和!=比较的是对象的引用，所以输出实际上应该先是false，再输出true(如你把45改成128，那么打印的结果就是这样，因为Integer内部维护着一个IntegerCache的缓存，，默认缓存范围是[-128,127]，所以[-128,127]之间的值用==和!=比较也能得到正确的结果，但是不推荐用关系运算符比较)。</p>
<p>​        那么怎么比较两个对象的内容是否相同呢？你必须使用所有对象(不包括基本类型)中都存在的equals()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/EqualsMethod.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer n1 = <span class="number">47</span>;</span><br><span class="line">        Integer n2 = <span class="number">47</span>;</span><br><span class="line">        System.out.println(n1.equals(n2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>​        上面的结果看起来是我们所期望的。但其实事情并非那么简单。下面我们来创建自己的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/EqualsMethod2.java</span></span><br><span class="line"><span class="comment">// 默认的 equals() 方法没有比较内容</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsMethod2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Value v1 = <span class="keyword">new</span> Value();</span><br><span class="line">        Value v2 = <span class="keyword">new</span> Value();</span><br><span class="line">        v1.i = v2.i = <span class="number">100</span>;</span><br><span class="line">        System.out.println(v1.equals(v2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>​        上例的结果再次令人困惑：结果是false。原因是equals()的默认行为是比较对象的引用而非具体内容。因此，除非你在新类中覆写equals()方法，否则我们将获取不到现要的结果。</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>​        每个逻辑运算符&amp;&amp;(AND)、||(OR)、!(非)根据参数的逻辑关系生成布尔值true或false。下面的代码示例中使用了关系运算符和逻辑运算符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/Bool.java</span></span><br><span class="line"><span class="comment">// 关系运算符和逻辑运算符</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">int</span> i = rand.nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> j = rand.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;j = &quot;</span> + j);</span><br><span class="line">        System.out.println(<span class="string">&quot;i &gt; j is &quot;</span> + (i &gt; j));</span><br><span class="line">        System.out.println(<span class="string">&quot;i &lt; j is &quot;</span> + (i &lt; j));</span><br><span class="line">        System.out.println(<span class="string">&quot;i &gt;= j is &quot;</span> + (i &gt;= j));</span><br><span class="line">        System.out.println(<span class="string">&quot;i &lt;= j is &quot;</span> + (i &lt;= j));</span><br><span class="line">        System.out.println(<span class="string">&quot;i == j is &quot;</span> + (i == j));</span><br><span class="line">        System.out.println(<span class="string">&quot;i != j is &quot;</span> + (i != j));</span><br><span class="line">        <span class="comment">// 将 int 作为布尔处理不是合法的 Java 写法</span></span><br><span class="line">        <span class="comment">//- System.out.println(&quot;i &amp;&amp; j is &quot; + (i &amp;&amp; j));</span></span><br><span class="line">        <span class="comment">//- System.out.println(&quot;i || j is &quot; + (i || j));</span></span><br><span class="line">        <span class="comment">//- System.out.println(&quot;!i is &quot; + !i);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;(i &lt; 10) &amp;&amp; (j &lt; 10) is &quot;</span></span><br><span class="line">        + ((i &lt; <span class="number">10</span>) &amp;&amp; (j &lt; <span class="number">10</span>)) );</span><br><span class="line">        System.out.println(<span class="string">&quot;(i &lt; 10) || (j &lt; 10) is &quot;</span></span><br><span class="line">        + ((i &lt; <span class="number">10</span>) || (j &lt; <span class="number">10</span>)) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i = 58</span></span><br><span class="line"><span class="comment">//j = 55</span></span><br><span class="line"><span class="comment">//i &gt; j is true</span></span><br><span class="line"><span class="comment">//i &lt; j is false</span></span><br><span class="line"><span class="comment">//i &gt;= j is true</span></span><br><span class="line"><span class="comment">//i &lt;= j is false</span></span><br><span class="line"><span class="comment">//i == j is false</span></span><br><span class="line"><span class="comment">//i != j is true</span></span><br><span class="line"><span class="comment">//(i &lt; 10) &amp;&amp; (j &lt; 10) is false</span></span><br><span class="line"><span class="comment">//(i &lt; 10) || (j &lt; 10) is false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        在Java逻辑运算中，我们不能像C/C++那样使用非布尔值，而仅能使用AND、OR、NOT。上面的例子中，我们将使用非布尔值的表达式注释掉了。请注意，如果在预期为String类型的位置上使用boolean类型的值，则结果会自动转为适当的文本格式(即“true”或“false”字符串)。</p>
<p>​        我们可以将前一个程序中int的定义替换为除boolean之外的任何其他基本数据类型。但请注意，float类型的数值比较严格，只要两个数字的最小位不同则两个数仍然不相等；只要数字最小位是大于0的，那么它就不等于0。</p>
<h3 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h3><p>​        逻辑运算符支持一种称为“短路”(short-circuiting)的现象。整个表达式会在运算到可以明确结果时就停止并返回结果，这意味着该逻辑表达式的后半部分不会被执行到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators / ShortCircuit.java </span></span><br><span class="line"><span class="comment">// 逻辑运算符的短路行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCircuit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1(&quot;</span> + val + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result: &quot;</span> + (val &lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> val &lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2(&quot;</span> + val + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result: &quot;</span> + (val &lt; <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> val &lt; <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">test3</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test3(&quot;</span> + val + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result: &quot;</span> + (val &lt; <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">return</span> val &lt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = test1(<span class="number">0</span>) &amp;&amp; test2(<span class="number">2</span>) &amp;&amp; test3(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;expression is &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//test1(0)</span></span><br><span class="line"><span class="comment">//result: true</span></span><br><span class="line"><span class="comment">//test2(2)</span></span><br><span class="line"><span class="comment">//result: false</span></span><br><span class="line"><span class="comment">//expression is false</span></span><br></pre></td></tr></table></figure>

<p>​        每个测试都对参数执行比较并返回true或false。同时控制台也会在方法执行时打印它们的执行状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">test1(<span class="number">0</span>) &amp;&amp; test2(<span class="number">2</span>) &amp;&amp; test3(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>​        你可能预期是程序会执行3个test方法并返回。我们来分析一下：第一个方法返回true，因此表达式会继续走下去。紧接着，第二个方法的返回结果是false。这就代表这整个表达式的结果肯定为false，所以就没有必须再判断剩下的表达式部分了。</p>
<p>​        所以，运用“短路”可以节省部分不必要的运算，从而提高程序潜在的性能。</p>
<h2 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h2><p>​        通常，当我们程序中插入一个字面值常量(Literal)时，编译器会确切地识别它的类型。当类型不明确时，必须辅以字面值常量关联来帮助编译器识别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/Literals.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Literals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0x2f</span>; <span class="comment">// 16进制 (小写)</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;i1: &quot;</span> + Integer.toBinaryString(i1));</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0X2F</span>; <span class="comment">// 16进制 (大写)</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;i2: &quot;</span> + Integer.toBinaryString(i2));</span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">0177</span>; <span class="comment">// 8进制 (前导0)</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;i3: &quot;</span> + Integer.toBinaryString(i3));</span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">0xffff</span>; <span class="comment">// 最大 char 型16进制值</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;c: &quot;</span> + Integer.toBinaryString(c));</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">0x7f</span>; <span class="comment">// 最大 byte 型16进制值  01111111;</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;b: &quot;</span> + Integer.toBinaryString(b));</span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">0x7fff</span>; <span class="comment">// 最大 short 型16进制值</span></span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;s: &quot;</span> + Integer.toBinaryString(s));</span><br><span class="line">        <span class="keyword">long</span> n1 = <span class="number">200L</span>; <span class="comment">// long 型后缀</span></span><br><span class="line">        <span class="keyword">long</span> n2 = <span class="number">200l</span>; <span class="comment">// long 型后缀 (容易与数值1混淆)</span></span><br><span class="line">        <span class="keyword">long</span> n3 = <span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Java 7 二进制字面值常量:</span></span><br><span class="line">        <span class="keyword">byte</span> blb = (<span class="keyword">byte</span>)<span class="number">0b00110101</span>;</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;blb: &quot;</span> + Integer.toBinaryString(blb));</span><br><span class="line">        <span class="keyword">short</span> bls = (<span class="keyword">short</span>)<span class="number">0B0010111110101111</span>;</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;bls: &quot;</span> + Integer.toBinaryString(bls));</span><br><span class="line">        <span class="keyword">int</span> bli = <span class="number">0b00101111101011111010111110101111</span>;</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;bli: &quot;</span> + Integer.toBinaryString(bli));</span><br><span class="line">        <span class="keyword">long</span> bll = <span class="number">0b00101111101011111010111110101111</span>;</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;bll: &quot;</span> + Long.toBinaryString(bll));</span><br><span class="line">        <span class="keyword">float</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">float</span> f2 = <span class="number">1F</span>; <span class="comment">// float 型后缀</span></span><br><span class="line">        <span class="keyword">float</span> f3 = <span class="number">1f</span>; <span class="comment">// float 型后缀</span></span><br><span class="line">        <span class="keyword">double</span> d1 = <span class="number">1d</span>; <span class="comment">// double 型后缀</span></span><br><span class="line">        <span class="keyword">double</span> d2 = <span class="number">1D</span>; <span class="comment">// double 型后缀</span></span><br><span class="line">        <span class="comment">// (long 型的字面值同样适用于十六进制和8进制 )</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i1: 101111</span></span><br><span class="line"><span class="comment">//i2: 101111</span></span><br><span class="line"><span class="comment">//i3: 1111111</span></span><br><span class="line"><span class="comment">//c: 1111111111111111</span></span><br><span class="line"><span class="comment">//b: 1111111</span></span><br><span class="line"><span class="comment">//s: 111111111111111</span></span><br><span class="line"><span class="comment">//blb: 110101</span></span><br><span class="line"><span class="comment">//bls: 10111110101111</span></span><br><span class="line"><span class="comment">//bli: 101111101011111010111110101111</span></span><br><span class="line"><span class="comment">//bll: 101111101011111010111110101111</span></span><br></pre></td></tr></table></figure>

<p>​        在本文值的后面添加的字符可以让编译器识别该文本值得类型。对于Long型数值，结尾使用大写L或小写l皆可(不推荐使用l，因为与阿拉伯数字1容易混淆)。大写F或小写f表示float浮点数。大写D或小写d表示double双精度。</p>
<p>​        十六进制，适用于所有整型数据类型，由前导0x或0X表示，后跟0-9或a-f(大写或小写)。如果我们在初始化某个类型的数值时，赋值超出其范围，那么编译器会报错。在上例的代码中，char、byte和short的值已经是最大了。如果超过这些值，编译器将会自动转型为int，并且提示我们需要声明强制类型转换，意味着我们已经越过该类的范围界限。</p>
<p>​        八进制由0~7之间数字和前导0表示。</p>
<p>​        Java7引入了二进制的字面值常量，由前导0b或0B表示，它可以初始化所有的整数类型。</p>
<p>​        使用整数值类型时，显示其二进制形式会很有用。Long型Integer型中这很容易实现，调用其静态的toBinaryString()方法即可。但是请注意，若将较小的类型传递给Integer.toBinaryString()时，类型将自动转型为int。</p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>​        Java7中有一个深思熟虑的补充：我们可以在数字字面量中包含下划线_，以使结果更加清晰。这对于大数值的分组特别有用。代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/Underscores.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Underscores</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">341_435_936.445_667</span>;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        <span class="keyword">int</span> bin = <span class="number">0b0010_1111_1010_1111_1010_1111_1010_1111</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(bin));</span><br><span class="line">        System.out.printf(<span class="string">&quot;%x%n&quot;</span>, bin); <span class="comment">// [1]</span></span><br><span class="line">        <span class="keyword">long</span> hex = <span class="number">0x7f_e9_b7_aa</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%x%n&quot;</span>, hex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.41435936445667E8</span></span><br><span class="line"><span class="comment">//101111101011111010111110101111</span></span><br><span class="line"><span class="comment">//2fafafaf</span></span><br><span class="line"><span class="comment">//7fe9b7aa</span></span><br></pre></td></tr></table></figure>

<p>​        下面为合理的使用规则：</p>
<ul>
<li>仅限单_，不能多条相连；</li>
<li>数值开头和结尾不允许出现_；</li>
<li>F、D和L的前后禁止出现_；</li>
<li>二进制前导b和十六进制x前后禁止出现_。</li>
</ul>
<p>​        注意%n的使用。熟悉C风格的程序员可能习惯于看到\n来表示换行符。问题在于它给你一个“Unix风格”的换行符。此外，如果我们使用的是Windows，则必须指定\r\n。这就是Java用%n实现的可以忽略平台间差异而生成适当的换行符，但只有当你使用System.out.printf()或System.out.format()时。对于System.out.println()，我们仍然必须使用\n；如果你使用%n，println()只会输出%n而不是换行符。</p>
<h3 id="指数计数法"><a href="#指数计数法" class="headerlink" title="指数计数法"></a>指数计数法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/Exponents.java</span></span><br><span class="line"><span class="comment">// &quot;e&quot; 表示 10 的几次幂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exponents</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 大写 E 和小写 e 的效果相同:</span></span><br><span class="line">        <span class="keyword">float</span> expFloat = <span class="number">1.39e-43f</span>;</span><br><span class="line">        expFloat = <span class="number">1.39E-43f</span>;</span><br><span class="line">        System.out.println(expFloat);</span><br><span class="line">        <span class="keyword">double</span> expDouble = <span class="number">47e47d</span>; <span class="comment">// &#x27;d&#x27; 是可选的</span></span><br><span class="line">        <span class="keyword">double</span> expDouble2 = <span class="number">47e47</span>; <span class="comment">// 自动转换为 double</span></span><br><span class="line">        System.out.println(expDouble);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.39E-43</span></span><br><span class="line"><span class="comment">//4.7E48</span></span><br></pre></td></tr></table></figure>

<p>​        在科学与工程学领域，e代表自然对数的基数，约等于2.718(Java里用一种更精确的double值Math.E来表示自然对数)。指数表达式“1.39x e-43”一位置“1.39x2.718的-43次方”。然而，自FORTRAN语言发明后，人们自然而然地觉得e代表“10的几次幂”。</p>
<p>​        在Java中看到类似“1.39e-43f”这样的表达式，请转换思维，从程序设计的角度思考它；它正真的含义是“1.39x10的-43次方”。</p>
<p>​        注意若编译器能够正确地识别类型，就不必使用后缀字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> n3 = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>

<p>​        它并不存在含糊不清的地方，所以200后面的L大可省去。然而，对于以下语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f4 = <span class="number">1e-43f</span>; <span class="comment">//10 的幂数</span></span><br></pre></td></tr></table></figure>

<p>​        编译器通常会将指数作为double类型来处理，所以倘若没有这个后缀f，编译器就会报错，提示我们应该将double型转换成float型。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>​        位运算符允许我们操作一个整型数字中的单个二进制。位运算会对两个整数对应的位执行布尔代数，从而产生结果。</p>
<p>​        若两个输入位都是1，则按位“与运算符”&amp;运算后结果是1，否则结果是0。若两个输入位至少有一个是1，则按位“或运算”|运算后结果是1；只有在两个输入位都是0的情况下，运算结果才是0。若两个输入位的某一个是1，另一个不是1，那么按位“异或运算符”^运算后结果才是1.按位“非运算符”~属于一元运算符；它只对一个自变量进行操作(其他所有运算符都是二元运算符)。按位非运算后结果于输入位相反。例如输入0，则输出1；输入1，则输出0。</p>
<p>​        位运算符和逻辑运算符都是用了同样的字符，只不过数量不同。位短，所以位运算符只有一个字符。位运算符可与等号=联合使用已接收结果及赋值：&amp;=，|=，^=都是合法的(由于~是一元运算符，所以不可与=联合使用)。</p>
<p>​        我们将Boolean类型被视为“单位值”(one-bit value)，所以它多少有些独特的地方。我们可以针对boolean变量执行与、或、异或运算，但不能执行非运算。对于布尔值，位运算符具有与逻辑运算符相同的效果，只是它们不会中途“短路”。此外，针对布尔值进行的位运算为我们新增了一个“异或”逻辑运算符，它并未包括在逻辑运算符的列表中。在移位表达式中，禁止使用布尔值。</p>
<h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>​        移位运算符面向的对象也是二进制的“位”。它只能用于处理整数类型。左移位运算符&lt;&lt;能将其左边的运算对象向左移动右侧指定的位数(在低位补0)。右移位运算符&gt;&gt;则相反。右移位运算符有“正”，“负”值：若值为正，则在高位插入0；若值为负，则在高位插入1。Java也添加了一种“不分正负”的右移位运算(&gt;&gt;&gt;)，它使用了“零扩展”(zero extension)：无论正负，都在高位插入0。</p>
<p>​        若移动char、byte或short，则会在移动之前将其提升为int，结果为int。仅使用右值(rvalue)的5个低阶位。这可防止我们移动超过int范围的位数。若对一个long值进行处理，最后得到的结果也是long。</p>
<p>​        移位可以与等号&lt;&lt;=或&gt;&gt;=或&gt;&gt;&gt;=组合使用。左值被替换为其移位运算后的值。但是，问题来了，当无符号右移与赋值相结合时，若将其与byte或short一起使用的话，则结果错误。取而代之的是，它们被提升为int型并右移，但在重新赋值时被截断。在这种情况下，结果为-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/URShift.java</span></span><br><span class="line"><span class="comment">// 测试无符号右移</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URShift</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line">        i &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(i));</span><br><span class="line">        <span class="keyword">long</span> l = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line">        l &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Long.toBinaryString(l));</span><br><span class="line">        <span class="keyword">short</span> s = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line">        s &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(s));</span><br><span class="line">        <span class="keyword">byte</span> b = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">        b &gt;&gt;&gt;= <span class="number">10</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">        b = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(Integer.toBinaryString(b));</span><br><span class="line">        System.out.println(Integer.toBinaryString(b&gt;&gt;&gt;<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">//1111111111111111111111</span></span><br><span class="line"><span class="comment">//1111111111111111111111111111111111111111111111111111111111111111</span></span><br><span class="line"><span class="comment">//111111111111111111111111111111111111111111111111111111</span></span><br><span class="line"><span class="comment">//11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">//11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">//11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">//11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">//11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">//1111111111111111111111</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/BitManipulation.java</span></span><br><span class="line"><span class="comment">// 使用位运算符</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitManipulation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">int</span> i = rand.nextInt();</span><br><span class="line">        <span class="keyword">int</span> j = rand.nextInt();</span><br><span class="line">        printBinaryInt(<span class="string">&quot;-1&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;+1&quot;</span>, +<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxpos = <span class="number">2147483647</span>;</span><br><span class="line">        printBinaryInt(<span class="string">&quot;maxpos&quot;</span>, maxpos);</span><br><span class="line">        <span class="keyword">int</span> maxneg = -<span class="number">2147483648</span>;</span><br><span class="line">        printBinaryInt(<span class="string">&quot;maxneg&quot;</span>, maxneg);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i&quot;</span>, i);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;~i&quot;</span>, ~i);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;-i&quot;</span>, -i);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;j&quot;</span>, j);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i &amp; j&quot;</span>, i &amp; j);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i | j&quot;</span>, i | j);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i ^ j&quot;</span>, i ^ j);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i &lt;&lt; 5&quot;</span>, i &lt;&lt; <span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i &gt;&gt; 5&quot;</span>, i &gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;(~i) &gt;&gt; 5&quot;</span>, (~i) &gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;i &gt;&gt;&gt; 5&quot;</span>, i &gt;&gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryInt(<span class="string">&quot;(~i) &gt;&gt;&gt; 5&quot;</span>, (~i) &gt;&gt;&gt; <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">long</span> l = rand.nextLong();</span><br><span class="line">        <span class="keyword">long</span> m = rand.nextLong();</span><br><span class="line">        printBinaryLong(<span class="string">&quot;-1L&quot;</span>, -<span class="number">1L</span>);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;+1L&quot;</span>, +<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">long</span> ll = <span class="number">9223372036854775807L</span>;</span><br><span class="line">        printBinaryLong(<span class="string">&quot;maxpos&quot;</span>, ll);</span><br><span class="line">        <span class="keyword">long</span> lln = -<span class="number">9223372036854775808L</span>;</span><br><span class="line">        printBinaryLong(<span class="string">&quot;maxneg&quot;</span>, lln);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l&quot;</span>, l);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;~l&quot;</span>, ~l);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;-l&quot;</span>, -l);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;m&quot;</span>, m);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l &amp; m&quot;</span>, l &amp; m);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l | m&quot;</span>, l | m);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l ^ m&quot;</span>, l ^ m);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l &lt;&lt; 5&quot;</span>, l &lt;&lt; <span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l &gt;&gt; 5&quot;</span>, l &gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;(~l) &gt;&gt; 5&quot;</span>, (~l) &gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;l &gt;&gt;&gt; 5&quot;</span>, l &gt;&gt;&gt; <span class="number">5</span>);</span><br><span class="line">        printBinaryLong(<span class="string">&quot;(~l) &gt;&gt;&gt; 5&quot;</span>, (~l) &gt;&gt;&gt; <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBinaryInt</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">        s + <span class="string">&quot;, int: &quot;</span> + i + <span class="string">&quot;, binary:\n &quot;</span> +</span><br><span class="line">        Integer.toBinaryString(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBinaryLong</span><span class="params">(String s, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        System.out.println(</span><br><span class="line">        s + <span class="string">&quot;, long: &quot;</span> + l + <span class="string">&quot;, binary:\n &quot;</span> +</span><br><span class="line">        Long.toBinaryString(l));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-1, int: -1, binary:</span></span><br><span class="line"><span class="comment">//11111111111111111111111111111111</span></span><br><span class="line"><span class="comment">//+1, int: 1, binary:</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//maxpos, int: 2147483647, binary:</span></span><br><span class="line"><span class="comment">//1111111111111111111111111111111</span></span><br><span class="line"><span class="comment">//maxneg, int: -2147483648, binary:</span></span><br><span class="line"><span class="comment">//10000000000000000000000000000000</span></span><br><span class="line"><span class="comment">//i, int: -1172028779, binary:</span></span><br><span class="line"><span class="comment">//10111010001001000100001010010101</span></span><br><span class="line"><span class="comment">//~i, int: 1172028778, binary:</span></span><br><span class="line"><span class="comment">// 1000101110110111011110101101010</span></span><br><span class="line"><span class="comment">//-i, int: 1172028779, binary:</span></span><br><span class="line"><span class="comment">//1000101110110111011110101101011</span></span><br><span class="line"><span class="comment">//j, int: 1717241110, binary:</span></span><br><span class="line"><span class="comment">//1100110010110110000010100010110</span></span><br><span class="line"><span class="comment">//i &amp; j, int: 570425364, binary:</span></span><br><span class="line"><span class="comment">//100010000000000000000000010100</span></span><br><span class="line"><span class="comment">//i | j, int: -25213033, binary:</span></span><br><span class="line"><span class="comment">//11111110011111110100011110010111</span></span><br><span class="line"><span class="comment">//i ^ j, int: -595638397, binary:</span></span><br><span class="line"><span class="comment">//11011100011111110100011110000011</span></span><br><span class="line"><span class="comment">//i &lt;&lt; 5, int: 1149784736, binary:</span></span><br><span class="line"><span class="comment">//1000100100010000101001010100000</span></span><br><span class="line"><span class="comment">//i &gt;&gt; 5, int: -36625900, binary:</span></span><br><span class="line"><span class="comment">//11111101110100010010001000010100</span></span><br><span class="line"><span class="comment">//(~i) &gt;&gt; 5, int: 36625899, binary:</span></span><br><span class="line"><span class="comment">//10001011101101110111101011</span></span><br><span class="line"><span class="comment">//i &gt;&gt;&gt; 5, int: 97591828, binary:</span></span><br><span class="line"><span class="comment">//101110100010010001000010100</span></span><br><span class="line"><span class="comment">//(~i) &gt;&gt;&gt; 5, int: 36625899, binary:</span></span><br><span class="line"><span class="comment">//10001011101101110111101011</span></span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>​        三元运算符，也称为条件运算符。下面是它的表达式格式：<br>​        布尔表达式？值1：值2</p>
<p>​        若表达式计算为true，则返回值1；如果表达式的计算为false，则返回值2。</p>
<p>​        当然，也可以换用普通的<strong>if-else</strong>语句，但三元运算符更加简洁。与if-else不同的是，三元运算符是有返回结果的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/TernaryIfElse.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TernaryIfElse</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ternary</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; <span class="number">10</span> ? i * <span class="number">100</span> : i * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">standardIfElse</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ternary(<span class="number">9</span>));</span><br><span class="line">        System.out.println(ternary(<span class="number">10</span>));</span><br><span class="line">        System.out.println(standardIfElse(<span class="number">9</span>));</span><br><span class="line">        System.out.println(standardIfElse(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//900</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//900</span></span><br><span class="line"><span class="comment">//100</span></span><br></pre></td></tr></table></figure>

<p>​        可以看出，ternary()中的代码更简短。然而，standardIfElse()中的代码更易于理解且不要求更多的录入。所以在挑选三元运算符时，请务必权衡一下利弊。</p>
<h2 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h2><p>​        这个运算符在Java里有一项特殊用途：连接字符串。</p>
<p>​        我们注意到运用String + 时有一些有趣的现象。若表达式以一个String类型开头，那么后续所有运算对象都必须是字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/StringOperators.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringOperators</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">1</span>, z = <span class="number">2</span>;</span><br><span class="line">        String s = <span class="string">&quot;x, y, z &quot;</span>;</span><br><span class="line">        System.out.println(s + x + y + z);</span><br><span class="line">        <span class="comment">// 将 x 转换为字符串</span></span><br><span class="line">        System.out.println(x + <span class="string">&quot; &quot;</span> + s);</span><br><span class="line">        s += <span class="string">&quot;(summed) = &quot;</span>; </span><br><span class="line">        <span class="comment">// 级联操作</span></span><br><span class="line">        System.out.println(s + (x + y + z));</span><br><span class="line">        <span class="comment">// Integer.toString()方法的简写:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x, y, z 012</span></span><br><span class="line"><span class="comment">//0 x, y, z</span></span><br><span class="line"><span class="comment">//x, y, z (summed) = 3</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>​        注意：上例中第1输出语句的执行结果是012而并非3，这是因为编译器将其分别转换为其字符串形式然后与字符串变量s连接。在第2条输出语句中，编译器将开头的变量转换为了字符串，由此可以看出，这种转换与数据位置无关，只要当中有一条数据是字符串类型，其他非字符串数据都被转换为字符串形式并连接。最后一条输出语句，我们可以看出+=运算符可以拼接其右侧的字符串连接结果并重赋值给自身变量s。括号()可以控制表达式的计算顺序，以便在显示int之前对其进行实际求和。</p>
<p>​            请注意最后方法中的最后一个例子：我们经常会看到一个空字符串“ ”跟着一个基本数据类型。这样可以隐式地将其转换为字符串，以代替繁琐的显示调用方法(Integer.toString())。</p>
<h2 id="常见陷阱"><a href="#常见陷阱" class="headerlink" title="常见陷阱"></a>常见陷阱</h2><p>​        使用运算符时很容易犯的一个错误是，在还没搞清楚表达式的计算方式时就试图忽略括号()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(x = y) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        显然，程序员愿意是测试等价性==，而非赋值=。在Java中，这样的表达式并结果并不会转化为一个布尔值。而编译器会试图把这个int类型的数据转换为预期应接收的布尔类型。最后，我们将会在试图运行前收到编译期错误。因此，Java天生避免了这种陷阱发生的可能性。</p>
<p>​        唯有一种情况例外：当变量x和y都是布尔值，例如x=y是一个逻辑表达式。除此之外，之前的那个例子，很大可能是错误的。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>​        “类型转换”(Casting)的作用是“与一个模型匹配”。在适当的时候，Java会将一种数据类型自动转换成另一种。例如，假设我们为float变量赋值一个整数型，计算机会将int自动转换为float。我们可以在程序未自动转换时显式、强制地使此类型发生转换。</p>
<p>​        要执行强制转换，需要将所需要的数据类型放在任何左侧的括号内：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/Casting.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Casting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">long</span> lng = (<span class="keyword">long</span>)i;</span><br><span class="line">        lng = i; <span class="comment">// 没有必要的类型提升</span></span><br><span class="line">        <span class="keyword">long</span> lng2 = (<span class="keyword">long</span>)<span class="number">200</span>;</span><br><span class="line">        lng2 = <span class="number">200</span>;</span><br><span class="line">        <span class="comment">// 类型收缩</span></span><br><span class="line">        i = (<span class="keyword">int</span>)lng2; <span class="comment">// Cast required</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        你可以这样地去转换一个数值类型的变量。但上例这种做法是多余的：因为编译器会在必要时自动提升int数据类型为long型。</p>
<p>​        当然，为了程序逻辑清晰或提醒自己留意，我们也可以显示地类型转换。在其他情况下，类型转换只有在代码编译时才显出其重要特性。在Java里，类型转换则是一种比较安全的操作。但是，若将数据类型进行“向下转换”(Narrowing Conversion)的操作(将容量较大的数据类型转换成容量较小的类型)，可能会发生信息丢失的危险。此时，编译器会强迫我们进行转型，好比在提醒我们：改操作可能危险，若你坚持着这么做，对不起，请明确需要转换的类型。对于“向上转换”(Widening conversion)，则不必进行显示的类型转换，因为较大类型的数据肯定能容纳较小类的数据，不会造成任何信息的丢失。</p>
<p>​        除了布尔类型，Java允许任何基本类型的数据转换为另外一种基本类型的数据。此外，类是不能进行类型转换的。为了将一个类型转换为另一个类型，需要使用特殊的方法。</p>
<h3 id="截断和舍入"><a href="#截断和舍入" class="headerlink" title="截断和舍入"></a>截断和舍入</h3><p>​        在执行“向下转换”时，必须注意数据的截断和舍入问题。若从浮点数转换为整型值，Java会做什么呢？例如：浮点数29.7被转换为整型值，结果会是29还是30？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/CastingNumbers.java</span></span><br><span class="line"><span class="comment">// 尝试转换 float 和 double 型数据为整型数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CastingNumbers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> above = <span class="number">0.7</span>, below = <span class="number">0.4</span>;</span><br><span class="line">        <span class="keyword">float</span> fabove = <span class="number">0.7f</span>, fbelow = <span class="number">0.4f</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;(int)above: &quot;</span> + (<span class="keyword">int</span>)above);</span><br><span class="line">        System.out.println(<span class="string">&quot;(int)below: &quot;</span> + (<span class="keyword">int</span>)below);</span><br><span class="line">        System.out.println(<span class="string">&quot;(int)fabove: &quot;</span> + (<span class="keyword">int</span>)fabove);</span><br><span class="line">        System.out.println(<span class="string">&quot;(int)fbelow: &quot;</span> + (<span class="keyword">int</span>)fbelow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(int)above: 0</span></span><br><span class="line"><span class="comment">//(int)below: 0</span></span><br><span class="line"><span class="comment">//(int)fabove: 0</span></span><br><span class="line"><span class="comment">//(int)fbelow: 0</span></span><br></pre></td></tr></table></figure>

<p>​        因此，答案是，从float和double转换为整数值，小数位将被截断。若你想对结果进行四舍五入，可以使用java.lang.Math的round()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/RoundingNumbers.java</span></span><br><span class="line"><span class="comment">// float 和 double 类型数据的四舍五入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundingNumbers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> above = <span class="number">0.7</span>, below = <span class="number">0.4</span>;</span><br><span class="line">        <span class="keyword">float</span> fabove = <span class="number">0.7f</span>, fbelow = <span class="number">0.4f</span>;</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;Math.round(above): &quot;</span> + Math.round(above));</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;Math.round(below): &quot;</span> + Math.round(below));</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;Math.round(fabove): &quot;</span> + Math.round(fabove));</span><br><span class="line">        System.out.println(</span><br><span class="line">        <span class="string">&quot;Math.round(fbelow): &quot;</span> + Math.round(fbelow));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Math.round(above): 1</span></span><br><span class="line"><span class="comment">//Math.round(below): 0</span></span><br><span class="line"><span class="comment">//Math.round(fabove): 1</span></span><br><span class="line"><span class="comment">//Math.round(fbelow): 0</span></span><br></pre></td></tr></table></figure>

<p>​        因为round()方法是java.lang的一部分，所以我们无需通过import就可以使用。</p>
<h3 id="类型提升"><a href="#类型提升" class="headerlink" title="类型提升"></a>类型提升</h3><p>​        你会发现，如果对小于int的基本数据类型(char、byte和short)执行任何算术或按位操作，这些值会在执行操作之前类型提升为int，并且结果值的类型为int。若想重新使用较小的类型，必须使用强制转换。通常，表达式中最大的数据类型是决定表达式结果的数据类型。float类型和double型相乘，结果是double型的；int和long相加，结果是long型。</p>
<h2 id="Java没有sizeof"><a href="#Java没有sizeof" class="headerlink" title="Java没有sizeof"></a>Java没有sizeof</h2><p>​        Java不需要sizeof()方法来满足这种需求，因为所有类型的大小在不同平台上是相同的。我么不必考虑这个层次的移植问题——Java本身就是一种“与平台无关”的语言。</p>
<h2 id="运算符总结"><a href="#运算符总结" class="headerlink" title="运算符总结"></a>运算符总结</h2><p>​        在char、byte和short类型中，我么可以看到算术运算符的“类型转换”效果。我们必须要显示强制类型转换才能将结果重新赋值为原始类型。对于int类型的运算则不用转换，因为默认就是int型。虽然我们不再停下来思考这一切是否安全，但是两个大的int型整数相乘时，结果有可能超出int型的范围，这种情况下结果会发生溢出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// operators/Overflow.java</span></span><br><span class="line"><span class="comment">// 厉害了！数据溢出了！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overflow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> big = Integer.MAX_VALUE;</span><br><span class="line">        System.out.println(<span class="string">&quot;big = &quot;</span> + big);</span><br><span class="line">        <span class="keyword">int</span> bigger = big * <span class="number">4</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;bigger = &quot;</span> + bigger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//big = 2147483647</span></span><br><span class="line"><span class="comment">//bigger = -4</span></span><br></pre></td></tr></table></figure>

<p>​        编译器没有报错或警告，运行时一切看起来都无异常。诚然，Java是优秀的，但是还不足够优秀。</p>
<p>​        对于char、byte或者short，混合赋值并不需要类型转换。即使为它们执行转换操作，也会获得与直接算术运算相同的结果。另外，省略类型转换可以使代码显得更加简练。总之，除boolean以外，其他任何两种类型间都可以进行类型转换。当我们向下转换类型时，需要注意结果的范围是否溢出，否则我们就很有可能在不知不觉中丢失精度。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>《On Java 8》</tag>
      </tags>
  </entry>
  <entry>
    <title>第九章 集合</title>
    <url>/2020/11/26/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第九章-集合"><a href="#第九章-集合" class="headerlink" title="第九章 集合"></a>第九章 集合</h1><h2 id="9-1-Java集合框架"><a href="#9-1-Java集合框架" class="headerlink" title="9.1 Java集合框架"></a>9.1 Java集合框架</h2><h3 id="9-1-1-集合接口与实现分离"><a href="#9-1-1-集合接口与实现分离" class="headerlink" title="9.1.1 集合接口与实现分离"></a>9.1.1 集合接口与实现分离</h3><p>与现代的数据结构类库的常见做法一样，Java集合类库也将接口(interface)与实现(implementation)分离。下面利用我们熟悉的数据结构——队列(Queue)来说明是如何分离的。</p>
<p>队列接口指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查找队列中元素的个数。当需要收集对象，并按照“先进先出”方式检索对象时就应该使用队列。</p>
<p>队列接口的最简形式可能类似下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口并没有说明是如何实现的。队列通常有两种实现方式”一种是使用循环数组；另一种是使用链表。</p>
 <span id="more"></span> 

<p>每一个实现都可以用一个实现了Queue接口的类表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    CircularArrayQueue(<span class="keyword">int</span> capacity)&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">private</span> E[] elemnts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Link head;</span><br><span class="line">    <span class="keyword">private</span> Link tail;</span><br><span class="line">    </span><br><span class="line">    LinkedListQueue()&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E elment)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在程序中使用队列时，一旦已经构造了集合，就不需要知道究竟使用了哪种实现。因此，只有在构造集合对象时，才会使用具体的类。可以使用接口类型存放集合引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> CircularArrayQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>利用这种方法，一旦改变了想法，就可以很轻松地使用另一种不同的实现。只需要对程序的一个地方做出修改，即调用构造器的地方。如果觉得LinkedListQueue是个更好的选择，就将代码修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> LinkedListQueue&lt;&gt;();</span><br><span class="line">expressLane.add(<span class="keyword">new</span> Customer(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>为什么选择这种实现，而不选择那种实现呢？接口本身并不能说明哪种实现的效率究竟如何。循环数组要比链表更高效，因此多数人优先选择循环数组。不过，通常来讲，这样做也需要付出一定的代价。</p>
<p>循环数组是一个有界集合，即容量有限。如果程序中要收集的对象数量没有上限，就最好使用链表来实现。</p>
<p>在研究API文档时，会发现另外一组名字以Abstract开头的类，例如，AbstractQueue。这些库是为类库实现者而设计的。如果想要实现自己的队列类，会发现扩展AbstractQueue类要比实现Queue接口中的所有方法轻松的多。</p>
<h3 id="9-1-2-Collection-接口"><a href="#9-1-2-Collection-接口" class="headerlink" title="9.1.2 Collection 接口"></a>9.1.2 Collection 接口</h3><p>在Java类库中，集合类的基本接口是Collection接口。这个接口有两个基本方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这两个方法之外，还有几个方法。</p>
<p>add方法用于向集合中添加元素。如果添加元素确实改变了集合就返回true；如果集合没有发生变化就返回flase。例如，如果试图向集(set)中添加一个对象，而这个对象在集中已经存在，这个add请求就没有失效，因为集中不允许有重复的对象。</p>
<p>iterator方法用于返回一个实现了Iterator接口的对象。可以使用这个迭代器对象依次访问集合中的元素。</p>
<h3 id="9-1-3-迭代器"><a href="#9-1-3-迭代器" class="headerlink" title="9.1.3 迭代器"></a>9.1.3 迭代器</h3><p>Iterator接口包含4个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过反复调用next方法，可以逐个访问集合中的每个元素。但是，如果到达了集合的末尾，next方法将抛出一个NoSuchElementException。因此，需要在调用之前调用hasNext方法。如果迭代器对象还有多个可以访问的元素，这个方法返回true。如果想要查看集合中的所有元素就请求一个迭代器，当hasNext()返回true时就反复地调用next方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext)</span><br><span class="line">&#123;</span><br><span class="line">    String element = it.next();</span><br><span class="line">    <span class="comment">//do something with element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用for each 循环可以更简练地表示同样的循环操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String element : c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do something with element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器简单地将for each 循环转换为带有迭代器的循环。</p>
<p>for each 循环可以处理任何实现了Iterable接口的对象，这个接口只包含了一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Collection 接口扩展了Iterable。因此，对于标准类库中的任何集合都可以使用for each 循环。</p>
<p>也可以不写循环，而是调用forEachRemaining方法并提供一个lambda表达式。将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iterator.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element)</span><br></pre></td></tr></table></figure>

<p>访问元素的顺序取决于集合类型。如果迭代器处理一个ArrayList，迭代器将从索引0开始，每迭代一次，索引值+1.不过，如果访问HashSet中的元素，会按照一种基本上随机的顺序获得元素。虽然可以确保在迭代过程中能够遍历到集合中的所有元素，但是无法预知访问各元素的顺序。这通常并不是什么问题，因为对于计算总和或匹配之类的计算，顺序并不重要。</p>
<p>Java集合类库中的迭代器与其他类库中的迭代器在概念上有着重要的区别。在传统的集合类库中，例如，C++的标准模板库，迭代器是根据数组索引建模的。如果给定这样一个迭代器，可以查找存储在指定位置上的元素，就像如果知道数组索引i，就可以查找数组元素a[i]。不需要查找元素，也可以将迭代器向前移动一个位置。这与不需要执行查找操作而通过i++将数组索引向前移动一样。但是，java迭代器并不是这样处理的。查找操作与位置变更紧密耦合。查找一个元素的唯一方法是调用next()，而在执行查找操作的同时，迭代器的位置就会随之向前移动。</p>
<p>因此，可以认为Java迭代器位于两个元素之间。当调用next时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。</p>
<p>Itterator接口的remove方法将会删除上次调用next方法时返回的元素。在大多数情况下，这是有道理的，在决定删除某个元素之前应该先看一下这个元素。不过，如果想要删除指定位置上的元素，仍然需要越过这个元素。例如，可以如下删除一个字符串集合中的第一个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">it.next;<span class="comment">// skip over the first element</span></span><br><span class="line">it.remove();<span class="comment">//now remove it</span></span><br></pre></td></tr></table></figure>

<p>更重要的是，next方法和remove方法调用之间存在依赖性。如果调用remove之前没有调用next，将是不合法的。如果这样做，将会抛出一个IllegalStateException异常。</p>
<p>如果想要删除两个相邻的元素，不能直接这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">it.remove();</span><br><span class="line">it.remove();<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>实际上，必须先调用next越过要删除的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">it.remove();</span><br><span class="line">it.next();</span><br><span class="line">it.remove();<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<h3 id="9-1-4-泛型实用方法"><a href="#9-1-4-泛型实用方法" class="headerlink" title="9.1.4 泛型实用方法"></a>9.1.4 泛型实用方法</h3><p>由于Collection与Iterator都是饭泛型接口，这意味着你可以编写任何集合类型的实用方法。例如，下面是一个检测任意集合是否包含指定元素的泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Collection&lt;E&gt; c, Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(E elmement : c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(element.equals(obj))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java类库的设计者认为：这些实用方法中有一些非常有用，应该将它们提供给用户使用。这样，类库的使用者就不必自己重新构建这些方法了。contains就是这样一个实用方法。</p>
<p>事实上，Collection接口声明了很多有用的方法，所有实现类都必须提供这些方法。下面列举了其中的一部分：</p>
<ul>
<li>int size()</li>
<li>boolean isEmpty()</li>
<li>boolean contains(Object obj)</li>
<li>boolean containsAll(Collection&lt;?&gt; c)</li>
<li>boolean equals(Object other)</li>
<li>boolean addAll(Collection&lt;?&gt; c)</li>
<li>void clear()</li>
<li>boolean retainAll(Collection&lt;?&gt; c)</li>
<li>Object[] toArray()</li>
<li>&lt;T&gt; T[] toArray(T[] arrayToFill)</li>
</ul>
<p>在这些方法中有许多方法的功能非常明确，不需要过多的解释。</p>
<p>当然，如果实现Collection接口的每一个类都要提供如此多的例行方法，这将是一件很烦人的事情。为了能够让实现者更容易地实现这个接口，Java类库提供了一个类AbstractCollection，它保持基础方法size和iterator仍为抽象方法，但是为实现者实现了其他例行方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(E element : <span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(element.equals(obj))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，具体集合可以扩展AbstractColletion类。现在要由具体的集合类提供iterator方法，而contains方法已由AbstractColletion超类提供。不过，如果子类有更加高效的方式实现cotains方法，也完全可以由子类提供contains方法。</p>
<p>这种做法有些过时了。这些方法最好是Collection接口的默认方法。但实际上并不是这样。不过，确实已经增加了很多默认方法。其中大部分方法都与流的处理有关。另外，还有一个很有用的方法：default boolean ramoveIf(Predicate&lt;? super E&gt; filter)这个方法用于删除满足某个条件的元素。</p>
<h2 id="9-2-集合框架中的接口"><a href="#9-2-集合框架中的接口" class="headerlink" title="9.2 集合框架中的接口"></a>9.2 集合框架中的接口</h2><p>集合中有两个基本接口：Coection和Map。我们已经看到，可以用以下方法在集合中插入元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span></span><br></pre></td></tr></table></figure>

<p>不过，由于映射包含键/值对，所以要用put方法来插入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br></pre></td></tr></table></figure>

<p>要从集合读取元素，可以用迭代器访问元素。不过，从映射中读取值则要使用get方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(K key)</span></span></span><br></pre></td></tr></table></figure>

<p>List是一个有序集合(ordered collection)。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器，或者使用一个整数索引来访问。后面这种方法称为随机访问(random access)，因为这样可以按照任意顺序访问元素。与之不同，使用迭代器访问时，必须顺序地访问元素。</p>
<p>List接口定义了多个用于随机访问的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index , E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br></pre></td></tr></table></figure>

<p>ListIterator接口是Iterator的一个子接口。它定义了一个方法用于在迭代器位置前面增加了一个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span></span><br></pre></td></tr></table></figure>

<p>坦率地讲，集合框架的这个方面设计得很不好。实际上有两种有序集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问。与之不同，链表尽管也是有序的，但是随机访很慢，所以最好使用迭代器来遍历。如果原先提供两个接口就会容易一些了。</p>
<p>set接口等同于Collection接口，不过其方法的行为有更严谨的定义。集(set)的add方法不允许增加重复的元素。要适当定义集的equals方法：只要两个集包含同样的元素就认为它们是相等的，而不要求这些元素有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集合会得到相同的散列码。</p>
<p>既然方法签名是一样的，为什么还要建立一个单独的接口呢？从概念上讲，并不是所有集合都是集。建立一个Set接口可以允许程序员编写只接受集的方法。</p>
<p>SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集试图的方法。</p>
<p>最后，Java6引入了接口NavigableSet和NavigableMap，其中包含一些用于搜索和遍历有序集合映射的方法。TreeSet和TreeMap类实现了这些接口。</p>
<h2 id="9-3-具体集合"><a href="#9-3-具体集合" class="headerlink" title="9.3 具体集合"></a>9.3 具体集合</h2><table>
<thead>
<tr>
<th>集合类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td></td>
</tr>
<tr>
<td>LinkedList</td>
<td></td>
</tr>
<tr>
<td>ArrayDeque</td>
<td></td>
</tr>
<tr>
<td>HashSet</td>
<td></td>
</tr>
<tr>
<td>TreeSet</td>
<td></td>
</tr>
<tr>
<td>EnumSet</td>
<td></td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td></td>
</tr>
<tr>
<td>PriorityQueue</td>
<td></td>
</tr>
<tr>
<td>HashMap</td>
<td></td>
</tr>
<tr>
<td>TreeMap</td>
<td></td>
</tr>
<tr>
<td>EnumMap</td>
<td></td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td></td>
</tr>
<tr>
<td>WeakHashMap</td>
<td></td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td></td>
</tr>
</tbody></table>
<h3 id="9-3-1-链表"><a href="#9-3-1-链表" class="headerlink" title="9.3.1 链表"></a>9.3.1 链表</h3><p>在本书中，有很多示例已经使用了数组以及动态的ArrayList类。不过，数组和数组列表都有一个重大的缺陷。这就是从数组中删除一个元素开销很大，其原因是数组中位于被删除元素之后的所有元素都要向数组的前端移动。在数组中间插入一个元素也是如此。</p>
<p>大家都知道的另外一个数组结构——链表(linked list)解决了这个问题。数组是在连续的存储位置上存放对象引用，而链表则是将每个对象存放在单独的链接(link)中。每个连接还存放这序列中下一个连接的引用。在Java程序设计语言上，所有链表实际上都是双向链接的(doubly linked)——即每个链接还存放着其前驱的引用。</p>
<p>从链表中间删除一个元素是一个很轻松的操作，只需要更新所删除元素周围的链接即可。</p>
<p>你也许曾经在数据结构中学习如何实现链表。在链表中添加或删除元素时，绕来绕去的指针可能给人们留下了极坏的印象。如果真是如此的话，你肯定为Java集合类库提供一个LinkedList类而感到高兴。</p>
<p>在下面的代码示例中，先添加3个元素，然后再将第2个元素删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">staff.add(<span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Carl&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iter = staff.iterator();</span><br><span class="line">String first = iter.next();<span class="comment">// visit first element</span></span><br><span class="line">String second = iter.next();<span class="comment">// visit second element</span></span><br><span class="line">iter.remove();<span class="comment">// remove last visited element</span></span><br></pre></td></tr></table></figure>

<p>不过，链表与泛型集合之间有一个重要区别。链表是一个有序集合(ordered collection)，每个对象的位置十分重要。LinkedList.add方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。由于迭代器描述了集合中的位置，所以这种依赖于位置的add方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。例如，下一节将要讨论的集(set)数据类型中，元素是完全无序的。因此，Iterator接口中没有add方法。实际上，集合类库提供了一个子接口ListIterator，其中包含add方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与Collection.add不同，这个方法不返回boolean类型的值，它假定add操作总会改变链表。</p>
<p>另外，ListIterator接口有两个方法。可以用来反向遍历链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">previous</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>与next方法一样，previous方法返回越过的对象。</p>
<p>LinkedList类的listIterator方法返回一个实现了ListIterator接口的迭代器对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator&lt;String&gt; iter =  staff.listIterator();</span><br></pre></td></tr></table></figure>

<p>add方法在迭代器位置之前添加一个新对象。例如，下面的代码越过链表中的第一个元素，在第二个元素之前添加“Juliet”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">staff.add(<span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Carl&quot;</span>);</span><br><span class="line">LsitIterator&lt;Stirng&gt; iter = staff.listIterator();</span><br><span class="line">iter.next();</span><br><span class="line">iter.add(<span class="string">&quot;Juliet&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果多次调用add方法，按照提供的次序把元素添加到链表中。他们被依次添加到迭代器当前位置之前。</p>
<p>当用一个刚由listIterator方法返回并指向链表表头的迭代器调用add操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时(hasNext返回false)，添加的元素将变成为列表的新表尾。如果链表有n个元素，会有n+1个位置可以添加新元素。这些位置与迭代器的n+1个可能的位置相对应。例如，如果链表包含3个元素，A，B，C就有4个位置可以插入新元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">|ABC</span><br><span class="line">A|BC</span><br><span class="line">AB|C</span><br><span class="line">ABC|</span><br></pre></td></tr></table></figure>

<p>最后需要说明，set方法用一个新元素替换调用next或previous方法返回上一个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator&lt;String&gt; iter = list.listIterator();</span><br><span class="line">String oldValue = iter.next();</span><br><span class="line">iter.set(newValue);</span><br></pre></td></tr></table></figure>

<p>可以想象，如果在某个迭代器修改集合时，另一个迭代器却在遍历这个集合，那么一定会出现混乱。例如，假设一个迭代器指向一个元素前面的位置，而另一个迭代器刚刚删除了这个元素，现在前一个迭代器就是无效的，并且不能再使用。链表迭代器设计可以检测到这种修改。如果一个迭代器发现它的集合被另外一个迭代器修改了，或是被该集合自身的某个方法修改了，就会抛出一个ConcurrentModificationException异常。例如，考虑下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = ...;</span><br><span class="line">ListIterator&lt;String&gt; iter1 = list.listIterator();</span><br><span class="line">ListIterator&lt;String&gt; iter2 = list.listIterator();</span><br><span class="line">iter1.next();</span><br><span class="line">iter1.remove();</span><br><span class="line">iter2.next();<span class="comment">//throws ConcurrentModificationException</span></span><br></pre></td></tr></table></figure>

<p>由于iter2检测出这个链表从外部修改了，所以对iter2.next的调用抛出一个ConcurrentModificationException异常。</p>
<p>为了避免发生并发修改异常，请遵循这样一个简单的规则：可以根据需要为一个集合关联多个迭代器，前提是这些迭代器只能读取集合。或者，可以再关联一个能同时读写的迭代器。</p>
<p>有一种简单的方法可以检测到并发修改。集合可以跟踪更改操作的次数。每个迭代器都会为它负责的更改操作维护一个单独的更改操作数。在每个迭代器方法的开始处，迭代器会检查它自己的更改操作数是否与集合的更改操作数相等。如果不一致，就抛出一个ConcurrentModificationException异常。</p>
<p>现在已经介绍了LinkedLsit类的基本方法。可以使用ListIterator类从前后两个方向遍历链表中的元素，以及添加和删除元素。</p>
<p>在9.2节已经看到，Collection接口还声明了操作链表的很多其他有用的方法。其中大部分方法都是在LinkedList类的超类AbstractCollection中实现的。例如，toString方法调用了所有元素的toString，并产生了一个格式为[A,B,C]的长字符串。这为调试工作提供了便利。可以使用contains方法检测某个元素是否出现在链表中。例如，如果链表中已经包含了一个等于“Harry”的字符串，调用staff.conatins(“Harry”)将会返回true。</p>
<p>在Java类库中，还提供了许多在理论上存在一定争议的方法。链表不支持快速随机访问。如果要查看链表中的第n个元素，就必须从头开始，越过n-1个元素。没有捷径可走。</p>
<p>鉴于这个原因，需要按整数索引访问元素时，程序员通常不选用链表。</p>
<p>不过，LinkedList类还是提供了一个用来访问某个特定元素的get方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = ...;</span><br><span class="line">String obj = list.get(n);</span><br></pre></td></tr></table></figure>

<p>当然，这个方法的效率并不太高。如果发现自己正在使用这个方法，说明对于所要解决的问题，你可能使用了错误的数据结构。</p>
<p>绝不应该使用这个“虚假”的随机访问来遍历链表。下面这段代码的效率极低：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> something with list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次查找一个元素都要从列表的头部重新开始搜索。LinkedList对象根本没有缓存位置信息。</p>
<p>列表迭代器接口还有一个方法，可以告诉你当前位置的索引。实际上，从概念上将，由于java迭代器指向两个元素之间的位置，所以可以有两个索引：nextIndex方法返回下一次调用next方法时所返回元素的整数索引；previousIndex方法返回下一次调用previous方法时所返回元素的整数索引。当然，这个索引只比nextIndex返回的索引值小1。这两个方法的效率非常高，因为有一个迭代器保持着当前位置的计数值。最后需要说明一点，如果有一个整数索引n，list.listIterator(n)将返回一个迭代器这个迭代器指向索引为n的元素前面的位置。也就是说，调用next()与调用list.get(n)会产生同一个元素，只是获得迭代器的效率比较低。</p>
<p>如果链表中只有很少几个元素，就完全没有必要为get方法和set方法的开销而烦恼。但是，最初为什么要使用链表呢？使用链表的唯一理由就是尽可能地减少在列表中间插入或删除元素的开销。如果列表只有很少几个元素，就完全可以使用ArrayList。</p>
<p>建议避免使用以整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，就使用数组或ArrayList，而不要使用链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedlistTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; a = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        a.add(<span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">        a.add(<span class="string">&quot;Carl&quot;</span>);</span><br><span class="line">        a.add(<span class="string">&quot;Erica&quot;</span>);</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;String&gt; b = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        b.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        b.add(<span class="string">&quot;Doug&quot;</span>);</span><br><span class="line">        b.add(<span class="string">&quot;Frances&quot;</span>);</span><br><span class="line">        b.add(<span class="string">&quot;Gloria&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ListIterator&lt;String&gt; aIter = a.listIterator();</span><br><span class="line">        Iterator&lt;String&gt; bIter = b.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (bIter.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (aIter.hasNext()) aIter.next();</span><br><span class="line">            aIter.add(bIter.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">        bIter = b.iterator();<span class="comment">//重制迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//间隔删除b中的元素</span></span><br><span class="line">        <span class="keyword">while</span> (bIter.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            bIter.next();</span><br><span class="line">            <span class="keyword">if</span> (bIter.hasNext())</span><br><span class="line">            &#123;</span><br><span class="line">                bIter.next();</span><br><span class="line">                bIter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在a中删除b里的元素</span></span><br><span class="line">        a.removeAll(b);</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-2-数组列表"><a href="#9-3-2-数组列表" class="headerlink" title="9.3.2 数组列表"></a>9.3.2 数组列表</h3><p>在上一节中，介绍了List接口和实现这个接口的LikedList类。List接口用于描述一个有序集合，并且集合中每个元素的位置都很重要。有两种访问元素的协议：一种是通过迭代器，另一种是通过get和set方法随机地访问每个元素。后者不适用于链表，但当然get和set方法对数组很有用。集合类库提供了一种大家熟悉的ArrayList类，这个类也实现了List接口。ArrayList封装了一个动态再分配的对象数组。</p>
<h3 id="9-3-3-散列集"><a href="#9-3-3-散列集" class="headerlink" title="9.3.3 散列集"></a>9.3.3 散列集</h3><p>链表和数组允许你根据意愿指定元素的次序。但是，如果想要查看某个指定的元素，却又不记得它的位置，就需要访问所有元素，直到找到为止。如果集合中包含的元素很多，这将会需要很长的时间。如果不在意元素的顺序，有几种能够快速查找元素的数据结构。其缺点是无法控制元素出现的次序。这些数据结构按照对自己最方便的方式组织元素。</p>
<p>有一种众所周知的数据结构，可以用于快速地查找，这就是散列表(hash table)。散列表为每个对象计算一个整数，称为散列码(hash code)。散列码是由对象的实例字段得出的一个整数。更准确地说，有不同数据的对象将产生不同的散列码。例如：它们是由String类的hashcode方法产生的。</p>
<table>
<thead>
<tr>
<th>字符串</th>
<th>散列码</th>
</tr>
</thead>
<tbody><tr>
<td>“Lee”</td>
<td>76268</td>
</tr>
<tr>
<td>“lee”</td>
<td>107020</td>
</tr>
<tr>
<td>“eel”</td>
<td>100300</td>
</tr>
</tbody></table>
<p>如果定义你自己的类，你就要负责实现自己得hashCode方法。有关hashCode方法的详细内容请参看第五章。注意，你的实现应该与equals方法兼容，即如果a.equals(b)为true，a与b必须有相同的散列码。</p>
<p>现在，最重要的问题是要能够快速计算出散列码，并且这个计算只与要计算散列的那个对象的状态有关，与散列表中的其他对象无关。</p>
<p>在Java中，散列表用链表数组实现。每个列表被称为桶(bucket)。想要查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。例如，如果某个对象的散列码为76268，并且有128个桶，那么这个对象应该保存在第108号桶中。或许很幸运，在这个桶中没有其他元素，此时将元素直接插入到桶中就可以了。当然，有时候会遇到桶已经被填充的情况。这种现象被称为散列冲突(hash collision)。这时，需要将新对象与桶中的所有对象进行比较，查看这个对象是否存在。如果散列码合理地随机分布，桶的数目也足够大，需要比较的次数就会很少。</p>
<p>如果想要更多地控制散列表的性能，可以指定一个初始的桶数。桶数是指用于收集有相同散列值的桶的数目。如果要插入到散列表中的元素太多，就会增加冲突数量，降低检索性能。</p>
<p>如果大致知道最终会有多少个元素要插入到散列表中，就可以设置桶数。通常，将桶数设置为预计元素个数的75%~150%。有些研究人员认为：最好将桶数设置是2的幂，默认值为16.</p>
<p>当然，并不总是能够知道需要存储多少个元素，也有可能最初的估计过低。如果散列表太满，就需要再散列(rehashed)。如果要对散列表再散列，就需要创建一个桶数更多的表，并将所有元素插入到这个新表中，然后丢弃原来的表。装填因子(load factor)可以确定何时对散列表进行再散列。例如，如果装填因子为0.75，说明表中已经填满了75%以上，就会自动再散列，新表的桶数是原来的两倍。对于大多数应用程序来说，装填因子为0.75是合理的。</p>
<p>散列表可以用于实现很多重要的数据结构。其中最简单的是集类型。集是没有重复元素的元素集合集的add方法首先在这个集中查找要添加的对象，如果不存在，就添加这个对象。</p>
<p>Java集合类库提供了HashSet类，它实现了基于散列表的集。可以用add方法添加元素。contains方法已经被重新定义，用来快速查找某个元素是否已经在集中。它只查看一个桶中的元素，而不必查看集合中的所有元素。</p>
<p>散列集迭代器将依次访问所有的桶。由于散列将元素分散在表中，所以会一种看起来随机的顺序访问元素。只有不关心集合中的顺序时才应该使用HashSet。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> setStudent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student: name=&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;,age=&quot;</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student otherobj = (Student)obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name,otherobj.name) &amp;&amp; <span class="keyword">this</span>.age == otherobj.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> setStudent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashsetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Student&gt; hs = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//创建HashSet集合</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;qwe&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;asd&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;zxc&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        Student s4 = <span class="keyword">new</span> Student(<span class="string">&quot;asd&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        Student s5 = <span class="keyword">new</span> Student(<span class="string">&quot;zxc&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把学生添加到集合</span></span><br><span class="line">        hs.add(s1);</span><br><span class="line">        hs.add(s2);</span><br><span class="line">        hs.add(s3);</span><br><span class="line">        hs.add(s4);</span><br><span class="line">        hs.add(s5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (Student s : hs)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-4-树集"><a href="#9-3-4-树集" class="headerlink" title="9.3.4 树集"></a>9.3.4 树集</h3><p>TreeSet类与散列集十分类似，不过，它比散列集有所改进。树集是一个有序集合(sorted collection)。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，值将自动地按照排序后的顺序呈现。例如，假设插入3个字符串，然后访问添加的所有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;String&gt; sorter = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sorter.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">sorter.add(<span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">sorter.add(<span class="string">&quot;Carl&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String s : sorter)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，值按照有序打印：Amy Bob Carl。正如TreeSet类名所示，排序是用一个是数据结构完成的(当前实现使用的是红黑树(red-black tree))。每次将一个元素添加到树中时，都会将其放置在正确的排序位置上。因此，迭代器总是以有序的顺序访问每个元素。</p>
<p>将一个元素添加到树中要比添加到散列表中慢，但是，与检查数组或链表中的重复元素相比，使用树会快很多。如果树中包含了1000个元素，添加一个新元素大约需要比较10次。</p>
<p>你可能很想知道是否应该总是用树集而不是散列集。毕竟，添加一个元素所花费的时间上去并不很长，而且元素是自动排序的。到底应该怎样做取决于所要收集的数据。如果不需要数据是有序的，就没有必要付出排序。更重要的是，对于某些数据来说，对其进行排序要比给出一个散列函数更加困难。散列函数只需要将对象适当地打乱存放，而比较函数必须精确地区分各个对象。</p>
<p>想要具体了解它们之间的差异，可以考虑收集一个矩形集的任务。如果使用TreeSet，就需要提供Comparator&lt;Rectangle&gt;。如何比较两个矩形呢？比较面积吗？这行不通。可能会有两个不同的矩形，它们的坐标不同，但面积却相同。树的排序顺序必须是全序。也就是说，任意两个元素都必须是可比的，并且只有两个元素相等时结果才为0.矩形确实有一种排序方式(按照坐标的词典顺序排序)，但这很牵强，而且计算繁琐。相反地，Rectangle类已经定义了散列函数，它直接对坐标进行散列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> treeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> partNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(String description, <span class="keyword">int</span> partNumber)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">        <span class="keyword">this</span>.partNumber = partNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[description=&quot;</span> + <span class="keyword">this</span>.description + <span class="string">&quot;,partNumber=&quot;</span> + <span class="keyword">this</span>.partNumber + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Item otherObj = (Item)obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.description,otherObj.description) &amp;&amp; <span class="keyword">this</span>.partNumber == otherObj.partNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(<span class="keyword">this</span>.description,<span class="keyword">this</span>.partNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Item obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = Integer.compare(<span class="keyword">this</span>.partNumber,obj.partNumber);</span><br><span class="line">        <span class="keyword">return</span> diff != <span class="number">0</span>? diff : <span class="keyword">this</span>.description.compareTo(obj.description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> treeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeSet&lt;Item&gt; parts = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        parts.add(<span class="keyword">new</span> Item(<span class="string">&quot;Toaster&quot;</span>,<span class="number">1234</span>));</span><br><span class="line">        parts.add(<span class="keyword">new</span> Item(<span class="string">&quot;Widget&quot;</span>,<span class="number">4562</span>));</span><br><span class="line">        parts.add(<span class="keyword">new</span> Item(<span class="string">&quot;Modem&quot;</span>,<span class="number">9912</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(parts);</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Item&gt; sortByDescription = <span class="keyword">new</span> TreeSet&lt;&gt;(Comparator.comparing(Item::getDescription));</span><br><span class="line"></span><br><span class="line">        sortByDescription.addAll(parts);</span><br><span class="line">        System.out.println(sortByDescription);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-5-队列与双端队列"><a href="#9-3-5-队列与双端队列" class="headerlink" title="9.3.5 队列与双端队列"></a>9.3.5 队列与双端队列</h3><p>前面已经讨论过，队列允许你高效地在尾部添加元素，并在头部删除元素。双端队列(即deque)允许在头部和尾部都高效地添加或删除元素。不支持在队列中间添加元素。Java6中引入了Deque接口，ArrayDeque和LinkedList类实现了这个接口。这两个类都可以提供双端队列，其大小可以根据需要扩展。</p>
<h3 id="9-3-6-优先队列"><a href="#9-3-6-优先队列" class="headerlink" title="9.3.6 优先队列"></a>9.3.6 优先队列</h3><p>优先队列(priority queue)中的元素可以按照任意的顺序插入，但会按照有序的顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前优先队列中最小的元素。不过，优先队列并没有对所有元素进行排序。如果迭代处理这些元素，并不需要对它们进行排序。优先队列使用了一个精巧且高效的数据结构，称为堆(heap)。堆是一个可以自组织的二叉树，其添加(add)和删除(remove)操作可以让最小的元素移动到根，而不必花费时间对元素进行排序。</p>
<p>与TreeSet一样。优先队列既可以实现了Comparable接口的类对象，也可以保存构造器中提供的Comparator对象。</p>
<p>优先队列的典型用法是任务调度。每一个任务有一个优先级，任务以随机顺序添加到队列中。每当启动一个新的任务时，都将优先级最高的任务从队列中删除。</p>
<h2 id="9-4-映射"><a href="#9-4-映射" class="headerlink" title="9.4 映射"></a>9.4 映射</h2><p>即时一个集合，允许你快速地查找现有的元素。但是，要查找一个元素，需要有所要查找的那个元素的准确副本。这不是一种常见的查找方式。通常，我们知道某些关键信息，希望查找与之关联的元素。映射(map)数据结构就是为此设计的。映射用来存放键/值对。如果提供了键，就能够查找到值。例如，可以存储一个员工记录表，其中键为员工ID，值为Employee对象。</p>
<h3 id="9-4-1-基本映射操作"><a href="#9-4-1-基本映射操作" class="headerlink" title="9.4.1 基本映射操作"></a>9.4.1 基本映射操作</h3><p>Java类库为映射提供了两个通用的实现：HashMap和TreeMap。这两个类都实现了Map接口。</p>
<p>散列映射对键进行散列，树映射根据键的顺序将元素组织为一个搜索树。散列或比较函数只应用于键。与键关联的值不进行散列或比较。</p>
<p>应该选择散列映射还是树映射呢？与集一样，散列稍微快一些，如果不需要按照有序的顺序访问键，最好选择散列映射。</p>
<p>以下代码将建立一个散列映射来存储员工信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,Employee&gt; = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Employee harry = <span class="keyword">new</span> Employee(<span class="string">&quot;Harry Hackr&quot;</span>);</span><br><span class="line">staff.put(<span class="string">&quot;983-98-996&quot;</span>,harry);</span><br></pre></td></tr></table></figure>

<p>每当往映射中添加一个对象，必须同时提供一个键。在这里，键是一个字符串，对应的值是Employee对象。</p>
<p>想要检索一个对象，必须使用键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String id = <span class="string">&quot;987-98-9996&quot;</span>;</span><br><span class="line">Employee e = staff.get(id);<span class="comment">//gets harry</span></span><br></pre></td></tr></table></figure>

<p>如果映射没有存储给定键对应的信息，get将返回null。</p>
<p>null返回值可能并不方便。有时对应没有出在映射中的键，可以使用一个好的默认值。</p>
<p>然后使用getOrDefault方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map(String,Integer) scores = ...;</span><br><span class="line"><span class="keyword">int</span> scores = scores.getOrDefault(id,<span class="number">0</span>);<span class="comment">//gets 0 if the id is not present</span></span><br></pre></td></tr></table></figure>

<p>键必须是唯一的。不能对同一个键存放两个值。如果对同一个键调用两次put方法，第二个值就会取代第一个值。实际上，put将返回与这个键参数关联的上一个值。</p>
<p>remove方法从映射中删除给定对应的元素。size方法返回映射中的元素数。</p>
<p>要迭代处理映射的键和值，最容易的方法是使用forEach方法。可以提供一个接收键和值的lambda表达式。映射中的每一项会依次调用这个表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scores.forEach((k,v) -&gt;</span><br><span class="line">              System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot;,value=&quot;</span> + v));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashMap&lt;String,Employee&gt; staff = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        staff.put(<span class="string">&quot;144-25-5464&quot;</span>,<span class="keyword">new</span> Employee(<span class="string">&quot;Amy Lee&quot;</span>));</span><br><span class="line">        staff.put(<span class="string">&quot;567-24-2546&quot;</span>,<span class="keyword">new</span> Employee(<span class="string">&quot;Harry Hacker&quot;</span>));</span><br><span class="line">        staff.put(<span class="string">&quot;157-62-7935&quot;</span>,<span class="keyword">new</span> Employee(<span class="string">&quot;Gary Cooper&quot;</span>));</span><br><span class="line">        staff.put(<span class="string">&quot;456-62-5527&quot;</span>,<span class="keyword">new</span> Employee(<span class="string">&quot;Francesca Cruz&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//print all entries</span></span><br><span class="line"></span><br><span class="line">        System.out.println(staff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove an entry</span></span><br><span class="line"></span><br><span class="line">        staff.remove(<span class="string">&quot;567-24-2546&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//replace an entry</span></span><br><span class="line"></span><br><span class="line">        staff.put(<span class="string">&quot;456-62-5527&quot;</span>,<span class="keyword">new</span> Employee(<span class="string">&quot;Francesca Miller&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//look up a value</span></span><br><span class="line"></span><br><span class="line">        System.out.println(staff.get(<span class="string">&quot;157-62-7935&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//iterate through all entries</span></span><br><span class="line"></span><br><span class="line">        staff.forEach((k,v) -&gt;</span><br><span class="line">                System.out.println(<span class="string">&quot;key&quot;</span> + k + <span class="string">&quot;,value=&quot;</span> + v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee=&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4-2-跟新映射条目"><a href="#9-4-2-跟新映射条目" class="headerlink" title="9.4.2 跟新映射条目"></a>9.4.2 跟新映射条目</h3><p>处理映射的一个难点就是更新映射条目。正常情况下，可以得到与一个键关联的原值，完成更新，再放回更新后的值。不过，必须考虑一个特殊情况，即键第一次出现。下面看一个例子，考虑使用映射统计一个单词在文中出现的频度。看到一个单词(word)时，我们将计数器增1，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.put(word,counts.get(word) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这是可以的，不过有一种特殊情况除外：就是第一次看到word时。在这种情况下，get会返回null，因此会出现一个NullPointerException异常。</p>
<p>一个简单的补救是使用getOrDefault方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.put(word,counts.getOrDefault(word,<span class="number">0</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>另外一种方法是首先调用putIfAbsent方法。只有当键原先存在时才会放入一个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.putIfAbsent(word,<span class="number">0</span>);</span><br><span class="line">counts.put(word,counts.get(word) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>不过还可以做得更好。merge方法可以简化这个常见操作。如果键原先不存在，下面调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">counts.merge(word,<span class="number">1</span>,Integer::sum);</span><br></pre></td></tr></table></figure>

<p>将把word与1关联，否则使用Integer::sum函数组合原值和1</p>
<h3 id="9-4-3-映射视图"><a href="#9-4-3-映射视图" class="headerlink" title="9.4.3 映射视图"></a>9.4.3 映射视图</h3><p>集合框架不认为映射本身是一个集合。不过，可以得到映射的视图(view)——这是实现了Collection接口或某个子类接口的对象。</p>
<p>有三种视图：键值、值集合以及键/值对集。键和键/值对可以构成一个集，因为映射中一个键只能有一个副本。下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Set&lt;k&gt; <span class="title">keySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Collection&lt;v&gt; <span class="title">values</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Set&lt;Map.Entry&lt;k,v&gt;&gt; <span class="title">entrySet</span><span class="params">()</span>    </span></span><br></pre></td></tr></table></figure>

<p>会分别返回这3个视图。</p>
<p>需要说明的是，keySet不是HshSet或TreeSet，而是实现了Set接口的另外某个类的对象。Set接口扩展了Collection接口。因此，可以像使用任何集合一样使用keySet。</p>
<p>例如，可以枚举一个映射的所有键：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key : keys)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> something with key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想同时查看键和值，可以通过枚举映射条目来避免查找值。使用以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Employee&gt; entry : staff.entrySet())</span><br><span class="line">&#123;</span><br><span class="line">    String k = entry.getkey();</span><br><span class="line">    Employee v = entry.getVaule();</span><br><span class="line">    <span class="keyword">do</span> something with k,v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【可以使用var声明避免笨拙的Map.Entry】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> entry : staff.entrySet())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> something with entry.getkey(),entry.getVaule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如今，只需要使用forEach方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((k,v) -&gt;</span><br><span class="line">            &#123;<span class="keyword">do</span> something with k,v&#125;);</span><br></pre></td></tr></table></figure>

<p>如果在键集视图上调用迭代器的remove方法，实际上会从映射中删除这个键和它关联的值。不过，不能向键集视图中添加元素。另外，如果添加一个键而没有同时添加值也是没有意义的。如果试图调用add方法，它会抛出一个UnsupportedOperationException。映射条目集视图有同样的限制，尽管理论上增加一个新的键/值对好像有意义。</p>
<h3 id="9-4-4-弱散列映射"><a href="#9-4-4-弱散列映射" class="headerlink" title="9.4.4 弱散列映射"></a>9.4.4 弱散列映射</h3><p>设计WeakHashMap类是为了解决一个有趣的问题。如果有一个值，它对应的键已经不再在程序中的任何地方使用，将会出现什么情况呢？假定对某个键的最后一个引用已经消失，那么不再有任何途径可以引用这个值的对象了。但是，由于程序中的任何部分不会再有这个键，所以，无法从映射中删除这个值/键对。为什么垃圾回收器不能删除它呢？删除无用的对象不就是垃圾回收器的工作吗？</p>
<p>遗憾的是，事情没有这么简单。垃圾回收器会跟踪活动的对象。只要映射对象是活动的，其中的所有桶也是活动的，他们不能被回收。因此，需要由程序负责从长期存活的映射表中删除那些无用的值。或者，你可以使用WeakHashMap。当对键的唯一引用来自散列表映射条目时，这个数据结构与垃圾回收器协同工作一起删除键/值对。</p>
<p>WeakHashMap使用弱引用(weak references)保存键。WeakReference对象将包含另一个对象的引用，在这里，就是一个散列表键。对于这种类型的对象，垃圾回收器采用一种特有的方式进行处理。正常情况下，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器也会将其回收，但会将引用这个对象的弱引用放入一个队列。WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经回收。于是，WeakHashMap将删除相关联的映射条目。</p>
<h3 id="9-4-5-链接散列集与映射"><a href="#9-4-5-链接散列集与映射" class="headerlink" title="9.4.5 链接散列集与映射"></a>9.4.5 链接散列集与映射</h3><p>LinkedHashSet和LinkedHashMap类会记住插入元素项的顺序。这样就可以避免散列表中的项看起来顺序是随机的。在表中插入元素项时，就会并入到双向链表中。</p>
<p>例如以下处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashMap&lt;String,Employee&gt; staff = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">staff.put(<span class="string">&quot;144-25-5464&quot;</span>,<span class="keyword">new</span> Employee(<span class="string">&quot;Ame Lee&quot;</span>));</span><br><span class="line">staff.put(<span class="string">&quot;567-24-2546&quot;</span>,<span class="keyword">new</span> Employee(<span class="string">&quot;Harry Hacker&quot;</span>));</span><br><span class="line">staff.put(<span class="string">&quot;157-62-7935&quot;</span>,<span class="keyword">new</span> Employee(<span class="string">&quot;Gary Cooper&quot;</span>));</span><br><span class="line">staff.put(<span class="string">&quot;456-62-5527&quot;</span>,<span class="keyword">new</span> Employee(<span class="string">&quot;Francesca Cruz&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>然后，staff.keySet().iterator()以下面的次序枚举键：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">144</span>-<span class="number">25</span>-<span class="number">5464</span></span><br><span class="line"><span class="number">567</span>-<span class="number">24</span>-<span class="number">2546</span></span><br><span class="line"><span class="number">157</span>-<span class="number">62</span>-<span class="number">7935</span></span><br><span class="line"><span class="number">456</span>-<span class="number">62</span>-<span class="number">5527</span></span><br></pre></td></tr></table></figure>

<p>staff.values()/iterator()以下面的顺序枚举值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Ame Lee</span><br><span class="line">Harry Hacker</span><br><span class="line">Gary Cooper</span><br><span class="line">Francesca Cruz</span><br></pre></td></tr></table></figure>

<p>或者，链接散列映射可以使用访问顺序而不是插入顺序来迭代处理映射条目。每次调用get或put时，受到影响的项将从当前的位置删除，并放到项链表的尾部。要构造这样一个散列映射，需要调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashMap&lt;K,V&gt;(initialCapacity,loadFactor,<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<p>访问顺序对于实现缓存的“最近最少使用”原则十分重要。例如，你可能需要将访问频率高的元素放在内存中，而访问频率低的元素从数据库中读取。当在表中找不到元素项而且表已经相当满时，可以得到表的一个迭代器，并删除它枚举的前几个元素。这些项是近期最少用的几个元素。</p>
<p>甚至可以让这一过程自动化，构造LinkedHashMap的一个子类，然后覆盖下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span></span></span><br></pre></td></tr></table></figure>

<p>每当你的方法返回true时，添加一个新映射条目就会导致删除eldset项。例如，下面的缓存最多可以存放100个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashMap&lt;K,V&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;K,V&gt;(<span class="number">18</span>,<span class="number">0.75F</span>，<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者，还可以考虑eldst元素，来决定是否将它删除。例如，可以检查与这一项一起存储的时间戳。</p>
<h3 id="9-4-6-枚举集与映射"><a href="#9-4-6-枚举集与映射" class="headerlink" title="9.4.6 枚举集与映射"></a>9.4.6 枚举集与映射</h3><p>EnumSet是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以EnumSet内部用位序列实现。如果对应的值在集中，则相应的位置为1。</p>
<p>EnumSet类没有公共的构造器。要使用静态工厂方法构造这个集：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;MONDAT,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURADAY,SUNDAY&#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY,Weekday.FRIDAY);</span><br><span class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY,Weekday.WEDNESDAY,Weekday.FRIDAY);</span><br></pre></td></tr></table></figure>

<p>可以使用Set接口的常用方法来修改EnumSet。</p>
<p>EnumMap是一个键类型为枚举类型的映射。它可以直接且高效地实现为一个值数组。需要在构造器中指定键类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EnumMap&lt;Weekday,Employee&gt; personInCharge = <span class="keyword">new</span> EnumMap&lt;Weekday,Employee&gt;(WeekDay.class);</span><br></pre></td></tr></table></figure>

<h3 id="9-4-7-标识散列映射"><a href="#9-4-7-标识散列映射" class="headerlink" title="9.4.7 标识散列映射"></a>9.4.7 标识散列映射</h3><p>类IdentityHashMap有特殊的用途。在这个类中，键的散列值不是用hashCode函数计算的，而是用System.identityHashCode方法计算的。这是Object.hashCode根据对象的内存地址计算散列码。而且，在对两个对象进行比较时，IdentityHashMap类使用==，而不使用equals。</p>
<p>也就是说，不同的键对象即使内容相同，也被视为不同的对象。在实现对象遍历算法时，这个类非常有用，可以用来跟踪哪些对象已经遍历过。</p>
<h2 id="9-5-视图与包装器"><a href="#9-5-视图与包装器" class="headerlink" title="9.5 视图与包装器"></a>9.5 视图与包装器</h2><h3 id="9-5-1-小集合"><a href="#9-5-1-小集合" class="headerlink" title="9.5.1 小集合"></a>9.5.1 小集合</h3><h3 id="9-5-2-子范围"><a href="#9-5-2-子范围" class="headerlink" title="9.5.2 子范围"></a>9.5.2 子范围</h3><h3 id="9-5-3-不可修改的视图"><a href="#9-5-3-不可修改的视图" class="headerlink" title="9.5.3 不可修改的视图"></a>9.5.3 不可修改的视图</h3><h3 id="9-5-4-同步视图"><a href="#9-5-4-同步视图" class="headerlink" title="9.5.4 同步视图"></a>9.5.4 同步视图</h3><h3 id="9-5-5-检查型视图"><a href="#9-5-5-检查型视图" class="headerlink" title="9.5.5 检查型视图"></a>9.5.5 检查型视图</h3><h3 id="9-5-6-关于可选操作的说明"><a href="#9-5-6-关于可选操作的说明" class="headerlink" title="9.5.6 关于可选操作的说明"></a>9.5.6 关于可选操作的说明</h3><h2 id="9-6-算法"><a href="#9-6-算法" class="headerlink" title="9.6 算法"></a>9.6 算法</h2><p>除了实现集合类，Java集合框架还提供了一些有用的算法。</p>
<h3 id="9-6-1-为什么使用泛型算法"><a href="#9-6-1-为什么使用泛型算法" class="headerlink" title="9.6.1 为什么使用泛型算法"></a>9.6.1 为什么使用泛型算法</h3><p>泛型集合接口有一个很大的优点，即算法只需要实现一次。例如，考虑一下计算集合中最大元素的简单算法。使用传统方式，程序设计人员可能会用循环实现这个算法。可以如下找出数组中最大的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a.length = <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">T largest = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(largest.compareTo(a[i]) &lt; <span class="number">0</span>)</span><br><span class="line">        largest = a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，要找到数组列表的最大元素，编写的代码会稍有差别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(v.size() == <span class="number">0</span>) <span class="function"><span class="keyword">throws</span> new <span class="title">NoSuchElementException</span><span class="params">()</span></span>;</span><br><span class="line">T largest = v.get(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(largest.compareTo(v.get(i)) &lt; <span class="number">0</span>)</span><br><span class="line">        largest = v.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表呢？链表没有高效的随机访问操作，不过可以使用迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(l.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">Iterator&lt;T&gt; iter = l.iterator();</span><br><span class="line">T largest = iter.next();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    T next = iter.next();</span><br><span class="line">    <span class="keyword">if</span>(largest.compareTo(next) &lt; <span class="number">0</span>)</span><br><span class="line">        largest = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写这些循环很繁琐，而且很容易出错。是否存在“差1”错误(off-by-one error)?这些循环对于空容器能正常工作吗？对于只含有一个元素的容器又会发生什么情况呢？我们不希望每次都测试和调试这些代码，也不想实现如下的一系列方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">max</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T extends Comparable&gt; T <span class="title">max</span><span class="params">(ArrayList&lt;T&gt; v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T extends Comparable&gt; T <span class="title">max</span><span class="params">(LinkedList&lt;T&gt; l)</span></span></span><br></pre></td></tr></table></figure>

<p>这里就可以使用集合接口。请考虑为了高效地执行这个算法所需要的最小集合接口。采用get和set方法的随机访问要比直接迭代层次高。在计算链表中最大元素的过程中已经看到，这项任务不需要随机访问。可以直接迭代处理元素来得出最大元素。因此，可以将max方法实现为能够接收任何实现了Collection接口的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;T&gt; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Iterator&lt;T&gt; iter = c.iterator();</span><br><span class="line">    T largest = iter.next();</span><br><span class="line">    <span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        T next = iter.next();</span><br><span class="line">        <span class="keyword">if</span>(largest.compareTo(next) &lt; <span class="number">0</span>)</span><br><span class="line">            largest = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就可以使用一个方法计算链表、数组列表或数组中最大元素了。</p>
<h3 id="9-6-2-排序与混排"><a href="#9-6-2-排序与混排" class="headerlink" title="9.6.2 排序与混排"></a>9.6.2 排序与混排</h3><p>Collections类中的sort方法可以对实现了List接口的集合进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">fill collection</span><br><span class="line">Collections.sort(staff);</span><br></pre></td></tr></table></figure>

<p>这个方法假定列表元素实现了Comparable接口。如果想采用其他方式对列表进行排序，可以使用List接口的sort方法并传入一个Comparator对象。可以如下按工资对一个员工列表排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary));</span><br></pre></td></tr></table></figure>

<p>如果想按照降序对列表进行排序，可以使用静态的便利方法Collections.reverseOrder()。这个方法将返回一个比较器，比较器则返回b.comparaTo(a)。例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.sort(Comparator.reverseOrder)</span><br></pre></td></tr></table></figure>

<p>这个方法将根据元素类型的compareTo方法所给定的排序顺序，按逆序对列表staff中的元素进行排序。同样地，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.sort(Comparator.comparingDoble(Employee::getSalary).reversed())</span><br></pre></td></tr></table></figure>

<p>按工资逆序排序。</p>
<p>人们可能会sort方法如何如何排序感到好奇。通常，在查看有关算法书籍中的排序算法时，会发觉介绍的都是有关数组的排序算法，而且使用的是随机访问方式。但是，链表的随机访问效率很低。实际上，可以使用一种归并排序对链表高效地排序。不过，Java程序设计语言并不是这样做的。它只是将所有元素转入一个数组，对数组进行排序，然后，再将排序后的序列复制回列表。</p>
<p>集合类库中使用排序算法比快速排序要慢一些，快速排序(QuickSort)是通过排序算法的传统选择。但是，归并排序有一个主要的优点：归并排序有一个主要的优点：归并排序是稳定的，也就是说，它不会改变相等元素的顺序。为什么要关注想等元素的顺序呢？下面来看一种常见的情况。假设有一个已经按照姓名排序的员工列表。现在，要按照工资再进行排序。如果两个员工的工资相等会发生什么情况？如果采用稳定的排序算法，将会保留按名字排序的顺序。换句话说，排序的结果是得到一个首先按照工资排序再按照姓名排序的列表。</p>
<p>因为集合不需要实现所有的“可选”方法，因此，所有接受集合参数的方法必须描述什么时候可以安全地将集合传递给算法。例如，显然不能将unmodifiableList列表传递给sort算法。那么，可以传递什么类型的列表呢？根据文档说明，列表必须是可修改的，但不一定可以改变大小。</p>
<p>下面是有关的术语定义：</p>
<ul>
<li>如果列表支持set方法，则是可以修改的(modifiable)</li>
<li>如果列表支持add和remove方法，则是可改变大小的(resizeable)</li>
</ul>
<p>Collections类有一个算法shuffle，其功能与排序刚好相反，它会随机地混排列表中元素的顺序。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Card&gt; cards = ...;</span><br><span class="line">Collections.shuffle(cards);</span><br></pre></td></tr></table></figure>

<p>如果提供的列表没有实现RandomAccess接口，shuffle方法会将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> shuffle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShuffleTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= <span class="number">49</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.shuffle(numbers);<span class="comment">//打乱</span></span><br><span class="line">        List&lt;Integer&gt; winningCombination = numbers.subList(<span class="number">0</span>,<span class="number">6</span>);<span class="comment">//取下标为0~5的放入List</span></span><br><span class="line">        Collections.sort(winningCombination);<span class="comment">//排序</span></span><br><span class="line">        System.out.println(winningCombination);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-6-3-二分查找"><a href="#9-6-3-二分查找" class="headerlink" title="9.6.3 二分查找"></a>9.6.3 二分查找</h3><p>要想在数组中查找一个对象，通常要依次访问数组中的每个元素，直到找到匹配的元素为止。不过，如果数组是有序的，可以检查中间的元素，查看是否大于要查找的元素。如果是，就在数组的前半部分继续查找；否则，在数组的后半部分继续查找。这样就可以将问题规模缩减一半，并以同样的方式继续下去。</p>
<p>Collections类的binarySearch方法实现了这个算法。注意，集合必须是有序的，否则算法会返回错误的答案。想要查找某个元素，必须提供集合以及要查找的元素。如果集合没有采用Comparable接口的compareTo方法进行排序，那么还要提供一个比较器对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = Collections.binarySearch(c,element);</span><br><span class="line">i = Collections.binarySearch(c,element,comparator);</span><br></pre></td></tr></table></figure>

<p>如果binarySearch方法返回一个非负的值，这表示匹配对象的索引。也就是说，c.get(i)等于在这个比较顺序下的element。如果返回负值，则表示没有匹配的元素。不过，可以利用返回值来计算应该将element插入到集合的哪个位置，以保持集合的有序性。插入的位置是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">insertionPoint = -i -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这并不是简单的-i，因为0值是不确定的。也就是说，下面这个操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">    c.add(-i - <span class="number">1</span>,element)</span><br></pre></td></tr></table></figure>

<p>将把元素插入到正确的位置上。</p>
<p>只有采用随机访问，二分查找才有意义。如果必须利用迭代方式查找链表的一半元素来找到中间元素，二分查找就完全失去了优势。因此，如果binarySearch算法提供一个链表，它将自动地退化为线性查找。</p>
<h3 id="9-6-4-简单算法"><a href="#9-6-4-简单算法" class="headerlink" title="9.6.4 简单算法"></a>9.6.4 简单算法</h3><p>Collections类中包含几个简单但很有用的算法。这一节最前面介绍的例子就是其中的一个算法，即查找集合中的最大元素。其他算法还包括：将一个列表中元素复制到另外一个列表中；用一个常量值填充容量；逆置一个列表的元素顺序。</p>
<p>为什么在标准库中提供这些简单算法呢？大多数程序员肯定可以很容易地采用简单的循环实现这些任务。我们之所以喜欢这些算法，是因为它们可以让程序员更轻松地读代码。当阅读由别人实现的循环时，必须要揣摩编程者的意图。例如，请看下面这个循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i++)</span><br><span class="line">    <span class="keyword">if</span>(words.get(i).equals(<span class="string">&quot;C++&quot;</span>)) words.set(i,<span class="string">&quot;Java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在将这个循环与一下调用进行比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.replaceAll(words,<span class="string">&quot;C++&quot;</span>,<span class="string">&quot;Java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>默认方法Colleciton.removeIf和List.replaceAll稍有复杂。要提供一个lambda表达式来测试或转换元素。例如，下面的代码将删除所有短词，并把其余单词改为小写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">words.removeIf(w -&gt; w.length() &lt;=<span class="number">3</span>);</span><br><span class="line">words.replaceAll(String::toLowerCase);</span><br></pre></td></tr></table></figure>

<h3 id="9-6-5-批操作"><a href="#9-6-5-批操作" class="headerlink" title="9.6.5 批操作"></a>9.6.5 批操作</h3><p>很多操作会“成批”复制或删除元素。以下调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">coll1.removeAll(coll2);</span><br></pre></td></tr></table></figure>

<p>将从coll1中删除coll2中出现的所有元素。与之相反，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">coll1.retainAll(coll2);</span><br></pre></td></tr></table></figure>

<p>会从coll1中删除所有未在coll2中出现的元素。下面是一个典型的应用。</p>
<p>假设希望找出两个集的交集(intersection)，也就是两个集中共有的元素。首先，建立一个新集来存放结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(firseSet);</span><br></pre></td></tr></table></figure>

<p>在这里，我们利用了一个事实：每一个集合都有这样一个构造器，其参数是包含初始值的另一个集合。</p>
<p>现在来使用retainAll方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result.retainAll(secondSet)</span><br></pre></td></tr></table></figure>

<p>这会保留两个集中都出现的所有元素。这样就构成了交集，而无需编写循环。</p>
<p>可以把这个思路更进一步，对视图应用一个批操作。例如，假设有一个映射，将员工ID映射到员工对象，另外有一个不再聘用的所有员工的ID集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Employee&gt; staffMap = ...;</span><br><span class="line">Set&lt;String&gt; terminatedIDs = ...;</span><br></pre></td></tr></table></figure>

<p>只需要建立一个键集，并删除终止聘用关系的所有员工的ID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staffMap.keySet().removeAll(terminatedIds);</span><br></pre></td></tr></table></figure>

<p>由于键集是映射的一个视图，所以键和相关联的员工名会自动从映射中删除。</p>
<p>通过使用子范围视图，可以把批操作限制在子列表和子集上。例如，假设希望把一个列表的前10个元素增加到另一个容器，可以建立一个子列表选出前10个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">relocated.addAll(staff.subList(<span class="number">0</span>,<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>这个子范围还可以完成更改操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.subList(<span class="number">0</span>,<span class="number">10</span>).clear();</span><br></pre></td></tr></table></figure>

<h3 id="9-6-6-集合与数组的转换"><a href="#9-6-6-集合与数组的转换" class="headerlink" title="9.6.6 集合与数组的转换"></a>9.6.6 集合与数组的转换</h3><p>如果需要把一个数组转换为集合，List.of包装器可以到达这个目的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] values = ...;</span><br><span class="line">HashSet&lt;&gt; staff = <span class="keyword">new</span> HashSet&lt;&gt;(List.of(values));</span><br></pre></td></tr></table></figure>

<p>从集合得到数组会更困难一些。当然，可以使用toArray方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] values = staff.toArray();</span><br></pre></td></tr></table></figure>

<p>不过，这样做的结果是一个对象数组。尽管你知道集合中包含的是一个特定类型的对象，但不能使用强制类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] values = (String[]) staff.toArray();<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>toArray方法返回的数组创建为一个Object[]数组，不能改变它的类型。实际上，必须使用toArray方法的一个变体，提供一个指定类型而且长度为0的数组。这样一来，返回的数组就会创建为相同的数组类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] values = staff.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>如果愿意，可以构造一个大小正确的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.toArray(<span class="keyword">new</span> String[staff.size()]);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，不会创建新数组。</p>
<h3 id="9-6-7-编写自己的算法"><a href="#9-6-7-编写自己的算法" class="headerlink" title="9.6.7 编写自己的算法"></a>9.6.7 编写自己的算法</h3><p>如果编写自己的算法(实际上，或者是以集合作为参数的任何方法)，应该尽可能地使用接口，而不要使用具体的实现。例如，假设你想处理集合元素。当然，可以实现类似下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processItems</span><span class="params">(ArrayList&lt;Item&gt; items)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Item item : items)</span><br><span class="line">        <span class="keyword">do</span> something with item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这样会限制方法的调用者，即调用者必须在ArrayList中提供元素。如果这些元素正好在另一个集合中，首先必须对它们重新包装，因此，最好接受一个更加通用的集合。</p>
<p>要问问自己：完成这项工作的最通用的集合接口是什么？你关心顺序吗？如果顺序很重要，就应当接受List。不过，如果顺序不重要，那么可以接受任意类型的集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processItems</span><span class="params">(Collection&lt;Item&gt; items)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Item item : items)</span><br><span class="line">        <span class="keyword">do</span> something with item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，任何人都可以用ArrayList或LinkedList(甚至用List.of包装器包装的数组)调用这个方法。</p>
<p>反过来，如果你的方法返回多个元素，你肯定不希望限制将来的改进。例如，考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Item&gt; <span class="title">lookupItems</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArrayList&lt;Item&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法承诺返回一个ArrayList，尽管调用者并不关心它是什么类型的列表。如果你返回一个List，任何时候都可以通过调用List.of返回一个空列表或单例列表。</p>
<h2 id="9-7-遗留的集合"><a href="#9-7-遗留的集合" class="headerlink" title="9.7 遗留的集合"></a>9.7 遗留的集合</h2><h3 id="9-7-1-Hashtable类"><a href="#9-7-1-Hashtable类" class="headerlink" title="9.7.1 Hashtable类"></a>9.7.1 Hashtable类</h3><p>经典的Hashtable类与HashMap类的作用一样，实际上，接口也基本相同。与Vector类的方法一样，Hashtable方法也是同步的。如果对与遗留代码的兼容性没有任何要求，就应该使用HashMap。如果需要并发访问，则要使用ConcurrentHashMap。</p>
<h3 id="9-7-2-枚举"><a href="#9-7-2-枚举" class="headerlink" title="9.7.2 枚举"></a>9.7.2 枚举</h3><p>遗留的集合使用Enumeration接口遍历元素序列。Enumeration接口有两个方法，即hasMoreElements和nextElement。这两个方法完全类似于Iterator接口的hasNext方法和next方法。</p>
<p>如果发现遗留的类实现了这个接口，可以使用Collections.list将元素收集到一个ArrayList中。例如，LogManager类只是将登录者的名字提供为一个Enumeration。可以如下得到所有登录者的名字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; loggerNames = Collections.list(LogManager.getLoggerNames());</span><br></pre></td></tr></table></figure>

<p>或者，在Java9中，可以把一个枚举转换为一个迭代器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LogManager.getLoggerNames().asIterator().forEachRemaining(n -&gt; &#123;...&#125;);</span><br></pre></td></tr></table></figure>

<p>有时还会遇到遗留的方法希望得到的枚举参数。静态方法Collections.enumeration将产生一个枚举对象，枚举集合中的元素。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;InputStream&gt; steams = ...;</span><br><span class="line">SequenceInputStream in = <span class="keyword">new</span> SequenceInputStream(Collections.enumeration(steams));</span><br></pre></td></tr></table></figure>

<h3 id="9-7-3-属性映射"><a href="#9-7-3-属性映射" class="headerlink" title="9.7.3 属性映射"></a>9.7.3 属性映射</h3><p>属性映射(property map)是一个特殊类型的映射结构。他又下面3个特性：</p>
<ul>
<li>键与值都是字符串</li>
<li>这个映射可以很容易地保存到文件以及从文件加载。</li>
<li>有一个二级表存放默认值</li>
</ul>
<p>实现属性映射的Java平台类名为Properties。属性映射对于指定程序的配置选项很有用。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties settings = <span class="keyword">new</span> Properties();</span><br><span class="line">settings.setProprety(<span class="string">&quot;width&quot;</span>,<span class="string">&quot;600.0&quot;</span>);</span><br><span class="line">settings.setProprety(<span class="string">&quot;filename&quot;</span>,<span class="string">&quot;/home/cay/cj11/code/v1ch11/raven.html&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以使用store方法将属性映射列表保存到一个文件中。在这里，我们将属性映射保存在文件program.properties中。第二个参数是包含在这个文件中的注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutStream out = <span class="keyword">new</span> FileOutStream(<span class="string">&quot;program.properties&quot;</span>);</span><br><span class="line">settings.store(out,<span class="string">&quot;Program Properties&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="9-7-4-栈"><a href="#9-7-4-栈" class="headerlink" title="9.7.4 栈"></a>9.7.4 栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">push</span><span class="params">(E item)</span><span class="comment">//将item压入栈并返回item</span></span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span><span class="comment">// 弹出并返回栈顶的item。如果栈为空，不要调用这个方法</span></span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span><span class="comment">//返回栈顶元素，但不弹出。如果栈为空，不要调用这个方法</span></span></span><br></pre></td></tr></table></figure>

<h3 id="9-7-5-位集"><a href="#9-7-5-位集" class="headerlink" title="9.7.5 位集"></a>9.7.5 位集</h3><p>Jav平台的BitSet类用于存储一个位序列。如果需要高效地存储位序列，就可以使用位集。由于位集将位包装在字节里，所以使用位集要比使用Boolean对象的ArrayList高效得多。</p>
<p>BitSet类提供了一个便于读取、设置或重置各个位得接口。使用这个接口可以避免掩码和其他调整位的操作，如果将位存储在int或long变量中就必须做这些繁琐的操作。</p>
<p>例如，对于一个名为bucketOfBits的BitSet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bucketOfBits.get(i)</span><br></pre></td></tr></table></figure>

<p>如果第i位处于“开”状态，就返回true；否则返回flase。类似地</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bucketOfBits.set(i)</span><br></pre></td></tr></table></figure>

<p>将第i位置为“开”状态。最后，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bucketOfBits.clear(i)</span><br></pre></td></tr></table></figure>

<p>将第i位置为“关”状态。</p>
<p>作为位集应用的一个示例，这里给出一个“埃拉托色尼筛选法”算法的实现，这个算法用来查找素数。这并不是查找素数的一种非常好的方法，但是由于某些原因，它已经成为测试编译器性能的一种流行的基准。</p>
<p>这个程序将计算2~2000000之间的所有素数。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sieve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sieve</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">2000000</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        BitSet bitSet = <span class="keyword">new</span> BitSet(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">            bitSet.set(i);</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i * i &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitSet.get(i))</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">2</span>* i;</span><br><span class="line">                <span class="keyword">while</span> (k &lt;= n)</span><br><span class="line">                &#123;</span><br><span class="line">                    bitSet.clear(k);</span><br><span class="line">                    k += i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitSet.get(i)) count++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(count+<span class="string">&quot;primes&quot;</span>);</span><br><span class="line">        System.out.println((end - start) + <span class="string">&quot; milliseconds&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 接口、lambda表达式与内部类</title>
    <url>/2020/10/27/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第六章-接口、lambda表达式与内部类"><a href="#第六章-接口、lambda表达式与内部类" class="headerlink" title="第六章 接口、lambda表达式与内部类"></a>第六章 接口、lambda表达式与内部类</h1><p>到目前为止，你已经学习了Java中面向对象编程的核心思想：类和继承。本章将介绍几种常用的高级技术。尽管这些内容可能不太容易理解，但一定要掌握，以完善你的Java工具箱。首先介绍第一种技术，即接口(interface)，接口用来描述类应该做什么，而不指定他们具体应该如何做。一个类可是实现(implement)一个接口或多个接口。有些情况可能要求符合这些接口，只要有这种要求，就可以实现了这个接口的类(及实现类)的对象。了解接口以后，再继续介绍lambda表达式，这是一种很简洁的方法，用来创建可以在将来某个时间点执行的代码块。通过使用lambda表达式，可以用一种精巧而简洁的方式表示使用回调或可变行为的代码。</p>
<p>接下来，我们将讨论内部类(inner class)机制。理论上讲，内部类有些复杂，内部类定义在另外一个类的内部，它们的方法可以访问包含它们的外部类的字段。内部类技术在设计具有相互协作关系的类集合时很有用。</p>
<p>在本章的最后还将介绍代理(proxy)，这是一种实现任意接口的对象。代理是一种非常专业的构造工具，可以用来构建系统级的工具。第一次阅读本书时可以先跳过那一节。</p>
<h2 id="6-1-接口"><a href="#6-1-接口" class="headerlink" title="6.1 接口"></a>6.1 接口</h2><h3 id="6-1-1-接口的概念"><a href="#6-1-1-接口的概念" class="headerlink" title="6.1.1 接口的概念"></a>6.1.1 接口的概念</h3><p>在Java程序设计语言中，接口不是类，而是对希望符合这个接口的类的一组需求。</p>
<p>我们经常听到服务提供商这样说：“如果你的类符合某个特定接口，我们就会履行这项服务。”下面给出一个具体示例。Array类中的sort方法承诺可以对对象数组进行排序，但要求满足下面这个条件：对象所属的类实现Comparable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这说明，任何实现Comparable接口的类都需要包含compapreTo方法，这个方法有一个Object参数，并且返回一个整数。</p>
<p>接口中的所有方法都是自动public方法。因此，在接口中声明方法时，不必提供关键字public。</p>
<p>当然，这个接口还有一个没有明确说明的附加要求：在调用x.compareTo(y)的时候，这个compareTo方法必须确实能够比较两个对象，并返回比较结果，即x和y哪一个更大 。当x小于y时返回一个负数；当x等于y时，返回0；否则返回一个正数。</p>
<p>上面这个接口只有一个方法，而有些接口可能包含多个方法。稍后可以看到，接口还可以定义常量。不过，更重要的是要知道接口不能提供什么。接口绝不会有实例字段，在Java8之前，接口绝对不会实现方法。</p>
<p>提供实例字段和方法实现的任务应该由实现接口的那个类来完成。因此，可以将接口看成是没有实例字段的抽象类。但是这两个概念还是有一定区别的，稍后将会给出i详细的解释。</p>
<p>现在，假设希望使用Arrays类的sort方法对Employee对象数组进行排序，Employee类就必须实现Comparable接口。</p>
 <span id="more"></span> 

<p>为了实现一个接口，通常需要完成下面两个步骤：</p>
<ul>
<li>将类声明为实现给定的接口；</li>
<li>对接口中的所有方法提供定义</li>
</ul>
<p>要将类声明为实现某个接口，需要使用关键字implements：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br></pre></td></tr></table></figure>

<p>当然，这里的Employee类需要提供compareTo方法。假设希望根据员工的薪水进行比较。以下是compareTo方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee other = (Employee) otherObject;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary,other.salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们使用了静态Double.compare方法。如果第一个参数小于第二个参数，它会返回一个负值；如果二者相等则返回0；否则返回一个正值。</p>
<p>我们可以做的更好一些，可以为泛型Comparable接口提供一个类型参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary,other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，对Object参数进行类型转换总是让人感觉不太顺眼，但现在已经不见了。</p>
<p>现在，我们已经看到，要让一个类使用排序服务必须让它实现compareTo方法。这是理所当然的，因为要向sort方法提供对象的比较方式。但是为什么不能在Employee类中直接提供一个compareTo方法，而必须实现Compareble接口呢？</p>
<p>主要在于Java程序设计语言是一种强类型(strongly typed)语言。在调用方法的时候，编译器要能检查这个方法确实存在。在sort方法中可能会有下面这样的语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i].compareTo(a[j]) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器必须确认a[i]一定有一个compareTo方法。如果a是一个Comparable对象的数组，就可以确保拥有compareTo方法，因为每个实现Comparable接口的类都必须提供这个方法的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.interfaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeSortTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        staff[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Harry hacker&quot;</span>,<span class="number">35000</span>);</span><br><span class="line">        staff[<span class="number">1</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Carl Cracker&quot;</span>,<span class="number">75000</span>);</span><br><span class="line">        staff[<span class="number">2</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Tony Tester&quot;</span>,<span class="number">38000</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(staff);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : staff)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name =&quot;</span> + e.getName() + <span class="string">&quot;,salary = &quot;</span> + e.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.interfaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise =  <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.salary,other.salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何定义一个接口的格式：public interface 接口名字{ // 接口内容} 【备注：换成关键字interface之后，编译生成的字节码文件仍然是.java –&gt; .class】</p>
<h3 id="6-1-2-接口的属性"><a href="#6-1-2-接口的属性" class="headerlink" title="6.1.2 接口的属性"></a>6.1.2 接口的属性</h3><p>接口不是类。具体来说，不能使用new运算符实例化一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="keyword">new</span> Comparable(...);<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>不过，尽管不能构造接口的对象，却能声明接口的变量:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparable x;<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>

<p>接口变量必须引用实现了这个接口的类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="keyword">new</span> Employee(...);<span class="comment">//OK provided Employee inplements Compaprable</span></span><br></pre></td></tr></table></figure>

<p>接下来，如同使用instanceof检查一个对象是否属于某个特定类一样，也可以使用instanceof检查一个对象是否实现了某个特定的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> Comparable)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>与建立类的继承层次一样，也可以扩展接口。这里允许有多条接口链，从通用性较高的接口扩展到专用性较高的接口。例如，假设有一个名为Moveable的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，可以假设一个名为Powered的接口扩展了以上Moveable的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Powered</span> <span class="keyword">extends</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">milesPerGallon</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然在接口中不能包含实例字段，但是可以包含常量。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Powered</span> <span class="keyword">extends</span> <span class="title">Moveable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">milesPerGallon</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">double</span> SPEED_LIMIT = <span class="number">95</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与接口中的方法都自动被设置为public一样，接口中的字段总是public static final。</p>
<p>有些接口只定义常量，而没有定义方法。例如，标准库中的SwingConstants就是这样一个接口，其中只包含NORTH、SOUTH、HORIZONTAL等常量。任何实现SwingConstants接口的类都自动地继承了这些常量，并可以在方法中直接地引用NORTH，而不必采用SwingConstants.NORTH这样繁琐的书写形式。不过，这样使用接口更像是退化，所以我们建议最好不要这样使用。</p>
<p>尽管每个类只能有一个超类，但却可以实现多个接口。这就定义类的行为提供了极大的灵活性。例如，Java程序设计语言有一个非常重要的的内置接口，名为Cloneable。如果某个类实现了这个Cloneable接口，Object类中的clone方法就可以创建你的类对象的一个标准副本。如果希望自己设计的类拥有克隆和比较的能力，只要实现这两个接口就可以了。可以使用逗号将想要实现的各个接口分隔开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Comparable</span></span></span><br></pre></td></tr></table></figure>

<p>接口当中的常量：必须使用public static final三个关键字进行修饰。</p>
<p>格式：public static final 数据类型 常量名称 = 数据值；</p>
<p>注意事项：</p>
<p>1.接口中的常量，可以省略public static final；</p>
<p>2.接口中的常量，必须进行赋值：不能不赋值;</p>
<p>3.接口一种常量的名称，使用完全大写的字母，用下划线进行分隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceConst</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_OF = <span class="number">10</span>;<span class="comment">//一旦使用final关键字进行修饰，说明不可变</span></span><br><span class="line">    Syestem.out.println(MyInterfaceConst.NUM_OF);<span class="comment">//常量的调用，接口名.常量名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果是java7，那么接口中可以包含的内容有：1.常量；2.抽象方法；</p>
<p>如果是java8，还可以额外包含有：3.默认方法；4.静态方法；</p>
<p>如果是java9，还可以额外包含有：5.私有方法</p>
<h3 id="6-1-3-接口与抽象类"><a href="#6-1-3-接口与抽象类" class="headerlink" title="6.1.3 接口与抽象类"></a>6.1.3 接口与抽象类</h3><p>如果阅读了第五章中有关抽象类的那一节，那就可能会产生这样一个疑问：为什么Java程序设计语言的设计者要那么麻烦地接口概念呢？为什么不将Comparable直接设计成一个抽象类呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Comparable</span>//<span class="title">why</span> <span class="title">NOT</span>?</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，Employee类只要需要扩展这个抽象类，并提供compareTo方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="title">enxteds</span> <span class="title">Comparable</span>//<span class="title">why</span> <span class="title">NOT</span>?</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常遗憾，使用抽象类表示通用属性存在一个严重的问题。每个类只能扩展一个类。假如设Employee类已经扩展了另外一个类，例如Person，他就不能再扩展第二个类了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="title">entends</span> <span class="title">Person</span>, <span class="title">Comparable</span>//<span class="title">ERROR</span></span></span><br></pre></td></tr></table></figure>

<p>但每个类可以实现多个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>//<span class="title">OK</span></span></span><br></pre></td></tr></table></figure>

<p>有些程序设计语言(C++)允许一个类有多个超类。我们将这个特性称为多重继承(multiple inheritance)。Java的设计者选择了不支持多重继承，其主要原因是多重继承会让语言变得非常复杂（C++），或者效率会降低(Eiffel)。实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<p>在任何版本的java中，接口都能定义为抽象方法：</p>
<p>public abstract 返回类型 方法名称(参数列表)；</p>
<p>注意事项：</p>
<p>1.接口当中的抽象方法，修饰符必须是两个固定的关键字public abstract;</p>
<p>2.这两个关键字修饰符可以省略;</p>
<p>3.方法的三要素，可以随意定义；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceAbstract</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodAbs4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的使用步骤：</p>
<ul>
<li>接口不能直接使用，必须有一个实现类来实现该接口【格式：】public class 实现类名称 implemetns 接口名称{…}</li>
<li>接口的实现类必须覆盖重写接口中所有的抽象方法。去掉abstract关键字，加上方法体大括号</li>
<li>创建实现类的对象，进行使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceAbstractImpl</span> <span class="keyword">implements</span> <span class="title">MyInterfaceAbstract</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;这是第一个方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是第二个方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是第三个方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是第四个方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyInterfaceAbstractImpl impl = <span class="keyword">new</span> MyInterfaceAbstractImpl();</span><br><span class="line">        impl.methodAbs1();</span><br><span class="line">        impl.methodAbs2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。</p>
<h3 id="6-1-4-静态和私有方法"><a href="#6-1-4-静态和私有方法" class="headerlink" title="6.1.4 静态和私有方法"></a>6.1.4 静态和私有方法</h3><p>在Java8中，允许在接口中增加静态方法。理论上讲，没有任何理由认为这是不合法的。只是这有违归于将接口作为抽象规范的初衷。</p>
<p>目前为止，通常的做法都是将静态方法放在伴随类中。在标准库中，你会看到成对出现的接口和实用工具，如Collection/Collections或Path/Paths。</p>
<p>可以由一个URI或者字符串序列构造一个文件或目录的路径，如Paths.get(“jdk-11”,“conf”,”security”)。在java11中，Path接口提供了等价的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Path</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">of</span> <span class="params">(URI uri)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">of</span><span class="params">(String first, String...more)</span></span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，Paths类就不再是必要的了。</p>
<p>类似地，实现你自己的接口时，没有理由再为实用工具方法另外提供一个伴随类。</p>
<p>在Java9中，接口中的方法可以是private。private方法可以是静态方法或实例方法。由于私有方法只能在接口本身的方法中使用，所以它们的用法很有限，只能作为接口中其他方法的辅助方法。</p>
<p>接口的静态方法：</p>
<p>从java8开始，接口当中允许定义静态方法：</p>
<p>【格式：】public static 返回值类型 方法名称(参数列表)</p>
<p>提示：就是将abstract或者default换成static即可，带上方法体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceStatic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是接口的静态方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceStaticImpl</span> <span class="keyword">implements</span> <span class="title">MyInterfaceStatic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不能通过接口实现类的对象来调用接口当中的静态方法。</p>
<p>正确用法：通过接口名称直接调用静态方法。【格式：】接口名.静态方法名(参数)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Interface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyInterfaceStaticImpl impl = <span class="keyword">new</span> MyInterfaceStaticImpl();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//错误写法：impl.methodStatic();</span></span><br><span class="line">        MyInterfaceStatic.methodStatic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的私有方法：</p>
<p>我们需要抽取一个公有方法，用来解决两个默认方法之间重复代码的问题。但这个公有方法不应该让实现类使用，应该是私有化的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfacePrivateA</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认方法1&quot;</span>);</span><br><span class="line">        methodCommon();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认方法2&quot;</span>);</span><br><span class="line">        methodCommon();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodCommon</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;CCC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfacePrivateB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodDefault1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认方法1&quot;</span>);</span><br><span class="line">        methodCommon();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodDefault2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认方法2&quot;</span>);</span><br><span class="line">        methodCommon();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodCommon</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;CCC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从java9开始，接口当中允许定义私有方法：</p>
<ul>
<li>普通私有方法，解决多个默认方法之间重复代码问题；【格式：】private 返回值类型 方法名称(参数列表){方法体}</li>
<li>静态私有方法，解决多个静态方法之间重复代码问题。【格式：】private static 返回值类型 方法名称(参数列表){方法体}</li>
</ul>
<h3 id="6-1-5-默认方法"><a href="#6-1-5-默认方法" class="headerlink" title="6.1.5 默认方法"></a>6.1.5 默认方法</h3><p>可以为接口方法提供一个默认实现。必须使用default修饰符标记这样一个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这并没有太大用处，因为Comparable的每一个具体实现都会覆盖这个方法。不过有些情况下，默认方法可能很有用。例如，在第九章会看到一个Iterator接口，用于访问一个数据结构中的元素。这个接口声明了remove方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你要实现一个迭代器，就需要提供hasNext和next方法。这些方法没有默认实现——它们依赖于你要遍历访问的数据结构。不过，如果你的迭代器是只读的，就不用操心实现remove方法。</p>
<p>默认方法可以调用其他方法。例如，Collection接口可以定义一个便利方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">boolean</span> isEmpty</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样实现Collection的程序员就不再操心实现isEmpty方法了。</p>
<p>默认方法的一个重要用法是“接口演化”(interface evolution)。以Collection为例。这个接口作为Java的一部分已经有很多年了。假设很久以前你提供了这样一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span> <span class="keyword">implements</span> <span class="title">Colloction</span></span></span><br></pre></td></tr></table></figure>

<p>后来，在java8中，又为这个接口增加了Stream方法。</p>
<p>假设Stream方法不是一个默认方法，那么Bag类将不能编译，因为它没有实现这个新方法。为接口增加一个非默认方法不能保证“源代码兼容”(source compatible)。不过，假设不重新编译这个类，而只是使用原先的一个包含这个类的JAR文件。这个类仍能正常加载，尽管没有这个新方法。程序仍然可以正常构造Bag实例，不会有意外发生。不过，如果程序在一个Bag实例上调用stream，就会出现一个AbstractMethodError。</p>
<p>将方法实现为一个默认(default)方法就可以解决这两个问题。Bag类又能正常编译了。另外如果没有重新编译而直接加载这个类，并在一个Bag实例上调用stream方法，将调用Collection.stream。</p>
<p>从Java8开始，接口允许定义默认方法。【格式：】public default 返回值类型 方法名称(参数列表){方法体}</p>
<p>接口当中的默认方法，可以解决接口升级的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceDefault</span></span></span><br><span class="line"><span class="class"></span>&#123;	</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新添加一个抽象方法,正常情况下需要在类中覆盖重写这个抽象方法</span></span><br><span class="line">    <span class="comment">//public abstract void methodAbs2();</span></span><br><span class="line">    <span class="comment">//新添加的方法，改成默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是新添加的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceDefaultA</span> <span class="keyword">implements</span> <span class="title">MyInterfaceDefault</span></span></span><br><span class="line"><span class="class"></span>&#123;	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现了抽象方法AAA&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceDefaultB</span> <span class="keyword">implements</span> <span class="title">MyInterfaceDefault</span></span></span><br><span class="line"><span class="class"></span>&#123;	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现了抽象方法BBB&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;	</span><br><span class="line">        <span class="comment">//创建类对象</span></span><br><span class="line">        MyInterfaceDefaultA a = <span class="keyword">new</span> MyInterfaceDefaultA();</span><br><span class="line">        a.methodAbs();<span class="comment">//调用抽象方法，实际运行的是右侧实现类</span></span><br><span class="line">        a.methodDefault();<span class="comment">//调用默认方法，如果实现类当中没有，会向上找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的默认方法，可以通过接口实现类对象，直接调用。</p>
<p>接口的默认方法，也可以被接口实现类进行覆盖重写。</p>
<p>接口的内容小结：</p>
<p>在java9+，接口的内容有：</p>
<p>1.成员变量其实是常量，【格式：[public] [static] [final] 常量名 = 数据值;】【注意：常量必须进行赋值，而且一旦赋值不能改变；常量名称完全大写，用下划线进行分隔】；</p>
<p>2.接口中最重要的就是抽象方法，【格式：[public] [abstract] 返回值类型 方法名称(参数列表);】【注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类】</p>
<p>3.从Java8+开始接口中允许定义默认方法，【格式：[public] default 返回值类型 方法名称(参数列表){方法体}】【注意：默认方法也可以被覆盖重写，若没覆盖，就用接口中的；若被覆盖，就用实现类的】</p>
<p>4.从Java8开始，接口中允许定义静态方法，【格式：[public] static 返回值类型 方法名称(参数列表){方法体}】【注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法】</p>
<p>5.从Java9开始，接口中允许定义私有方法，【格式：普通私有方法——private 返回值类型 方法名称(参数列表){方法体}；静态私有方法——private static 返回值类型 方法名称(参数列表){方法体}；【注意：private的方法只有接口自己才能调用，不能被实现类或别人使用。】</p>
<p>使用接口注意事项：</p>
<p>1.接口不能有静态代码块或构造方法；</p>
<p>2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。</p>
<p>3.如果实现类所实现的多个接口当中，存在重复的抽象类，那么只需要覆盖重写一次就行。</p>
<p>4.如果实现类没有覆盖所有接口当中的抽象方法，那么实现类就必须是一个抽象类。</p>
<p>5.如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写</p>
<p>6.一个类如果直接父类当中的方法，和接口当中的默认方法，产生了冲突，优先使用父类的方法</p>
<h3 id="6-1-6-解决默认方法冲突"><a href="#6-1-6-解决默认方法冲突" class="headerlink" title="6.1.6 解决默认方法冲突"></a>6.1.6 解决默认方法冲突</h3><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义同样的方法，会发生什么情况？Java的相应规则如下：</p>
<ul>
<li>1.超类优先。如果超类提供了一个具体方法，同名而且有相同参数的默认方法会被忽略。</li>
<li>2.接口冲突。如果一个接口提供一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法，必须覆盖这个方法来解决冲突。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;_&quot;</span> + hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有一个类同时实现了这两个接口会怎么样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Named</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类会继承Person和Named接口提供的两个不一致的getName方法。并不是从中选择一个，Java编译器会报告一个错误，让程序员来解决这个二义性问题。只需要在Student类中提供一个getName方法即可。在这个方法中，可以选择两个冲突方法中的一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Named</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Person.<span class="keyword">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设Named接口没有为getName提供默认实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Student类会从Person接口继续继承默认方法么？不过Java设计者更强调一致性。两个接口如何冲突并不重要。如果至少有一个接口提供了一个实现，编译器就会报告错误，程序员就必须解决这个二义性。</p>
<p>我们只讨论了两个接口的命名冲突。现在来考虑另外一种情况，一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法。例如，假设Person是一个类，Student定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Named</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，只会考虑超类方法，接口的所有默认方法都会被忽略。在我们的例子中，Student从Person继承了getName方法，Named接口是否为getName提供提供了默认实现并不会带来什么区别。这正是“类优先”规则。</p>
<p>“类优先”规则可以确保与Java7的兼容性。如果为一个接口增加默认方法，这对于有些默认方法之前能正常工作的代码不会有任何影响。</p>
<p>接口当中的继承:</p>
<p>1.类与类之间是单继承的.直接父类只能有一个</p>
<p>2.类与接口之间是多实现的。一个类可以实现多个接口</p>
<p>3.接口与接口之间是多继承的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> <span class="keyword">extends</span> <span class="title">MyInterfaceA</span>, <span class="title">MyInterfaceB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceA</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Common</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Common</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个子接口当中有几个方法？4个</p>
<p>注意事项：</p>
<p>1.多个父接口当中的抽象方法如果重复，没关系。</p>
<p>2.多个父接口当中的默认方法如果重复，有关系，那么子接口必须进行默认方法的覆盖重写，而且要带着default关键字。</p>
<p>接口多态的综合案例：进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘：</p>
<ul>
<li>USB接口，包含打开设备、关闭设备功能</li>
<li>笔记本类，包含开机功能、关机功能、使用USB设备功能</li>
<li>鼠标类，实现USB接口，并具备点击的方法</li>
<li>键盘类，实现USB接口，具备敲击的方法</li>
</ul>
<p><img src="/2020/10/27/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/image-20201022184531184.png" alt="image-20201022184531184"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.interfaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.interfaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">USB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开鼠标！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭鼠标！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标点击！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.interfaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span> <span class="keyword">implements</span> <span class="title">USB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开键盘！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭键盘！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;敲击键盘！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.interfaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laptop</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关机！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用USB设备的方法，使用接口作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDevice</span><span class="params">(USB usb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        usb.open();</span><br><span class="line">        <span class="keyword">if</span> (usb <span class="keyword">instanceof</span> Mouse)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Mouse) usb).click();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (usb <span class="keyword">instanceof</span> Keyboard)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Keyboard)usb).type();</span><br><span class="line">        &#125;</span><br><span class="line">        usb.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.interfaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaptopTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个笔记本</span></span><br><span class="line">        Laptop computer = <span class="keyword">new</span> Laptop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开机</span></span><br><span class="line">        computer.powerOn();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备一个鼠标，供电脑使用</span></span><br><span class="line">        Mouse mouse = <span class="keyword">new</span> Mouse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用鼠标</span></span><br><span class="line">        computer.useDevice(mouse);</span><br><span class="line">        <span class="comment">//使用键盘</span></span><br><span class="line">        Keyboard keyboard = <span class="keyword">new</span> Keyboard();</span><br><span class="line">        computer.useDevice(keyboard);</span><br><span class="line">        </span><br><span class="line">        computer.powerOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="6-1-7-接口与回调"><a href="#6-1-7-接口与回调" class="headerlink" title="6.1.7 接口与回调"></a>6.1.7 接口与回调</h3><p>回调(callback)是一种常见的程序设计模式。在这种模式中，可以指定某个特定事件发生时应该采取的动作。例如，按下鼠标或选择某个菜单项时，你可能希望完成某个特定的动作。不过，由于至此还没有介绍如何实现用户界面，所以只能讨论一种与此类似但更简单的情况。</p>
<p>在java.swing包中有一个Timer类，如果希望经过一定时间间隔就得到通知，Timer类就很有用。例如，假如程序中有一个时钟，可以请求每秒通知一次，以便更新时钟的表盘。</p>
<p>构造定时器时，需要设置一个时间间隔，并告诉定时器经过这个时间间隔时需要做些什么。</p>
<p>如何告诉定时器要做什么呢？在很多程序设计语言中，可以提供一个函数名，定时器要定期地调用这个函数。但是，Java标准类库中的采用的是面向对象方法。你可以向定时器传入某个类的对象，然后，定时器调用这个对象的方法。由于对象可以携带一些附加的信息，所以传递一个对象比传递一个函数要灵活的多。</p>
<h3 id="6-1-8-Comparator-接口"><a href="#6-1-8-Comparator-接口" class="headerlink" title="6.1.8 Comparator 接口"></a>6.1.8 Comparator 接口</h3><p>6.1.1节中，我们已经了解了如何对一个对象数组进行排序，前提是这些对象是实现了Comparable接口的类的实例。例如，可以对一个字符串数组进行排序，因为String类实现了Comparable&lt;String&gt;，而且String.compareTo方法可以按字典顺序比较字符串。</p>
<p>现在假设我们希望按长度递增的顺序对字符串进行排序，而不是按字典顺序进行排序。肯定不能让String类用两种不同的方式实现compareTo方法——更何况，String类也不应由我们来修改。</p>
<p>要处理这种情况，Arrays.sort方法还有第二个版本，有一个数组和一个比较器（comparator）作为参数，比较器是实现了Comparator接口的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T first, T second)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要按长度比较字符串，可以如下定义一个实现Comparator&lt;String&gt;的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first, String second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体完成比较时，需要建立一个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LengthComparator comp = <span class="keyword">new</span> LengthComparator();</span><br><span class="line"><span class="keyword">if</span>(comp.compare(words[i],words[j]) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这个调用与word[i].compareTo(words[j])进行比较。这个compare方法要在比较器对象上调用，而不是在字符串本身上调用。</p>
<p>要对一个数组排序，需要为Arrays.sort方法传入一个LengthComparator对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] friends = &#123;<span class="string">&quot;Peter&quot;</span>,<span class="string">&quot;Paul&quot;</span>,<span class="string">&quot;Mary&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(friends, <span class="keyword">new</span> LengthComparator());</span><br></pre></td></tr></table></figure>

<p>现在这个数组可能是[“Paul”,”Mary”,”Peter”]或[“Mary”,”Paul”,”Peter”]。</p>
<h3 id="6-1-9-对象克隆"><a href="#6-1-9-对象克隆" class="headerlink" title="6.1.9 对象克隆"></a>6.1.9 对象克隆</h3><p>本节我们会讨论Cloneable接口，这个接口指示一个类提供了一个安全的clone方法。由于克隆并不太常见，而且有关的细节技术性很强，你可能只是想稍做了解，等真正需要时再深入学习。</p>
<p>要了解克隆的具体含义，先来回忆为一个包含对象引用的变量建立副本时会发生什么。原变量和副本都是同一对象的引用。这说明，任何一个变量改变都会影响另一个变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee original = <span class="keyword">new</span> Employee(<span class="string">&quot;John Public&quot;</span>,<span class="number">50000</span>);</span><br><span class="line">Employee copy = original;</span><br><span class="line">copy.raiseSalary(<span class="number">10</span>);<span class="comment">//oops- -also changed original</span></span><br></pre></td></tr></table></figure>

<p>如果希望copy是一个新对象，它的初始状态与original相同，但是之后它们各自会有自己不同的状态，这种情况下就要使用clone方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee copy = original.clone();</span><br><span class="line">copy.raiseSalary(<span class="number">10</span>);<span class="comment">//OK- -original unchanged</span></span><br></pre></td></tr></table></figure>

<p>不过并没有这么简单。clone方法是Object的一个protected方法，这说明你的代码不能直接调用这个方法。只有Employee类可以克隆Employee对象。这个限制是有原因的。想想看Object类如何实现clone。它对于这个对象一无所知，所以只能逐个字段地进行拷贝。如果对象中所有数据字段都是数值或其他基本类型，拷贝这些字段没有任何问题。但是如果对象包含子对象的引用，拷贝字段就会得到相同子对象的引用，拷贝字段就会得到相同子对象的另一个引用，这样一来，原对象和克隆的对象仍然会共享一些信息。</p>
<p>默认的克隆操作是“浅拷贝”，并没有克隆对象中的引用的其他对象。浅拷贝会有什么影响？这要看具体影响？这要看具体情况。如果原来对象和浅克隆对象共享的子对象是不可变的，那么这种共享就是安全的。如果子对象属于一个不可变列的类，如String，就是这种情况。或者在对象的生命周期中，子对象一直包含不变的常量，没有更改器方法会改变它，也没有方法会生成它，这种情况下同样是安全的。</p>
<p>不过，通常子对象都是可变的，必须重新定义clone方法来建立一个深拷贝(deep copy)，同时克隆所有子对象。在这个例子中，hireDay字段是一个Date，这是可变的，所以它必须克隆。</p>
<p>对于每个类，需要确定：</p>
<ul>
<li>默认的clone方法是否满足要求；</li>
<li>是否可以在可变的子对象上调用clone来修补默认的clone方法；</li>
<li>是否不该使用clone；</li>
</ul>
<p>实际上第三个选项是默认选项。如果选择第一项或第二项，类必须：</p>
<ul>
<li>实现Cloneable接口；</li>
<li>重新定义clone方法，并指定public访问修饰符</li>
</ul>
<p>在这里，Cloneable接口的出现与接口的正常使用并没有关系。具体来说，他并没有指定clone方法，这个是从Object类继承的。这个接口只是作为一个标记，指示类设计者了解克隆过程。对象对于克隆很“偏执”，如果一个对象请求克隆，但是没有实现这个接口，就会产生一个检查型异常。</p>
<p>必须当心子类的克隆。例如，一旦Employee类定义了clone方法，任何人都可以用它来克隆Manager对象。Employee克隆方法能完成工作吗？这取决了Manager类的字段。在这里是没有问题的，因为bonus字段是基本类型。但Manager可能会有需要拷贝或不可克隆的字段。不能保证子类的实现者一定会修正clone方法让它正常工作。出于这个原因，在Object类中clone方法声明为protected。不过，如果你希望类用户调用clone，就不能这样做。</p>
<p>要不要在自己的类中实现clone呢？如果你的客户需要建立深拷贝，可能就需要实现这个方法。有些人认为应该完全避免使用clone，而实现另一个方法来达到同样的目的。clone相当笨拙，这一点我们也同意，不过如果让另一个方法来完成这个工作，还是会遇到同样的问题。毕竟，克隆没有你想象中那么常用。标准类中只有不到5%的类实现了clone。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.clone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.util.calendar.Gregorian;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee clone = (Employee)<span class="keyword">super</span>.clone();</span><br><span class="line"></span><br><span class="line">        clone.hireDay = (Date)hireDay.clone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHireDay</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Date newHireDay = <span class="keyword">new</span> GregorianCalendar(year,month - <span class="number">1</span>, day).getTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.hireDay.setTime(newHireDay.getTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee[name=&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;,salary=&quot;</span> + <span class="keyword">this</span>.salary + <span class="string">&quot;,hireDay=&quot;</span> + <span class="keyword">this</span>.hireDay + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.clone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee original = <span class="keyword">new</span> Employee(<span class="string">&quot;John Q. Public&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        original.setHireDay(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        Employee copy = original.clone();</span><br><span class="line">        copy.raiseSalary(<span class="number">10</span>);</span><br><span class="line">        copy.setHireDay(<span class="number">2002</span>,<span class="number">12</span>,<span class="number">31</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;original&quot;</span> + original);</span><br><span class="line">        System.out.println(<span class="string">&quot;copy&quot;</span> + copy);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-lambda-表达式"><a href="#6-2-lambda-表达式" class="headerlink" title="6.2 lambda 表达式"></a>6.2 lambda 表达式</h2><h3 id="6-2-1-为什么引入lambda表达式"><a href="#6-2-1-为什么引入lambda表达式" class="headerlink" title="6.2.1 为什么引入lambda表达式"></a>6.2.1 为什么引入lambda表达式</h3><p>lambda表达式是一个可传递的代码块，可以以后执行一次或多次。下面先退一步，观察一下我们在Java中的哪些地方用过这种代码块。</p>
<p>在6.1.4节中，你已经了解如何按指定时间间隔完成工作。将这个工作放在一个ActionListener的actionPerformed方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woker</span> <span class="keyword">implements</span> <span class="title">ActionListence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ationPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//do some work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要反复执行这个代码，可以构造Worker类的一个实例。然后把这个实例提交到一个Timer对象。</p>
<p>这里重点是actionPerformed方法包含希望以后执行的代码。</p>
<p>或者可以考虑如何使用一个定制比较器完成排序。如果想长度而不是默认的字典顺序对字符进行排序，可以向sort方法传入一个Comparator对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Stirng first, String second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.length - second,lentgh;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...;</span><br><span class="line">Arrays.sort(Strings, <span class="keyword">new</span> LengthComparator);</span><br></pre></td></tr></table></figure>

<p>compare方法不是立即调用。实际上，在数组完成排序之前，sort方法会一直调用compare方法，只要元素的顺序不正确就会重新排列元素。将比较元素所需的代码段放在sort方法中，这个代码将其余的排序逻辑集成(你可能不打算重新实现其余的这部分逻辑)。</p>
<p>这两个例子有一些共同点，都是讲一个代码块传递到某个对象。这个代码块会在将来某个时间调用。</p>
<p>到目前为止，在Java中传递一个代码段并不容易，你不能直接传递代码段。Java是一种面向对象语言，所以必须构造一个对象，这个对象的类需要有一个方法包含所需的代码。</p>
<h3 id="6-2-2-lambda-表达式的语法"><a href="#6-2-2-lambda-表达式的语法" class="headerlink" title="6.2.2 lambda 表达式的语法"></a>6.2.2 lambda 表达式的语法</h3><p>再来考虑上一节讨论的排序例子。我们传入代码来检查一个字符串是否比另一个字符串短。这里计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">first.length() - second.length();</span><br></pre></td></tr></table></figure>

<p>first和second是什么？他们都是字符串。Java是一种强类型语言，所以我们还要指定它们的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line"> -&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure>

<p>这就是你看到的第一个lambda表达式。lambda表达式就是一个代码块，以及必须传入代码的变量规范。</p>
<p>你已经见过java中的一种lambda表达式形式：参数，箭头(-&gt;)以及一个表达式。如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在{}中，并包含显示的的return语句。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String first, String second) -&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(first.length() &gt; second.length) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使lambda表达式没有参数，仍然要提供括号，就像无参数方法一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">100l</span> i &gt;= <span class="number">0</span>; i--) System.out.println(i);&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp</span><br><span class="line">    = (first, second)<span class="comment">//same as (String first, String second)</span></span><br><span class="line">    -&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure>

<p>在这里，编译器可以推导出first和second必然是字符串，因为这个lambda表达式将赋给一个字符串比较器。</p>
<p>如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActionListener listener = event -&gt;</span><br><span class="line">    System.out,println(<span class="string">&quot;The time is&quot;</span></span><br><span class="line">    + Instant.ofEpochMilli(event,getWhen()));</span><br></pre></td></tr></table></figure>

<p>无需指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。例如，下面的表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String first, String second) -&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure>

<p>可以在需要int类型结果的上下文中使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            String[] plants = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Mercury&quot;</span>,<span class="string">&quot;Venus&quot;</span>,<span class="string">&quot;Earth&quot;</span>,<span class="string">&quot;Mars&quot;</span>,<span class="string">&quot;Jupiter&quot;</span>,<span class="string">&quot;Saturn&quot;</span>,<span class="string">&quot;Uranus&quot;</span>,<span class="string">&quot;Neptune&quot;</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(plants));</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted in dictionary order&quot;</span>);</span><br><span class="line">        Arrays.sort(plants);</span><br><span class="line">        System.out.println(Arrays.toString(plants));</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted by length:&quot;</span>);</span><br><span class="line">        Arrays.sort(plants,(first,second)-&gt;first.length() - second.length());</span><br><span class="line">        System.out.println(Arrays.toString(plants));</span><br><span class="line"></span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer(<span class="number">1000</span>,e -&gt;</span><br><span class="line">                System.out.println(<span class="string">&quot;The time is&quot;</span> + <span class="keyword">new</span> Date()));</span><br><span class="line">        timer.start();</span><br><span class="line">        JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">&quot;Quit program?&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-3-函数式接口"><a href="#6-2-3-函数式接口" class="headerlink" title="6.2.3 函数式接口"></a>6.2.3 函数式接口</h3><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口(functional interface)。</p>
<p>为了展示如何转换为函数式接口，下面考虑Arrays.sort方法。它的第二个参数需要一个Cmparator实例，Comparator就是只有一个方法的接口，所以可以提供一个lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(words,(first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure>

<p>在底层，Arrays.sort方法会接受实现了&lt;Comparator&lt;String&gt;的某个类的对象。在这个对象上调用compare方法会执行这个lambda表达式的体。这些对象和类的管理完全取决于具体实现，与传统的内联类相比，这样可能要高效得多。最好把labmda表达式看作一个函数，而不是对象，另外要接受lambda表达式可以传递到函数式接口。</p>
<p>lambda表达式可以转换为接口，这一点让lambda表达式很有吸引力。具体的语法很简短。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer(<span class="number">1000</span>,e -&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;AT the tone, the time is&quot;</span> + Instant.ofEpochMilli(e.getWhen()));</span><br><span class="line">Toolkit.getDefaultTookit().beep();</span><br><span class="line">                        &#125;)</span><br></pre></td></tr></table></figure>

<p>与使用实现了ActionListener接口的类相比，这段代码的可读性要好得多。</p>
<p>实际上，在Java中，对lambda表达式所能做的也只是转化为函数式接口。在其他支持函数字面量的程序设计语言中，可以声明函数类型(如(String, String) -&gt; int)，声明这些类型的变量，还可以使用变量保存函数式表达式。不过，Java设计者还是决定保持我们熟悉的接口的概念，没有为Java语言增加函数类型。</p>
<p>Java API 在java.util.function包中定义了很多非常通用的函数式接口。其中一个接口BiFunction&lt;T,U,R&gt;描述了参数类型为T和U而且返回类型为R的函数。可以把我们的字符串比较lambda表达式保存在这个类型的变量中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiFunction&lt;String, String, Integer&gt;comp</span><br><span class="line">    = (first,second) -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure>

<h3 id="6-2-4-方法引用"><a href="#6-2-4-方法引用" class="headerlink" title="6.2.4 方法引用"></a>6.2.4 方法引用</h3><h3 id="6-2-5-构造器引用"><a href="#6-2-5-构造器引用" class="headerlink" title="6.2.5 构造器引用"></a>6.2.5 构造器引用</h3><h3 id="6-2-6-变量作用域"><a href="#6-2-6-变量作用域" class="headerlink" title="6.2.6 变量作用域"></a>6.2.6 变量作用域</h3><h3 id="6-2-7-处理lambda表达式"><a href="#6-2-7-处理lambda表达式" class="headerlink" title="6.2.7 处理lambda表达式"></a>6.2.7 处理lambda表达式</h3><h3 id="6-2-8-再谈Comparator"><a href="#6-2-8-再谈Comparator" class="headerlink" title="6.2.8 再谈Comparator"></a>6.2.8 再谈Comparator</h3><h2 id="6-3-内部类"><a href="#6-3-内部类" class="headerlink" title="6.3 内部类"></a>6.3 内部类</h2><p>内部类(inner class)是定义在另外一个类中的类。为什么需要使用内部类呢？主要有两个原因：</p>
<ul>
<li>内部类可以对同一个包中的其他类隐藏。</li>
<li>内部类方法可以访问这个类的作用域中的数据，包括原本私有数据。</li>
</ul>
<p>内部类原先对于简洁地实现回调非常重要。不过如今lambda表达式在这方面可以做得更好。但内部类对于构建代码还是很有用的。</p>
<p>内部类的分类：</p>
<p>1.成员内部类</p>
<p>2.局部内部类(包含匿名内部类)</p>
<h3 id="6-3-1-使用内部类访问对象状态"><a href="#6-3-1-使用内部类访问对象状态" class="headerlink" title="6.3.1 使用内部类访问对象状态"></a>6.3.1 使用内部类访问对象状态</h3><p>内部类的语法复杂。鉴于此情况，我们选择一个简单但不太实用的例子来说明内部类的使用。我们将重构TimerTest实例，抽象出一个TalkingClock类。构造一个语音时钟需要提供两个参数：发出通知的间隔和开关铃声的标志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interval;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> beep;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkingClock</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrint</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">// an inner class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的，这里的TimePrinter类位于TalkingClock类内部。这并不意味着每个TalkingClock都有一个TimePrinter实例字段。如前所示，TimePrinter对象是由Talkingclock类的方法构造的。</p>
<p>下面是TimePrinter类的详细内容。需要注意的一点，actionPerformed方法在发出铃声之前会检查beep标志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrint</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;At the tone, the time is&quot;</span> + Instant,ofEpochMilli(event.getWhen()));</span><br><span class="line">        <span class="keyword">if</span>(beep)</span><br><span class="line">        &#123;</span><br><span class="line">            Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>令人惊讶的事情发生了。TimePrinter类没有实例字段或者名为beep的变量，实际上，beep指示TalkingClock对象中创建这个TimePrinter的字段。可以看到，一个内部类方法可以访问自身的数据字段，也可以访问创建它的外围对象的数据字段。</p>
<p>为此，内部类的对象总有一个隐式引用，指向创建它的外部类对象。</p>
<p>这个引用在内部类的定义是不可见的。不过，为了说明这个概念，我们将外围类对象的引用称为outer。于是actionPerformed方法将等价于以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;At the tone,the time is&quot;</span> + Instant.ofEpochMilli(event.getWhen()));</span><br><span class="line">    <span class="keyword">if</span>(outer.beep)</span><br><span class="line">    &#123;</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外围类的引用在构造器中设置。编译器会修改所有内部类构造器，添加一个对应外围类引用的参数。因为TimePrinter类没有定义构造器，所有编译器为这个类生成了无参数构造器，生成的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TimePrinter</span><span class="params">(TalkingClock clock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outer = clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次强调，注意outer不是java关键字。我们只是用它说明内部类的有关机制。在start方法中构造了一个TimePrinter对象后，编译器就会将当前语音时钟的this引用传递给这个构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TimePrinter listener = <span class="keyword">new</span> TimePrinter(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.innerClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TalkingClock clock = <span class="keyword">new</span> TalkingClock(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        clock.start();</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">&quot;QUIT program?&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> interval;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> beep;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkingClock</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interval = interval;</span><br><span class="line">        <span class="keyword">this</span>.beep = beep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TimePrinter listener = <span class="keyword">new</span> TimePrinter();</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer(interval,listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;At the tone, the time is&quot;</span> + Instant.ofEpochMilli(event.getWhen()));</span><br><span class="line">            <span class="keyword">if</span> (beep)Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类的定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名称</span>&#123;</span><br><span class="line">	修饰符 <span class="class"><span class="keyword">class</span> 内部类名称</span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">	&#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-2-内部类的特殊语法规则"><a href="#6-3-2-内部类的特殊语法规则" class="headerlink" title="6.3.2 内部类的特殊语法规则"></a>6.3.2 内部类的特殊语法规则</h3><p>在上一节，我们解释了内部类有一个外围类的引用，我们把它叫做outer。事实上，使用外围类引用的正规语法还要复杂一些。表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.<span class="keyword">this</span></span><br></pre></td></tr></table></figure>

<p>表示外围类引用。例如，可以像下面这样编写TimePrinter内部类的actionPerformed方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">if</span>(TalkingClock.thi.beep) Toolkit.egtDefaultToolkit().beep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以采用以下语法更加明确的编写内部类对象的构造器：</p>
<p>outerObject.new.InnerClass(constrution parameters)</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActionListener listener = <span class="keyword">this</span>.<span class="function">new <span class="title">TimePrinter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">TalkingClock jabberer = <span class="keyword">new</span> TalkingClock(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br><span class="line">TalkingClock.TimePrinter listener = jabberer.n<span class="function">ew <span class="title">TimePrinter</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在外围类的作用于之外，可以这样引用内部类；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.InnerClass</span><br></pre></td></tr></table></figure>

<p>注意：内用外，随意访问；外用内，需要内部类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span>//外部类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span>//成员内部类</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span><span class="comment">//内部类的方法</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;心脏跳动！&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;我叫：&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodBody</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Heart().beat();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Body body = <span class="keyword">new</span> Body;<span class="comment">//外部类的对象</span></span><br><span class="line">        body.methodBody();<span class="comment">//通过外部类的对象，调用外部类的方法，里面间接使用了内部类Heart</span></span><br><span class="line">        </span><br><span class="line">        Body.Heart heart = <span class="keyword">new</span> Body().n<span class="function">ew <span class="title">hear</span><span class="params">()</span></span>;</span><br><span class="line">        heart.beat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用内部类？有两种方式：</p>
<p>1.间接方式：外部类的方法当中使用内部类；然后main只是调用外部类的方法。</p>
<p>2.直接方式：公式：外部类名称.内部类名称 对象名 = new 外部类名称().new内部类名称()；</p>
<p>内部类的同名变量访问：</p>
<p>如果出现了重名现象：外部类名称.this.外部类成员变量名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;<span class="comment">//外部类成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span>//</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>;<span class="comment">//内部类成员变量</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>;<span class="comment">//内部类方法的局部变量</span></span><br><span class="line">            System.out.println(num);<span class="comment">//30,局部变量，就近原则</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num);<span class="comment">//内部类的成员变量</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num);<span class="comment">//外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-3-内部类是否有用、必要和安全"><a href="#6-3-3-内部类是否有用、必要和安全" class="headerlink" title="6.3.3 内部类是否有用、必要和安全"></a>6.3.3 内部类是否有用、必要和安全</h3><p>不能否认，内部类的语法很有复杂。它与访问控制和安全性等其他语言特性没有明显的关联。</p>
<p>需要指出，内部类是一个编译器现象，与虚拟机无关。编译器将会把内部类转换为常规的类文件，用$(美元符号)分隔外部类名与内部类名，而虚拟机则对此一无所知。</p>
<p>例如，TalkingClock类内部的TimePrinter类被转换文件TalkingClock$TimePrinter.class。</p>
<h3 id="6-3-4-局部内部类"><a href="#6-3-4-局部内部类" class="headerlink" title="6.3.4 局部内部类"></a>6.3.4 局部内部类</h3><p>如果仔细查看TalkingClock示例的代码，就会发现，类型TimePrinter的名字只出现了一次：只是在start方法中创建这个类型的对象时使用一次。</p>
<p>当遇到这类情况时，可以在一个方法中局部地定义这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;At the tone, the time is&quot;</span> + Instant.ofEpochMilli(event,getWhen()));</span><br><span class="line">        <span class="keyword">if</span>(beep) Toolkit.getDefaultTookit().beep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明局部类时不能有访问修饰符(public ,private)。局部类的作用域被限定在声明这个局部类的块中。局部类有一个很大的优势，即对外部世界完全隐藏，甚至TalkingClock类中的其他代码也不能访问它。除start方法之外，没有任何方法知道TimePrinter类的存在。</p>
<p>局部内部类：</p>
<p>如果一个类定义在一个方法内部，那么就是一个局部内部类</p>
<p>局部：只有当前所属的方法才能使用它，出了这个方法外就不能使用了！</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    修饰符 返回值类型 外部方法名(参数列表)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> 局部内部类名称</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            ...;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                system.out.println(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.methodInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结一下类的权限修饰符：public &gt; protected&gt;(default)&gt;private</p>
<p>定义一个类的时候，权限修饰符的规则是：</p>
<p>1.外部类：public / (defalut)</p>
<p>2.成员内部类：public / protected / default / private</p>
<p>3.局部内部类：什么都不能写</p>
<p>使用内部类的final问题：</p>
<p>局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的。</p>
<p>从java8+开始，只要局部变量事实不变，那么final关键字可以省略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myouter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;<span class="comment">//final int num = 10;</span></span><br><span class="line">        num = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyInner</span></span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methoInner</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(num);<span class="comment">//错误了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-5-由外部方法访问变量"><a href="#6-3-5-由外部方法访问变量" class="headerlink" title="6.3.5 由外部方法访问变量"></a>6.3.5 由外部方法访问变量</h3><p>与其他内部类相比，局部类还有一个优点。它们不仅能够访问外部类的字段，话可以访问局部变量！不过，那些局部变量！不过，那些局部变量必须是事实最终变量(effectively final)。这说明，他们一旦赋值就绝不会改变。</p>
<p>下面是一个典型的示例。这里，将TalkingClock构造器的参数interval和beep移至start方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;At the tone, the time is&quot;</span> + Instant.ofEpochMilli(event.getWhen()));</span><br><span class="line">        <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TimePrinter listener =  <span class="keyword">new</span> TimePrinter();</span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer(interval,listener);</span><br><span class="line">    time.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，TalkingClock类不再需要存储实例变量beep；它只是引用start方法中的beep参数变量。</p>
<p>这看起来好像没什么值得大惊小怪的。代码行if(beep)…</p>
<p>毕竟最后会在start方法内部，为什么不能访问beep变量的值呢？</p>
<p>仔细考察这个控制流程：</p>
<ul>
<li>调用start方法</li>
<li>调用内部类TimePrinter的构造器，以便初始化对象变量listener</li>
<li>listener引用传递给Timer构造器，定时器开始计数，start方法退出。此时，start方法的beep参数变量不复存在</li>
<li>1秒后，actionPerformed方法执行if(beep)…</li>
</ul>
<h3 id="6-3-6-匿名内部类"><a href="#6-3-6-匿名内部类" class="headerlink" title="6.3.6 匿名内部类"></a>6.3.6 匿名内部类</h3><p>使用局部内部类时，通常还可以再进行一步。假如只想创建这个类的一个对象，甚至不需要为类指定名字。这样一个类被称为匿名内部类(anonymous inner class)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AcitionListenner listener = <span class="keyword">new</span> ActionListenner()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;At the tone, the time is&quot;</span> + Instant.ofEpochMilli(event.getWhen()));</span><br><span class="line">            <span class="keyword">if</span>(beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer(interval, listener);</span><br><span class="line">    timer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个语法确实晦涩难懂。它的含义是：创建一个类的新对象，这个类实现了ActionListenner接口，需要实现的方法actionPerformed在括号{}内定义。</p>
<p>一般地，语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SuperType(construction parameters)</span><br><span class="line">&#123;</span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">methods</span> <span class="title">and</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中，SuperType可以是接口，如ActionListenner，如果是这样，内部类就要实现这个接口。SuperType也可以是一个类，如果是这样，内部类就要扩展这个类。</p>
<p>由于构造器的名字必须与类名相同，而匿名类内没有类名，所以，匿名内部类不能有构造器。实际上，构造器参数要传给超类(superclass)构造器。具体地，只要内部类实现一个接口，就不能有任何构造参数。不过，仍然要提供一组小括号，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> InterfaceType()</span><br><span class="line">&#123;</span><br><span class="line">    methods and data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须仔细研究构造一个类的新对象与构造一个扩展了那个类的匿名内部类的对象之间有什么差别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person queen = <span class="keyword">new</span> Person(<span class="string">&quot;mary&quot;</span>);<span class="comment">// a Person object</span></span><br><span class="line">Person count = <span class="keyword">new</span> Person(<span class="string">&quot;Dracula&quot;</span>)<span class="comment">// an object of an inner class extending Person</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果构造参数列表的结束小括号后面跟一个开始打括号，就是在定义匿名内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.anonymousInner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerClassTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            TalkingClock clock = <span class="keyword">new</span> TalkingClock();</span><br><span class="line">            clock.start(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(<span class="keyword">null</span>,<span class="string">&quot;Quit program?&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ActionListener listener = <span class="keyword">new</span> ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + Instant.ofEpochMilli(event.getWhen()));</span><br><span class="line">                <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        javax.swing.Timer timer = <span class="keyword">new</span> javax.swing.Timer(interval,listener);</span><br><span class="line">        timer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类：</p>
<p>如果接口实现类只需要使用唯一的一次，那么这种情况下就可以省略该类的定义，而改为使用匿名内部类：</p>
<p>格式：</p>
<p>接口名 对象名 = new 接口名(){ 覆盖重写接口中的抽象方法};</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyInterface obj = <span class="keyword">new</span> MyInterface()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现了方法！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        obj.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用匿名内部类的注意事项：</p>
<p>对格式的解析：接口名 对象名 = new 接口名(){ 覆盖重写接口中的抽象方法};</p>
<p>1.new代表代表创建对象的动作；</p>
<p>2.接口名就是匿名内部类要实现的哪个接口</p>
<p>3.{…}匿名内部类的内容</p>
<p>注意的问题：</p>
<p>1.匿名内部类，在创建对象的时候，只能使用唯一的一次。如果希望多次创建对象，而且类的内容一样的话，那么必须使用单独定义的实现类了。</p>
<p>2.匿名对象，在调用方法的时候，只能调用唯一的一次。如果希望给同一个对象，调用多次方法，那么必须给对象一个名字。</p>
<p>3.匿名内部类是省略了【实现类/子类】，但匿名对象是省略了【对象名称】</p>
<h3 id="6-3-7-静态内部类"><a href="#6-3-7-静态内部类" class="headerlink" title="6.3.7 静态内部类"></a>6.3.7 静态内部类</h3><p>有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类有外围类对象的一个引用。为此，可以将内部类声明为static，这样就不会生成那个引用。下面是一个想要使用静态内部类的典型例子。考虑这样一个任务：计算数组中的最小值和最大值。当然，可以编写两个方法，一个方法用于计算最小，另一个方法用于计算最大。在调用这两个方法的时候，数组被遍历了两次。如果只遍历数组一次，并能同时计算出最大值和最小值，那么就可以大大地提高效率了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> min = Double.POSITIVE_INFINITY;</span><br><span class="line"><span class="keyword">double</span> max = Double.NEGATIVE_INFINITY;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> v : values)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(min &gt; v) min = v;</span><br><span class="line">    <span class="keyword">if</span>(max &lt; v) max = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这个方法必须返回两个数，为此，可以定一个包含两个值的类Pair：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> second;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">pair</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">double</span> second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>minman 方法可以返回一个Pair类型的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> pair <span class="title">minmax</span><span class="params">(<span class="keyword">double</span>[] values)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(min,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的调用者可以使用get方法获得答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair p = ArrayAlg.minmax(d);</span><br><span class="line">System.out.println(<span class="string">&quot;min = &quot;</span> + p.getFirst());</span><br><span class="line">System.out.println(<span class="string">&quot;max = &quot;</span> + p.getSecond());</span><br></pre></td></tr></table></figure>

<p>当然,Pair是一个十分大众化的名字。在大型项目中，其他程序员也很有可能使用这个名字，只不过可能会定义一个Pair类包含一对字符串。这样就会产生名字冲突，解决这个问题的办法是将Pair定义为ArrayAlg的一个公共内部类。此后可以通过ArrayAlg.pair访问它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayAlg.pair p = ArrayAlg.minmax(d);</span><br></pre></td></tr></table></figure>

<p>不过，与前面例子中所使用的内部类不同，在Pair对象中不需要任何其他对象的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，只有内部类可以声明为static。静态内部类就类似于其他内部类，只不过静态内部类的对象没有生成它的外围类引用的对象。在我们的实例中，必须使用静态内部类，这是由于内部类对象是在静态方法中构造的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">minmax</span><span class="params">(<span class="keyword">double</span>[] d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pair(min,max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有将Pair类声明为static，那么编译器将会报错，指出没有可用的隐式ArrayAlg类型对象来初始化内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.staticInnerClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] values = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            values[i] = <span class="number">100</span> * Math.random();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayAlg.Pair p = ArrayAlg.minmax(values);</span><br><span class="line">        System.out.println(<span class="string">&quot;min =&quot;</span> + p.getFirst());</span><br><span class="line">        System.out.println(<span class="string">&quot;max =&quot;</span> + p.getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> first;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> second;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">double</span> second)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">            <span class="keyword">this</span>.second = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">minmax</span><span class="params">(<span class="keyword">double</span>[] values)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> min = Double.POSITIVE_INFINITY;</span><br><span class="line">        <span class="keyword">double</span> max = Double.NEGATIVE_INFINITY;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> v : values)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &lt; min) min = v;</span><br><span class="line">            <span class="keyword">if</span> (v &gt; max) max = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(min,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-4-服务加载器"><a href="#6-4-服务加载器" class="headerlink" title="6.4 服务加载器"></a>6.4 服务加载器</h2><h2 id="6-5-代理"><a href="#6-5-代理" class="headerlink" title="6.5 代理"></a>6.5 代理</h2><h3 id="6-5-1-何时使用代理"><a href="#6-5-1-何时使用代理" class="headerlink" title="6.5.1 何时使用代理"></a>6.5.1 何时使用代理</h3><h3 id="6-5-2-创建代理对象"><a href="#6-5-2-创建代理对象" class="headerlink" title="6.5.2 创建代理对象"></a>6.5.2 创建代理对象</h3><h3 id="6-5-3-代理类的特性"><a href="#6-5-3-代理类的特性" class="headerlink" title="6.5.3 代理类的特性"></a>6.5.3 代理类的特性</h3>]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《On Java 8》--第六章 初始化和清理</title>
    <url>/2021/04/27/%E9%98%85%E8%AF%BB%E3%80%8AOn-Java-8%E3%80%8B-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>​    “不安全”的编程是造成编程代价昂贵的罪魁祸首之一。有两个安全性问题：初始化和清理。</p>
<p>​        Java采用了构造器的概念，另外还使用了垃圾收集器(Garbage Collector，GC)去自动回收不再被使用的对象所占的资源。这一章将讨论初始化和清理的问题，以及在Java中对它们的支持。</p>
 <span id="more"></span> 

<h2 id="利用构造器保证初始化"><a href="#利用构造器保证初始化" class="headerlink" title="利用构造器保证初始化"></a>利用构造器保证初始化</h2><p>​        在Java中，类的设计者通过构造器保证每个对象的初始化。如果一个类有构造器，那么Java会在用户使用对象之前自动调用对象的构造器方法，从而保证初始化。下一个挑战是如何命名构造器方法。在Java中使用了与C++同样的方式：构造器名称和类名相同。在初始化过程中自动调用构造器方法是有意义的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/SimpleConstructor.java</span></span><br><span class="line"><span class="comment">// Demonstration of a simple constructor</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock</span> </span>&#123;</span><br><span class="line">    Rock() &#123; <span class="comment">// 这是一个构造器</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Rock &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Rock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock </span></span><br></pre></td></tr></table></figure>

<p>​        现在，当创建一个对象时：new Rock()，内存被分配，构造器被调用。构造器保证了对象在你使用之前进行了正确的初始化。</p>
<p>​        有一点需要注意，构造器方法名与类名相同，不需要符合首字母小写的风格。</p>
<p>​        跟其他方法一样，构造器方法也可以传入参数来定义如何创建一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/SimpleConstructor2.java</span></span><br><span class="line"><span class="comment">// Constructors can have arguments</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rock2</span> </span>&#123;</span><br><span class="line">    Rock2(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Rock &quot;</span> + i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleConstructor2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Rock2(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Rock 0 Rock 1 Rock 2 Rock 3 Rock 4 Rock 5 Rock 6 Rock 7</span></span><br></pre></td></tr></table></figure>

<p>​        如果类Tree有一个构造方法，只接收一个参数用来表示树的高度，那么你可以像下面这样创建一棵树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tree t = <span class="keyword">new</span> Tree(<span class="number">12</span>); <span class="comment">// 12-foot 树</span></span><br></pre></td></tr></table></figure>

<p>​        如果Tree(int)是唯一的构造器，那么编译器就不允许你以其他任何方式创建Tree类型的对象。</p>
<p>​        构造器消除了一类重要的问题，使得代码更易读。例如：在上面的代码中，你看不到initialize()方法的显示调用，而从概念上来看，initialize()方法应该与对象的创建分离。在Java中，对象的创建和初始化对象是统一的概念，二者不可分割。</p>
<p>​        构造器没有返回值，它是一种特殊的方式。但它和返回类型为void的普通方法不同，普通方法可以返回空值，你还能选择让它返回别的类型；而构造器没有返回值，却同时也没有给你选择的余地(new表达式虽然返回了刚创建的对象的引用，但构造器本身却没有任何返回值)。如果它有返回值，并且你也可以自己选择让它返回什么，那么编译器就还得知道接下来该怎么处理那个返回值(这个返回值没有接收者)。</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>​        在Java中，还有一个因素也促成了必须使用方法重载：构造器。因为构造器方法肯定与类名相同，所以一个类中只有一个构造器名。那么你怎么通过不同的方式创建一个对象呢？例如，你想创建一个类，这个类的初始化有两种方式：一种是标准化方式，另一种是从文件中读取信息的方式。你需要两个构造器：无参构造器和有一个String类型参数的构造器，该参数传入文件名。两个构造器具有相同的名字——与类名相同。因此，方法重载是必要的，它允许方法具有相同的方法名但接收的参数不同。尽管方法重载对于构造器是重要的，但是也可以很方便对其他任何方法进行重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Overloading.java</span></span><br><span class="line"><span class="comment">// Both constructor and ordinary method overloading</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    Tree() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Planting a seedling&quot;</span>);</span><br><span class="line">        height = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree(<span class="keyword">int</span> initialHeight) &#123;</span><br><span class="line">        height = initialHeight;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating new Tree that is &quot;</span> + height + <span class="string">&quot; feet tall&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tree is &quot;</span> + height + <span class="string">&quot; feet tall&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s + <span class="string">&quot;: Tree is &quot;</span> + height + <span class="string">&quot; feet tall&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overloading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Tree t = <span class="keyword">new</span> Tree(i);</span><br><span class="line">            t.info();</span><br><span class="line">            t.info(<span class="string">&quot;overloaded method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Tree(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Creating new Tree that is 0 feet tall</span></span><br><span class="line"><span class="comment">//Tree is 0 feet tall</span></span><br><span class="line"><span class="comment">//overloaded method: Tree is 0 feet tall</span></span><br><span class="line"><span class="comment">//Creating new Tree that is 1 feet tall</span></span><br><span class="line"><span class="comment">//Tree is 1 feet tall</span></span><br><span class="line"><span class="comment">//overloaded method: Tree is 1 feet tall</span></span><br><span class="line"><span class="comment">//Creating new Tree that is 2 feet tall</span></span><br><span class="line"><span class="comment">//Tree is 2 feet tall</span></span><br><span class="line"><span class="comment">//overloaded method: Tree is 2 feet tall</span></span><br><span class="line"><span class="comment">//Creating new Tree that is 3 feet tall</span></span><br><span class="line"><span class="comment">//Tree is 3 feet tall</span></span><br><span class="line"><span class="comment">//overloaded method: Tree is 3 feet tall</span></span><br><span class="line"><span class="comment">//Creating new Tree that is 4 feet tall</span></span><br><span class="line"><span class="comment">//Tree is 4 feet tall</span></span><br><span class="line"><span class="comment">//overloaded method: Tree is 4 feet tall</span></span><br><span class="line"><span class="comment">//Planting a seedling</span></span><br></pre></td></tr></table></figure>

<h3 id="区分方法重载"><a href="#区分方法重载" class="headerlink" title="区分方法重载"></a>区分方法重载</h3><p>​        如果两个方法命名相同，Java是怎么知道你调用的是哪个呢？有一条简单的规则：每个被重载的方法必须有独一无二的参数列表。你甚至可以根据参数列表中的参数顺序来区分不同的方法，尽管这会造成代码难以维护：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OverloadingOrder.java</span></span><br><span class="line"><span class="comment">// Overloading based on the order of the arguments</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingOrder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;String: &quot;</span> + s + <span class="string">&quot;, int: &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int: &quot;</span> + i + <span class="string">&quot;, String: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="string">&quot;String first&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        f(<span class="number">99</span>, <span class="string">&quot;Int first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//String: String first, int: 1</span></span><br><span class="line"><span class="comment">//int: 99, String: Int first</span></span><br></pre></td></tr></table></figure>

<p>​        两个f()方法具有相同的参数，但是参数顺序不同，根据这个就可以区分它们。</p>
<h3 id="重载与基本类型"><a href="#重载与基本类型" class="headerlink" title="重载与基本类型"></a>重载与基本类型</h3><p>​        基本类型可以自动从较小的类型转型为较大的类型。当这与重载结合时，这会令人有点困惑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/PrimitiveOverloading.java</span></span><br><span class="line"><span class="comment">// Promotion of primitives and overloading</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveOverloading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(char)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(byte)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(short)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f1(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(byte)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(short)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f2(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f3(short)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f3(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f3(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f3(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f3(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f4(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f4(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f4(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f4(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f5(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f5(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f5(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f6(float)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f6</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f6(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f7</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;f7(double)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testConstVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;5: &quot;</span>);</span><br><span class="line">        f1(<span class="number">5</span>);f2(<span class="number">5</span>);f3(<span class="number">5</span>);f4(<span class="number">5</span>);f5(<span class="number">5</span>);f6(<span class="number">5</span>);f7(<span class="number">5</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> x = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;char: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;byte: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">short</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;short: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;int: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;long: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;float: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDouble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;double: &quot;</span>);</span><br><span class="line">        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrimitiveOverloading p = <span class="keyword">new</span> PrimitiveOverloading();</span><br><span class="line">        p.testConstVal();</span><br><span class="line">        p.testChar();</span><br><span class="line">        p.testByte();</span><br><span class="line">        p.testShort();</span><br><span class="line">        p.testInt();</span><br><span class="line">        p.testLong();</span><br><span class="line">        p.testFloat();</span><br><span class="line">        p.testDouble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5: f1(int)f2(int)f3(int)f4(int)f5(long)f6(float)f7(double)</span></span><br><span class="line"><span class="comment">//char: f1(char)f2(int)f3(int)f4(int)f5(long)f6(float)f7(double)</span></span><br><span class="line"><span class="comment">//byte: f1(byte)f2(byte)f3(short)f4(int)f5(long)f6(float)f7(double)</span></span><br><span class="line"><span class="comment">//short: f1(short)f2(short)f3(short)f4(int)f5(long)f6(float)f7(double)</span></span><br><span class="line"><span class="comment">//int: f1(int)f2(int)f3(int)f4(int)f5(long)f6(float)f7(double)</span></span><br><span class="line"><span class="comment">//long: f1(long)f2(long)f3(long)f4(long)f5(long)f6(float)f7(double)</span></span><br><span class="line"><span class="comment">//float: f1(float)f2(float)f3(float)f4(float)f5(float)f6(float)f7(double)</span></span><br><span class="line"><span class="comment">//double: f1(double)f2(double)f3(double)f4(double)f5(double)f6(double)f7(double)</span></span><br></pre></td></tr></table></figure>

<p>​        如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错。</p>
<h3 id="返回值重载"><a href="#返回值重载" class="headerlink" title="返回值重载"></a>返回值重载</h3><p>​        经常有人会困惑，“为什么只能通过方法名和参数列表，不能通过方法名和返回值区分方法呢？”。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>​        有些情况下，编译器很容易就可以从上下文准确推断出该调用哪个方法，如int x = f()。</p>
<p>​        但是，你可以调用一个方法且忽略返回值。这叫做调用一个函数的副作用，因为你不在乎返回值，只是想利用方法做些事。所以如果你直接调用f()，Java编译器就不知道你想调用哪个方法，阅读者也不明所以。因为这个原因，所以你不能根据返回值类型区分重载的方法。</p>
<h2 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h2><p>​        一个无参构造器就是不接收参数的构造器，用来创建一个“默认的对象”。如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/DefaultConstructor.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird bird = <span class="keyword">new</span> Bird(); <span class="comment">// 默认的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        表达式new Bird()创建了一个新对象，调用了无参构造器，尽管在Bird类中并没有显示的定义无参构造器。试想一下若果没有构造器，我们如何创建一个对象呢。但是，一旦你显示地定义了构造器(无论有参还是无参)，编译器就不会自动为你创建无参构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/NoSynthesis.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird2</span> </span>&#123;</span><br><span class="line">    Bird2(<span class="keyword">int</span> i) &#123;&#125;</span><br><span class="line">    Bird2(<span class="keyword">double</span> d) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSynthesis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- Bird2 b = new Bird2(); // No default</span></span><br><span class="line">        Bird2 b2 = <span class="keyword">new</span> Bird2(<span class="number">1</span>);</span><br><span class="line">        Bird2 b3 = <span class="keyword">new</span> Bird2(<span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果你调用了new Bird2()，编译器会提示找不到匹配的构造器。当类中没有构造器时，编译器会说“你一定需要构造器，那么让我为你创建一个吧”。但是如果类中有构造器，编译器会说“你已经写了构造器了，所以肯定知道你在做什么，如果你没有创建默认的构造器，说明你本来就不需要”。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>​        对于两个相同类型的对象a和b，你可能在想如何调用这两个对象的peel()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/BananaPeel.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">peel</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*...*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BananaPeel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Banana a = <span class="keyword">new</span> Banana(), b = <span class="keyword">new</span> Banana();</span><br><span class="line">        a.peel(<span class="number">1</span>);</span><br><span class="line">        b.peel(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果只有一个方法peel()，那么怎么知道调用的是对象a的peel()方法还是对象b的peel()方法呢？编译器做了一些底层工作，所以你可以像这样编写代码。peel()方法中第一个参数隐秘地传入了一个指向操作对象的引用，因此，上述例子中的方法调用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Banana.peel(a, <span class="number">1</span>)</span><br><span class="line">Banana.peel(b, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>​        这是在内部实现的，你不可以直接这么编写代码，编译器是不会接受，但能说明到地方生了什么。假设现在在方法内部，你想获得当前对象的引用。但是，对象引用是被秘密地传达给编译器——并不在参数列表中。方便的是，有一个关键字：this。this关键字只能在非静态方法内部使用。当你调用一个对象的方法时，this生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用该类的其他方法，不要使用this，直接调用即可，this自动地应用于其他方法上了。因此你可以像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Apricot.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apricot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pick();</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在pit()方法中，你可以使用this.pick()，但是没有必要。编译器自动为你做了这些。this关键字只用在一些必须显式使用当前对象引用的特殊场合。例如，用在return语句中返回当前对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Leaf.java</span></span><br><span class="line"><span class="comment">// Simple use of the &quot;this&quot; keyword</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Leaf <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Leaf x = <span class="keyword">new</span> Leaf();</span><br><span class="line">        x.increment().increment().increment().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i = 3</span></span><br></pre></td></tr></table></figure>

<p>​        因为increment()通过this关键字返回当前对象的引用，因此在相同的对象上可以轻易地执行多次操作。</p>
<p>​        this关键字在向其他方法传递当前对象时也很有用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/PassingThis.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        Apple peeled = apple.getPeeled();</span><br><span class="line">        System.out.println(<span class="string">&quot;Yummy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Peeler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Apple <span class="title">peel</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... remove peel</span></span><br><span class="line">        <span class="keyword">return</span> apple; <span class="comment">// Peeled</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="function">Apple <span class="title">getPeeled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Peeler.peel(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassingThis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person().eat(<span class="keyword">new</span> Apple());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Yummy</span></span><br></pre></td></tr></table></figure>

<p>​        Apple因为某些原因，必须调用一个外部工具方法Peeler.peel()做一些行为。必须使用this才能将自身传递给外部方法。</p>
<h3 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h3><p>​        当你在一个类中写了多个构造器，有时你想在一个构造器中调用另一个构造器来避免代码重复。你通过this关键字实现这样的调用。</p>
<p>​        通常当你说this，意味着“这个对象”或“当前对象”，它本身生成对当前对象的引用。在一个构造器中，当你给this一个参数列表时，它是另一层意思。它通过最直接的方式显示地调用匹配参数列表的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Flower.java</span></span><br><span class="line"><span class="comment">// Calling constructors with &quot;this&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> petalCount = <span class="number">0</span>;</span><br><span class="line">    String s = <span class="string">&quot;initial value&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Flower(<span class="keyword">int</span> petals) &#123;</span><br><span class="line">        petalCount = petals;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor w/ int arg only, petalCount = &quot;</span> + petalCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower(String ss) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor w/ string arg only, s = &quot;</span> + ss);</span><br><span class="line">        s = ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower(String s, <span class="keyword">int</span> petals) &#123;</span><br><span class="line">        <span class="keyword">this</span>(petals);</span><br><span class="line">        <span class="comment">//- this(s); // Can&#x27;t call two!</span></span><br><span class="line">        <span class="keyword">this</span>.s = s; <span class="comment">// Another use of &quot;this&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;String &amp; int args&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Flower() &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;hi&quot;</span>, <span class="number">47</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;no-arg constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printPetalCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//- this(11); // Not inside constructor!</span></span><br><span class="line">        System.out.println(<span class="string">&quot;petalCount = &quot;</span> + petalCount + <span class="string">&quot; s = &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Flower x = <span class="keyword">new</span> Flower();</span><br><span class="line">        x.printPetalCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Constructor w/ int arg only, petalCount = 47</span></span><br><span class="line"><span class="comment">//String &amp; int args</span></span><br><span class="line"><span class="comment">//no-arg constructor</span></span><br><span class="line"><span class="comment">//petalCount = 47 s = hi</span></span><br></pre></td></tr></table></figure>

<p>​        从构造器Flower(String s, int petals)可以看出，其中只能通过this调用一次构造器。另外，必须首先调用构造器，否则编译器会报错。这个例子同样展示了this的另一个用法。参数列表中的变量名s和成员变量s相同，会引起混淆。你可以通过this.s表名你指的是成员变量s，从而避免重复。在printPetalConut()方法中，编译器不允许你在一个构造器之外的方法里调用构造器。</p>
<h3 id="static的含义"><a href="#static的含义" class="headerlink" title="static的含义"></a>static的含义</h3><p>​        记住了this关键字的内容，你会对static修饰的方法更加具有深入的理解：static方法中不会存在this。你不能在静态方法中调用非静态方法(反之可以)。静态方法是为类而创建的，不需要任何对象。事实上，这就是静态方法的主要目的，静态方法看起来就像全局方法一样，但Java中不允许全局方法，一个类中的静态方法可以访问其他静态方法和静态属性。一些人认为静态方法不是面向对象的，因为它们的确具有全局方法的语义。使用静态方法，因为不存在this，所以你没有向一个对象发消息。的确，如果你发现代码中出现了大量的static方法，就该重新考虑自己的设计了。然而，static的概念很实用，许多时候都要用到它。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>​        Java中有垃圾回收器回收无用对象占用的内存。但现在考虑一种特殊情况：你创建的对象不是通过new来分配内存的，而垃圾回收器只知道如何释放new创建的对象的内存，所以它不知道如何回收不是new分配的内存。为了处理这种情况，Java允许在类中定义一个名为finalize()的方法。</p>
<p>​        它的工作原理“假定”是这样的：当垃圾回收器准备回收对象的内存时，首先会调用其finalize()方法，并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的内存。所以如果你打算使用finalize()，就能在垃圾回收时做一些重要的清理工作。finalize()是一个潜在的编程陷阱，因为一些程序员会一开始把它误认为是C++中的析构函数(C++在销毁对象时会调用这个函数)。所以有必要明确区分一下：在C++中，对象总是被销毁的，而在Java中，对象并非总是被垃圾回收，或者换句话说：</p>
<ul>
<li>1.对象可能不被垃圾回收</li>
<li>2.垃圾回收不等同于析构</li>
</ul>
<p>​        这意味着在你不需要某个对象之前，如果必须执行某些动作，你得自己去做。Java没有析构器或类似的概念，所以你必须得自己创建一个普通的方法完成这项清理工作。例如，对象在创建的过程中将自己绘制到屏幕上。如果不是明确地从屏幕上将其擦除，它可能永远得不到清理。如果在finalize()方法中加入某种擦除功能，那么当垃圾回收发生时，finalize()方法被调用(不保证一定会发生)图像就会被擦除，要是“垃圾回收”没有发生，图像则仍会保留下来。</p>
<p>​        也许你会发现，只要程序没有濒临内存用完的那一刻，对象占用的空间就总也得不到释放。如果程序执行结束，而垃圾回收器一直没有释放你创建的任何对象的内存，则当程序退出时，那些资源会全部交还给操作系统。这个策略是恰当的，因为垃圾回收本身也有开销，要是不使用它，那就不用支付这部分开销了。</p>
<h3 id="finalize-的用途"><a href="#finalize-的用途" class="headerlink" title="finalize()的用途"></a>finalize()的用途</h3><p>​        如果你不能将finalize()方法作为通用的清理方法，那么这个方法有什么用呢？这引入了要记住的第3点：3.垃圾回收只与内存有关。</p>
<p>​        也就是说，使用垃圾回收的唯一原因就是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说(尤其是finalize()方法)，它们也必须同内存及其回收有关。</p>
<p>​        但这是否意味着如果对象中包括其他对象，finalize()方法就应该明确释放那些对象？不是，无论对象是如何创建的，垃圾回收器都会负责释放对象所占用的所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式之外的方式为对象分配了存储空间。不过，你可能会想，Java中万物皆对象，这种情况怎么可能发生？</p>
<p>​        看起来之所以有finalize()方法，是因为在分配内存时可能采用了类似C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下，本地方法是一种Java语言调用非Java语言代码的形式。本地方法目前只支持C和C++，但是它们可以调用其他语言写的代码，所以实际上可以调用任何代码。在非Java代码中，也许会调用C的malloc()函数系列来分配存储空间，而且除非调用free()函数，不然存储空间永远得不到释放，造成内存泄露。但是，free()是C和C++中的函数，所以你需要在finalize()方法里用本地方法调用它。</p>
<h3 id="你必须实施清理"><a href="#你必须实施清理" class="headerlink" title="你必须实施清理"></a>你必须实施清理</h3><p>​        要清理一个对象，用户必须在需要清理的时候执行清理动作的方法。在C++中，所有对象都会被销毁，或者说应该被销毁。如果在C++创建了一个局部对象，此时的销毁动作发生在以“右花括号”为边界的、此对象作用域的末尾处。如果对象是用new创建的，那么程序员调用C++的delete操作符，就会调用相应的析构函数。如果程序员忘记调用delete，那么永远不会调用析构函数，这样就导致内存泄漏，对象的其他部分也不会得到清理。相反。在Java中，没有用于释放对象的delete，因为垃圾回收器会帮助你释放存储空间。设置可以肤浅地认为，正是由于垃圾回收的存在，使得Java没有析构函数。然而，随着学习的深入，你会明白垃圾回收器的存在并不能完全替代析构函数(而且绝不能直接调用finalize()，所以这也不是一种解决方案)。如果希望进行除释放存储空间之外的清理工作，还是得明确用某个恰当的Java方法：这就等同于使用了析构函数，只是没有它方便。</p>
<p>​        记住，无论是“垃圾回收”还是“终结”，都不保证一定会发生。如果JVM并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。</p>
<h3 id="终结条件"><a href="#终结条件" class="headerlink" title="终结条件"></a>终结条件</h3><p>​        通常，不能指望finalize()，你必须创建其他的“清理”方法，并明确地调用它们。所以看起来，finalize()只对大部分程序员很难用到的一些晦涩内存清理有用了。但是，finalize()还有一个有趣的用法，它不依赖于每次都要对finalize()进行调用，这就是对象终结条件的验证。</p>
<p>​        当对某个对象不感兴趣时——也就是它将被清理了，这个对象应该处于某种状态，这种状态下它占用的内存可以被安全地释放掉。例如，如果对象代表了一个打开的文件，在对象被垃圾回收之前程序员应该关闭这个文件。只要对象中存在没有被适当清理的部分，程序就存在很隐晦的bug。finalize()可以用来最终发现这个情况。尽管它并不是总被调用。如果某次finalize()的动作使得bug被发现，那么就可以据此找出问题所在——这才是人们真正关心的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/TerminationCondition.java</span></span><br><span class="line"><span class="comment">// Using finalize() to detect a object that</span></span><br><span class="line"><span class="comment">// hasn&#x27;t been properly cleaned up</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> onjava.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> checkedOut = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Book(<span class="keyword">boolean</span> checkOut) &#123;</span><br><span class="line">        checkedOut = checkOut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkedOut = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkedOut) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error: checked out&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Normally, you&#x27;ll also do this:</span></span><br><span class="line">        <span class="comment">// super.finalize(); // Call the base-class version</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminationCondition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Book novel = <span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// Proper cleanup:</span></span><br><span class="line">        novel.checkIn();</span><br><span class="line">        <span class="comment">// Drop the reference, forget to clean up:</span></span><br><span class="line">        <span class="keyword">new</span> Book(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// Force garbage collection &amp; finalization:</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">new</span> Nap(<span class="number">1</span>); <span class="comment">// One second delay</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Error: checked out</span></span><br></pre></td></tr></table></figure>

<p>​        本例的终结条件是：所有Book对象在被垃圾回收之前必须被登记。在main()方法中，有一本书没有登记。要是没有finalize()方法来验证终结条件，将会很难发现这个bug。</p>
<p>​        你可能会注意到使用了@Override。@意味着这是一个注解，注解是关于代码的额外信息。在这里，该注解告诉编译器这不是偶然地重新定义在每个对象中都存在的finalize()方法——程序员知道自己在做什么。编译器确保你没有拼错方法名，而且确保那个方法存在于基类中。</p>
<p>​        注意，System.gc()用于强制进行终结动作。但是即使不这么做，只要重复地执行程序，最终也能找出错误的Book对象。</p>
<p>​        你应该总是假设基类版本的finalize()也要做一些重要的事情，使用super调用它，就像Book.finalize()中看到的那样。</p>
<h3 id="垃圾回收器如何工作"><a href="#垃圾回收器如何工作" class="headerlink" title="垃圾回收器如何工作"></a>垃圾回收器如何工作</h3><p>​        你可以把C++里的堆想象成一个院子，里面每个对象都负责管理自己的地盘。一段时间后，对象可能被销毁，但地盘必须复用。在某些Java虚拟机中，堆的实现既然不同：它更像一个传送带，每分配一个新对象，它就向前移动一格。这意味着对象存储空间的分配速度特别快。Java的“堆指针”只是简单地移动到尚未分配的区域，所以它的效率与C++在栈上分配空间的效率相当。当然实际过程中，在薄记工作方面还有少量额外的开销，但是这部分开销比不上查找可用空间开销大。</p>
<p>​        你可能意识到了，Java中的堆并非完全像传送带那样工作。要是那样的话，势必会导致频繁的内存页面调度——将其移进移出硬盘，因此会显得需要拥有比实际需要更多的内存。页面调度会显著影响性能。最终，在创建了足够多的对象后，内存资源被耗尽。其中的秘密在于垃圾回收器的介入。当它工作时，一边回收内存，一边使堆中的对象紧凑排列，这样“堆指针”就可以很容易地移动到更靠近传送带的开始处，也就尽量避免了页面错误。垃圾回收器通过重新排列对象，实现了一种高速的，有无限空间可分配的堆模型。</p>
<p>​        要想理解Java中的垃圾回收，先了解其它系统中的垃圾回收机制将会很有帮助。一种简单但速度很慢的垃圾回收机制叫作引用计数。每个对象中含有一个引用计数器，每当有引用指向该对象时，引用计数加1.当引用离开作用域或被置为null时，引用计数减1.因此管理引用计数是一个开销不大但是在程序的整个生命周期频繁发生的负担。垃圾回收器会遍历含有全部对象的列表，当发现某个对象的引用计数为0时，就释放其占用空间。这个机制存在一个缺点：如果对象之间存在循环引用，那么它们的引用计数都不为0，就会出现应该被回收但无法被回收的情况。对垃圾回收器而言，定位这样的循环引用所需要的工作量极大。引用计数常用来说明垃圾回收的工作方式，但似乎从未被应用于任何一种JVM实现中。</p>
<p>​        在更快的策略中，垃圾回收器并非基于引用计数。它们的依据是：对于任意“活”的对象，一定能最终追溯到其存活在栈或静态存储区中的引用。这个引用链条可能会穿过数个对象层次，由此，如果从栈或静态存储区出发，遍历所有的引用，你将会发现所有“活”的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是该对象包含的所有引用，如此反复进行，知道访问完“根源于栈活静态存储区的引用”所形成的整个网络。你所访问过的对象一定是“活”的。注意，这解决了对象间循环引用的问题，这些对象不会被发现，因此也就被自动回收了。</p>
<p>​        在这种方式下，JVM采用了一种自适应的垃圾回收技术。至于如何处理找到的存活对象，取决于不同的JVM实现。其中，有一种叫做停止-复制(stop-and-copy)。顾名思义，这需要先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，没有复制的就是需要被垃圾回收的。另外，当对象被复制到新堆时，它们是一个挨着一个紧凑排列，然后就可以按照前面描述的那样简单、直接地分配新空间了。</p>
<p>​        当对象从一处复制到另一处，所有指向它的引用都必须修正。位于栈或静态存储区的引用可以直接被修正，但可能还有其他指向这些对象的引用，它们在遍历的过程中才能被找到。</p>
<p>​        这种所谓的“复制回收器”效率低下主要因为两个原因。其一：得有两个堆，然后在这两个分离的堆之间来回折腾，得围护比实际需要多一倍的空间。某些Java虚拟机对此问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。</p>
<p>​        其二在于复制本身。一旦程序进入稳定状态之后，可能只产生少量垃圾，甚至没有垃圾。尽管如此，复制回收器仍然会将所有内存从一处复制到另一处，这很浪费。为了避免这种状态，一些JVM会进行检查：要是没有新垃圾产生，就会转换到另一种模式(即“自适应”)。这种模式称为标记-清扫(mark-and-sweep)对一般用途而言，“标记-清扫”方式速度相当慢，但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。</p>
<p>​        “标记-清扫”所依据的思路仍然是从栈和静态存储区出发，遍历所有的引用，找出所有存活的对象。但是，每当找到一个存活对象，就给对象设一个标记，并不回收它。只有当标记过程完成后，清理动作才开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。“标记-清扫”后剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就需要重新整理剩下的对象。</p>
<p>​        “停止-复制”指的是这种垃圾回收动作不是在后台进行的；相反，垃圾回收动作发生的同时，程序将会暂停。许多参考文档将垃圾回收视为低优先级的后台进程，但是早期版本的JVM并不是这么实现垃圾回收器的。当可用内存较低时，垃圾回收器会暂停程序。同样，“标记-清扫”工作也必须在程序暂停的情况下才能进行。</p>
<p>​        这里讨论的JVM中，内存分配以较大的“块”为单位。如果对象较大，它会占用单独的块。严格来说，“停止-复制”要求在释放旧对象之前，必须先将所有存活对象从旧堆复制到新堆，这导致了大量的内存复制行为。有了块，垃圾回收器就可以把对象复制到废弃的块。每个块都有年代数来记录自己是否存活。通常，如果块在某处被引用，其年代数加1，垃圾回收器会对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作——大型对象仍然不会复制(只是年代数增加)，含有小型对象的那些块则被复制并整理。JVM会监视，如果所有对象都很稳定，垃圾回收的效率降低的话，就切换到“标记-清扫”方式。同样，JVM会跟踪“标记-清扫”的效果。如果堆空间出现很多碎片，就会切回“停止-复制”方式。这就是“自适应”的由来，你可以给它个啰嗦的称呼：“自适应的、分代的、停止-复制、标记-清扫”式的垃圾回收器。</p>
<p>​        JVM中有许多附加技术用来提升速度。尤其是加载器操作有关的，被称为“即时”(Just-In-time，JIT)编译器的技术。这种技术可以把程序全部或部分翻译成本地机器码，所以不需要JVM来进行翻译，因此运行得更快。当需要装载某个类时，编译器先会找到其.class文件，然后将该类得字节码装入内存。你可以让即时编译器编译所有代码，但这种做法有两个缺点：一是这种加载动作贯穿整个程序生民周期内，累加起来需要花更多时间；二是会增加可执行代码得长度，这会导致页面调度，从而一定降低程序速度。另一种做法称为惰性评估，意味着即时编译器只有在必要的时候才编译代码。这样，从未被执行的代码也许就压根不会被JIT编译。新版JDK中的Java Ho’tSpot技术就采用了类似的做法，代码每被执行一次就优化一些，所执行次数越多，它的速度就越快。</p>
<h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2><p>​        Java尽量保证所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，这种保证会以编译错误的方式呈现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        你会得到一条错误，告诉你i可能尚未初始化。编译器可以为i赋一个默认值，但是未初始化的局部变量更有可能是程序员的疏忽，所以采用默认值反而会掩盖这种失误。强制程序员提供一个初始值，往往能帮助找出程序里的bug。</p>
<p>​        若类的成员变量是基本类型，情况会变得有些不同。类的每个基本类型数据成员保证都会有一个初始值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/InitialValues.java</span></span><br><span class="line"><span class="comment">// Shows default initial values</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialValues</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> t;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">byte</span> b;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    InitialValues reference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInitialValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Data type Initial value&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;boolean &quot;</span> + t);</span><br><span class="line">        System.out.println(<span class="string">&quot;char[&quot;</span> + c + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;byte &quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;short &quot;</span> + s);</span><br><span class="line">        System.out.println(<span class="string">&quot;int &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;long &quot;</span> + l);</span><br><span class="line">        System.out.println(<span class="string">&quot;float &quot;</span> + f);</span><br><span class="line">        System.out.println(<span class="string">&quot;double &quot;</span> + d);</span><br><span class="line">        System.out.println(<span class="string">&quot;reference &quot;</span> + reference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InitialValues().printInitialValues();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Data type Initial value</span></span><br><span class="line"><span class="comment">//boolean false</span></span><br><span class="line"><span class="comment">//char[NUL]</span></span><br><span class="line"><span class="comment">//byte 0</span></span><br><span class="line"><span class="comment">//short 0</span></span><br><span class="line"><span class="comment">//int 0</span></span><br><span class="line"><span class="comment">//long 0</span></span><br><span class="line"><span class="comment">//float 0.0</span></span><br><span class="line"><span class="comment">//double 0.0</span></span><br><span class="line"><span class="comment">//reference null</span></span><br></pre></td></tr></table></figure>

<p>​        可见尽管数据成员的初始值还没有给出，但它们确实有初值(char值为0，所以显示为空白)。所以这样至少不会出现“未初始化变量”的风险了。</p>
<p>​        在类里定义一个对象引用时，如果不将其初始化，那么引用就会被赋值为null。</p>
<h3 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h3><p>​        怎么给一个变量赋初值呢？一种很直接的方法是在定义类成员变量的地方为其赋值。以下代码修改了InitialValues类成员变量的定义，直接提供了初值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/InitialValues2.java</span></span><br><span class="line"><span class="comment">// Providing explicit initial values</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialValues2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> bool = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    <span class="keyword">byte</span> b = <span class="number">47</span>;</span><br><span class="line">    <span class="keyword">short</span> s = <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">long</span> lng = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">3.14f</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.14159</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        你也可以用同样的方式初始化非基本类型的对象。如果Depth是一个类，那么可以像下面这样创建一个对象并初始化它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Measurement.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Depth</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Measurement</span> </span>&#123;</span><br><span class="line">    Depth d = <span class="keyword">new</span> Depth();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        如果没有为d赋予初值就尝试使用它，就会出现运行时错误，告诉你产生了一个异常。</p>
<p>​        你也可以通过调用某个方法来提供初值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/MethodInit.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = f();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        这个方法可以带有参数，但这参数不能是未初始化的类成员变量，因此，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/MethodInit2.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInit2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = f();</span><br><span class="line">    <span class="keyword">int</span> j = g(i);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        但你不能这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/MethodInit3.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInit3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//- int j = g(i); // Illegal forward reference</span></span><br><span class="line">    <span class="keyword">int</span> i = f();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        显然，上述程序的正确性取决于初始化的顺序，而与其编译方式无关。所以，编译器恰当地对“向前引用”发出了警告。</p>
<p>​        这种初始化方式简单，但有个限制：类InitialValues的每个对象都有相同的初值，有时这的确是我们需要的，但有时却需要更大的灵活性。</p>
<h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><p>​        可以用构造器进行初始化，这种方式给了你更大的灵活性，因为你可以在运行时调用方法进行初始化。但是，这无法阻止自动初始化的进行，它会在构造器被调用之前发生。因此，如果使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Counter.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    Counter() &#123;</span><br><span class="line">        i = <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        i首先会被初始化为0，然后变为7。对于所有的基本类型和引用，包括在定义时已明确指定初值的变量，这种情况都是成立的。因此，编译器不会强制你一定要在构造器的某个地方或在使用它们之前初始化元素——初始化早已得到了保证。</p>
<h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>​        在类中变量定义的顺序决定了它们初始化的顺序。即变量定义散布在方法定义之间，它们仍会在任何方法(包括构造器)被调用之前得到初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OrderOfInitialization.java</span></span><br><span class="line"><span class="comment">// Demonstrates initialization order</span></span><br><span class="line"><span class="comment">// When the constructor is called to create a</span></span><br><span class="line"><span class="comment">// Window object, you&#x27;ll see a message:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">    Window(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Window(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    Window w1 = <span class="keyword">new</span> Window(<span class="number">1</span>); <span class="comment">// Before constructor</span></span><br><span class="line"></span><br><span class="line">    House() &#123;</span><br><span class="line">        <span class="comment">// Show that we&#x27;re in the constructor:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;House()&quot;</span>);</span><br><span class="line">        w3 = <span class="keyword">new</span> Window(<span class="number">33</span>); <span class="comment">// Reinitialize w3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>); <span class="comment">// After constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>); <span class="comment">// At end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderOfInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        House h = <span class="keyword">new</span> House();</span><br><span class="line">        h.f(); <span class="comment">// Shows that construction is done</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Window(1)</span></span><br><span class="line"><span class="comment">//Window(2)</span></span><br><span class="line"><span class="comment">//Window(3)</span></span><br><span class="line"><span class="comment">//House()</span></span><br><span class="line"><span class="comment">//Window(33)</span></span><br><span class="line"><span class="comment">//f()</span></span><br></pre></td></tr></table></figure>

<p>​        在House类中，故意把几个Window对象定义散布各处，以证明它们全都会在调用构造器或其他方法之前得到初始化。此外，w3在构造器中被再次赋值。</p>
<p>​        由输出可见，引用w3被初始化了两次：一次在调用构造器前，一次在构造器调用期间(第一次引用的对象将被丢弃，并作为垃圾回收)。这咋一看可能觉得效率不高，但保证了正确的初始化。试想，如果定义了一个重载构造器，在其中没有初始化w3，同时在定义w3时没有赋予初值，那么会产生怎样的后果呢？</p>
<h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3><p>​        无论创建多少个对象，静态数据都只占一份存储区域。static关键字不能应用于局部变量，所以只能作用于(字段、域)。如果一个字段是静态的基本类型，你没有初始化它，那么它就会获得基本类型的标准初值。如果它是对象引用，那么它的默认值就是null。</p>
<p>​        如果在定义时进行初始化，那么静态变量看起来就跟非静态变量一样。</p>
<p>​        下面例子显示了静态存储区是何时初始化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/StaticInitialization.java</span></span><br><span class="line"><span class="comment">// Specifying initial values in a class definition</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bowl</span> </span>&#123;</span><br><span class="line">    Bowl(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bowl(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f1(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Bowl bowl1 = <span class="keyword">new</span> Bowl(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    Table() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Table()&quot;</span>);</span><br><span class="line">        bowl2.f1(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f2(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> Bowl bowl2 = <span class="keyword">new</span> Bowl(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cupboard</span> </span>&#123;</span><br><span class="line">    Bowl bowl3 = <span class="keyword">new</span> Bowl(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">static</span> Bowl bowl4 = <span class="keyword">new</span> Bowl(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    Cupboard() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cupboard()&quot;</span>);</span><br><span class="line">        bowl4.f1(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f3(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> Bowl bowl5 = <span class="keyword">new</span> Bowl(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main creating new Cupboard()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Cupboard();</span><br><span class="line">        System.out.println(<span class="string">&quot;main creating new Cupboard()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Cupboard();</span><br><span class="line">        table.f2(<span class="number">1</span>);</span><br><span class="line">        cupboard.f3(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> Table table = <span class="keyword">new</span> Table();</span><br><span class="line">    <span class="keyword">static</span> Cupboard cupboard = <span class="keyword">new</span> Cupboard();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Bowl(1)</span></span><br><span class="line"><span class="comment">//Bowl(2)</span></span><br><span class="line"><span class="comment">//Table()</span></span><br><span class="line"><span class="comment">//f1(1)</span></span><br><span class="line"><span class="comment">//Bowl(4)</span></span><br><span class="line"><span class="comment">//Bowl(5)</span></span><br><span class="line"><span class="comment">//Bowl(3)</span></span><br><span class="line"><span class="comment">//Cupboard()</span></span><br><span class="line"><span class="comment">//f1(2)</span></span><br><span class="line"><span class="comment">//main creating new Cupboard()</span></span><br><span class="line"><span class="comment">//Bowl(3)</span></span><br><span class="line"><span class="comment">//Cupboard()</span></span><br><span class="line"><span class="comment">//f1(2)</span></span><br><span class="line"><span class="comment">//main creating new Cupboard()</span></span><br><span class="line"><span class="comment">//Bowl(3)</span></span><br><span class="line"><span class="comment">//Cupboard()</span></span><br><span class="line"><span class="comment">//f1(2)</span></span><br><span class="line"><span class="comment">//f2(1)</span></span><br><span class="line"><span class="comment">//f3(1)</span></span><br></pre></td></tr></table></figure>

<p>​        Bowl类展示类的创建，而Table和Cupboard在它们的类定义中包含Bowl类型的静态数据成员。注意，在静态数据成员定义之前，Cupboard类中先定义了一个Bowl类型的非静态成员b3。</p>
<p>​        由输出可见，静态初始化只有在必要时刻才会进行。如果不创建Table对象，也不引用Table.bowl1和Table.bowl2，那么静态的Bowl类对象bowl1和bowl2永远不会被创建。只有在第一个Table对象被创建时，它们才会被初始化。此后，静态对象不会再次被初始化。</p>
<p>​        初始化的顺序先是静态对象，然后是非静态对象，从输出可以看出。要执行main()方法，必须加载StaticInitialization类，它的静态属性table和cupboard随后被初始化，这会导致它们对应的类也被加载，而由于它们都包含静态的Bowl对象，所以Bowl类也会被加载。因此，在这个特殊的程序中，所有类都会在main()方法之前被加载。实际情况通常并非如此，因为在典型的程序中，不会像本例中所示的那样，将所有事物通过static联系起来。</p>
<p>​        概括一下创建对象的过程，假设有个名为Dog的类：</p>
<ul>
<li>即使没有显示地使用static关键字，构造器实际上也是静态方法。所以，当首次创建Dog类型的对象或首次访问Dog类的静态方法或属性时，Java解释器必须在类路径中查找，以定位Dog.class。</li>
<li>当加载完Dog.class后，有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载Class对象时初始化一次。</li>
<li>当用new Dog()创建对象时，首先会在堆上为Dog对象分配足够的存储空间。</li>
<li>分配的存储空间首先会被清零，即会将Dog对象中的所有基本数据设置为默认值，引用被置为null。</li>
<li>执行所有出现在字段定义处的初始化动作。</li>
<li>执行构造器。</li>
</ul>
<h3 id="显示的静态初始化"><a href="#显示的静态初始化" class="headerlink" title="显示的静态初始化"></a>显示的静态初始化</h3><p>​        你可以将一组静态初始化动作放在类里面的一个特殊的“静态子句”(有时叫做静态块)中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Spoon.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spoon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">47</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这看起来像个方法，但实际上它只是一段跟在static关键字后面的代码块。与其他静态初始化一样，这段代码仅执行一次：当首次创建这个类的对象或首次访问这个类的静态成员(甚至不需要创建该类的对象)时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/ExplicitStatic.java</span></span><br><span class="line"><span class="comment">// Explicit static initialization with &quot;static&quot; clause</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cup</span> </span>&#123;</span><br><span class="line">    Cup(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cup(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cups</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Cup cup1;</span><br><span class="line">    <span class="keyword">static</span> Cup cup2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cup1 = <span class="keyword">new</span> Cup(<span class="number">1</span>);</span><br><span class="line">        cup2 = <span class="keyword">new</span> Cup(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Cups() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cups()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        Cups.cup1.f(<span class="number">99</span>); <span class="comment">// [1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// static Cups cups1 = new Cups(); // [2]</span></span><br><span class="line">    <span class="comment">// static Cups cups2 = new Cups(); // [2]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Inside main()</span></span><br><span class="line"><span class="comment">//Cup(1)</span></span><br><span class="line"><span class="comment">//Cup(2)</span></span><br><span class="line"><span class="comment">//f(99)</span></span><br></pre></td></tr></table></figure>

<h3 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h3><p>​        Java提供了被称为实例初始化的类似语法，用来初始化每个对象的非静态变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Mugs.java</span></span><br><span class="line"><span class="comment">// Instance initialization</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mug</span> </span>&#123;</span><br><span class="line">    Mug(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mug(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mugs</span> </span>&#123;</span><br><span class="line">    Mug mug1;</span><br><span class="line">    Mug mug2;</span><br><span class="line">    &#123; <span class="comment">// [1]</span></span><br><span class="line">        mug1 = <span class="keyword">new</span> Mug(<span class="number">1</span>);</span><br><span class="line">        mug2 = <span class="keyword">new</span> Mug(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;mug1 &amp; mug2 initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Mugs() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Mugs(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mugs(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Mugs();</span><br><span class="line">        System.out.println(<span class="string">&quot;new Mugs() completed&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Mugs(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;new Mugs(1) completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Inside main()</span></span><br><span class="line"><span class="comment">//Mug(1)</span></span><br><span class="line"><span class="comment">//Mug(2)</span></span><br><span class="line"><span class="comment">//mug1 &amp; mug2 initialized</span></span><br><span class="line"><span class="comment">//Mugs()</span></span><br><span class="line"><span class="comment">//new Mugs() completed</span></span><br><span class="line"><span class="comment">//Mug(1)</span></span><br><span class="line"><span class="comment">//Mug(2)</span></span><br><span class="line"><span class="comment">//mug1 &amp; mug2 initialized</span></span><br><span class="line"><span class="comment">//Mugs(int)</span></span><br><span class="line"><span class="comment">//new Mugs(1) completed</span></span><br></pre></td></tr></table></figure>

<p>​        看起来它很像静态代码块，只不过少了static关键字。这种语法对于支持“匿名内部类”的初始化是必须的，但是你也可以使用它保证某些操作一定会发生，而不管哪个构造器被调用。从输出看出，实例初始化子句是在两个构造器之前执行的。</p>
<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>​        数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本数据类型。数组是通过方括号操作符[]来定义和使用的。要定义一个数组引用，只需要在类型名加上方括号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1;</span><br></pre></td></tr></table></figure>

<p>​        方括号也可以放在标识符的后面，两者含义是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[];</span><br></pre></td></tr></table></figure>

<p>​        编译器不允许指定数组的大小。这又把我们带回有关“引用”的问题上。你所拥有的只是对数组的一个引用，但是还没有给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式，它必须在创建数组的地方出现。这种特殊的初始化是由一对花括号括起来的值组成。这种情况下，存储空间的分配将由编译器负责：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>​        那么为什么在还没有数组的时候定义一个数组引用呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a2;</span><br></pre></td></tr></table></figure>

<p>​        在Java中可以将一个数组赋值给另一个数组，所以可以这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a2 = a1;</span><br></pre></td></tr></table></figure>

<p>​        其实真正做的只是复制了一个引用，就像下面演示的这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/ArraysOfPrimitives.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysOfPrimitives</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] a2;</span><br><span class="line">        a2 = a1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a2.length; i++) &#123;</span><br><span class="line">            a2[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a1.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a1[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + a1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a1[0] = 2;</span></span><br><span class="line"><span class="comment">//a1[1] = 3;</span></span><br><span class="line"><span class="comment">//a1[2] = 4;</span></span><br><span class="line"><span class="comment">//a1[3] = 5;</span></span><br><span class="line"><span class="comment">//a1[4] = 6;</span></span><br></pre></td></tr></table></figure>

<p>​        a1初始化了，但是a2没有；这里a2在后面被赋给另一个数组。由于a1和a2是相同数组的别名，因此通过a2所做的修改在a1中也能看到。</p>
<p>​        所有的数组都有一个固定成员length，告诉你这个数组有多少个元素，你不能对其修改。Java数组计数也是从0开始的，所能使用的最大下标数是length-1。在你访问超出这个边界时，会报运行时错误(异常)，从而避免此类问题。</p>
<h3 id="动态数组创建"><a href="#动态数组创建" class="headerlink" title="动态数组创建"></a>动态数组创建</h3><p>​        若果在编写程序时，不确定数组中需要多少个元素，可以使用new在数组中创建元素。如下例所示，使用new创建基本类型数组。new不能创建非数组以外的基本类型数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/ArrayNew.java</span></span><br><span class="line"><span class="comment">// Creating arrays with new</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line">        System.out.println(<span class="string">&quot;length of a = &quot;</span> + a.length);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//length of a = 18</span></span><br><span class="line"><span class="comment">//[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure>

<p>​        数组的大小是通过Random.nextInt()随机确定的，这个方法会返回0到输入参数之间的一个值。由于随机性，很明显数组的创建确实是在运行时进行的。此外，程序输出表名，数组元素中的基本数据类型会自动初始化为默认值(对于数字和字符是0，对于布尔类型是false)。Arrays.toString()是java.util标准库中的方法，会产生一维数组的可打印版本。</p>
<p>​        本例中，数组也可以在定义的同时进行初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">20</span>)];</span><br></pre></td></tr></table></figure>

<p>​        如果可能的话，应该尽量这么做。如果你创建了一个非基本类型的数组，那么你创建的是一个引用数组。以整数的包装类型Integer为例，它是一个类而非基本类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/ArrayClassObj.java</span></span><br><span class="line"><span class="comment">// Creating an array of nonprimitive objects</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayClassObj</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        Integer[] a = <span class="keyword">new</span> Integer[rand.nextInt(<span class="number">20</span>)];</span><br><span class="line">        System.out.println(<span class="string">&quot;length of a = &quot;</span> + a.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = rand.nextInt(<span class="number">500</span>); <span class="comment">// Autoboxing</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">length of a = <span class="number">18</span></span><br><span class="line">[<span class="number">55</span>, <span class="number">193</span>, <span class="number">361</span>, <span class="number">461</span>, <span class="number">429</span>, <span class="number">368</span>, <span class="number">200</span>, <span class="number">22</span>, <span class="number">207</span>, <span class="number">288</span>, <span class="number">128</span>, <span class="number">51</span>, <span class="number">89</span>, <span class="number">309</span>, <span class="number">278</span>, <span class="number">498</span>, <span class="number">361</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<p>​        这里，即使使用new创建之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[rand.nextInt(<span class="number">20</span>)];    </span><br></pre></td></tr></table></figure>

<p>​        它只是一个引用数组，直到通过创建新的Integer对象，并把对象赋值给引用，初始化才算结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[i] = rand.nextInt(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>​        如果忘记了创建对象，但试图使用数组中的空引用，就会在运行时产生异常。</p>
<p>​        也可以用花括号括起来的列表来初始化数组，有两种形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/ArrayInit.java</span></span><br><span class="line"><span class="comment">// Array initialization</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] a = &#123;</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="comment">// Autoboxing</span></span><br><span class="line">        &#125;;</span><br><span class="line">        Integer[] b = <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="comment">// Autoboxing</span></span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        System.out.println(Arrays.toString(b));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>​        在这两种形式，初始化列表的最后一个逗号是可选的。</p>
<p>​        尽管第一种形式很有用，但是它更加受限，因为它只能用于数组定义处。第二种形式可以用在任何地方，甚至用在方法的内部。例如，你创建了一个String数组，将其传递给另一个类的main()方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/DynamicArray.java</span></span><br><span class="line"><span class="comment">// Array initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Other.main(<span class="keyword">new</span> String[] &#123;<span class="string">&quot;fiddle&quot;</span>, <span class="string">&quot;de&quot;</span>, <span class="string">&quot;dum&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s: args) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fiddle de dum </span></span><br></pre></td></tr></table></figure>

<p>​        Other.main()的参数是在调用处创建的，因此你甚至可以在方法的调用处提供可替换的参数。</p>
<h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><p>​        你可以以一种类似C语言中的可变参数列表来创建和调用方法。这可以应用在参数个数或类型未知的场合。由于所有的类都最后继承于Object类，所以你可以创建一个以Object数组为参数的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/VarArgs.java</span></span><br><span class="line"><span class="comment">// Using array syntax to create variable argument lists</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj: args) &#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printArray(<span class="keyword">new</span> Object[] &#123;<span class="number">47</span>, (<span class="keyword">float</span>) <span class="number">3.14</span>, <span class="number">11.11</span>&#125;);</span><br><span class="line">        printArray(<span class="keyword">new</span> Object[] &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;);</span><br><span class="line">        printArray(<span class="keyword">new</span> Object[] &#123;<span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//47 3.14 11.11 </span></span><br><span class="line"><span class="comment">//one two three </span></span><br><span class="line"><span class="comment">//A@15db9742 A@6d06d69c A@7852e922</span></span><br></pre></td></tr></table></figure>

<p>​        printArray()参数是Object数组，使用for-in语法遍历和打印数组的每一项。标准Java库能输出有意义的内容，但这里创建的是类的对象，打印出的内容是类名，后面跟着一个@符号以及多个十六进制数字。因而，默认行为(如果没有定义toString()方法的话)就是打印类名和对象的地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/NewVarArgs.java</span></span><br><span class="line"><span class="comment">// Using array syntax to create variable argument lists</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewVarArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj: args) &#123;</span><br><span class="line">            System.out.print(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Can take individual elements:</span></span><br><span class="line">        printArray(<span class="number">47</span>, (<span class="keyword">float</span>) <span class="number">3.14</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="number">47</span>, <span class="number">3.14F</span>, <span class="number">11.11</span>);</span><br><span class="line">        printArray(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        printArray(<span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A());</span><br><span class="line">        <span class="comment">// Or an array:</span></span><br><span class="line">        printArray((Object[]) <span class="keyword">new</span> Integer[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        printArray(); <span class="comment">// Empty list is OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//47 3.14 11.11 </span></span><br><span class="line"><span class="comment">//47 3.14 11.11 </span></span><br><span class="line"><span class="comment">//one two three </span></span><br><span class="line"><span class="comment">//A@15db9742 A@6d06d69c A@7852e922 </span></span><br><span class="line"><span class="comment">//1 2 3 4 </span></span><br></pre></td></tr></table></figure>

<p>​        有了可变参数，你就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你填充数组。你获取的仍然是一个数组，这就是为什么printArray()可以使用for-in迭代数组的原因。但是，这不仅仅只是从元素列表到数组的自动转换。注意程序的倒数第二行，一个Integer数组被转型为一个Object数组，并且传递给了printArray()。显然，编译器会发现这是一个数组，不会执行转换。因此，如果你有一组事物，可以把它们当作列表传递，而如果你已经有了一个数组，该方法会把它们当作可变参数列表来接受。</p>
<p>​        程序的最后一行表名，可变参数的个数可以为0。当具有可选的尾随参数，这一特性会有帮助：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OptionalTrailingArguments.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTrailingArguments</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> required, String... trailing)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;required: &quot;</span> + required + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s: trailing) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        f(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        f(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//required: 1 one </span></span><br><span class="line"><span class="comment">//required: 2 two three </span></span><br><span class="line"><span class="comment">//required: 0 </span></span><br></pre></td></tr></table></figure>

<p>​        这段程序展示了如何使用Object类之外类型的可变参数列表。这里，所有的可变参数都是String对象。可变参数列表中可以使用任何类型的参数，包括基本类型。下面例子展示了可变参数列表为数组的情形，并且如果列表中没有任何元素，那么转变大小为0的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/VarargType.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarargType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.print(args.getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot; length &quot;</span> + args.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123;</span><br><span class="line">        System.out.print(args.getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot; length &quot;</span> + args.length)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        f();</span><br><span class="line">        g(<span class="number">1</span>);</span><br><span class="line">        g();</span><br><span class="line">        System.out.println(<span class="string">&quot;int[]: &quot;</span>+ <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>].getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//class [Ljava.lang.Character; length 1</span></span><br><span class="line"><span class="comment">//class [Ljava.lang.Character; length 0</span></span><br><span class="line"><span class="comment">//class [I length 1</span></span><br><span class="line"><span class="comment">//class [I length 0</span></span><br><span class="line"><span class="comment">//int[]: class [I</span></span><br></pre></td></tr></table></figure>

<p>​        getClass()方法属于Object类。它会产生对象的类，并在打印该类时，看到表示该类类型的编码字符串。前导[代表这是一个后面紧随的类型的数组，I表示基本类型int；为了进行双重检查，我在最后一行创建了一个int数组，打印了其类型。这样也验证了使用可变参数列表不依赖于自动装箱，而使用的是基本类型。</p>
<p>​        然而，可变参数列表与自动装箱可以和谐共处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/AutoboxingVarargs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoboxingVarargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Integer... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer i: args) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        f(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        f(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2</span></span><br><span class="line"><span class="comment">//4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">//10 11 12</span></span><br></pre></td></tr></table></figure>

<p>​        注意吗，你可以在单个参数列表中将类型混合在一起，自动装箱机制会有选择地把int类型提升为Integer。</p>
<p>​        可变参数列表使得方法重载更加复杂了，尽管乍看之下似乎足够安全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OverloadingVarargs.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Character c: args) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Integer... args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i: args) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Long... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        f(<span class="number">1</span>);</span><br><span class="line">        f(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        f(<span class="number">0</span>);</span><br><span class="line">        f(<span class="number">0L</span>);</span><br><span class="line">        <span class="comment">//- f(); // Won&#x27;s compile -- ambiguous</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//first a b c</span></span><br><span class="line"><span class="comment">//second 1</span></span><br><span class="line"><span class="comment">//second 2 1</span></span><br><span class="line"><span class="comment">//second 0</span></span><br><span class="line"><span class="comment">//third</span></span><br></pre></td></tr></table></figure>

<p>​        在每种情况下，编译器都会使用自动装箱来匹配重载的方法，然后调用最明确的方法。</p>
<p>​        但是如果调用不含参数的f()，编译器就无法直到应该调用哪个方法了。尽管这个错误可以弄清楚，但是它可能会使客户端程序员感到意外。</p>
<p>​        你可能会通过某个方法中增加一个非可变参数解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OverloadingVarargs2.java</span></span><br><span class="line"><span class="comment">// &#123;WillNotCompile&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/OverloadingVarargs3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadingVarargs3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> i, Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> c, Character... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//first</span></span><br><span class="line"><span class="comment">//second</span></span><br></pre></td></tr></table></figure>

<p>​        你应该总在重载方法的一个版本上使用可变参数列表，或者压根不用它。</p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>​        Java5中添加了一个看似很小的特性enum关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便地处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Spiciness.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Spiciness</span> </span>&#123;</span><br><span class="line">    NOT, MILD, MEDIUM, HOT, FLAMING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这里创建了一个名为Spiciness的枚举类型，它有5个值。由于枚举类型的实例是常量，因此按照命名惯例，它们都用大写字母表示。要使用enum，需要创建一个该类型的引用，然后将其赋值给某个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/SimpleEnumUse.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleEnumUse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Spiciness howHot = Spiciness.MEDIUM;</span><br><span class="line">        System.out.println(howHot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MEDIUM</span></span><br></pre></td></tr></table></figure>

<p>​        在你创建enum时，编译器会自己添加一些有用的特性。例如，它会创建toString()方法，以便你方便地显示某个enum实例的名称，这从上面例子中的输出可以看出。编译器还会创建ordonal()方法表示某个特定enum常量的声明顺序，static values()方法按照enum常量的声明顺序，生成这些常量值构成的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/EnumOrder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumOrder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Spiciness s: Spiciness.values()) &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot;, ordinal &quot;</span> + s.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NOT, ordinal 0</span></span><br><span class="line"><span class="comment">//MILD, ordinal 1</span></span><br><span class="line"><span class="comment">//MEDIUM, ordinal 2</span></span><br><span class="line"><span class="comment">//HOT, ordinal 3</span></span><br><span class="line"><span class="comment">//FLAMING, ordinal 4</span></span><br></pre></td></tr></table></figure>

<p>​        尽管enum看起来是一种新的数据类型，但是这个关键字只是在生成enum的类时，产生了某些编译行为，因此在很大程度上你可以将enum当作其他任何类。事实上，enum确实是类，并且具有自己的方法。</p>
<p>​        enum有一个很实用的特性，就是在switch语句中使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// housekeeping/Burrito.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Burrito</span> </span>&#123;</span><br><span class="line">    Spiciness degree;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Burrito</span><span class="params">(Spiciness degree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.degree = degree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;This burrito is &quot;</span>);</span><br><span class="line">        <span class="keyword">switch</span>(degree) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOT:</span><br><span class="line">                System.out.println(<span class="string">&quot;not spicy at all.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MILD:</span><br><span class="line">            <span class="keyword">case</span> MEDIUM:</span><br><span class="line">                System.out.println(<span class="string">&quot;a little hot.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOT:</span><br><span class="line">            <span class="keyword">case</span> FLAMING:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;maybe too hot&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Burrito plain = <span class="keyword">new</span> Burrito(Spiciness.NOT),</span><br><span class="line">        greenChile = <span class="keyword">new</span> Burrito(Spiciness.MEDIUM),</span><br><span class="line">        jalapeno = <span class="keyword">new</span> Burrito(Spiciness.HOT);</span><br><span class="line">        plain.describe();</span><br><span class="line">        greenChile.describe();</span><br><span class="line">        jalapeno.describe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//This burrito is not spicy at all.</span></span><br><span class="line"><span class="comment">//This burrito is a little hot.</span></span><br><span class="line"><span class="comment">//This burrito is maybe too hot.</span></span><br></pre></td></tr></table></figure>

<p>​        由于switch是在有限的可能值集合中选择，因此enum是绝佳的组合。注意，enum的名称是如何能够倍加清楚地表名程序的目的的。</p>
<p>​        通常，你可以将enum用作另一种创建数据类型的方式，然后使用所得到的类型。这正是关键所在，所以你不用过多地考虑它们。在enum被引入之前，你必须花费大量的精力去创建一个等同的枚举类型，并是安全可用的。</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>《On Java 8》</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 继承</title>
    <url>/2020/10/19/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><p>本章将学习面向对象程序设计的另外一个基本概念：继承(inheritance)。继承的基本思想是，可以基于已有的类创建新的类。继承已存在的类就是复用(继承)这些类的方法，而且可以增加一些新的方法和字段，使新类能够适应新的情况。这是Java程序设计中的一项核心技术。</p>
<p>另外，本章还阐述了反射(reflection)的概念。反射是指在程序运行期间更多地了解类及其属性的能力。反射是一个功能强大的特性，不过，不可否认它也相当复杂。</p>
<p>继承主要解决的问题就是：共性抽取。</p>
<h2 id="5-1-类、超类和子类"><a href="#5-1-类、超类和子类" class="headerlink" title="5.1 类、超类和子类"></a>5.1 类、超类和子类</h2><p>回忆一下在前一章中讨论过的Employee类。假设你在某个公司工作，这个公司里的经理的待遇与普通员工的待遇存在着一些差异。不过，他们之间也存在着很多相同的地方，例如，他们都领取薪水。只是普通员工在完成本职任务之后仅领取薪水，而经理在完成了预期的业绩之后还能得到奖金。这种情形下就需要使用继承。为什么呢？因为需要为经理定义一个新类Manager，并增加一些新功能。但可以重用Employee类中已经编写的部分代码，并保留原来Employee类中的所有字段。从理论上讲，在Manager与Employee之间存在着明显的“is-a”关系，每个经理都是一个员工：“is-a”关系是继承的一个明显特征。</p>
<h3 id="5-1-1-定义子类"><a href="#5-1-1-定义子类" class="headerlink" title="5.1.1 定义子类"></a>5.1.1 定义子类</h3><p>可以如下继承Employee类来定义Manager类，这里使用关键字extends表示继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    added methods and fields</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字extends表明正在构建的新类派生于一个已经存在的类。这个已存在的类称为超类(superclass)、基类(base class)</p>
<p>或父类(parent class)；新类称为子类(subclass)、派生类(derived class)或孩子类(child class)。</p>
<p>尽管Employee类是一个超类，但并不是因为它优于子类或者拥有比子类更多的功能。实际上恰恰相反，子类比超类拥有更多的功能。</p>
<p>继承关系的特点：</p>
<ul>
<li>子类可以拥有父类的内容</li>
<li>子类还可以拥有自己专有的内容</li>
</ul>
<p>直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找。</p>
<p>间接通过成员方法访问成员变量：方法属于谁，就优先用谁，没有则向上找。</p>
<p>区分子类方法中重名的三种变量：</p>
<ul>
<li>局部变量： 直接写</li>
<li>本类的成员变量：this.成员变量名</li>
<li>父类的成员变量：super.成员变量名</li>
</ul>
 <span id="more"></span> 

<h3 id="5-1-2-覆盖方法"><a href="#5-1-2-覆盖方法" class="headerlink" title="5.1.2 覆盖方法"></a>5.1.2 覆盖方法</h3><p>重写(override)：方法名称一样，参数列表也【一样】。</p>
<p>重载(overload)：方法名称一样，参数列表【不一样】。</p>
<p>方法的覆盖重写特点：创建的是子类对象，则有先用子类方法。</p>
<p>方法覆盖的注意事项：</p>
<ul>
<li>必须保证父子类之间方法的名称相同，参数列表也相同。@override：写在方法前面，用来检测是不是有效的正确覆盖重写。这个注解就算不写，只要满足要求，也是正确的方法覆盖。</li>
<li>子类方法的返回值必须【小于等于】父类方法的返回值范围。String有一个父类是Object，Object类是所有类的公共最高父类(祖宗类)java.lang.Object。</li>
<li>子类方法的权限必须【大于等于】父类方法的权限修饰符 public &gt; protected &gt; default &gt; private (default)不是关键字default，而是什么都不写，留空。</li>
</ul>
<p>超类中的有些方法对子类Manager并不一定适用。具体来说，Manager类中的getSalary方法应该返回薪水和奖金的总和。为此，需要提供一个新的方法来覆盖(override)超类中的这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该如何实现这个方法呢？乍看起来似乎简单，只要返回salary和bonus字段的总和就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary + bonus;<span class="comment">//won&#x27;t work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这样不行。回想一下，只有Employee方法直接访问Employee类的私有字段。这意味着，Manager类的getSalary方法不能直接访问Salary字段。如果Manager类的方法想要访问那些私有字段，就要像所有其他方法一样使用公共接口，在这里就是要使用Employee类中的公共方法getSalary。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> baseSalary = getSalary();</span><br><span class="line">    <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码仍有问题。问题出现在调用的getSalary的语句上，它只是在调用自身，这是因为Manager类也有一个getSalary方法(就是我们正在实现的这个方法)，所以这条语句将会导致无限次地调用自己，直到整个程序最终崩溃。</p>
<p>这里需要指出：我们希望调用超类Employee中的getSalary方法，而不是当前类的这个方法。为此，可以使用特殊的关键字super解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>.getSalary()</span><br></pre></td></tr></table></figure>

<p>这个语句调用的是Employee类中的getSalary方法。下面是Manager类中getSalary方法的正确版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();</span><br><span class="line">    <span class="keyword">return</span> bseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在父子类的继承关系当中，创建子类对象，访问成员方法的规则：</p>
<ul>
<li>创建的对象是谁，就优先用谁，如果没有则向上找。</li>
<li>无论是成员方法还是成员变量，如果没有都是想上找，绝不会向下找子类的。</li>
</ul>
<h3 id="5-1-3-子类构造器"><a href="#5-1-3-子类构造器" class="headerlink" title="5.1.3 子类构造器"></a>5.1.3 子类构造器</h3><p>在例子的最后，我们来提供一个构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name,salary,year,month,day);</span><br><span class="line">    bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键字super具有不同的含义。是调用超类Employee中带有n,s,year,month和day参数的构造器的简写形式。</p>
<p>由于manager类的构造器不能访问Employee类的私有字段，所以必须通过一个构造器来初始化这些私有字段。可以利用特殊的super语法来调用这个构造器。使用super调用这个构造器的语法必须是子类构造的第一条语句。</p>
<p>如果子类的构造器没有显示地调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数的构造器，并且在子类的构造器中又没有显示地调用超类的其他构造器，Java编译器就会报告一个错误。</p>
<p>继承关系中，父子类构造方法的访问特点：</p>
<ul>
<li>子类构造方法当中有一个默认隐含的“super()”调用，所以一定先调用的父类构造，后执行子类构造。</li>
<li>子类构造可以通过super关键字来调用父类重载构造。</li>
<li>super的父类调用必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ihheritance_ManagegerTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        inheritance_Manager boss = <span class="keyword">new</span> inheritance_Manager(<span class="string">&quot;carl&quot;</span>,<span class="number">80000</span>,<span class="number">1987</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">        boss.setBonus(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        inheritance_Employee[] staff = <span class="keyword">new</span> inheritance_Employee[<span class="number">3</span>];</span><br><span class="line">         staff[<span class="number">0</span>] = boss;</span><br><span class="line">         staff[<span class="number">1</span>] = <span class="keyword">new</span> inheritance_Employee(<span class="string">&quot;Harry Hacker&quot;</span>,<span class="number">50000</span>,<span class="number">1989</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">         staff[<span class="number">2</span>] = <span class="keyword">new</span> inheritance_Employee(<span class="string">&quot;Tommy Tester&quot;</span>,<span class="number">40000</span>,<span class="number">1990</span>,<span class="number">3</span>,<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (inheritance_Employee e : staff)</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;name=&quot;</span>+e.getName()+<span class="string">&quot;, salary=&quot;</span>+e.getSalary());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         for (int i = 0; i &lt; staff.length; i++)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             System.out.println(&quot;name=&quot;+staff[i].getName()+&quot;, salary&quot;+staff[i].getSalary());</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">inheritance_Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">inheritance_Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">inheritance_Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = LocalDate.of(year,month,day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHireDay</span><span class="params">(LocalDate hireDay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.inheritance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">inheritance_Manager</span> <span class="keyword">extends</span> <span class="title">inheritance_Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">inheritance_Manager</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">inheritance_Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,salary,year,month,day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();</span><br><span class="line">        <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> bonus)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super关键字的三种用法：</p>
<ul>
<li>在子类的成员方法中，访问父类的成员变量</li>
<li>在子类的成员方法中，访问父类的成员方法。</li>
<li>在子类的构造方法中，访问父类的构造方法。</li>
</ul>
<p>this关键字的三种用法：</p>
<ul>
<li>在本类的成员方法中，访问本类的成员变量。</li>
<li>在本类的成员方法中，访问本类的另一个成员方法。</li>
<li>在本类的构造方法中，访问本类的另一个构造方法。</li>
</ul>
<p><img src="/2020/10/19/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BB%A7%E6%89%BF/image-20201013093430566.png" alt="image-20201013093430566"></p>
<h3 id="5-1-4-继承层次"><a href="#5-1-4-继承层次" class="headerlink" title="5.1.4 继承层次"></a>5.1.4 继承层次</h3><p>继承不限于一个层次。例如，可以由Manager类派生Executive类。由一个公共超类派生出来的所有类的集合称为继承层次(inheritance hierarchy)。在继承层次中，从某个特定的类到其祖先的路径称为该类的继承链(inheritance chain)。通常一个祖先类可以有多个子孙链。</p>
<p>Java继承的三个特点：</p>
<ul>
<li>java语言是单继承的。一个类的直接父类只能有一个。</li>
<li>java语言可以多级继承。</li>
<li>一个子类的直接父类是唯一的，但一个父类可以拥有很多个子类。</li>
</ul>
<p><img src="/2020/10/19/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BB%A7%E6%89%BF/image-20201013094645001.png" alt="image-20201013094645001"></p>
<h3 id="5-1-5-多态"><a href="#5-1-5-多态" class="headerlink" title="5.1.5 多态"></a>5.1.5 多态</h3><p>有一个简单规则可以用来判断是否应该将数据设计为继承关系，这就是“is-a”规则，它指出子类的每个对象也是超类的对象。例如，每个经理都是员工，因此，将manager类设计为Employee类的子类是有道理的；反之则不然，并不是每一个员工都是经理。</p>
<p>“is-a”规则的另一种表述是替换原则(substitution principle)。它指出程序中出现超类对象的任何地方都可以使用子类对象替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e = <span class="keyword">new</span> Employee(...);</span><br><span class="line">e = <span class="keyword">new</span> Manager(...);</span><br></pre></td></tr></table></figure>

<p>可以将子类的对象赋给超类变量。</p>
<p>在Java程序设计语言中，对象变量是多态的(polymorphic)。一个Employee类型的变量既可以引用一个Employee类型的对象，也可以引用Employee类的任何一个子类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manager boss = <span class="keyword">new</span> Manager(...);</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>] = boss;</span><br><span class="line">boss.setBonus(<span class="number">5000</span>);<span class="comment">//OK</span></span><br><span class="line">staff[<span class="number">0</span>].setBonus(<span class="number">5000</span>);<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>因为staff[0]声明的类型是Employee，而setBonus不是Employee类的方法。</p>
<p>extends继承或implements实现，是多态性的前提。</p>
<p>代码中体现多态性，其实就是一句话：父类引用指向子类对象。</p>
<p>【格式：父类名称 对象名 = new 子类名称();】或者【接口名称 对象名 = new 实现类名称()；】</p>
<p>访问成与变量的两种方式：</p>
<p>1.直接通过对象名称访问成员变量：等号左边是谁，优先用谁，没有则向上找。</p>
<p>2.间接通过成员方法访问成员变量：该方法属于谁，优先用谁，没有则向上找。被重写优先看子类</p>
<p>多态中的成员方法：</p>
<p>1.看new谁，就优先用谁，没有则向上找；</p>
<p>2.编译看左边，运行看右边。</p>
<h3 id="5-1-6-理解方法调用"><a href="#5-1-6-理解方法调用" class="headerlink" title="5.1.6 理解方法调用"></a>5.1.6 理解方法调用</h3><p>准确理解如何在对象上应用方法调用非常重要。下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。下面调用过程的详细描述：</p>
<ul>
<li>编译器查看对象的声明类型和方法名。需要注意的是：有可能存在多个名字为f但参数类型不一样的方法。编译器将会一一例举C类中所有名为f的方法和其超类中所有名为f而且可访问的方法(超类的私有方法不可访问)。至此，编译器已经知道所有可能被调用的候选方法。</li>
<li>接下来，编译器要确定方法调用中提供的参数类型。如果在所有名为f的方法中存在一个所提供参数类型完全匹配的方法，就选择这个方法。这个过程称为重载解析(overloading resolution)。至此，编译器已经知道需要调用的方法的名字和参数类型。</li>
<li>如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法。这称为静态绑定(static binding)。于此对应的是，如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用动态绑定。</li>
<li>程序运行并采用动态绑定调用方法时，虚拟机必须调用于x所引用对象的实际类型对应的那个方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就会调用这个方法；否则，将在D类的超类中寻找f(String)，以此类推。</li>
</ul>
<p>每次调用方法都要完成这个搜索，时间开销相当大。因此，虚拟机预先为每个类计算了一个方法表(method table)，其中列出了所有方法的签名和调用的实际方法。这样一来，在真正调用方法的时候，虚拟机仅要找这个表就行了。</p>
<p>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法必须也要声明为public。</p>
<h3 id="5-1-7-阻止继承：final-类和方法"><a href="#5-1-7-阻止继承：final-类和方法" class="headerlink" title="5.1.7 阻止继承：final 类和方法"></a>5.1.7 阻止继承：final 类和方法</h3><p>有时候我们可能希望阻止人们利用某个类定义子类。不允许被扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。例如，假设希望阻止人们派生Executive类的子类，就可以声明这个类的时候使用final修饰符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Excutive</span> <span class="keyword">extends</span> <span class="title">Manager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中某个特定的方法也可以被声明为final，如果这样做，子类就不能覆盖这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意：字段也可以声明为final。对于字段来说，构造对象之后就不允许改变他们的值了。不过，如果将一个类声明为final，只有其中的方法自动地称为final，而不包括字段。</p>
<h3 id="5-1-8-强制类型转换"><a href="#5-1-8-强制类型转换" class="headerlink" title="5.1.8 强制类型转换"></a>5.1.8 强制类型转换</h3><p>第三章曾经讲过，将一个类型强制转换为另外一个类型的过程称为强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">3.405</span>;</span><br><span class="line"><span class="keyword">int</span> nx = <span class="keyword">int</span>(x);</span><br></pre></td></tr></table></figure>

<p>正像有时候需要浮点数转换为整数一样，有时候也可能需要将某个类的对象引用转换成另外一个类的对象引用。要完成对象引用的强制类型转换，转换语法与数值表达式的强制类型转换类似，仅需要一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manager boss = (Manager)staff[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>进行强制类型转换的唯一原因是：要在暂时忽视对象的实际之后使用对象的全部功能。例如，在ManagerTest类中，由于某些元素是普通员工，所以staff数组必须是Employee对象数组。我们需要将数组中引用经理的元素复原成Manager对象，以便能够访问新增加的所有变量。</p>
<p>如果试图在继承链上进行向下的强制类型转换，并且“谎报”对象包含的内容，会发生什么情况呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manager boss = (Manager)staff[<span class="number">1</span>];<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<p>运行这个程序时，Java运行时系统将注意到你的承诺不符，并产生一个ClassCastException异常。为此只需要使用instanceof操作符就可以实现。</p>
<ul>
<li>只能在继承层次内进行强制类型转换；</li>
<li>在将超类强制转成子类之前，应该使用instanceof进行检查。</li>
</ul>
<p>实际上，通过强制类型转换来转换对象类型通常并不是一种好的做法。在我们的示例中，大多数情况并不需要将Employee对象强制转换成Manager对象，两个类的对象都能够正确地调用getSalary，这是因为实现多态性的动态绑定机制能够自动地找到正确的方法。</p>
<p>对象的向上转型：其实就是多态的写法：父类名称 对象名 = new 子类名称()；含义：右侧创建一个子类，把它当作父类看待使用。向上转型一定是安全的。弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的方法。解决：用对象的向下转型。</p>
<p>对象的向下转型：对象的向下转型，其实是一个还原的动作【格式：子类名称 对象名 = (子类名称)父类对象】含义：将父类对象，还原成子类对象。注意事项：必须保证对象本来创建的就是子类，才能向下转型成该子类。如果对象创建不是该子类非要转型为该子类，就会报错。ClassCastException。</p>
<p>如何才能知道一个父类引用的对象，本来是什么子类？</p>
<p>对象 instanceof 类型，这将得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal animal =  <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Dog)</span><br><span class="line">&#123;</span><br><span class="line">    Dog dog = (Dog)annimal;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(annimal <span class="keyword">instanceof</span> Cat)</span><br><span class="line">&#123;</span><br><span class="line">    Cat cat = (Cat)animal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-1-9-抽象类"><a href="#5-1-9-抽象类" class="headerlink" title="5.1.9 抽象类"></a>5.1.9 抽象类</h3><p>如果自下而上在类的继承层次结构中上移，位于上层的类更具有一般性，可能更加抽象。当前，可以让Person.getDescription()返回一个空字符串。不过还有一个更好的方法，就是使用abstract关键字，这样就完全不需要实现这个方法了。</p>
<p>抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。</p>
<p>抽象类：抽象方法所在的类，必须是抽象类。在class之前写上abstract即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了抽象方法之外，抽象类还可以包含字段和具体方法。抽象方法充当着占位方法的角色，它们在子类中具体实现。扩展抽象类可以有两种选择。一种是在子类中保留抽象类中的部分或所有抽象方法仍未定义，这样就必须将子类也标记为抽象类；另一种做法是定义全部方法，这样一来，子类就不是抽象的了。</p>
<p>如何使用抽象类和抽象方法：</p>
<ul>
<li>抽象类不能实例化。但可以创建一个具体子类的对象。</li>
<li>必须用一个子类来继承抽象类</li>
<li>子类必须覆盖重写抽象父类当中所有的抽象方法：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</li>
<li>创建子类对象进行使用</li>
</ul>
<p>注意事项：</p>
<ul>
<li>抽象类不能创建对象</li>
<li>抽象类中，可以有构造方法，供子类创建对象时，初始化父类成员使用。</li>
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>抽象类的子类，必须重写抽象父类所有的抽象方法，否则，编译无法通过。除非该子类也是抽象类。</li>
</ul>
<p>即使不含抽象方法，也可以将类声明为抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.abstractClasses;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person[] people = <span class="keyword">new</span> Person[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        people[<span class="number">0</span>] = <span class="keyword">new</span> Employee(<span class="string">&quot;Harry Hacker&quot;</span>,<span class="number">50000</span>,<span class="number">1989</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">        people[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">&quot;Maria Morris&quot;</span>,<span class="string">&quot;computer sscience&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person p : people)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(p.getName()+<span class="string">&quot;,&quot;</span>+p.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.abstractClasses;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.abstractClasses;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = LocalDate.of(year,month,day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;an employee with a salary of $%.2f&quot;</span>,<span class="keyword">this</span>.salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.abstractClasses;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String major;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,String major)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.major = major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;a studengt majoring in&quot;</span>+major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发红包案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.sendredPacket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">double</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">double</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;,money=&quot;</span>+<span class="keyword">this</span>.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.sendredPacket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">extends</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Member</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Member</span><span class="params">(String name, <span class="keyword">double</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(ArrayList&lt;Double&gt; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(list.size());</span><br><span class="line">        <span class="keyword">double</span> delta = list.remove(index);</span><br><span class="line">        <span class="keyword">double</span> money = <span class="keyword">super</span>.getMoney();</span><br><span class="line">        <span class="keyword">super</span>.setMoney(money + delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.sendredPacket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Double&gt; <span class="title">send</span><span class="params">(<span class="keyword">double</span> totalMoney,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Double&gt; redlist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> letfMoney = <span class="keyword">super</span>.getMoney();</span><br><span class="line">        <span class="keyword">if</span> (letfMoney &lt; totalMoney)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额不足！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> redlist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.setMoney(letfMoney - totalMoney);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> avg = totalMoney / count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            redlist.add(avg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.sendredPacket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendRedPacketTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Manager manager = <span class="keyword">new</span> Manager(<span class="string">&quot;Manager&quot;</span>,<span class="number">5000</span>);</span><br><span class="line">        Member[] members = <span class="keyword">new</span> Member[<span class="number">3</span>];</span><br><span class="line">        members[<span class="number">0</span>] = <span class="keyword">new</span> Member(<span class="string">&quot;memberA&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        members[<span class="number">1</span>] = <span class="keyword">new</span> Member(<span class="string">&quot;memberB&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        members[<span class="number">2</span>] = <span class="keyword">new</span> Member(<span class="string">&quot;memberC&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        manager.show();</span><br><span class="line">        <span class="keyword">for</span> (Member m : members)</span><br><span class="line">        &#123;</span><br><span class="line">            m.show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Double&gt; lista = manager.send(<span class="number">30</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Member m : members)</span><br><span class="line">        &#123;</span><br><span class="line">            m.receive(lista);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        manager.show();</span><br><span class="line">        <span class="keyword">for</span> (Member m : members)</span><br><span class="line">        &#123;</span><br><span class="line">            m.show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-10-受保护访问"><a href="#5-1-10-受保护访问" class="headerlink" title="5.1.10 受保护访问"></a>5.1.10 受保护访问</h3><p>大家都知道，最好将类中的字段标记为private，而方法标记为public。任何声明为private的内容对其他类都是不可见的。这对于子类来说也完全适用，即子类也不能访问超类的私有字段。</p>
<p>不过，在有些时候，你可能希望限制超类中的某个方法只允许子类访问，或者更少见地，可能希望允许子类的方法访问超类的某个字段。为此，需要将这些类方法或字段声明为受保护(protected)。例如，如果将超类Employee中的hireDay字段声明为proteced，而不是private，Manager方法就可以直接访问这个字段。</p>
<p>在Java中，保护字段只能由同一个包中的类访问。</p>
<p>下面对Java中的四个访问控制修饰符做个小结：</p>
<ul>
<li>仅对本类可见–private</li>
<li>对外部完全可见–public</li>
<li>对本包和所有子类可见–protected</li>
<li>对本包可见–默认，不需要修饰符。</li>
</ul>
<h2 id="5-2-Object：所有类的超类"><a href="#5-2-Object：所有类的超类" class="headerlink" title="5.2 Object：所有类的超类"></a>5.2 Object：所有类的超类</h2><p>Object类是Java中所有类的始祖，在Java中每个类都扩展了object。但是并不需要这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure>

<p>如果没有明确地指出超类，Object就被认为是这个类的超类。</p>
<h3 id="4-2-1-Object类型的变量"><a href="#4-2-1-Object类型的变量" class="headerlink" title="4.2.1 Object类型的变量"></a>4.2.1 Object类型的变量</h3><p>可以使用Object类型的变量引用任何类型的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Employee(<span class="string">&quot;Harry Hacker&quot;</span>,<span class="number">35000</span>);</span><br></pre></td></tr></table></figure>

<p>当然，Object类型的变量只能用于作为各种值的一个泛型容器。想要对其中的内容进行具体操作，还需要清楚对象的原始类型，并进行相应的强制类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e = (Employee) obj;</span><br></pre></td></tr></table></figure>

<p>在Java中，只有基本类型(primitive type)不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee[] staff = <span class="keyword">new</span> Employee[<span class="number">10</span>];</span><br><span class="line">obj = staff;<span class="comment">//ok</span></span><br><span class="line">obj = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-equals-方法"><a href="#5-2-2-equals-方法" class="headerlink" title="5.2.2 equals 方法"></a>5.2.2 equals 方法</h3><p>Object类中的equals方法用于检测一个对象是否等于一个对象。Object类中实现的equals方法将确定两个对象引用是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == otherObject)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(otherObject == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != otherObject.getClass())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Employee other = (Employee)otherObject;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(other.name) &amp;&amp; <span class="keyword">this</span>.salary == other.salary &amp;&amp; <span class="keyword">this</span>.hireDay.equals(other.hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getClass方法将返回一个对象所属的类。在我们的检测中，只有两给对象属于同一个类时，才有可能相等。</p>
<p>在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的字段都相等，就需要比较子类中的实例字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">if</span>(! <span class="keyword">super</span>.equals(otherObject))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Manager other = (Manager) otherObject;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bonus == other.bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-相等测试与继承"><a href="#5-2-3-相等测试与继承" class="headerlink" title="5.2.3 相等测试与继承"></a>5.2.3 相等测试与继承</h3><p>如果隐式和显示参数不属于同一个类，equals方法将如何处理呢？这是一个很有争议的问题。在前面的例子中，如果发现类不匹配，equals方法就返回false。但是，许多程序却喜欢使用instanceof进行检测：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> Employee))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就允许otherObject属于一个子类。但是这种方法可能会招致一些麻烦。正因为这些麻烦，所以建议不要采用这种处理方式。Java语言规范要求equals方法具有下面的特性：</p>
<ul>
<li>自反性：对于任何非空引用x，x.equals(x)应该返回true；</li>
<li>对称性：对于任何引用x和y，当且仅当y.equals(x)返回true，x.equals(y)返回true；</li>
<li>传递性：对于任何引用x，y，z如果x.equals(y)返回true，y.equals(z)返回true,x.equals(z)也应该返回true</li>
<li>一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果；</li>
<li>对于任意非空引用x，x.equals(null)应该返回false。</li>
</ul>
<p>不过，就对称性规则来说，当参数不属于同一个类的时候会有一些微妙的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e.equals(m)</span><br></pre></td></tr></table></figure>

<p>这里e是一个Employee对象，m是一个Manager对象，并且两个对象有相同的名字、薪水和雇佣日期。如果在Employee.equals中用instanceof进行检测，这个调用将返回true。然而这意味着反过来调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m.equals(e)</span><br></pre></td></tr></table></figure>

<p>也需要返回true。这就使得Manager类收到了束缚。</p>
<p>就现在看来，有两种完全不同的情形：</p>
<ul>
<li>如果子类可以有自己的相等性概念，则对称性需求将强制使用getClass检测。</li>
<li>如果由超类决定相等性概念，那么就可以使用instanceof检测，这样可以在不同子类的对象之间进行相等性比较。</li>
</ul>
<p>下面给出编写一个完美的equals方法的建议：</p>
<ul>
<li>显示参数命名为otherObject，稍后需要将它强制转换为另一个名为other的变量；</li>
<li>检测this与otherObject是否相等；</li>
<li>检测otherObject是否为null，为null，返回false</li>
<li>比较this与otherObject的类。</li>
<li>将otherObject强制转换为相应类型的变量</li>
<li>根据相等性概念的要求比较字段。使用==比较基本类型字段，使用Objects.equals比较对象字段。</li>
</ul>
<p>如果在子类中重新定义equals，就要在其中包含一个super.equals(other)调用。</p>
<h3 id="5-2-4-hashCode方法"><a href="#5-2-4-hashCode方法" class="headerlink" title="5.2.4 hashCode方法"></a>5.2.4 hashCode方法</h3><p>散列码(hash code)是由对象导出的一个整形值。散列码是没有规律的。如果x和y是两个不同的对象，x.hashCode()和y.hashCode()基本上不会相同。</p>
<p>String类使用以下算法计算散列码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    hash = <span class="number">31</span> * hash + charAt(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果重新定义了equals方法，就必须为用户可能插入散列表的对象重新定义hashCode方法。</p>
<p>例如，下面是Employee类的hashCode方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> * name.hashCode() + <span class="number">11</span> * <span class="keyword">new</span> Double(salary).hashCode() + <span class="number">13</span> * hireDay.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，还可以做的更好。首先，最好使用null安全的方法Objects.hashCode。若其参数为null，这个方法返回0，否则返回参数调用hashCode的结果。另外，使用静态方法Double.hashCode来避免创建Double对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> * Objects.hashCode(name) + <span class="number">11</span> * Double.hashCode(salary) + <span class="number">13</span> * Objects.hashCode(hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有更好的做法，需要组合多个散列值时，可以调用Object.hash并提供所有这些参数。这个方法会对各个参数调用Objects.hashCode，并组合这些散列值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, salary, hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-5-toString方法"><a href="#5-2-5-toString方法" class="headerlink" title="5.2.5 toString方法"></a>5.2.5 toString方法</h3><p>它会返回表示对象值的一个字符串。下面是一个典型例子。Point类的toString方法将返回下面这样的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Employee[name=&quot;</span> + name + <span class="string">&quot;,salary=&quot;</span> + salary + <span class="string">&quot;,hireDay&quot;</span> + hireDay + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上。还可以设计更好的一些。最好通过调用getClass().getName()获得类名的字符串。而不要将类名硬编码写道toString方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toSting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;[name=&quot;</span> + name + <span class="string">&quot;,salary=&quot;</span> + salary + <span class="string">&quot;,hireDay&quot;</span> + hireDay + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样toSting方法也可以由子类调用。当然，设计子类应该自己定义的toString方法，并加入子类的字段。如果超类使用了getClass().getName()，那么子类只要调用super.toString()就可以了。例如下面是Manager类中的toString方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">&quot;[bonus=&quot;</span> + bonus + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随处可见toString方法的主要原因是：只要对象与一个字符串通过操作符“+”连接起来Java编译器就会自动地调用toString方法来获得这个对象的字符串描述。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">String message = <span class="string">&quot;The current position is&quot;</span> + p;</span><br></pre></td></tr></table></figure>

<p>如果x是一个任意对象，并调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure>

<p>println方法就会简单地调用x.toString()，并打印输出得到的字符串。Object类定义了toString方法，可以打印对象的类名和散列码。例如调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(System.out)</span><br></pre></td></tr></table></figure>

<p>将生成以下输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.PrintStream@2f6684</span><br></pre></td></tr></table></figure>

<p>之所以得到这样的结果，是因为PrintStream类的实现者没有覆盖toString方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.equals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee alice1 = <span class="keyword">new</span> Employee(<span class="string">&quot;Alice Adams&quot;</span>,<span class="number">75000</span>,<span class="number">1987</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">        Employee alice2 = alice1;</span><br><span class="line">        Employee alice3 = <span class="keyword">new</span> Employee(<span class="string">&quot;Alice Adams&quot;</span>,<span class="number">75000</span>,<span class="number">1987</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">        Employee bob = <span class="keyword">new</span> Employee(<span class="string">&quot;Bob Brandson&quot;</span>,<span class="number">50000</span>,<span class="number">1989</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;alice1 == alice2:&quot;</span>+(alice1 == alice2));</span><br><span class="line">        System.out.println(<span class="string">&quot;alice1 == alice3:&quot;</span> + (alice1 == alice3));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;alice1.equals(alice3):&quot;</span> + alice1.equals(alice3));</span><br><span class="line">        System.out.println(<span class="string">&quot;alice1.equals(Bob):&quot;</span> + alice1.equals(bob));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;bob.toString():&quot;</span> + bob);</span><br><span class="line"></span><br><span class="line">        Manager carl = <span class="keyword">new</span> Manager(<span class="string">&quot;Carl Cracker&quot;</span>,<span class="number">80000</span>,<span class="number">1987</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">        Manager boss = <span class="keyword">new</span> Manager(<span class="string">&quot;Carl Cracker&quot;</span>,<span class="number">80000</span>,<span class="number">1987</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">        boss.setBonus(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;boss.toString():&quot;</span> + boss);</span><br><span class="line">        System.out.println(<span class="string">&quot;carl.equals(boss):&quot;</span> + carl.equals(boss));</span><br><span class="line">        System.out.println(<span class="string">&quot;alice1.hashCode():&quot;</span> + alice1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;alice3.hashCode():&quot;</span> + alice3.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;bob.hashCode():&quot;</span> + bob.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Carl.hashCode()&quot;</span> + carl.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.equals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = LocalDate.of(year,month,day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Employee other = (Employee) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name,other.name) &amp;&amp; <span class="keyword">this</span>.salary == other.salary &amp;&amp; Objects.equals(<span class="keyword">this</span>.hireDay,other.hireDay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name,salary,hireDay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getClass().getName()+ <span class="string">&quot;[name=&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;,salary=&quot;</span> + <span class="keyword">this</span>.salary + <span class="string">&quot;,hireDay=&quot;</span> + <span class="keyword">this</span>.hireDay + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.equals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,salary,year,month,day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> baseSalary = <span class="keyword">super</span>.getSalary();</span><br><span class="line">        <span class="keyword">return</span> bonus + baseSalary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> bonus)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(otherObject))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Manager other = (Manager)otherObject;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bonus == other.bonus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(<span class="keyword">super</span>.hashCode(),<span class="keyword">this</span>.bonus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">&quot;[bonus=&quot;</span> + <span class="keyword">this</span>.bonus + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-3-泛型数组列表"><a href="#5-3-泛型数组列表" class="headerlink" title="5.3 泛型数组列表"></a>5.3 泛型数组列表</h2><p>数组有一个缺点，一旦创建，程序运行期间长度不可以发生改变。</p>
<p>ArrayList是一个有参数类型(type parameter)的泛型类(generic class)。为了指定数组列表保存的元素对象的类型，需要一对尖括号将类名括起来追加到ArrayList后面，例如ArrayList&lt;Employee&gt;。</p>
<p>对于ArrayList来说，有一个尖括号<E>代表泛型；泛型：就是装在集合当中的所有元素，全部是统一的什么类型。</E></p>
<p>注意：泛型只能是引用类型，不能是基本类型。</p>
<p>对于ArrayList集合来说，直接打印得到的不是地址值而是内容。如果内容为空，得到的是空的中括号：[ ]。</p>
<h3 id="5-3-1-声明数组列表"><a href="#5-3-1-声明数组列表" class="headerlink" title="5.3.1 声明数组列表"></a>5.3.1 声明数组列表</h3><p>声明和构造一个保存Employee对象的数组列表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line"><span class="keyword">var</span> staff = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();<span class="comment">//java10</span></span><br><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br></pre></td></tr></table></figure>

<p>使用add方法可以将元素添加到数组列表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.add(<span class="keyword">new</span> Employee(<span class="string">&quot;Harry Hacker&quot;</span>,...));</span><br><span class="line">staff.add(<span class="keyword">new</span> Employee(<span class="string">&quot;Tony Tester&quot;</span>,...));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_ArrayList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//创建了一个ArrayList集合，集合的名称是list，里面装的全部是String字符串类型的数据</span></span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//向集合中添加一些数据，需要用到add方法。</span></span><br><span class="line">        list.add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[qwe]</span></span><br><span class="line">        list.add(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;zxc&quot;</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[qwe, asd, zxc]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果已经知道或是能估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.ensureCapacity(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这个方法调用将分配一个包含100个对象的内部数组。这样一来，前100次add调用不会带来开销很大的重新分配空间。另外，还可以把初始容量传递给ArrayList构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">100</span>); </span><br></pre></td></tr></table></figure>

<p>size方法将返回数组列表中包含的实际元素个数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.size();</span><br></pre></td></tr></table></figure>

<p>将返回staff数组列表的当前元素个数，它等价于数组a的a.length。</p>
<p>trimToSize()将数组列表的存储空间削减到当前大小。</p>
<p>ArrayList当中常用的方法：</p>
<ul>
<li>public boolean add(E e)：向集合当中添加元素，参数类型和泛型一致。(对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可以不用；但是对于其他集合来说，add添加动作不一定成功。)</li>
<li>public E get (int index)：从集合中获取元素，参数是索引编号，返回值就是对应位置的元素。</li>
<li>public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素。</li>
<li>public int size()：获取集合的尺寸长度，返回值是集合中包含的元素个数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_ArrayListMethod</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = list.add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加动作是否成功呢&quot;</span>+success);</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;zxc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;rty&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;fgh&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;vbn&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//从集合中获取元素：get，索引值从0开始</span></span><br><span class="line">        String name = list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">//从集合中删除元素：remove，索引值从0开始</span></span><br><span class="line">        String whoRemove = list.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//获取集合的长度尺寸，也就是元素个数</span></span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        System.out.println(size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-3-2-访问数组列表元素"><a href="#5-3-2-访问数组列表元素" class="headerlink" title="5.3.2 访问数组列表元素"></a>5.3.2 访问数组列表元素</h3><p>要设置第i个元素，可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.set(i,harry);</span><br></pre></td></tr></table></figure>

<p>它等价于对数组a的元素赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a[i] = harry;</span><br></pre></td></tr></table></figure>

<p>要得到一个数组列表的元素，可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e = staff.get(i);</span><br></pre></td></tr></table></figure>

<p>这等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e = a[i];</span><br></pre></td></tr></table></figure>

<p>可以使用for each循环遍历数组列表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Employee e : staff)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> something with e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相同效果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; staff.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    Employee e = staff.get(i);</span><br><span class="line">    <span class="keyword">do</span> something with i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_ArrayListBasic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//泛型只能使用引用类型，不能使用基本类型</span></span><br><span class="line">        list.add(<span class="number">100</span>);</span><br><span class="line">        list.add(<span class="number">120</span>);</span><br><span class="line">        list.add(<span class="number">220</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.ArrayListTest;</span><br><span class="line"><span class="keyword">import</span> com.NoTrouble.equals.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        staff.add(<span class="keyword">new</span> Employee(<span class="string">&quot;Carl Cracker&quot;</span>,<span class="number">75000</span>,<span class="number">1987</span>,<span class="number">12</span>,<span class="number">15</span>));</span><br><span class="line">        staff.add(<span class="keyword">new</span> Employee(<span class="string">&quot;Harry Hacker&quot;</span>,<span class="number">50000</span>,<span class="number">1989</span>,<span class="number">10</span>,<span class="number">1</span>));</span><br><span class="line">        staff.add(<span class="keyword">new</span> Employee(<span class="string">&quot;Tony Tester&quot;</span>,<span class="number">40000</span>,<span class="number">1990</span>,<span class="number">3</span>,<span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Employee e : staff)</span><br><span class="line">        &#123;</span><br><span class="line">            e.raiseSalary(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Employee e : staff)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;e=&quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-3-类型化与原始数组列表的兼容性"><a href="#5-3-3-类型化与原始数组列表的兼容性" class="headerlink" title="5.3.3 类型化与原始数组列表的兼容性"></a>5.3.3 类型化与原始数组列表的兼容性</h3><h2 id="5-4-对象包装器与自动装箱"><a href="#5-4-对象包装器与自动装箱" class="headerlink" title="5.4 对象包装器与自动装箱"></a>5.4 对象包装器与自动装箱</h2><p>有时，需要将int这样的基本类型转换为对象。所有基本类型都有一个与之对应的类。例如，Integer类对应基本类型int。通常，这些类称为包装器(wrapper)。这些包装器类有显而易见的名字：Integer、Long、Float、Double、Short、Byte、Character、Boolean。包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，包装器类还是final，因此因此不能派生它们的子类。</p>
<p>假设想要定义一个整型数组列表。遗憾的是，尖括号中的类型参数不允许是基本类型，也就是说，不允许写成ArrayList&lt;int&gt;。这里就可以用到Integer包装器类。我们可以声明一个Integer对象的数组列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>幸运的是，有一个很有用的特性，从而可以很容易地向ArrayList&lt;Integer&gt;添加int类型的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>将自动变换成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(Integer.valueOf(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>这种变换称为自动装箱(aotoboxing)。</p>
<p>相反地，当一个Integer对象赋给一个int值时，将会自动地拆箱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = list.get(i);</span><br><span class="line"><span class="comment">//转换为</span></span><br><span class="line"><span class="keyword">int</span> n = list.get(i).intValue();</span><br></pre></td></tr></table></figure>

<p>自动地装箱和拆箱甚至也适用于算术表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="number">3</span>;</span><br><span class="line">n++;</span><br></pre></td></tr></table></figure>

<p>大多数情况下容易有一种假象，认为基本类型与它们的对象包装器是一样的。但它们有一点有很大不同：同一性。大家都知道，==运算符可以应用于包装器对象，不过检测的是对象是否有相同的内存位置，因此，下面的比较通常会失败：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1000</span>;</span><br><span class="line">Integer b = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span>(a == b )</span><br><span class="line">&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，Java实现却有可能(如果选择这么做)让他成立。如果经常出现的值包装到相同的对象中，这种比较就可能成功这种不确定的结果并不是我们所希望的。解决这个问题的办法是在比较两个包装器对象时调用equals方法。</p>
<p>注意：自动装箱规范要求boolean、byte、cahr&lt;=127，介于-128和127之间的short和int被包装到固定的对象中。例如在前面的例子中将a和b初始化为100，那么他们的比较结果一定成功。</p>
<p>关于自动装箱还有几点需要说明。首先，由于包装器类引用可以为null，所以自动装箱有可能会抛出一个NullPointerException异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="number">2</span> * n);<span class="comment">//throws NullPointerException</span></span><br></pre></td></tr></table></figure>

<p>另外，如果在一个条件表达式混合使用Integer和Double类型，Integer值就会拆箱，提升为double，再装箱为Double：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="number">1</span>;</span><br><span class="line">Double x =<span class="number">2.0</span>;</span><br><span class="line">System.out.println(<span class="keyword">true</span> ? n : x);<span class="comment">//prints 1.0</span></span><br></pre></td></tr></table></figure>

<p>最后强调一下，装箱和拆箱是编译器要做的工作，而不是虚拟机。编译器在生成类字节码时会插入必要的方法调用。虚拟机只是执行这些字节码。</p>
<p>API：java.lang.Integer</p>
<ul>
<li>int intValue()：将这个Integer对象的值作为一个int返回</li>
<li>static String toString(int i)：返回一个新的String对象，表示指定数值i的十进制表示。</li>
<li>static String toString(int i, int radix)：返回数值i基于radix参数指定进制的表示。</li>
<li>static int parseInt(String s)：</li>
<li>static int parseInt(String s, int radix)：返回字符串s表示整数，指定字符串必须表示一个十进制整数(第一种方法)，或者采用radix参数指定的进制(第二种进制)。</li>
<li>static Integer valueOf(String s)</li>
<li>static Integer valueOf(String s, int radix)：返回一个新的Integer对象，用字符串s表示的整数初始化。指定字符串必须表示一个十进制整数(第一种方法)，或者采用radix参数指定的进制(第二种方法)。</li>
</ul>
<p>API：java.text.NumberFormat</p>
<ul>
<li>Number parse(String s)：返回数字值，假设给定的String表示一个值。</li>
</ul>
<h2 id="5-5-参数数量可变的方法"><a href="#5-5-参数数量可变的方法" class="headerlink" title="5.5 参数数量可变的方法"></a>5.5 参数数量可变的方法</h2><p>可以提供参数数量可变的方法(有时候这些方法称为“参变”(varargs)方法)。前面已经看到过这样一个方法：printf。下面的方法调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">System.out.printf(<span class="string">&quot;%d%s&quot;</span>,n,<span class="string">&quot;widgets&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这两条语句都调用一个方法，不过一个调用有两个参数，另一个调用有三个参数。</p>
<p>printf方法是这样定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStream</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String fmt,Object... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> format(fmt,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里省略号…是Java代码的一部分，它表明这个方法可以接收任意数量的对象(除fmt参数之外)。实际上，printf方法接收两个参数，一个是格式字符串，另外一个是Object[]数组，其中保存着所有其他参数(如果调用者提供的是整数或者其他基本类型的值，会把它们装箱为对象)。现在不可避免地要扫描fmt字符串，并将第i个格式化说明符与args[i]的值匹配起来。</p>
<p>换句话说，对于printf的实现者来说，Object…参数类型与Object[]完全一样。编译器需要转换每个printf调用，将参数绑定到数组中，并在必要的时候进行自动装箱：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%d %s&quot;</span>,<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> Integer(n),<span class="string">&quot;widegts&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>你自己也可以定义有可变参数的方法，可以为参数指定任意类型，甚至是基本类型。下面是一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span>...values)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> largest = Double.NEGATIVE_INFINITY;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> v : values)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v &gt; largest)</span><br><span class="line">        &#123;</span><br><span class="line">            largest = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-枚举类"><a href="#5-6-枚举类" class="headerlink" title="5.6 枚举类"></a>5.6 枚举类</h2><p>在第三章已经看到如何定义一个枚举类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Size</span></span>&#123;SMALL,MEDIUM,LARGE,EXTRA_LARGE&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上，这个声明定义的类型是一个类，它刚好有四个实例，不可能构造新的对象。</p>
<p>因此，在比较两个枚举类型的值时，并不需要调用equals，直接用“==”就可以了。</p>
<p>如果需要的话，可以为枚举类型增加构造器 、方法和字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Size</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>),MEDIUM(<span class="string">&quot;M&quot;</span>),LARGE(<span class="string">&quot;L&quot;</span>),EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbreviation)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abbreviation = abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbreviation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举的构造器是私有的。可以像前例中一样省略private修饰符。如果声明一个enum构造器为public或protected，会出现语法错误。所有的枚举类型都是Enum类的子类。它们继承了这个类的许多方法。其中最有用的一个是toString，这个方法会返回枚举常量名。例如，Size.SMALL.toString()将会放回字符串“SMALL”。</p>
<p>toString的逆方法是静态方法valueOf。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Size s =Enum.valueOf(Size.class,<span class="string">&quot;SMALL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将s设置成Size.SMALL。</p>
<p>每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Size[] values = Size.values();</span><br></pre></td></tr></table></figure>

<p>返回包含元素Size.SMALL，Size.MEDIU，Size.LARGE，Size.EXTRA_LARGE的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.enums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;Enter a size:(SMALL,MEDIUM,LARGE,EXTRA_LARGE)&quot;</span>);</span><br><span class="line">        String input = sc.next().toUpperCase();<span class="comment">//将字符串小写转为大写</span></span><br><span class="line">        Size size = Enum.valueOf(Size.class,input);</span><br><span class="line">        System.out.println(<span class="string">&quot;abbreviation=&quot;</span> + size.getAbbreviation());</span><br><span class="line">        <span class="keyword">if</span> (size == Size.EXTRA_LARGE)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;GOOD JOB--you paid attention to the .&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Size</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>),MEDIUM(<span class="string">&quot;M&quot;</span>),LARGE(<span class="string">&quot;L&quot;</span>),EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbreviation)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abbreviation = abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbreviation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.abbreviation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-7-反射"><a href="#5-7-反射" class="headerlink" title="5.7 反射"></a>5.7 反射</h2><p>反射库(fefiection library)提供le’yi’ge 丰富且精巧的工具集，可以用来编写能够动态操纵Java代码的程序。使用反射，Java可以支持用户界面生成器、对象关系映射器以及很多其他需要动态查询类能力的开发工具。</p>
<p>反射的机制：将类的各个组成部分封装为其他对象</p>
<p><img src="/2020/10/19/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BB%A7%E6%89%BF/image-20201018131720276.png" alt="image-20201018131720276"></p>
<p>能够分析类能力的程序称为反射(reflective)。反射机制的功能极其强大，在下面几小节可以看到，反射机制可以用来：</p>
<ul>
<li>在运行时分析类的能力；</li>
<li>在运行时检查类对象，例如，编写一个适用于所有类的toString方法；</li>
<li>实现泛型数组操作代码；</li>
<li>利用Method对象，这个对象很像C++中的函数指针。</li>
</ul>
<p>反射是一种功能强大复杂的机制。主要是开发工具的程序员对它感兴趣，一般程序员并不需要考虑反射机制。</p>
<h3 id="5-7-1-Class类"><a href="#5-7-1-Class类" class="headerlink" title="5.7.1 Class类"></a>5.7.1 Class类</h3><p>在程序运行期间，Java运行时系统始终为所有对象维护一个运行时类标识。这个信息会跟踪每个对象所属的类。虚拟机利用运行时类信息选择要执行的正确的方法。</p>
<p>不过，可以使用一个特殊的Java类访问这些信息。保存这些信息的类名为Class，这个名字有些让人困惑。Object类中的getClass()方法将会返回一个class类型的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">...;</span><br><span class="line">Class cl = e.getClass();</span><br></pre></td></tr></table></figure>

<p>就像Employee对象描述一个特定员工的属性一样，Class对象会描述一个特定类的属性。可能最常用的Class方法就是getName。这个方法将会返回类的名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.Println(e.getClass().getName() + <span class="string">&quot;&quot;</span> + e.getName());<span class="comment">//Employee Harry Hacker</span></span><br></pre></td></tr></table></figure>

<p>如果类在一个包，包的名字也作为类名的一部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random generator = <span class="keyword">new</span> Random();</span><br><span class="line">Class cl = generation.Class();</span><br><span class="line">String name = cl.getName();<span class="comment">//name is set to &quot;java.util.Random&quot;</span></span><br></pre></td></tr></table></figure>

<p>还可以使用静态方法forName获得类对应的Class对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String className = <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line">Class cl = Class.forName(className);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>如果类名保存在一个字符串中，这个字符串会在运行时变化，就可以使用这个方法。如果ClassName是一个类名或接口名，这个方法可以正常执行。否则，forName方法将抛出一个检查型异常(checked exception)。无论如何使用这个方法，都应该提供一个异常处理器(exception handler)。关于如何提供异常处理器，请参看下一节。</p>
<p>获得Class类对象的第三种方法是一个很方便的快捷方式。如果R是任意的Java类型，T.class将代表匹配的类的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cl1 = Random.class;<span class="comment">// if you import java.util.*;2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cl2</span> </span>= <span class="keyword">int</span>.class;</span><br><span class="line">Class cl3 = Double.class;</span><br></pre></td></tr></table></figure>

<p>请注意，一个Class对象实际上表示的是一个类型，这可能是类，也可能不是类。例如，int不是类，但int.Class是一个Class类型的对象。</p>
<p>虚拟机为每一个类型管理一个唯一的Class对象。因此，可以利用==运算符实现两个类对象的比较。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(e.getClass == Employee.class)...;<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>如果e是一个Employee实例，这个测试将通过。与条件e instanceof Employee不同，如果e是某个子类的实例，这个测试将失败。</p>
<p>如果有一个Class类型的对象，可以用它构造类的实例。调用getConstrustor方法将得到一个Construstor类型的对象，然后使用newInstance方法来构造一个实例。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String className = <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line">Class cl = Class.forName(className);</span><br><span class="line">Object obj = cl.getConstructor().newInstance();</span><br></pre></td></tr></table></figure>

<p>如果这个类没有无参数的构造器，getConstructor方法会抛出一个异常。可参见5.7.7节了解如何调用其他构造器。</p>
<p>获取Class对象的方式：</p>
<ul>
<li>Class.forName(全类名)；将字节码文件加载进内存，返回Class对象；(多用于配置文件，将类名定义在配置文件中)</li>
<li>类名.Class：通过类名的属性class获取；(多用于参数的传递)</li>
<li>对象.getClass()：getClaa()方法在Object类中定义着。(多用于对象获取字节码的方式)</li>
</ul>
<p>使用Class对象功能：</p>
<ul>
<li><p>获取功能：</p>
<ul>
<li>获取成员变量：<ul>
<li>Field[ ] getFields()：获取所有public 修饰的成员变量；</li>
<li>Field getField(String name)：获取指定名称的public 修饰的成员变量；</li>
<li>Field[ ] getDeclaredFields()：获取所有的成员变量，不考虑修饰符。</li>
<li>Field getDeclaredField(String name)：获取指定名称的成员变量，不考虑修饰符。 </li>
</ul>
</li>
<li>获取构造方法：<ul>
<li>Constructor[ ] getConstructors()</li>
<li>Constructor getConstructor(String name,类&lt;?&gt;…parameterTypes)</li>
<li>Constructor[ ] getDeclaredConstructors()</li>
<li>Constructor getDeclaredConstructor(String name,类&lt;?&gt;…parameterTypes)</li>
</ul>
</li>
<li>获取成员方法：<ul>
<li>Method[ ] getMethods()</li>
<li>Method getMethod(String name,类&lt;?&gt;…parameterTypes)</li>
<li>Method[ ] getDeclaredMethods()</li>
<li>Method[ ] getDeclaredMethod(String name,类&lt;?&gt;…parameterTypes)</li>
</ul>
</li>
<li>获取类名：<ul>
<li>String getName( )</li>
</ul>
</li>
</ul>
<p>Field：成员变量</p>
<ul>
<li>操作：<ul>
<li>设置值：void set(Object obj,Object value)</li>
<li>获取值：get(Object obj)</li>
<li>忽略访问修饰符的安全检查：setAccessible(true)</li>
</ul>
</li>
</ul>
<p>Constructor：构造器</p>
<ul>
<li>创建对象：<ul>
<li>T newInstance(object…initargs)：如果使用空参构造方法创建对象，操作可以简化：Class.newInstacne();</li>
<li>Class对象.getDeclaredConstructor().newInstance()</li>
</ul>
</li>
</ul>
<p>Method：成员方法</p>
<ul>
<li>执行方法：<ul>
<li>Object invoke(Object obj,Object…args)</li>
<li>String getName()</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflecTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//可以执行创建任意类的对象，执行任意方法</span></span><br><span class="line">        <span class="comment">//1.加载配置文件：</span></span><br><span class="line">        <span class="comment">//1.1创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//1.2加载配置文件，转换为一个集合</span></span><br><span class="line">        <span class="comment">//1.2.1获取文件的路径</span></span><br><span class="line">        ClassLoader classLoader = ReflecTest.class.getClassLoader();</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;Pro.Properties&quot;</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line">        <span class="comment">//2.获取配置文件中定义的数据</span></span><br><span class="line">        String className = pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        String methodName = pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">//3.加载该类进内存</span></span><br><span class="line">        Class cl = Class.forName(className);</span><br><span class="line">        <span class="comment">//4.创建对象</span></span><br><span class="line">        Object obj = cl.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">//5.获取方法对象</span></span><br><span class="line">        Method method = cl.getMethod(methodName);</span><br><span class="line">        <span class="comment">//6.执行方法</span></span><br><span class="line">        method.invoke(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>API：java.lang.Class</p>
<ul>
<li>static Class forName(String className)：返回一个class对象，表示名为className的类</li>
<li>Constructor getConstructor(class… paprameterTypes)：生成一个对象，描述有指定参数类型的构造器。</li>
</ul>
<p>java.lang.reflect.Constructor</p>
<ul>
<li>Object newInstance(object… params)：将params传递到构造器，来构造这个构造声明类的一个新实例</li>
</ul>
<p>java.lang.Throwable</p>
<ul>
<li>void printStackTrace()：将Throwable对象和堆栈轨迹打印到标准错误流。</li>
</ul>
<h3 id="5-7-2-声明异常入门"><a href="#5-7-2-声明异常入门" class="headerlink" title="5.7.2 声明异常入门"></a>5.7.2 声明异常入门</h3><p>我们将在第七章全面地介绍异常处理机制，但现在时常遇到一些可能抛出异常的方法。</p>
<p>当运行时放生错误时，程序就会抛出一个异常。抛出异常比终止程序要灵活的多，这是因为可以提供一个处理器(handler)捕获这个异常并进行处理。</p>
<p>如果没有提供处理器，程序就会终止，并在控制台打印出一个消息，给出异常的类型。你可能在前面已经看到过一些异常报告，例如，偶然使用null引用或者数组越界等。</p>
<p>异常有两种类型：非检查型(unchecked)异常和检查型(checked)异常。对于检查型异常，编译器将会检查你是否知道这个异常并做好准备来处理后果。不过，有很多常见的异常，例如，越界错误或访问null引用，都属于非检查型异常。编译器并不期望你为这些异常提供处理器。毕竟，你应该集中精力避免这些错误的发生，而不要将精力花在编写异常处理器上。</p>
<p>不是所有错误都是可以避免的。如果竭尽全力还是可能发生异常，大多数JavaAPI都会抛出一个检查型异常。Class.forName方法就是一个例子。没有办法确保有指定名字的类一定存在。在第七章，将会看到几种异常处理的策略。现在我们只介绍最简单的一个策略。</p>
<p>如果一个方法包含一条可能抛出检查异常的语句，则在方法名上增加一个throws子句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomethingWithClass</span><span class="params">(String name)</span> <span class="keyword">throws</span> ReflectiveOperationException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class cl = Class.forName(name);</span><br><span class="line">    <span class="keyword">do</span> something with cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用这个方法的任何方法也都需要一个throws声明。这也包括main方法。如果一个异常确实出现，main方法将终止并提供一个堆栈轨迹。</p>
<h3 id="5-7-3-资源"><a href="#5-7-3-资源" class="headerlink" title="5.7.3 资源"></a>5.7.3 资源</h3><p>类通常有一些关联的数据文件，例如：</p>
<ul>
<li>图像和声音文件；</li>
<li>包含消息字符串和按钮标签的文本文件。</li>
</ul>
<p>在Java中，这些关联文件都被称为资源(resource)。</p>
<h3 id="5-7-4-利用反射分析类的能力"><a href="#5-7-4-利用反射分析类的能力" class="headerlink" title="5.7.4 利用反射分析类的能力"></a>5.7.4 利用反射分析类的能力</h3><p>下面简要介绍反射机制最重要的内容——检查类的结构。</p>
<p>在java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的字段、方法和构造器。这三个类都有一个叫getName的方法、用来返回字段、方法或构造器的名称。Field类有个getType方法，用来返回描述字段类的一个对象，这个对象的类型同样是Class。Method和Constructor类有报告参数类型的方法，method类还有一个报告返回值类型的方法。这三个类都有一个名为getModifiers的方法，它将返回一个整数，用于不同0/1位描述所使用的修饰符，如public和static。另外，还可以利用java.lang.reflect包中的Modifier类的静态方法分析getModifiers返回的这个整数。例如，可以使用Modifier类中isPublic、isPrivate或isFinal判断方法或构造器是public、private还是final。我们需要做的就是在getNodifiers返回的整数上调用Modifier类中适当的方法，另外们还可以将方法修饰符打印出来。</p>
<p>Class类中的getFields、getMethods和getConstructors方法将分别返回这个类支持的公共字段、方法和构造器的数组，其中包括超类的公共成员。Class类的getDeclareFields、getDeclareMethods和getDeclareConstructors方法将分别返回类中声明的全部字段、方法和构造器的数组，其中包括私有成员、包成员、受保护成员，但不包括超类的成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            name = args[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;Enter class name (e.g. java.util.Date):&quot;</span>);</span><br><span class="line">            name = sc.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(name);</span><br><span class="line">        Class supercl = cl.getSuperclass();</span><br><span class="line">        String modifiers = Modifier.toString(cl.getModifiers());</span><br><span class="line">        <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(modifiers + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;class&quot;</span> + name);</span><br><span class="line">        <span class="keyword">if</span> (supercl != <span class="keyword">null</span> &amp;&amp; supercl != Object.class)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;extends&quot;</span> + supercl.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;\n&#123;\n&quot;</span>);</span><br><span class="line">        printConstructors(cl);</span><br><span class="line">        System.out.println();</span><br><span class="line">        printMethods(cl);</span><br><span class="line">        System.out.println();</span><br><span class="line">        printFields(cl);</span><br><span class="line">        System.out.println(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print all constructors of a class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">        Constructor[] constructors = cl.getDeclaredConstructors();<span class="comment">//构造器数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">            String name = c.getName();</span><br><span class="line">            System.out.print(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            String modifiers = Modifier.toString(c.getModifiers());<span class="comment">//构造器的修饰符</span></span><br><span class="line">            <span class="keyword">if</span> (constructors.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(modifiers + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(name + <span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//print parameter types</span></span><br><span class="line">            Class[] paramTypes = c.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">                    System.out.print(paramTypes[j].getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;);&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * prints all methods of a class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@para</span> cl a class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">        Method[] methods = cl.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            Class retType = m.getReturnType();</span><br><span class="line">            String name = m.getName();</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            <span class="comment">//print modifiers,return type and method name</span></span><br><span class="line">            String modifiers = Modifier.toString(m.getModifiers());</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(modifiers + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(retType.getName() + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//print parameter</span></span><br><span class="line">            Class[] paraTypes = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; paraTypes.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(paraTypes[j].getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;);&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * prints all fields of a class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class cl)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Field[] fields = cl.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field f : fields)</span><br><span class="line">        &#123;</span><br><span class="line">            Class type = f.getType();</span><br><span class="line">            String name = f.getName();</span><br><span class="line">            System.out.print(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            String modifiers = Modifier.toString(f.getModifiers());</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(modifiers + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(type.getName() + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-7-5-使用反射在运行时分析对象"><a href="#5-7-5-使用反射在运行时分析对象" class="headerlink" title="5.7.5 使用反射在运行时分析对象"></a>5.7.5 使用反射在运行时分析对象</h3><p>从前面一节，我们已经知道如何查看任意对象数据字段字段的名字和类型：</p>
<ul>
<li>获得对应的Class对象</li>
<li>在这个Class对象上调用getDeclaredFields</li>
</ul>
<p>本节将进一步查看字段的具体内容。当然，在编写程序时，如果想查看字段名和类型，查看对象中指定字段的内容是一件很容易地事情。而利用反射机制可以查看在编译时还不知道的对象字段。</p>
<p>要做到这一点，关键方法是Field类中的get方法。如果f是一个Field类型的对象，（通过getDeclaredFields得到的对象）obj是某个包含f字段的类的对象，f.get(obj)将返回一个对象，其值为obj的当前字段值。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee harry = <span class="keyword">new</span> Employee(<span class="string">&quot;Harry hacker&quot;</span>,<span class="number">50000</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">1989</span>);</span><br><span class="line">Class cl = harry.getClass();</span><br><span class="line">Field f = cl.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">Object v = f.get(harry);</span><br></pre></td></tr></table></figure>

<p>当然，不仅可以获得值，也可以设置值。调用f.set(obj,value)将把对象obj的f表示的字段设置为新值。</p>
<p>实际上，这段代码存在一个问题。由于name是一个私有字段，所以get和set方法会抛出一个IllegalAccessException。只能对可以访问的字段使用get和set方法。Java安全机制允许查看一个对象有哪些字段，但是除非拥有访问权限，否则不允许写那些字段的值。</p>
<p>反射机制的默认行为受Java的访问控制。不过，可以调用Field、Method或Constructor对象的setAccessible方法覆盖Java的访问控制。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f.setAccessible(<span class="keyword">true</span>);<span class="comment">//now OK to call f.get(harry)</span></span><br></pre></td></tr></table></figure>

<p>serAccessible方法是AccessibleObject类中的一个方法，它是Field、Method和Constructor类的公共超类。这个特性是为调试、持久存储和类似机制提供的。本节将利用它编写一个通用的toString方法。如果不允许访问，setAccessible调用会抛出一个异常。</p>
<p>由于太多的库都是用了反射，所以当你使用反射访问一个模块中的非公共特性时，Java9和10只会给出一个警告。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.objectAnalyzer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.AccessibleObject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnalyzer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Object&gt; visited = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(Object obj)</span><span class="keyword">throws</span> ReflectiveOperationException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(obj))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.add(obj);</span><br><span class="line">        Class cl = obj.getClass();</span><br><span class="line">        <span class="keyword">if</span> (cl == String.class)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cl.isArray())</span><br><span class="line">        &#123;</span><br><span class="line">            String r = cl.getComponentType() + <span class="string">&quot;[]&#123;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Array.getLength(obj); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    r += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                    Object val = Array.get(obj,i);</span><br><span class="line">                    <span class="keyword">if</span> (cl.getComponentType().isPrimitive())</span><br><span class="line">                    &#123;</span><br><span class="line">                        r += val;</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        r += toString(val);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String r = cl.getName();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            r += <span class="string">&quot;[&quot;</span>;</span><br><span class="line">            Field[] fields = cl.getDeclaredFields();</span><br><span class="line">            AccessibleObject.setAccessible(fields,<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">for</span> (Field f : fields)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!Modifier.isStatic(f.getModifiers()))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!r.endsWith(<span class="string">&quot;[&quot;</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        r += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    r += f.getName() + <span class="string">&quot;=&quot;</span>;</span><br><span class="line">                    Class t = f.getType();</span><br><span class="line">                    Object val = f.get(obj);</span><br><span class="line">                    <span class="keyword">if</span> (t.isPrimitive())</span><br><span class="line">                    &#123;</span><br><span class="line">                        r += val;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        r += toString(val);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r +=<span class="string">&quot;]&quot;</span>;</span><br><span class="line">            cl = cl.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cl != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-7-6-使用反射编写泛型数组代码"><a href="#5-7-6-使用反射编写泛型数组代码" class="headerlink" title="5.7.6 使用反射编写泛型数组代码"></a>5.7.6 使用反射编写泛型数组代码</h3><p>java.lang.reflect包中的Array类允许动态地创建数组。例如，Array类中的copyOF方法实现就使用了这个类。回想一下，这个方法可以用于扩展一个已经填满的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee[] a = <span class="keyword">new</span> Employee[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// array is full</span></span><br><span class="line">a = Arrays.copyOf(a,<span class="number">2</span> * a.length);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] badCopyOf(Object[] a, <span class="keyword">int</span> newLength)</span><br><span class="line">&#123;</span><br><span class="line">    Object[] newArray = <span class="keyword">new</span> Object[newLength];</span><br><span class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(a.length,newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，在实际使用得到的数组时会遇到一个问题。这段代码返回的数组类型是一个对象数组(Object[ ])，这是因为我们使用了下面这行代码来创建这个数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Object[newLength]</span><br></pre></td></tr></table></figure>

<p>对象数组不能强制转换称为员工数组(Employee[ ])。如果这样做，Java虚拟机在运行时生成一个ClassCastException异常。这里的关键是，前面已经看到，Java数组会记住每个元素的类型，即创建数组时new表达式中使用的元素类型。将一个Employee[ ]临时转换成Object[ ]数组，然后再把它转换回来是可以的，但一个从开始就是Object[ ]的数组却永远不能转换成Employee[ ]数组。为了编写这类通用的数组代码，需要能够创建与原数组类型相同的新数组。为此，需要java,lang.reflect包中Array类的一些方法。其中最关键的是Array类的静态方法newInstance，这个方法能够构造一个新数组。在调用这个方法时必须提供两个参数，一个是数组的元素类型，一个是数组的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object newArray = Array.newInstance(componentType,newLength);</span><br></pre></td></tr></table></figure>

<p>为了通过具体实现，需要获得新数组的长度和元素类型。</p>
<p>可以通过调用Array.getLength(a)获得数组的长度。Array类的静态getLength方法会返回一个数组的长度。要获得新数组的元素类型，就需要完成以下工作：</p>
<ul>
<li>首先获得a数组的类对象；</li>
<li>确认它确实是一个数组；</li>
<li>使用Class类的getComponentType方法(只为表示数组的类对象定义了这个方法)确定数组的正确类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class cl = a.getClass();</span><br><span class="line">    <span class="keyword">if</span>(!cl.isArray())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Class componentType = cl.getComponentType();</span><br><span class="line">    <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">    Object newArray = Array.newInstance(componentType,length);</span><br><span class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(length,newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这个CopyOf方法可以用来扩展任意类型的数组，而不仅是对象数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">a = (<span class="keyword">int</span>[]) goodCopyOf(a,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>为了能够实现上述操作，应该将goodCopyOf的参数声明为Object类型，而不要声明为对象型数组(Object [ ])。整型数组类型int[ ]可以转换成Object，但不能转成对象数组！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOfTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        a = (<span class="keyword">int</span>[])goodCopyOf(a,<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">        String[] b= &#123;<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Dick&quot;</span>,<span class="string">&quot;Harry&quot;</span>&#125;;</span><br><span class="line">        b = (String[])goodCopyOf(b,<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(b));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;The following call will generate an exception&quot;</span>);</span><br><span class="line">        b = (String[])badCopyOf(b,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object[] badCopyOf(Object[] a, <span class="keyword">int</span> newLength)</span><br><span class="line">    &#123;</span><br><span class="line">        Object[] newArray = <span class="keyword">new</span> Object[newLength];</span><br><span class="line">        System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(a.length,newLength));</span><br><span class="line">        <span class="keyword">return</span> newArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Class cl = a.getClass();</span><br><span class="line">        <span class="keyword">if</span> (!cl.isArray())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class componentType = cl.getComponentType();</span><br><span class="line">        <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">        Object newArray = Array.newInstance(componentType,newLength);</span><br><span class="line">        System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(length,newLength));</span><br><span class="line">        <span class="keyword">return</span> newArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-7-7-调用任意方法和构造器"><a href="#5-7-7-调用任意方法和构造器" class="headerlink" title="5.7.7 调用任意方法和构造器"></a>5.7.7 调用任意方法和构造器</h3><p>回想一下，可以用Field类的get方法查看一个对象的字段。与之类似，Method类有一个invoke方法，允许你调用包装在当前Method对象中的方法。invoke方法的签名是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj,Object...args)</span></span></span><br></pre></td></tr></table></figure>

<p>第一个参数是隐式参数，其余的对象提供了显示参数。对于静态方法，第一个参数可以忽略，即可以将它设置为null。</p>
<p>例如，假设用ml表示Employee类的getName方法，下面这条语句显示了如何调用这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String n  = (String)ml.invoke(harry);</span><br></pre></td></tr></table></figure>

<p>如果返回类型是基本类型，invoke方法会返回其包装类型。例如，假设m2表示Employee类的getSalary方法，那么会返回的对象实际上是一个Double，必须相应地完成强制类型转换。可以使用自动拆箱将它转换为一个double：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> s = (Double)m2.invoke(harry);</span><br></pre></td></tr></table></figure>

<p>如何得到Method对象呢？当然，可以调用getDelareMethods方法，然后搜索返回的Method对象数组，直到发现想要的方法为止。也可以调用Class类的getMethod方法得到想要的方法。它与getField方法类似。getField方法根据表示字段名的字符串，返回一个Field对象。不过，有可能存在若干个同名的方法，因此要准确地得到想要的方法必须格外小心。有鉴于此，还必须提供想要的方法的参数类型。getMethod的签名是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name,Class...parameterTypes)</span></span></span><br></pre></td></tr></table></figure>

<p>例如，下面说明如何获得Employee类的getName方法和raiseSalary方法的方法指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method m1 = Employee.class.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">Method m2 = Employee.class.getMethod(<span class="string">&quot;raiseSalary&quot;</span>,<span class="keyword">double</span>.class);</span><br></pre></td></tr></table></figure>

<p>可以使用类似的方法调用任意的构造器。将构造器的参数类型提供给Class.getConstructor方法，并把参数值提供给Constructor.newInstance方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cl = Random.class;</span><br><span class="line">Constructor cons = cl.getConstructor(<span class="keyword">long</span>.class);</span><br><span class="line">Object obj = cons.newInstance(<span class="number">42L</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.NoTrouble.methods;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Methods</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> ReflectiveOperationException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Method square =  Methods.class.getMethod(<span class="string">&quot;square&quot;</span>, <span class="keyword">double</span>.class);</span><br><span class="line">        Method sqrt = Math.class.getMethod(<span class="string">&quot;sqrt&quot;</span>, <span class="keyword">double</span>.class);</span><br><span class="line"></span><br><span class="line">        printTable(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,square);</span><br><span class="line">        printTable(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,sqrt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the square of a number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x a number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> x squared</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTable</span><span class="params">(<span class="keyword">double</span> from, <span class="keyword">double</span> to, <span class="keyword">int</span> n, Method f)</span><span class="keyword">throws</span> ReflectiveOperationException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> dx = (to - from) / (n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> x = from; x &lt;= to; x += dx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> y = (Double)f.invoke(<span class="keyword">null</span>,x);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%10.4f | %10.4f%n&quot;</span>,x,y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子清楚地表明，利用method对象可以实现C语言中函数指针所完成的所有操作。同C中一样，这种编程风格不是很简便，而且总是很容易出错。如果在调用方法的时候提供了错误的参数会放生什么？invoke方法将会抛出一个异常。另外，invoke的参数和返回值必须是Object类型。这就意味着必须来回进行多次强制类型转换。这样一来，编译器会丧失检查代码的机会，以至于等到测试阶段才会发现错误，而这个时候查找和修正错误会麻烦的多。不仅如此，使用反射获得方法指针的代码比直接调用方法的代码慢得多。</p>
<p>有鉴于此，建议仅在绝对必要的时候才在你自己的程序中使用Method对象。通常更好的是使用接口以及Java8引入的lambda表达式。特别要强调：我们建议Java开发者不要使用回调函数的Method对象。可以使用回调的接口，这样不仅代码执行的速度更快，也更易于维护。</p>
<h2 id="5-8-继承的设计技巧"><a href="#5-8-继承的设计技巧" class="headerlink" title="5.8 继承的设计技巧"></a>5.8 继承的设计技巧</h2><p>在本章的最后，我们给出对设计继承很有帮助的一些技巧：</p>
<ul>
<li>将公共操作和字段放在超类中：这就是将姓名字段放在Person类中，而没有将它重复放在Employee和Student类中的原因。</li>
<li>不要使用受保护的字段：protected机制并不能够带来更多的保护，这有两方面的原因：第一，子类集合是无限制的，任何一个人都能够有你的类派生一个子类，然后编写代码直接访问protected实例字段，从而破坏了封装性。第二，在Java中，在同一包中的所有类都可以访问protected字段，而不管它们是否为这个类的子类。</li>
<li>使用继承实现“is - a”关系</li>
<li>除非所有继承的方法都有意义，否则不要使用继承</li>
<li>在覆盖方法时，不要改变预期的行为</li>
<li>使用多态，而不要使用类型信息</li>
<li>不要滥用反射：反射机制使人们可以在运行时查看字段和方法，从而能编写出更具有通用性的程序。这种功能对于编写系统程序及其有用，但是通常不适用于编写应用程序。反射是很脆弱的，如果使用反射，编译器将无法帮助你查找编写错误，因此只有在运行时才会发现错误并导致异常。</li>
</ul>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《Java工程师成神之路》</title>
    <url>/2021/04/02/%E9%98%85%E8%AF%BB%E3%80%8AJava%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E3%80%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h3><p><strong>什么是面向过程？</strong></p>
<p>​        自顶而下的编程模式。把问题分解成一个个步骤，每个步骤用函数实现，依次调用即可。</p>
<p><strong>什么是面向对象？</strong></p>
<p>​        将事务高度抽象化的编程模式。将问题分解成一个个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p>
<h3 id="优劣对比"><a href="#优劣对比" class="headerlink" title="优劣对比"></a>优劣对比</h3><ul>
<li>面向对象：占用资源相对高，速度相对慢</li>
<li>面向过程：占用资源相对低，速度相对快</li>
</ul>
 <span id="more"></span> 

<h2 id="面向对象的三大基本特征和五大基本原则"><a href="#面向对象的三大基本特征和五大基本原则" class="headerlink" title="面向对象的三大基本特征和五大基本原则"></a>面向对象的三大基本特征和五大基本原则</h2><h3 id="面向对象的三大基本特征"><a href="#面向对象的三大基本特征" class="headerlink" title="面向对象的三大基本特征"></a>面向对象的三大基本特征</h3><p><strong>封装(Encapsulation)</strong></p>
<p>​        所谓封装，就是把客观事物封装成抽象的类，并且类可以把自己的属性和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。<br>​        封装是面向对象的特征之一，是对象和类概念的主要特征。一个类就是封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不被外界访问。通过这种方式，对象对内部类数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<p><strong>继承(Inheritance)</strong></p>
<p>​        继承是指这样一种能力：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。<br>​        通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”，“父类”或“超类”。继承的过程，就是从一般到特殊的过程。<br>​        继承概念的实现方式：实现继承和接口继承。实现继承是指直接使用基类的属性和方法而无需额外的编码能力；接口继承是指仅使用属性和方法名称，但子类必须提供实现的能力。</p>
<p><strong>多态(Polymorphism)</strong></p>
<p>​        多态是指一个类实例的相同方法在不同情形有不同表现得形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共类，它们可以以相同的方式予以调用。<br>​        最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p>
<h3 id="面向对象的五大基本原则"><a href="#面向对象的五大基本原则" class="headerlink" title="面向对象的五大基本原则"></a>面向对象的五大基本原则</h3><p><strong>单一职责原则(Single-Responsibility Principle)</strong></p>
<p><strong>开放封闭原则(Open-Closed Principle)</strong></p>
<p><strong>Liskov 替换原则(Liskov-Substitution Principle)</strong></p>
<p><strong>依赖倒置原则(Dependecy-Inversion Principle)</strong></p>
<p><strong>接口隔离原则(Interface-Segregation Principle)</strong></p>
<h2 id="Java中的封装、继承、多态"><a href="#Java中的封装、继承、多态" class="headerlink" title="Java中的封装、继承、多态"></a>Java中的封装、继承、多态</h2><h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h3><p>​        同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态是一种运行期的状态。</p>
<h3 id="多态的必要条件"><a href="#多态的必要条件" class="headerlink" title="多态的必要条件"></a>多态的必要条件</h3><p>​        为了实现运行期的多态，或者说是动态绑定，需要满足三个条件：</p>
<ul>
<li>有类继承或者接口实现</li>
<li>子类重写父类方法</li>
<li>父类的引用指向子类的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Im Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Im Son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daughter</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Im Daughter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parent p = <span class="keyword">new</span> Son();</span><br><span class="line">        Parent p1 = <span class="keyword">new</span> Daughter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这样，就实现了多态，同样是Parent类的实例，p.call调用的是Son类的实现，p1.call调用的是Daughter的实现。例如Spring中IOC出来的对象，你在使用的可以不用关心他是谁，根据具体情况而定。<br>​        上面提到的那种动态绑定是动态多态，因为只有在运行期才能知道正真调用的是哪个类的方法。还有一种静态多态，一般认为Java中的函数重载是一种静态多态，因为它需要在编译期决定具体调用哪个方法。</p>
<h3 id="方法重写与重载"><a href="#方法重写与重载" class="headerlink" title="方法重写与重载"></a>方法重写与重载</h3><p>​        重载(Overloading)和重写(Overriding)是Java中两个比较重要的概念。</p>
<p><strong>重载</strong></p>
<p>​        函数或方法有相同的名称，但是参数列表不同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p>
<p><strong>重写</strong></p>
<p>​        重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</p>
<p><strong>重写与重载的区别</strong></p>
<ul>
<li>重载是一个编译期概念，重写是一个运行期间的概念</li>
<li>重载遵循所谓“编译期绑定”，即在编译时根据参数量的类型判断应该调用哪个方法。</li>
<li>重写遵循所谓“运行期绑定”，即在运行的时候根据引用变量所指向的实际对象的类型来调用方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;woof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hound</span> <span class="keyword">extends</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sniff</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sniff&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bowl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverridingTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Hound();</span><br><span class="line">        dog.bark();<span class="comment">//bowl</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上面的例子中，dog对象被定义为Dog类型。在编译期，编译器会检查Dog类中是否有可访问的bark()方法，只要其中包含bark()方法，那么就可以编译通过。在运行期，Hound对象被new出来，并赋值给dog变量，这时，JVM是明确的知道dog变量指向的其实是Hound对象的引用。所以，当dog调用bark()方法的时候，就会调用Hound类中定义的bark()方法。这就是所谓的动态多态性。</p>
<p><strong>重写的条件</strong></p>
<ul>
<li>参数列表必须完全与被重写方法的相同</li>
<li>返回类型必须与被重写方法的返回类型相同</li>
<li>访问级别的限制性一定不能比被重写方法的强</li>
<li>访问级别的限制性可以比被重写的方法的弱</li>
<li>重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常</li>
<li>重写的方法能够抛出更少或更有限的异常</li>
<li>不能重写被标示为final的方法</li>
<li>如果不能继承一个方法，则不能重写这个方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System,out.println(<span class="string">&quot;woof&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//overloading method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woof&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上面的代码中，定义了两个bark方法，一个是没有参数的bark方法，另外一个是包含一个int类型参数的bark方法。在编译期，编译期可以根据方法签名(方法名和参数情况)确定哪个方法被调用。</p>
<p><strong>重载的条件</strong></p>
<ul>
<li>被重载的方法必须改变参数列表</li>
<li>被重载的方法可以改变返回类型</li>
<li>被重载的方法可以改变访问修饰符</li>
<li>被重载的方法可以声明新的或更广的检查异常</li>
<li>方法能够在同一类中或者一个子类中被重载</li>
</ul>
<h3 id="Java的继承与实现"><a href="#Java的继承与实现" class="headerlink" title="Java的继承与实现"></a>Java的继承与实现</h3><p>​        面向对象有三个特性：封装、继承、多态</p>
<p>​        其中继承和实现都体现了传递性。</p>
<p>​        <strong>继承：</strong>如果多个类的某个部分的功能相同，那么可以抽象出一个类出来，把他们的相同部分放到父类里，让他们都继承这个类。</p>
<p>​        <strong>实现：</strong>如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标。</p>
<p>​        继承的根本原因是因为要复用，而实现的根本原因是需要定义一个标准。</p>
<p>​        在Java中，继承使用extends关键字实现，而实现通过implements关键字。在Java中支持一个类同时实现多个接口，但不支持同时继承多个类。</p>
<p>​        在接口中只能定义全局常量(static final)和无实现的方法(Java 8以后可以有default方法)，然而在继承中可以定义属性方法，变量，常量等。</p>
<h3 id="Java的继承与组合"><a href="#Java的继承与组合" class="headerlink" title="Java的继承与组合"></a>Java的继承与组合</h3><p><strong>面向对象的复用技术</strong></p>
<p>​        复用性是面向对象技术带来的很棒的潜在的好处之一。如果运用的好的话可以帮助我们节省很多开发时间，提升开发效率。但是，如果被滥用那么就很可能产生很多难以维护的代码。作为一门面向对象开发的语言，代码复用是Java引人注意的功能之一。Java代码的复用有继承，组合以及代理三种具体的表现形式。</p>
<p><strong>继承</strong></p>
<p>​        继承(Inheritance)是一种联结类与类的层次模型。指的是一个类(子类、子接口)继承另外一个类(父类、父接口)的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；继承是一种is-a关系。</p>
<p><strong>组合</strong></p>
<p>​        组合(Composition)体现的是整体与部分、拥有的关系，即has-a的关系。</p>
<p><strong>继承和组合的区别与联系</strong></p>
<p>​        在继承结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用一种白盒式代码复用。(如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性。)</p>
<p>​        组合是通过对现有的对象进行拼装产生新的，更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也可以说这种方式的代码复用是黑盒式代码复用。(因为组合中一般都有定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法)</p>
<p>​        继承，在写代码的时候就要指名具体继承哪个类，所以，在编译期就确定了关系。(从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。)</p>
<p>​        组合，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在运行期确定。</p>
<p><strong>优缺点对比</strong></p>
<table>
<thead>
<tr>
<th>组合关系</th>
<th>继承关系</th>
</tr>
</thead>
<tbody><tr>
<td>优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立</td>
<td>缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性</td>
</tr>
<tr>
<td>优点：具有较好的可扩展性</td>
<td>缺点：支持扩展，但是往往以增加系统结构的复杂度为代价</td>
</tr>
<tr>
<td>优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象</td>
<td>缺点：不支持动态继承。在运行时，子类无法选择不同的父类</td>
</tr>
<tr>
<td>优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口</td>
<td>缺点：子类不能改变父类的接口</td>
</tr>
<tr>
<td>缺点：整体类不能自动获得和局部类同样的接口</td>
<td>优点：子类能自动继承父类的接口</td>
</tr>
<tr>
<td>缺点：创建整体类的对象时，需要创建所有局部类的对象</td>
<td>优点：创建子类的对象时，无需创建父类的对象</td>
</tr>
</tbody></table>
<p><strong>如何选择</strong></p>
<p>​        建议在同样可行的情况下，优点使用组合而不是继承。因为组合更安全，更简单，更灵活，更高效。注意，并不是说继承就一点用都没有，在一些场景还是需要使用继承的，或者是更适合使用继承。</p>
<p>​        继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。</p>
<p>​        只有当子类正真是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在is-a关系的时候，类B才应该继承类A。</p>
<h3 id="构造函数与默认构造函数"><a href="#构造函数与默认构造函数" class="headerlink" title="构造函数与默认构造函数"></a>构造函数与默认构造函数</h3><p>​        构造函数是一种特殊的方法。主要用来在创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。</p>
<p>​        构造函数跟一般的实例方法十分相似；但是与其他方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。构造器的函数名称必须和它所属的类的名称相同。他承担着初始化对象数据成员的任务。</p>
<p>​        如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器。默认构造函数一般会把成员变量的初始化为默认值，如int-&gt;0，Integer-&gt;null。</p>
<h3 id="类变量、成员变量和局部变量"><a href="#类变量、成员变量和局部变量" class="headerlink" title="类变量、成员变量和局部变量"></a>类变量、成员变量和局部变量</h3><p>​        Java中共有三种变量，分别是类变量、成员变量、局部变量。它们分别存放在JVM的方法区、堆内存、栈内存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variables</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上面定义的变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。</p>
<h3 id="成员变量和方法作用域"><a href="#成员变量和方法作用域" class="headerlink" title="成员变量和方法作用域"></a>成员变量和方法作用域</h3><p>对于成员变量和方法的作用域，public，protected，private以及不写之间的区别：</p>
<ul>
<li>public：表明该成员变量或者方法是对所有类或者对象都是可见的，所有类或者对象都可以直接访问。</li>
<li>private：表明该成员变量或者方法是私有的，只有当前类对其具有访问权限，除此之外其它类或者对象都没有访问权限，子类也没有访问权限。</li>
<li>protected：表明成员变量或者方法对类自身，与同一个包中的其它类可以见，其他包下的类不可访问，除非是它的子类。</li>
<li>default：表明该成员变量或者方法只有和其位于同一个包的内可见，其他包内的类不能访问，即便是它的子类。</li>
</ul>
<h2 id="什么是平台无关性"><a href="#什么是平台无关性" class="headerlink" title="什么是平台无关性"></a>什么是平台无关性</h2><h3 id="Java如何实现的平台无关性"><a href="#Java如何实现的平台无关性" class="headerlink" title="Java如何实现的平台无关性"></a>Java如何实现的平台无关性</h3><p><strong>什么是平台无关性</strong></p>
<p>​        平台无关性就是一种语言在计算机上的运行不受平台约束，一次编译，到处执行(Write Once ,Run Anywhere)。也就是说，用Java创建的可执行二进制程序，能够不加改变的运行于多个平台。</p>
<p><strong>平台无关性好处</strong></p>
<p>​        因为其平台无关性，所以Java程序可以在各种各样的设备上，尤其是一些嵌入式设备，如打印机、扫描仪、传真机等。随着5G时代的来临，也会有更多的终端接入网络，相信平台无关性的Java也能做出一些贡献。<br>​        对于Java开发者来说，Java减少了开发和部署到多个平台的成本和时间。真正的做到一次编译，到处运行。</p>
<p><strong>平台无关性的实现</strong></p>
<p>​        对于Java的平台无关性的支持，就像对安全性和网络移动性的支持一样，是分布在整个Java体系结构中的。其中扮演着重要的角色的有Java语言规范、Class文件、Java虚拟机(JVM)等。</p>
<p><strong>编译原理基础</strong></p>
<p>​        在计算机世界中，计算机只认识0和1，所以真正被计算机执行的其实是由0和1组成的二进制文件。但是，我们日常开发使用的C、C++、Java、Python等都属于高级语言，而非二进制语言。所以，想要让计算机认识我们写出来的Java代码，那就需要把他“翻译”成由0和1组成的二进制文件。这个过程就叫做编译。负责这一过程的处理的工具叫做编译器。</p>
<p>​        在Java平台上，想要把Java文件编译成二进制文件，需要经过两步编译，前端编译和后端编译：</p>
<ul>
<li>前端编译：主要指与源语言有关但与目标机无关的部分。Java中，我们熟知的javac的编译就是前端编译。除此之外，我们使用的很低IDE，如eclipese，idea等，都内置了前端编译器。主要功能就是把.java代码转换成.class文件。</li>
<li>后端编译：主要是将中间代码再翻译成机器语言。Java中，这一步骤就是Java虚拟机来执行的。</li>
</ul>
<p><strong>Java虚拟机</strong></p>
<p>​        所谓平台无关性，就是说要能够做到可以在多个平台上都能无缝对接。但是，对于不同的平台，硬件和操作系统肯定都是不一样的。</p>
<p>​        对于不同硬件和操作系统，最主要的区别就是指令不同。比如同样执行a+b，A操作系统对应的二进制指令可能是10001000，而B操作系统对应的指令可能是11101110。那么，想要做到跨平台，最重要的就是可以根据对应的硬件和操作系统生成对应的二进制指令。</p>
<p>​        而这一工作，主要由我们的Java虚拟机完成。虽然Java语言是平台无关的，但JVM却是平台有关的，不同的操作系统上面要安装对应的JVM。</p>
<p>​        有了Java虚拟机，想要执行a+b操作，A操作系统上面的虚拟机就会把指令翻译成10001000，B操作系统上面的虚拟机就会把指令翻译成11101110。所以，Java之所以可以做到跨平台，是因为Java虚拟机充当了桥梁。它扮演了运行时Java程序与其下的硬件和操作系统之间的缓冲角色。</p>
<p><strong>字节码</strong></p>
<p>​        各种不同的平台的虚拟机都使用了统一的程序存储格式——字节码(ByteCode)是构成平台无关性的另外一个基石。Java虚拟机只与由字节码组成的Class文件进行交互。我们说的Java语言可以Write Once ，Run Anywhere。这里的Write其实指的就是生成Class文件的过程。因为Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有了Java的平台无关性。</p>
<p><strong>Java语言规范</strong></p>
<p>​        已经有了统一的Class文件，以及可以在不同平台上将Class文件翻译成对应的二进制文件的Java虚拟机，Java就可以实现跨平台了吗？其实并不是的，Java语言在跨平台方面也是做了一些努力的，这些努力被定义在Java语言规范中。</p>
<p>​        比如，Java中基本数据类型的值域和行为都是由其自己定义的。而C/C++中，基本数据类型由它的占位宽度决定的，占位宽度则是由所在平台决定的。所以，在不同的平台中，对于同一个C++程序的编译结果会出现不同的行为。举一个简单的例子，对于int类型，在Java中，int占4个字节，这是固定的。但是在C++中却不是固定的了。在16位计算机上，int类型的长度可能为两个字节；在32位的计算机上，可能为4字节；当64位计算机流行起来后，int类型的长度可能会达到8字节。</p>
<p>​        通过保证基本数据类型在所有平台的一致性，Java语言为平台无关性提供了强有力的支持。</p>
<p><strong>小结</strong></p>
<p>​        对于Java的平台无关性的支持是分布在整个Java体系结构中的，其中扮演着重要角色的有Java语言规范、Class文件、Java虚拟机等。</p>
<ul>
<li><p>Java语言规范：通过规定Java语言中基本数据类型的取值范围和行为</p>
</li>
<li><p>Class文件：所有Java文件都要编译成统一的Class文件</p>
</li>
<li><p>Java虚拟机：通过Java虚拟机将Class文件转换成对应平台的二进制文件等</p>
<p>​    Java的平台无关性是建立在Java虚拟机的平台有关性基础之上的，是因为Java虚拟机屏蔽了底层操作系统和硬件的差异。</p>
</li>
</ul>
<p><strong>语言无关性</strong></p>
<p>​        Java的无关性不仅仅体现在平台无关性上面，Java还具有语言无关性。</p>
<p>​        JVM其实并不是和Java文件交互的，而是和Class文件，也就是说，其实JVM运行的时候，并不依赖于Java语言。</p>
<p>​        时至今日，商业机构金额开源机构已经在Java语言之外发展出了一大批可以在JVM上运行的语言了，如Groovy、Scala、Jython等。之所以可以支持，就是因为这些语言也可以被编译成字节码。而虚拟机并不关心字节码是由哪种语言编写出的。</p>
<p><strong>JVM还支持哪些语言</strong></p>
<p>​        目前Java虚拟机已经可以支持很多除Java语言以外的语言了，如Kotlin、Groovy、JRuby、Jython、Scala等。之所以可以支持，就是因为这些语言也可以被编译成字节码。</p>
<h2 id="Java中的值传递"><a href="#Java中的值传递" class="headerlink" title="Java中的值传递"></a>Java中的值传递</h2><h3 id="值传递、引用传递"><a href="#值传递、引用传递" class="headerlink" title="值传递、引用传递"></a>值传递、引用传递</h3><p><strong>实参与形参</strong></p>
<p>​        在Java中定义方法的时候是可以定义参数。比如Java中的main方法，public static void main(String[] args)，这里args就是参数。参数在程序语言中分为形式参数和实际参数。</p>
<ul>
<li>形式参数：是定义在函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数。</li>
<li>实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ParaTest pt = <span class="keyword">new</span> ParamTest();</span><br><span class="line">    pt.sout(<span class="string">&quot;qwe&quot;</span>);<span class="comment">//实际参数为：qwe</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sout</span><span class="params">(String name)</span></span>&#123;<span class="comment">//形式参数为name</span></span><br><span class="line">    System,out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。</p>
<p><strong>值传递与引用传递</strong></p>
<p>​        当我们调用一个有参函数的时候，会把实际参数传递给形式参数。但是在程序语言中，这个传递过程中传递的两种情况，即值传递和引用传递。</p>
<ul>
<li><p>值传递(pass by value)：在调用函数时将实际参数赋值一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
</li>
<li><p>引用传递(pass by reference)：在调用函数时将实际参数地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<p>​    所以值传递会创建副本，函数中无法改变原始对象；引用传递不创建副本所以函数中可以改变原始对象。</p>
</li>
</ul>
<p><strong>求值策略</strong></p>
<p>​        我们说当进行方法调用的时候，需要把实际参数传递给形式参数，那么传递的过程中到底传递的是什么东西呢？这其实是程序设计中求值策略(Evaluation strategies)的概念。</p>
<p>​        在计算机科学中，求值策略是确定编程语言中表达式的求值的一组规则。求值策略定义何时和以何种顺序求值给函数的实际参数、什么时候把它们代换入函数、和代换以何种形式发生。</p>
<p>​        求值策略分为两大基本类，基于如何处理给函数的实际参数，分为严格的和非严格的。</p>
<p><strong>严格求值</strong></p>
<p>​        在“严格求值”中，函数调用过程中，给函数的实际参数总是在应用这个函数之前求值。多数现存编程语言对函数都使用严格求值。</p>
<p>​        在严格求值中有几个关键的求值策略是我们比较关心的，那就是传值调用(Call by value)、传引用调用(Call by reference)以及传共享对象调用(Call by sharing)。</p>
<ul>
<li><p>传值调用(值传递)：在传值调用中，实际参数先被求值，然后其值通过复制，被传递给被调用函数的形式参数。因为形式参数拿到的只是一个“局部拷贝”，所以如果在被调函数中改变了形式参数的值，并不会改变实际参数的值。</p>
</li>
<li><p>传引用调用(引用传递)：在传引用调用中，传递给函数的是它的实际参数的隐式引用而不是实参的拷贝。因为传递的是引用，所以，如果在被调函数中改变了形式参数的值，改变对于调用者来说是可见的。</p>
</li>
<li><p>传共享对象调用(共享对象传递)：传共享对象调用中，先获取到实际参数的地址，然后将其复制后，并把该地址的拷贝传递给被调函数的形式参数。因为参数的地址都指向同一个对象，所以我们也称之为“传共享对象”，所以，如果在被调函数中改变了形式参数的值，调用者是可以看到这种变化的。</p>
<p>​    其中传共享对象调用和传值调用的过程几乎是一样的，都是进行“求值”、“拷贝”、“传递”。但是，传共享对象调用和传引用调用的结果又是一样的，都是在被调函数中如果改变参数的内容，那么这种改变也会对调用者有影响。</p>
</li>
</ul>
<p>​        传值调用和传引用调用的主要区别：传值调用是指在调用函数时将实际参数复制一份传递到函数中，传引用调用是指在调用函数时将实际参数的引用直接传递到函数中。所以，连着最主要的区别就是是直接传递的，还是传递的是一个副本。</p>
<p><strong>Java的求值策略</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Test pt = <span class="keyword">new</span> Test();</span><br><span class="line">    </span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">    user.setGender(<span class="string">&quot;Male&quot;</span>);</span><br><span class="line">    pt.pass(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;print in main, user is&quot;</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    user.setName(<span class="string">&quot;qweasd&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;print in pass, user is&quot;</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print in pass, user is User&#123;name=&#x27;qweasd&#x27;,gender=&#x27;Male&#x27;&#125;</span></span><br><span class="line"><span class="comment">//print in main, user is User&#123;name=&#x27;qweasd&#x27;,gender=&#x27;Male&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>​        可以看到，对象类型在被传递到pass方法后，在方法内容改变了其内容，最终调用main方法中的对象也变了。所以，很多人说，这和引用传递的现象是一样的，就是在方法内改变参数的值，会影响到调用方。但是，其实这是走进了一个误区。</p>
<p><strong>Java中的对象传递</strong></p>
<p>​        原始参数通过值传递给方法。这意味着对参数值的任何更改都只存在于方法的范围内。当方法返回时，参数将消失，对它们的任何更改都将丢失。也就是说，引用数据类型参数也按值传递给方法，这意味着，当方法返回时，传入的引用仍然引用与以前相同的对象。但是，如果对象字段具有适合的访问级别，则可以在方法中更改这些字段的值。</p>
<p>​        其实Java中使用的求值策略就是传共享对象调用，也就是说，Java会将对象的地址的拷贝传递给被调函数的形式参数。只不过“传共享对象调用”这个词并不常用，传共享对象调用其实是传值调用的一个特例。</p>
<p><strong>值传递和共享对象传递的现象冲突吗？</strong></p>
<p>​        既然贡献对象传递是值传递的一个特例，那么它们的现象是完全不同的呢？难道值传递过程中，如果在被调方法中改变了值，也有可能会对调用者有影响吗？那到底什么时候会影响什么时候不会影响呢？<br>​        其实是不冲突的，之所以会有这种疑惑，是因为对于到底是什么是“改变值”有误解。在参数传递的过程中，实际参数的地址被拷贝给了形参。这个过程其实就是值传递，只不过传递的值的内容是对象的应用。<br>​        那为什么我们改变了user中的属性的值，却对原来的user产生了影响呢？Java对象的传递，是通过复制的方式把引用关系传递了，如果我们没有改引用关系，而是找到引用的地址，把里面的内容改了，是会对调用者有影响的，因为大家指向的是同一个共享对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;qweasd&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;print in pass, user is&quot;</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print in pass, user is User&#123;name=&#x27;qweasd&#x27;,gender=&#x27;Male&#x27;&#125;</span></span><br><span class="line"><span class="comment">//print in main, user is User&#123;name=&#x27;qwe&#x27;,gender=&#x27;Male&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>​        所以，Java中的对象传递，如果是修改引用，是不会对原来的对象有任何影响的，但是如果直接修改共享对象的属性的值，是会对原来的对象有影响的。</p>
<p><strong>总结</strong></p>
<p>​        编程语言中需要进行方法间的参数传递，这个传递的策略就叫做求值策略。<br>​        在程序设计中，求值策略有很多种，比较常见的就是值传递和引用传递。还有一种值传递的特例——共享对象传递。<br>​        值传递和引用传递最大的区别是传递的过程中没有复制出一个副本来，如果是传递副本，那就是值传递，否则就是引用传递。<br>​        在Java中，其实是通过值传递实现的参数传递，只不过对于Java对象的传递，传递的内容是对象的引用。我们可以总结说，Java中的求值策略是贡献对象传递，这是完全正确的。</p>
<hr>
<h2 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h2><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><strong>8种基本数据类型</strong></p>
<ul>
<li>字符型：char</li>
<li>布尔型：boolean</li>
<li>数值型：<ul>
<li>整型：byte、short、int、long</li>
<li>浮点型：float、double</li>
</ul>
</li>
</ul>
<p><strong>整型中byte、short、int、long的取值范围</strong></p>
<p>​        Java中的整型主要包含byte、short、int、long这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和它们存储数据时所占的字节数有关。1字节=8位(bit)，Java中的整型属于有符号数。<br>​        8bit可以表示的数字：最小值：10000000(-128)($-2^7$)，最大值：01111111(127)($2^7-1$)<br>​        byte：byte用1个字节来存储，范围为-128<del>127，在变量初始化的时候，byte类型的默认值为0。<br>​        short：short用2个字节存储，范围为-32768</del>32767，在变量初始化的时候，short类型的默认值为0，一般情况下，因为Java本身转型的原因，可以直接写为0。<br>​        int：int用4个字节存储，范围为：-2147483648<del>2147483647，在变量初始化的时候，int类型的默认值为0。<br>​        long：long用8个字节存储，范围为(-$2^{63}$)</del>($2^{63}-1$)，在变量初始化的时候，long类型的默认值为0L，也可以直接写为0。<br>​        上面说过了，整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> j = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> k = i + j;</span><br><span class="line">System.out.println(<span class="string">&quot;i(&quot;</span> + i + <span class="string">&quot;) + j(&quot;</span> + j + <span class="string">&quot;) = k(&quot;</span> + k + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"><span class="comment">//i(2147483647) + j(2147483647) = k(-2)</span></span><br></pre></td></tr></table></figure>

<p>​        这就是发生了溢出，溢出的时候并不会抛出异常，也没有任何提示。所以，在程序中，使用同类型的数据进行运算的时候，一定要注意数据溢出的问题。</p>
<p><strong>什么是浮点型？</strong></p>
<p>​        在计算机科学中，浮点是一种对于实数的近似值数值表现法，由一个有效数字加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数(floating-point number)</p>
<p>​        计算机使用浮点数运算的主因，在于电脑使用二进制位的运算。例如4的二进制位100，2的二进制位010，在二进制中，相当于退一位数(100-&gt;010)。</p>
<p>​        1的二进制是01，那么0.5的二进制标为(0.1),以此类推，0.25的二进制表示位(0.01)，所以，并不是所有的十进制小数都能准确的用二进制表示出来，如0.1，因此只能使用近似值的方式表达。</p>
<p>​        十进制的小数在计算机中是由一个整数或定点数乘以某个基数的整数次幂得到的，这种表示类似于基数位10的科学计数法。</p>
<p>​        一个浮点数a由两个数m和e来表示：$a = m\times be$。在任意一个这样的系统中，我们选择一个基数b(记数系统的基)和精度p(即使用多少位来存储)。m(即尾数)是形如$\pm d.ddd.ddd$的p位数(每一位是一个介于0到b-1之间的整数，包括0和b-1)。如果m的第一位是非0整数，m称作正规化的。有一些描述使用一个单独的符号位(s代表+或者-)来表示正负，这样m必须是正的。e是指数。</p>
<p>​        位(bit)是衡量浮点数所需要存储空间的单位，通常为32或者64位，分别被叫做单精度和双精度。</p>
<p><strong>什么是单精度和双精度</strong></p>
<p>​        单精度浮点数在计算机存储器中占用4个字节(32bits)，利用“浮点”(浮动小数点)的方法，可以表示一个范围很大的数值。<br>​        比其单精度浮点数，双精度浮点数(double)使用64位(8字节)来存储一个浮点数。</p>
<p><strong>为什么不能用浮点型表示金额</strong></p>
<p>​        由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。<br>​        建议使用BigDecimal或者Long(单位为分)来表示金额。</p>
<h2 id="Java中关键字"><a href="#Java中关键字" class="headerlink" title="Java中关键字"></a>Java中关键字</h2><h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p>​        在关于Java的集合类的学习中，我们发现ArrayList类和Vector类都是使用数组实现的，但是在定义数组elementDate这个属性时稍有不同，那就是ArrayList使用了transient关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementDate;</span><br><span class="line"><span class="keyword">protected</span> Object[] elementDate;</span><br></pre></td></tr></table></figure>

<p>​        transient是Java语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。这里的对象存储是指，Java的serialization提供的一种持久化对象实例机制。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。使用情况是：当持久化对象时，可能有个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。<br>​        简单点说，就是被transient修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后，transient变量的值被设为初始值，如int型的是0，对象型的是null。</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>​        instanceof是Java的一个二元操作符，类似于==，&gt;，&lt;等操作符。instanceof是Java的保留关键字。它的作用是测试它的左边对象是否是它右边的类的实例，返回boolean的数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayObjectClass</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Vector)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象是 java.util.Vector 类的实例&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o <span class="keyword">instanceof</span> ArrayList)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象是 java.util.ArrayList 类的实例&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象是 &quot;</span> + o.getClass() + <span class="string">&quot; 类的实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>​        Java语言为了解决并发编程中存在的原子性、可见性和有序性问题，提供了一系列和并发处理相关的关键字，比如synchronized、volatile、final、concurren包等。</p>
<p>​        volatile通常被比喻为“轻量级的synchronized”，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton == <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这是一个比较典型的使用双重锁校验的形式实现单例的，其中使用volatile关键字修饰符可能被多个线程同时访问到的singleton。</p>
<p><strong>volatile原理</strong></p>
<p>​        为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议。</p>
<p>​        缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<p>​        如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了volatile在并发编程中，其值在多个缓存中是可见的。</p>
<p><strong>volatile与可见性</strong></p>
<p>​        可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>​        Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己得工作内存和主内存之间进行数据同步进行。所以，就可能出现线程1改变了某个变量的值，但线程2不可见的情况。</p>
<p>​        Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</p>
<p><strong>volatile与有序性</strong></p>
<p>​        有序性即程序执行的顺序按照代码的先后顺序执行。</p>
<p>​        由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save有可能被优化成load-&gt;save-&gt;add。这就是可能存在的有序性问题。<br>​        而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是它可以禁止指令重排优化等。<br>​        普通的变量仅仅会保证在该方法的执行过程中依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。volatile可以禁止指令重排，这就保证了代码会严格按照代码的先后顺序执行。这就保证了有序性。被volatile修饰的变量的操作，会严格的按照代码顺序执行，load-&gt;add-&gt;save的执行顺序就是：load、add、save。</p>
<p><strong>volatile与原子性</strong></p>
<p>​        原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。</p>
<p>​        线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。volatile是不能保证原子性的。</p>
<p>​        在以下两个场景中可以使用volatile来代替synchronized：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值</li>
<li>变量不需要与其他状态变量共同参与不变约束</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">1000</span>; j++)&#123;</span><br><span class="line">                        test.increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        以上的代码，就是创建10个线程，然后分别执行了1000次i++操作。正常情况下，程序的输出结果应该是10000，但是，多次执行后的结果都小于10000.这其实就是volatile无法满足原子性的原因。</p>
<p><strong>总结</strong></p>
<p>​        synchronized可以保证原子性、有序性和可见性。而volatile却只能保证有序性和可见性。 </p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>​        synchronized关键字在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成的。</p>
<p><strong>synchronized的用法</strong></p>
<p>​        synchronized是Java提供一个并发控制的关键字。主要有两种用法，分别是同步方法和同步代码块。也就是说，synchronized既可以修饰方法也可以修饰代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span></span>&#123;</span><br><span class="line">    <span class="comment">//同步方法</span></span><br><span class="line">    <span class="function">piublic <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.pribtln(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(SynchronizedDemo.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        被synchronized修饰的代码块及方法，在同一时间，只能被单个线程访问。</p>
<p><strong>synchronized的实现原理</strong></p>
<p>​        synchronized是Java中用于解决并发情况下数据同步访问的一个很重要的关键字。当我们要保证一个共享资源在同一个时间只会被一个线程访问到时，我们可以在代码中使用synchronized关键字对类或者对象加锁。</p>
<p>​        通过反编译后代码可以看出：对于同步方法，JVM采用ACC_SYNCHRONIZED标记符来实现同步。对于同步块代码，JVM采用monitorenter、monitorexit两个指令来实现同步。</p>
<p>​        方法级的同步是隐式的。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。当某个线程要访问某个方法的时候，会检查是否ACC_SYNCHRONIZED，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会自动释放。</p>
<p>​        同步代码块使用monitorenter、monitorexit两个指令实现。可以把执行monitorenter指令理解为加锁，执行monitorexit理解为释放锁。每个对象维护着一个记录被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁后，该计数器自增变为1，当同一个线程再次获得该对象的锁的时候，计数器再次自增。当同一个线程释放锁的时候，计数器再自减。当计数器为0的时候，锁将被释放，其他线程便可以获得锁。</p>
<p>​        无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的，在Java虚拟机中，Monitor是基于C++实现的，由ObjectMonitor实现。ObjectMonitor类中提供了几个方法，如enter、exit、wait、notify、notifyAll等。sychronized加锁的时候，会调用objectMonitor的enter方法，解锁的时候会调用exit方法。</p>
<p><strong>synchronized与原子性</strong></p>
<p>​        原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。</p>
<p>​        线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。volatile是不能保证原子性的。</p>
<p>​        在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。通过monitorenter和monitorexit指令，可以保证被synchronized修饰的代码在同一时间被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用synchronized来保证方法和代码块的操作是原子性的。</p>
<p>​        线程1在执行monitorenter指令的时候，会对Monitor进行加锁，加锁后其他线程无法获得锁，出非线程1主动解锁。即使在执行过程中，由于某种原因，比如CPU时间片用完，线程1放弃了CPU，但是，他并没有进行解锁。而由于synchronized的锁是可重入的，下一个时间片还是只能被他自己获得到，还是会继续执行代码。直到所有代码执行完这就保证了原子性。</p>
<p><strong>synchronized与可见性</strong></p>
<p>​        可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>​        Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己得工作内存和主内存之间进行数据同步进行。所以，就可能出现线程1改变了某个变量的值，但线程2不可见的情况。</p>
<p>​        被synchronized修饰的代码，在开始执行时会加锁，执行完毕后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。</p>
<p>​        所以，synchronized关键字锁住的对象，其值是具有可见性的。</p>
<p><strong>synchronized与有序性</strong></p>
<p>​        有序性即程序执行的顺序按照代码的先后顺序执行。</p>
<p>​        由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save有可能被优化成load-&gt;save-&gt;add。这就是可能存在的有序性问题。</p>
<p>​        这里需要注意的是，synchronized是无法禁止指令重排和处理器优化的。也就是说，synchronized无法避免上述提到的问题。那么，为什么还说synchronized也提供了有序性保证呢？Java程序中天然的有序性可以总结为：如果在本线程内观察，所有操作都是天然有序的。如果是在一线程观察另外一个线程，所有操作都是无序的。</p>
<p>​        as-if-serial语义的意思指：不管怎么重排序，单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。</p>
<p>​        在单线程中，指令重排序是有一定的限制的，而只要编译器和处理器都遵守这个语义，那么就可以认为单线程程序是按照顺序执行的。当然，实际上还是有重排的，只不过我们无需关心这种重排的干扰。</p>
<p>​        所以，由于synchronized修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。</p>
<p><strong>synchronized与锁优化</strong></p>
<p>​        synchronized其实是借助Monitor实现的，在加锁时会调用objectMonitor的enter方法，解锁的时候会调用exit方法。事实上，只有JDK1.6之前，synchronized的实现才会直接调用ObjectMonitor的enter和exit，这种锁被称之为重量级锁。</p>
<p>​        在JDK1.6中出现对锁进行了很多优化，进而出现轻量级锁、偏向锁、锁消除、适应性自旋锁，锁粗化，这些操作都是为了在线程之间更高效的共享数据，解决竞争问题。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>​        final是Java中的一个关键字，它表示的是“这部分是无法修改的”。使用final可以定义：变量、方法、类。</p>
<p><strong>final变量</strong></p>
<p>​        如果将变量设置为final，则不能更改final变量的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String name = <span class="string">&quot;qwe&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        一旦final变量被定义之后，是无法进行修改的。</p>
<p><strong>final方法</strong></p>
<p>​        如果任何方法声明为final，则不能覆盖它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        当我们定义以上类的子类的时候，无法覆盖其name方法，会编译失败。</p>
<p><strong>final类</strong></p>
<p>​        如果把任何一个类声明为final，则不能继承它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        以上类不能被继承！</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>​        static表示“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块。</p>
<p><strong>静态变量</strong></p>
<p>​        我们用static表示变量的级别，一个类中的静态变量，不属于类的对象或者实例。因为静态变量与所有的对象实例共享，因为它们不具有线程安全性。<br>​        通常，静态变量常用final关键字来修饰，表示通用资源或可以被所有对象所使用。如果静态变量未被私有化，可以用“类名.变量名”的方式来使用。</p>
<p><strong>静态方法</strong></p>
<p>​        与静态变量一样，静态方法是属于类而不是实例。<br>​        一个静态方法只能使用静态变量和调用静态方法。通常静态方法通常用于想给其它的类使用而不需要创建实例。<br>​        Java的包装类和实用类包含许多静态方法。main()方法就是Java程序的入口点，是静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK6</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count &amp; gt;<span class="number">0</span>)</span><br><span class="line">        StaticExample.count = count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">addInts</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>...js)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : js)</span><br><span class="line">        sum+=x;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        从Java8以上版本开始也可以有接口类型的静态方法了。</p>
<p><strong>静态代码块</strong></p>
<p>​        Java的静态块是一组指令在类装载的时候在内存中由Java ClassLoader执行。静态块常用于初始化类的静态变量。大多数时候还用于在类装载时候创建静态资源。Java不允许在静态块中使用非静态变量。一个类中可以有多个静态块，尽管这似乎没有什么用。静态块只在类装载入内存时，执行一次。</p>
<p><strong>静态类</strong></p>
<p>​        Java可以嵌套使用静态类，但是静态类不能用于嵌套的顶层。静态嵌套类的使用与其他顶层类一样，嵌套只是为了便于项目打包。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>​        const是Java预留关键字，用于后期扩展用，用法跟final相似，不常用。</p>
<hr>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="字符串的不可变性"><a href="#字符串的不可变性" class="headerlink" title="字符串的不可变性"></a>字符串的不可变性</h3><p><strong>定义一个字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​        s中保存了string对象的引用。</p>
<p><strong>使用变量来赋值变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s2 = s;</span><br></pre></td></tr></table></figure>

<p>​        s2保存了相同的引用值，因为他们代表同一个对象。</p>
<p><strong>字符串连接</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = s.concat(<span class="string">&quot;ef&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​        s中保存的是一个重新创建出来的string对象的引用。</p>
<p><strong>总结</strong></p>
<p>​        一旦一个String对象在内存中被创建出来，他就无法被修改。特别要注意的是，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。<br>​        如果你需要一个可修改的字符串，应该使用StringBuffer或者StringBuilder。否则会有大量时间浪费在垃圾回收上，因为每次试图修改都有新的String对象被创建出来。</p>
<h3 id="JDK6和JDK7中substring的原理及区别"><a href="#JDK6和JDK7中substring的原理及区别" class="headerlink" title="JDK6和JDK7中substring的原理及区别"></a>JDK6和JDK7中substring的原理及区别</h3><p>​        substring(int beginIndex, int endIndex)方法在不同版本的JDK中的实现是不同的。了解它们的区别可以帮助你更好的使用它。为了方便，记使用substring()代表substring(int beginIndex, int endIndex)方法。</p>
<p><strong>substring()的作用</strong></p>
<p>​        substring(int beginIndex, int endIndex)方法截取字符串并返回其[beginIndex, endIndex-1]范围内的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String x = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">x = x.substring(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(x);</span><br><span class="line"><span class="comment">//bc</span></span><br></pre></td></tr></table></figure>

<p><strong>调用substring()时发生了什么</strong></p>
<p>​        x是不可变的，当使用x.substring(1,3)对x赋值的时候，他会指向一个全新的字符串。然而，在jdk6和jdk7中调用substring时发生的事情并不一样。</p>
<p><strong>JDK6中的substring</strong></p>
<p>​        String是通过字符数组实现的。在JDK6中，String类包含三个成员变量：char value[ ]，int offset， int count。他们分别用来存储真正的字符数组，数组的第一个位置的索引以及字符串中包含的字符个数。</p>
<p>​        当调用substring方法的时候，会创建一个新的string对象，但这个string的值仍然指向堆中的同一个字符数组。这两个对象中只有count和offset的值是不同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String(<span class="keyword">int</span> offset, <span class="keyword">int</span> count, <span class="keyword">char</span> value[])&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(offset + beginIndex, endIndex - endIdnex, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK6中substring导致的问题</strong></p>
<p>​        如果有一个很长的字符串，但是当你使用substring进行切割的时候你只需要很短的一段。这可能导致性能问题，你只需要一小段的字符序列，但你引用了整个字符串(因为这个非常长的字符串一直在被引用，所以无法被回收，就可能导致内存泄露)。在JDK6中，一般用以下方式来解决该问题，原理其实就是生成了一个新的字符串并引用它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = x.substring(x,y) + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​        内存泄露：在计算机科学中，内存泄露指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄露并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成内存的浪费。</p>
<p><strong>JDK7中的substring</strong></p>
<p>​        上面的问题，在JDK7中得到解决，在JDK7中substring方法会在堆内存中创建一个新的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset + count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在JDK7中substring方法，其实用new String创建了一个新的字符串，避免对老字符串的引用。从而解决了内存泄露问题。</p>
<p>​        所以，如果你的生产环境中的JDK版本小于1.7，当你使用String的substring方法时一定要注意，避免内存泄露。</p>
<h3 id="replaceFirst、replaceAll、replace区别"><a href="#replaceFirst、replaceAll、replace区别" class="headerlink" title="replaceFirst、replaceAll、replace区别"></a>replaceFirst、replaceAll、replace区别</h3><p>​        replaceFirst、replaceAll、replace是Java中常用的替换字符的方法，它们的方法定义是：</p>
<p>​        replace(CharSequence target，charSequence replacement)，用replacement替换所有的target，两个参数都是字符串。</p>
<p>​        replaceAll(String regex, String replacement)，用replacement替换所有的regex匹配项，regex是个正则表达式，replacement是字符串。</p>
<p>​        replaceFirst(String regex, String replacement)，基本和replaceAll相同，区别是只替换第一个匹配项。</p>
<p>​        其中replaceAll以及replaceFirst是和正则表达式有关的，而replace和正则表达式无关。replaceAll和replaceFirst的区别主要是替换的内容不同，replaceAll是替换所有匹配的字符，而replaceFirst()仅替换第一次出现的字符串。</p>
<p><strong>用法例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//replaceAll()替换符合正则的所有文字</span></span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">&quot;正则表达式&quot;</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="string">&quot;正则表达式 Hello World, 正则表达式 Hello World&quot;</span>);</span><br><span class="line">System.out.println(matcher.replaceAll(<span class="string">&quot;Java&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//replaceFirst()替换第一个符合正则的数据</span></span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">&quot;正则表达式&quot;</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="string">&quot;正则表达式 Hello World, 正则表达式 Hello World&quot;</span>);</span><br><span class="line">System.out.println(matcher.replaceFirst(<span class="string">&quot;Java&quot;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//replaceAll()替换所有html标签</span></span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">&quot;&lt;.+?&gt;&quot;</span>, Patten.DOTALL);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="string">&quot;&lt;a href=\&quot;index.html\&quot;&gt;主页&lt;/a&gt;&quot;</span>);</span><br><span class="line">String string = matcher.replaceAll(<span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(string);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//replaceAll()替换指定文字</span></span><br><span class="line">String str = <span class="string">&quot;Java 目前的发展史是由&#123;0&#125;年-&#123;1&#125;年&quot;</span>;</span><br><span class="line">String[][] object = &#123;</span><br><span class="line">    <span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">&quot;\\&#123;0\\&#125;&quot;</span>,<span class="string">&quot;1995&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">&quot;\\&#123;1\\&#125;&quot;</span>,<span class="string">&quot;2007&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(replace(str, object));</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replace</span><span class="params">(<span class="keyword">final</span> String sourceString, Object[] object)</span></span>&#123;</span><br><span class="line">    String temp = sourceString;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; object.length; i++)&#123;</span><br><span class="line">        String[] result = (String[]) object[i];</span><br><span class="line">        Pattern pattern = Pattern.compile(result[<span class="number">0</span>]);</span><br><span class="line">        Matcher matcher = pattern.matcher(temp);</span><br><span class="line">        temp = matcher.replaceAll(result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//replace()替换字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;abac&quot;</span>.replace(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;\a&quot;</span>));<span class="comment">//\ab\ac</span></span><br></pre></td></tr></table></figure>

<h3 id="String对“-”的重载"><a href="#String对“-”的重载" class="headerlink" title="String对“+”的重载"></a>String对“+”的重载</h3><ul>
<li>String s = “a” + “b”，编译器会进行常量折叠(因为两个都是编译期常量，编译期可知)，即变成String s = “ab”</li>
<li>对于能够进行优化的(String s = “a” + 变量 等)用StringBuilder的append()方法替代，最后调用toString()方法</li>
</ul>
<h3 id="字符串拼接的几种方式和区别"><a href="#字符串拼接的几种方式和区别" class="headerlink" title="字符串拼接的几种方式和区别"></a>字符串拼接的几种方式和区别</h3><p><strong>字符串拼接</strong></p>
<p>​        String是Java中一个不可变的类，所以它一旦被实例化就无法被修改。不可变类的实例一旦创建，其成员变量的值就不能被修改。这样设计有很多好处，例如：可以缓存hashcode、使用更加便利以及更加安全。既然字符串是不可变的，那么字符串拼接又是怎么回事呢？</p>
<p><strong>字符串不变性与字符串拼接</strong></p>
<p>​        其实，所有的所谓字符串拼接，都是重新生成了一个新的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">s = s.concat(<span class="string">&quot;ef&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>使用+拼接字符串</strong></p>
<p>​        在Java中，拼接字符串最简单的方式就是直接使用符号+来拼接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String wechat = <span class="string">&quot;wk&quot;</span>;</span><br><span class="line">String introduce = <span class="string">&quot;qweewq&quot;</span>;</span><br><span class="line">String wk = wechat + <span class="string">&quot;,&quot;</span> + introduce;</span><br></pre></td></tr></table></figure>

<p>​        有人把Java中使用+拼接字符串的功能理解为运算符重载。其实并不是，Java是不支持运算符重载的。这其实只是Java提供的一个语法糖。</p>
<p>​        运算符重载：在计算程序设计中，运算符重载(operator overloading)是多态的一种。运算符重载，就是对已有的运算符重新进行定义，赋予其另一种能供，以适应不同的数据类型。</p>
<p>​        语法糖：语法糖(Syntactic sugar)，指计算机语言中添加的某种语法，这种语法对语言功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。</p>
<p><strong>Concat</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String wechat = <span class="string">&quot;wk&quot;</span>;</span><br><span class="line">String introduce = <span class="string">&quot;qweasd&quot;</span>;</span><br><span class="line">String wk = wechat.concat(<span class="string">&quot;,&quot;</span>).concat(introduce);</span><br></pre></td></tr></table></figure>

<p><strong>StringBuffer</strong></p>
<p>​        用来定义字符串变量的StringBuffer类，它的对象是可以扩充和修改的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer wechat = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">String introduce = <span class="string">&quot;qweasd&quot;</span>;</span><br><span class="line">StringBuffer wk = wechat.append(<span class="string">&quot;,&quot;</span>).append(introduce);</span><br></pre></td></tr></table></figure>

<p><strong>StringBuilder</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder wechat = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">String introduce = <span class="string">&quot;qweasd&quot;</span>;</span><br><span class="line">StringBuilder wk = wechat.append(<span class="string">&quot;,&quot;</span>).append(introduce);</span><br></pre></td></tr></table></figure>

<p><strong>StringUtils.join</strong></p>
<p>​        一些开源类库中提供的字符串拼接方法，如apache.commons中提供的StringUtils类，其中join方法可以拼接字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String wechat = <span class="string">&quot;wk&quot;</span>;</span><br><span class="line">String introduce = <span class="string">&quot;qweads&quot;</span>;</span><br><span class="line">System.out.println(StringUtils.join(wechat,<span class="string">&quot;,&quot;</span>,introduce));</span><br></pre></td></tr></table></figure>

<p>​        StringUtils中提供的join方法，最主要的功能是：将数组或集合以某种拼接符拼接到一起形成新的字符串，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] list = &#123;<span class="string">&quot;wk&quot;</span>,<span class="string">&quot;qweasd&quot;</span>&#125;;</span><br><span class="line">String result = StringUtils.join(list,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">//wk,qweasd</span></span><br></pre></td></tr></table></figure>

<p>​        并且，Java8中的String类中也提供了静态的join方法，用法和StringUtils.join类似。</p>
<p><strong>使用+拼接字符串的实现原理</strong></p>
<p>​        通过查看反编译以后的代码，我们可以发现，原来字符串常量在拼接过程中，是将String转成了StringBuilder后，使用其append方法进行处理。也就是说，Java中对+字符串的拼接，其实现原理是使用了StringBuilder.append。</p>
<p><strong>concat是如何实现的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span>(otherLen == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        首先创建一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个新的String对象并返回。经过concat方法，其实是new了一个新的String，也就呼应之前说的的字符串的不变性问题。</p>
<p><strong>StringBuffer和StringBuilder</strong></p>
<p>​        和String类类似，StringBuilder类也封装了一个字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure>

<p>​        与String不同的是，它并不是final的，所以它是可以修改的。与String不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        该类继承了AbstractStringBuilder类，其append方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        append会拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。</p>
<p>​        StringBuffer和StringBuilder类似，最大的区别就是StringBuffer是线程安全的，看一下StringBuffer的append方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.appen(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        该方法使用synchronized进行声明，说明是一个线程安全的方法。而StringBuilder则不是线程安全的。</p>
<p><strong>StringUtils.join是如何实现的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(<span class="keyword">final</span> Object[] array, String separator, <span class="keyword">final</span> <span class="keyword">int</span> startIndex, <span class="keyword">final</span> <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(separator == <span class="keyword">null</span>)&#123;</span><br><span class="line">        separator = EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> noOfItems = endIndex - startIndex;</span><br><span class="line">    <span class="keyword">if</span>(noOfItems &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> StringBuilder buf = <span class="keyword">new</span> StringBuilder(noOfItems * <span class="number">16</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex; i &lt; endIndex; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; startIndex)&#123;</span><br><span class="line">            buf.append(separator);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">            buf.append(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效率比较</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//这里是初始字符串定义</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> i &lt; <span class="number">50000</span>; i++)&#123;</span><br><span class="line">    <span class="comment">//这里是字符串拼接代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;cost:&quot;</span> + (t2 - t1));</span><br><span class="line"><span class="comment">//+ cost:5119</span></span><br><span class="line"><span class="comment">//StringBuilder cost:3</span></span><br><span class="line"><span class="comment">//StringBuffer cost:4</span></span><br><span class="line"><span class="comment">//concat cost:3623</span></span><br><span class="line"><span class="comment">//StringUtils.join cost:25726</span></span><br></pre></td></tr></table></figure>

<p>​        从结果上看，用时从短到长的对比是：StringBuilder &lt; StringBuffer &lt; concat &lt; + &lt; StringUtils.join。<br>​        StringBuffer在StringBuilder的基础上，做了同步设置，所以耗时上会相对多一些。StringUtils.join也是使用了StringBuilder，并且其中还有很多其他操作，所以耗时较长。StringUtils.join更擅长处理字符数组或者列表的拼接。</p>
<p>​        其实使用+拼接字符串的实现原理也是使用的StringBuilder，那为什么结果相差这么多？在反编译后的代码中，每次都是new了一个StringBuilder，然后再把String转成StringBuilder，再进行append。<br>​        而频繁的新建对象当然要耗费很多时间了，不仅仅会浪费时间，频繁的创建对象，还会造成内存资源的浪费。所以，Java开发手册建议：循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展，而不要使用+。</p>
<p><strong>总结</strong></p>
<p>​        虽然字符串是不可变的，但是还是可以通过新建字符串的方式来进行字符串的拼接。常用的字符串拼接方式有五种，分别是StringBuilder、StringBuffer、concat、+、StringUtils.join。使用StringBuilder的方式是效率最高的，因为StringBuilder天生就是设计来定义可变字符串和字符串的变化操作的。</p>
<p>​        需要强调的是：</p>
<ul>
<li>如果不是在循环体中进行字符串拼接的话，直接使用+就好了</li>
<li>如果在并发场景下进行字符串拼接，要使用StringBuff来代替StringBuilder</li>
</ul>
<h3 id="String-valueOf和Interger-toString的区别"><a href="#String-valueOf和Interger-toString的区别" class="headerlink" title="String.valueOf和Interger.toString的区别"></a>String.valueOf和Interger.toString的区别</h3><p>​        我们有三种方式将一个int类型的变量变成String类型，那么有什么区别呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">String i1 = <span class="string">&quot;&quot;</span> + i;</span><br><span class="line">String i2 = String.valueOf(i);</span><br><span class="line">String i3 = Integer.toString(i);</span><br></pre></td></tr></table></figure>

<p>​        第三行和第四行没有任何区别，因为String.valueOf(i)也是调用Integer.toString(i)来实现的。<br>​        第二行代码其实是String i1 = (new StringBuilder()).append(i).toString()；首先创建一个StringBuilder对象，然后在调用append方法，再调用toString方法。</p>
<h3 id="switch对String的支持"><a href="#switch对String的支持" class="headerlink" title="switch对String的支持"></a>switch对String的支持</h3><p>​        Java7中，switch的参数可以是String类型了，这对我们来说是一个很方便的改进。到目前为止switch支持这样几种数据类型：byte、short、int、char、String。</p>
<p><strong>switch对整型支持的实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoInt</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>​        反编译后的代码和之前的代码除了多了两行注释以外没有任何区别，那么我们就知道，switch对int的判断是直接比较整数的值。</p>
<p><strong>switch对字符型支持的实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoChar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        对char类型进行比较的时候，实际上比较的是ascii码，编译器会把char型变量转换成对应的int型变量。</p>
<p><strong>switch对字符串支持的实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoString</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(str)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        字符串的switch是通过equals()和hashCode()方法来实现的。记住，switch中只能使用整型，比如byte，short，char(ascii码是整型)以及int。hashCode()方法返回的是int，而不是long。进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不差。因为java编译器只增加了一个equals方法，如果你比较的是字符串字面量的话会非常快，比如“abc” == “abc”。如果把hashCode()方法的调用也考虑进来，那么还会再多一次的调用开销，因为字符串一旦创建了，他就会把哈希值缓存起来。因此如果这个switch语句是用在一个循环里的，比如逐项处理某个值，或者游戏引擎循环地渲染屏幕，这里hashCode()方法的调用开销其实不会很大。</p>
<p>​        其实switch只支持一种数据类型，那就是整型，其他数据类型都是转换成整形之后在使用switch的。</p>
<h3 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h3><p>​        String作为一个Java类，可以通过以下两种方式创建一个字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;qwe&quot;</span>;</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;qwe&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​        第一种是我们比较常用的做法，这种形式叫做“字面量”。在JVM中，为了减少相同的字符串的重复创建，为了达到节省内存的目的。会单独开辟一块内存，用于保存字符串常量，这个内存区域被称为字符串常量池。<br>​        当代码中出现双引号形式(字面量)创建字符串对象时，JVM会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是字符串驻留或池化。</p>
<p><strong>字符串常量池的位置</strong></p>
<p>​        在JDK7之前的版本中，字符串常量池是放在永久代中的。</p>
<p>​        因为按照计划，JDK会在后续的版本中通过元空间来代替永久代，所以首先在JDK7中，将字符串常量池先从永久代中移出，暂时放到了堆内存中。</p>
<p>​        在JDK8中，彻底移除了永久代，使用元空间代替了永久代，于是字符串常量池再次从堆内存移动到永久代中。</p>
<h3 id="Class-常量池"><a href="#Class-常量池" class="headerlink" title="Class 常量池"></a>Class 常量池</h3><p>​        在Java体系中，共用三种常量池。分别是字符串常量池、Class常量池和运行时常量池。</p>
<p><strong>什么是Class文件</strong></p>
<p>​        计算机只认识0和1，所以程序员写的代码都需要经过编译成0和1构成二进制格式才能够让计算机运行。为了让Java语言具有良好的跨平台能力，Java独具匠心的提供了一种在所有平台上都使用的一种中间代码——字节码(ByteCode)。有了字节码，无论是哪种平台，只要安装了虚拟机，都可以直接运行字节码。同样，有了字节码，也解除了Java虚拟机和Java语言之间的耦合。目前Java虚拟机已经可以支持很多除了Java语言以外的语言了，之所以可以支持，这些语言也可以被编译成字节码。而虚拟机并不关心字节码是哪种语言编译而来的。<br>​        Java语言中负责编译出字节码的编译器是一个命令javac。javac是收录于JDK中的Java语言编译器。该工具可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。</p>
<p><strong>Class常量池</strong></p>
<p>​        Class常量池也可以理解为Class文件中的资源仓库。Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Lieral)和符号引用(Symbolic Reference)。</p>
<p>​        由于不同的Class文件中包含的常量的个数是不固定的，所以在Class文件的常量池入口处会设置两个字节的常量池容量计数器，记录了常量池中常量的个数。</p>
<p>​        当然，还有一种比较简单的查看Class文件中常量池的方法，通过javap命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javap -v HelloWorld.class</span><br></pre></td></tr></table></figure>

<p><strong>常量池中有什么</strong></p>
<p>​        常量池中主要存放两大类常量：字面量(literal)和符号引用(symbolic references)。</p>
<p><strong>字面量</strong></p>
<p>​        在计算机科学中，字面量(literal)是用于表达源代码中一个固定值的表示法(notation)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。<br>​        简单的说，字面量就是指由字母、数字等构成的字符串或者数值。<br>​        字面量只可以右值出现，所谓右值是指等号右边的值，如： int a = 123这里a为左值，123为右值。在这个例子中123就是字面量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">String s = <span class="string">&quot;qwe&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>符号引用</strong></p>
<p>​        常量池中，除了字面量以外，还有符号引用，那么到底什么是符号引用呢。符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括以下三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p><strong>Class常量池有什么用</strong></p>
<p>​        Class常量池是Class文件中的资源仓库，其中保存了各种常量。而这些常量都是开发者定义出来，需要在程序的运行期使用的。<br>​        Java代码在进行javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池得对应得符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。<br>​        也就是说，Class是用来保存常量的一个媒介场所，并且是一个中间场所。在JVM真的运行时，需要把常量池中的常量加载到内存中。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>​        运行时常量池(Runtime Constant Pool)是每一个类或接口的常量池(Constant_Pool)的运行时表示形式。它包括了若干种不同的常量：从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。运行时常量池扮演了类似传统语言中符号表(Symbol Table)的角色，不过它的存储数据范围比通常意义上的符号表要更为广泛。<br>​        每一个运行时常量池都分配在Java虚拟机的方法区中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。以上就是Java虚拟机规范中关于运行时常量池的定义。</p>
<p><strong>运行时常量在JDK各个版本中的实现</strong></p>
<p>​        根据Java虚拟机规范约定：每一个运行时常量池都在Java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。在不同版本的JDK中，运行时常量池所处位置也不一样，以HotSpot为例：<br>​        在JDK1.7之前，方法区位于堆内存的永久代中，运行时常量池作为方法区的一部分，也处于永久代中。因为使用永久代实现方法区可能导致内存泄露问题。<br>​        所以，从JDK1.7开始，JVM尝试解决这一问题，在1.7中将原本位于永久代中的运行时常量池移动到堆内存中。<br>​        在JDK1.8中，彻底移除了永久代，方法区通过元空间的方式实现。随之，运行时常量池也在元空间中实现。</p>
<p><strong>运行时常量池中常量的来源</strong></p>
<p>​        运行时常量池中包含了若干种不同的常量：编译期可知的字面量和符号引用(来自Class常量池)运行期解析后可获得的常量(如String的intern方法)。所以，运行时常量池中的内容包含：Class常量池中的常量、字符串常量池中的内容。</p>
<p>​        虚拟机启动过程中，会将各个Class文件中的常量池载入到运行时常量池中。所以，Class常量池只是一个媒介场所，在JVM真的运行时，需要把常量池中的常量加载到内存中，进入到运行时常量池。字符串常量池可以理解为运行时常量池分出来的部分。加载时，对于class的静态常量池，如果字符串会被装到字符串常量池中。</p>
<h3 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h3><p>​        在JVM中，为了减少相同的字符串的重复创建，为了达到节省内存的目的。会单独开辟一块内存，用于保存字符串常量，这个内存区域被叫做字符串常量池。</p>
<p>​        当代码中出现双引号形式创建字符串对象时，JVM会先对这个字符串进行检查，如果字符串常量池存在相同的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。</p>
<p>​        除了以上方式之外，还有一种可以在运行期将字符串内容放置到字符串常量池的办法，那就是使用intern。在每次赋值的时候使用String的intern方法，如果常量池中有相同的值，就会重复使用该对象，返回对象引用。</p>
<h3 id="String有没有长度限制"><a href="#String有没有长度限制" class="headerlink" title="String有没有长度限制"></a>String有没有长度限制</h3><p><strong>String的长度限制</strong></p>
<p>​        想要搞清楚这个问题，首先我们需要翻阅一下String的源码，看下其中是否有关于长度的限制或定义。<br>​        String类中有很多重载的构造函数，其中有几个是支持用户传入length来执行长度的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure>

<p>​        可以看到，这里的参数length是使用int类型定义的，那么也就是说，String定义的时候，最大支持的长度就是int的最大范围值。根据Integer类的定义，java.lang.Integer#MAX_VALUE的最大值是$2^{31}-1$；那么，我们是否就可以认为String能支持的最大长度就是这个值了呢？<br>​        其实并不是，这个值只是在运行期，我们构造String的时候可以支持的一个最大长度，而实际上，在编译期，定义字符串的时候也是有长度限制的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;11111...1111&quot;</span>;<span class="comment">//10万个字符&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p>​        当我们使用如上形式一个字符串的时候，当我们执行javac编译时，会抛出异常的。那么，明明String的构造函数指定的长度是可以支持2147483647的，为什么上面的定义无法编译呢？</p>
<p>​        形如String s = “xxx”；定义String的时候，xxx被我们称之为字面量，这种字面量在编译之后会以常量的形式进入到Class常量池。那么问题就来了，因为要进入常量池，就要遵循常量池的有关规定。</p>
<p><strong>常量池限制</strong></p>
<p>​        javac是将Java文件编译成class文件的一个命令，那么在Class文件生成过程中，就需要遵守一定的格式。在《Java虚拟机规范》常量池的定义，CONSTANT_String_info用于表示java.lang.String类型的常量对象，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONSTANT_String_info&#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 string_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        其中，string_index项的值必须是对常量池的有效索引，常量值在该索引处的项必须是CONSTANT_Utf8_info结构，表示一组Unicode码点序列，这组Unicode码点序列最终会初始化为一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CONSTANT_Utf8_info&#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 length;</span><br><span class="line">    u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        其中，length则指名了bytes[]数组长度，其类型为u2。u2表示为两个字节的无符号数，那么1个字节有8位，2个字节就有16位。16位无符号数可表示的最大值为$2^{16}-1=65535$。也就是说，Class文件中常量池的格式规定了，其字符串常量的长度不能超过65535。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;11111...1111&quot;</span>;<span class="comment">//有65535个字符“1”</span></span><br></pre></td></tr></table></figure>

<p>​        尝试使用javac编译，同样会得到“错误：常量字符串过长”，那么原因是什么？其实，这个原因在javac的代码中是可以找到的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStringConstant</span><span class="params">(DiagnosticPosition var1, Object var2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.nerrs == <span class="number">0</span> &amp;&amp; var2 != <span class="keyword">null</span> &amp;&amp; var2 <span class="keyword">instanceof</span> String &amp;&amp; ((String)var2).length() &gt;= <span class="number">65535</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.log.error(var1, <span class="string">&quot;limit.string&quot;</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        ++<span class="keyword">this</span>.nerrs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        代码中可以看出，当参数类型为String，并且长度大于等于65535的时候，就会导致编译失败。</p>
<p>​        如果我们尝试65534个字符定义字符串，则会发现可以正常编译。</p>
<p><strong>运行期限制</strong></p>
<p>​        上面提到的这种String长度的限制是编译期的限制，也就是使用String s  = “”；这种字面值方式定义的时候才会有的限制。<br>​        那么，String在运行期有没有限制呢，答案是有的，就是我们前文提到的那个Integer.MAX_VALUE，这个值约等于4G，在运行期，如果String的长度超过这个范围，就可能会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2^31 - 1 = 2147483647 个 16-bit Unicodecharacter</span></span><br><span class="line"><span class="comment">//2147483647 * 16 = 34359738352 位</span></span><br><span class="line"><span class="comment">//34359738352 / 8 = 4294967294 Byte</span></span><br><span class="line"><span class="comment">//4294967294 / 1024 = 4194303.998046875KB</span></span><br><span class="line"><span class="comment">//4194303.998046875 / 1024 = 4095.9999980MB</span></span><br><span class="line"><span class="comment">//4095.9999980 / 1024 = 3.999999GB</span></span><br></pre></td></tr></table></figure>

<p>​        很多人会有疑惑，编译的时候最大长度都要求小于65535了，运行期怎么会出现大于65535的情况呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">    s += <span class="string">&quot;i&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        得到的字符长度就有10万。在系统对接中，需要传输高清图片，约定的传输方式是对方将图片转成BASE6编码，我们接受到之后再转成图片。在将BASE64编码后的内容赋值给字符串的时候就抛了异常。</p>
<p><strong>总结</strong></p>
<p>​        字符串有长度限制，在编译期，要求字符串常量池中的常量不能超过65535，并且在javac执行过程中控制了最大值为65534。在运行期，长度不能超过int的范围，否则会抛异常。</p>
<hr>
<h2 id="自动拆-装箱的实现"><a href="#自动拆-装箱的实现" class="headerlink" title="自动拆/装箱的实现"></a>自动拆/装箱的实现</h2><h3 id="自动拆-装箱"><a href="#自动拆-装箱" class="headerlink" title="自动拆/装箱"></a>自动拆/装箱</h3><p><strong>基本数据类型</strong></p>
<p>​        基本类型，或者叫做内置类型，是Java中不同于类(Class)的特殊类型。它们是我们编程中使用最频繁的类型。<br>​        Java是一种强类型语言，第一次申明变量必须说明数据类型，第一次变量赋值称为变量的初始化。<br>​        Java基本类型共有八种，基本类型可以分为三类：</p>
<ul>
<li><p>字符类型 char</p>
</li>
<li><p>布尔类型 boolean</p>
</li>
<li><p>数值类型 byte、short、int、long、float、double</p>
<p>​    Java中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器环境或者操作系统的改变而改变。实际上，Java中还存在另外一种基本类型void，它有对应的包装类java.lang.Void，不过我们无法直接对它们进行操作。</p>
</li>
</ul>
<p><strong>基本数据类型有什么好处</strong></p>
<p>​        我们都知道在Java语言中，new一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象；所以，对象本身来说是比较消耗资源的。<br>​        对于经常用到的类型，如int等，如果我们每次使用这种变量的时候都需要new一个Java对象的话，就会比较笨重。所以，和C++一样，Java提供了基本数据类型，这种数据的变量不需要使用new创建，它们不会在堆上创建，而是直接在栈内存中存储，因此会更加高效。</p>
<p><strong>整型的取值范围</strong></p>
<p>​        Java中整型主要包含byte、short、int和long这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。[详见](# 基本数据类型)</p>
<p><strong>包装类型</strong></p>
<p>​        Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p><strong>为什么需要包装类</strong></p>
<p>​        因为Java是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们无法将int、double等类型放进去的。因为集合的容器要求元素是Object类型。<br>​        为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加属性和方法，丰富了基本类型的操作。</p>
<p><strong>拆箱与装箱</strong></p>
<p>​        那么，有了基本数据类型和包装类，肯定有些时候要在他们之间进行转换。比如把一个基本数据类型的int转换成包装类型Integer对象。<br>​        我们认为包装类是对基本类型的包装，所以，把基本数据类型转换成包装类的过程就是打包装，英文对应于boxing，中文翻译为装箱。<br>​        反之，把包装类转换成基本数据类型的过程就是拆包装，英文对应于unboxing，中文翻译为拆箱。<br>​        在JavaSE5之前，要进行装箱，可以通过以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>自动拆箱与自动装箱</strong></p>
<p>​        在JavaSE5中，为了减少开发人员的工作，Java提供了自动拆箱和自动装箱功能。</p>
<ul>
<li>自动装箱：就是将基本数据类型自动转换成对应的包装类</li>
<li>自动拆箱：就是将包装类自动转换成对应的基本数据类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = i;</span><br><span class="line"><span class="comment">// Integer i = 10 可以替代 Integer i = new Integer(10)</span></span><br></pre></td></tr></table></figure>

<p>​        就是因为Java帮助我们提供了自动装箱的功能，不需要开发者手动new一个Integer对象</p>
<p><strong>自动装箱与自动拆箱的实现原理</strong></p>
<p>​        既然Java提供了自动拆箱的能力，那么，我们就来看一下，到底是什么原理，Java是如何实现的自动拆箱功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Integer integer = <span class="number">1</span>;<span class="comment">//装箱</span></span><br><span class="line">    <span class="keyword">int</span> i = integer;<span class="comment">//拆箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对以上代码进行反编译后可以得到以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Integer integer = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = integer.intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        int的自动装箱是通过Integer.valueOf()方法来实现的，Integer的自动拆箱都是通过integer.intValue来实现的。即自动装箱都是通过包装类的valueOf()方法来实现的，自动拆箱都是通过包装类的对象的xxxValue()来实现的。</p>
<p><strong>哪些地方会自动拆装箱</strong></p>
<ul>
<li>将基本数据类型放入集合类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">    li.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>包装类型和基本类型的大小比较</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">System.out.println(a == <span class="number">1</span> ? <span class="string">&quot;等于&quot;</span> : <span class="string">&quot;不等于&quot;</span>);</span><br><span class="line">Boolean bool = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(bool?<span class="string">&quot;真&quot;</span>:<span class="string">&quot;假&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​        包装类与基本类进行数据类型进行比较运算，是先将包装类进行拆箱成基本数据类型，然后进行比较的。</p>
<ul>
<li>包装类型的运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;</span><br><span class="line">Integer j = <span class="number">20</span>;</span><br><span class="line">System.out.println(i + j);</span><br></pre></td></tr></table></figure>

<p>​        两个包装类型之间的运算，会被自动拆箱成基本类型进行。</p>
<ul>
<li>三目运算符的使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">Integer i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = flag ? i : j;</span><br></pre></td></tr></table></figure>

<p>​        当第二，第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。在例子中，第二段i是一个包装类型的对象，而第三段的j是一个基本类型，所以会对包装类进行自动拆箱。如果这个时候i的值为null，那么就会发生NPE。</p>
<ul>
<li>函数参数与返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum1</span><span class="params">(Integer num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自动拆箱与缓存</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... strings)</span></span>&#123;</span><br><span class="line">    Integer integer1 = <span class="number">3</span>;</span><br><span class="line">    Integer integer2 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(integer1 == integer2)</span><br><span class="line">        System.out.println(<span class="string">&quot;integer1 == integer2&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot;integer1 != integer2&quot;</span>);</span><br><span class="line">    Integer integer3 = <span class="number">300</span>;</span><br><span class="line">    Integer integer4 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">if</span>(integer3 == integer4)</span><br><span class="line">        System.out.println(<span class="string">&quot;integer3 == integer4&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot;integer3 != integer4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//integer1 == integer2</span></span><br><span class="line"><span class="comment">//integer3 != integer4</span></span><br></pre></td></tr></table></figure>

<p>​        我们普遍认为上面的两个判断的结果都是false。虽然比较的值都是相等的，但是由于比较的是对象，而对象的引用不一样，所以会认为if判断都是false的。在Java中，==比较的的是对象的引用，而equals比较的是值。所以，在这个例子中，不同的对象有不同的引用，所以在进行比较的时候都将返回false。奇怪的是，这里两个类似的if条件判断返回不同的布尔值。</p>
<p>​        原因就和Integer中的缓存机制有关。在Java5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。<br>​        适用于整数值-128<del>+127<br>​        只适用于自动装箱。使用构造函数创建对象不适用。<br>​        我们只需要知道，当需要进行自动装箱时，如果数字在-128</del>127之间时，会直接使用缓存中的对象，而不是重新创建一个对象。其中最大值127可以通过-XX：AutoBoxCacheMax=size修改。在Java5中引入的时候，范围是固定的-128至127。后来在Java6中，可以通过java.lang.Integer.IntegerCache.high设置最大值。到底是什么原因选择这-128到127范围呢？因为这个范围的数字是最被广泛使用的。在程序中，第一次使用Integer的时候也需要一定的额外时间来初始化这个缓存。</p>
<p>​        在Boxing Conversion部分的Java语言规范(JLS)规定如下：<br>如果一个变量p的值是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-128至127之间的整数</span></span><br><span class="line"><span class="comment">//true和false的布尔值</span></span><br><span class="line"><span class="comment">//&#x27;\u000&#x27;至&#x27;\u007f&#x27;之间的字符</span></span><br></pre></td></tr></table></figure>

<p>​        范围内，将p包装成a和b两个对象，可以直接使用a==b判断a和b的值是否相等。</p>
<p><strong>自动拆装箱带来的问题</strong></p>
<p>​        当然，自动拆装箱是一个很好的功能，大大的节省了开发人员的精力，不再需要关心到底什么时候需要拆装箱。但是，他也会引入一些问题。<br>​        包装对象的数值比较，不能简单的使用==，虽然-128至+127之间的数字可以，但是这个范围之外还是需要使用equals比较。<br>​        前面提到的，有些场景会进行自动拆装箱，同时也说了，由于自动拆箱，如果包装类对象为null，那么自动拆箱时就有可能抛出NPE。<br>​        如果一个for循环中有大量的拆箱操作，会浪费很多资源。</p>
<h3 id="Integer的缓存机制"><a href="#Integer的缓存机制" class="headerlink" title="Integer的缓存机制"></a>Integer的缓存机制</h3><p>​        这是在Java5中引入的一个有助于节省内存、提高性能的功能。</p>
<p><strong>Java中Integer的缓存实现</strong></p>
<p>​        在Java5中，在 Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。适用于整数值区间-128至+127。只适用于自动装箱，使用构造函数创建对象不适用。<br>​        Java的编译器把基本数据类型自动转换成封装类对象的过程叫做自动装箱，相当于使用valueOf方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">10</span>;</span><br><span class="line">Integer b = Integer.valueOf(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>​        JDK中的valueOf方法，下面是JDK1.8.0 build 25的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntergerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在创建对象之前先从IntegerCache.cache中寻找。如果没找到才使用new新建对象。</p>
<p><strong>IntegerCache Class</strong></p>
<p>​        IntegerCache Class 是Integer类中定义的一个private static的内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(integerCacheHighPropValue != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i =  parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i,<span class="number">127</span>);</span><br><span class="line">                h = Math.min(i,Integer.MAX_VALUE - (-low) - <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(NumberFormatException nfe)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high  = h;</span><br><span class="line">        </span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)&#123;</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        其中的javadoc详细说明了缓存支持-128到127之间的自动装箱过程。最大值127可以通过-XX:AutoBoxCacheMax=size修改。缓存通过一个for循环实现，从低到高创建尽可能多的整数并存储在一个整数数组中。这个缓存会在Integer类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例对象。<br>​        实际上这个功能在Java6中引入的时候，范围是-128至127，后来在Java6中，可以通过java.lang.Integer.IntegerCache.high设置最大值。这使得我们可以根据应用程序的实际情况灵活地调整来提高性能。到底是什么原因选择这个-128到+127范围呢？因为这个范围的数字是最被广泛使用的。在程序中，第一次使用Integer的时候也需要一定的额外时间来初始化这个缓存。</p>
<p><strong>Java语言规范中的缓存行为</strong></p>
<p>在Boxing Conversion部分的Java语言规范(JLS)规定如下：<br>如果一个变量p的值是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-128至127之间的整数</span></span><br><span class="line"><span class="comment">//true和false的布尔值</span></span><br><span class="line"><span class="comment">//&#x27;\u000&#x27;至&#x27;\u007f&#x27;之间的字符</span></span><br></pre></td></tr></table></figure>

<p>​        范围内，将p包装成a和b两个对象，可以直接使用a==b判断a和b的值是否相等。</p>
<p><strong>其他缓存的对象</strong></p>
<p>​        这种缓存行为不仅适用于Integer对象。我们针对所有的整数类型都有类似的缓存机制。</p>
<ul>
<li>ByteCache用于缓存Byte对象</li>
<li>ShortCache用于缓存Short对象</li>
<li>LongCache用于缓存Long对象</li>
<li>CharacterCache用于缓存Character对象</li>
</ul>
<p>Byte，Short，Long有固定的范围-128到127.对于Character，范围是0到127.除了Integer以外，这个范围都不能改变。</p>
<h3 id="如何正确定义接口的返回值-boolean-Boolean-类型及命名-success-isSuccess"><a href="#如何正确定义接口的返回值-boolean-Boolean-类型及命名-success-isSuccess" class="headerlink" title="如何正确定义接口的返回值(boolean/Boolean)类型及命名(success/isSuccess)"></a>如何正确定义接口的返回值(boolean/Boolean)类型及命名(success/isSuccess)</h3><p>​        在日常开发中，我们经常要在类中定义布尔类型的变量，比如在给外部系统中提供一个RPC接口的时候，我们一般会定义一个字段表示本次请求是否成功。</p>
<p>​        关于这个“本次请求是否成功”的字段的定义，一般情况下，我们可以有以下四种方式来定义一个布尔类型的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> success</span><br><span class="line"><span class="keyword">boolean</span> isSuccess</span><br><span class="line">Boolean success</span><br><span class="line">Boolean isSuccess</span><br></pre></td></tr></table></figure>

<p>​        前两种和后两种的主要区别是变量的类型不同，前者使用的是boolean，后者使用的是Boolean。另外，第一种和第三种在定义变量的时候，变量名为success，而另外两种使用的是isSuccess来命名。</p>
<p><strong>success还是isSuccess</strong></p>
<p>​        在Java开发手册中关于这一点，有一个【强制性】规定：</p>
<p>POJO类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。反例：定义为基本数据类型boolean isSuccess;的属性，它的方法也是isSuccess()，RPC框架在反向解析的时候，“以为”对应的属性名称是success，导致属性获取不到，进而抛出异常。</p>
<p>​        我们看一下POJO中布尔类型变量不同的命名有什么区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean isSuccess;</span><br><span class="line">    <span class="function">piublic <span class="keyword">void</span> <span class="title">setSuccess</span><span class="params">(Boolean success)</span></span>&#123;</span><br><span class="line">        isSuccess = success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getSuccess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line">    <span class="function">piublic <span class="keyword">void</span> <span class="title">setSuccess</span><span class="params">(Boolean success)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.success = success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getSuccess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model3</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isSuccess;</span><br><span class="line">    <span class="function">piublic <span class="keyword">void</span> <span class="title">setSuccess</span><span class="params">(<span class="keyword">boolean</span> success)</span></span>&#123;</span><br><span class="line">        isSuccess = success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model4</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success;</span><br><span class="line">    <span class="function">piublic <span class="keyword">void</span> <span class="title">setSuccess</span><span class="params">(<span class="keyword">boolean</span> success)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.success = success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        以上的代码的setter/getter都是IDEA自动生成的，仔细观察你会发现：</p>
<ul>
<li><p>基本类型自动生成getter和setter方法名称都是isXXX()和setXXX()形式</p>
</li>
<li><p>包装类型自动生成getter和setter方法名称都是getXXX()和setXXX()形式</p>
<p>既然，我们已经达成一致共识使用基本类型boolean来定义成员变量，那么我们再来看Model3和Model4中setter/getter有何区别。</p>
</li>
</ul>
<p>我们可以发现，虽然Model3和Model4中成员变量的名称不同，但是他们自动生成的getter和setter反方法名都是isSuccess和setSuccess。</p>
<p><strong>Java Bean中关于setter/getter的规范</strong></p>
<p>​        关于Java Bean中的getter/setter方法的定义有明确的规定，如果是普通参数propertyName，要以下方式定义其setter/getter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;PropertyType&gt; get&lt;PropertyName&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> set&lt;PropertyName&gt;(&lt;PropertyType&gt; a);</span><br></pre></td></tr></table></figure>

<p>​        但是，布尔类型的变量peopertyName则单独定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> is&lt;PropertyName&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> set&lt;PropertyName&gt;(<span class="keyword">boolean</span> m);</span><br></pre></td></tr></table></figure>

<p>​        通过这份Java Beans规范，我们发现，再Model4中，变量名为isSuccess，如果严格按照规范定义的话，它的getter方法应该叫isIsSuccess。但是很多IDE都会默认生成为isSuccess。</p>
<p>​        那么这样做会带来什么问题的？在一般情况下，其实是没有什么影响的，但是有一种特殊情况就会有问题，那就是发生序列化的时候。</p>
<p><strong>序列化带来的影响</strong></p>
<p>​        我们使用比较常用的JSON序列化来举例，看看常用的fastJson、jackson和Gson之间有何区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanMainTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//定一个Model3类型</span></span><br><span class="line">        Model3 model3 = <span class="keyword">new</span> Model3();</span><br><span class="line">        model3.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//使用fastjson(1.2.16)序列化model3成字符串并输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Serializable Result With fastJson :&quot;</span> + JSON.toJSONString(model3));</span><br><span class="line">        <span class="comment">//使用Gson(2.8.5)序列化model3成字符串并输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Serializable Result With Gson :&quot;</span> + gson.toJson(model3));</span><br><span class="line">        <span class="comment">//使用jackson(2.9.7)序列化model3成字符串并输出</span></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        System.out.println(<span class="string">&quot;Serializable Result With jackson :&quot;</span> + om.writeValueAsString(model3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model3</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1836697963736227954L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isSuccess;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccess</span><span class="params">(<span class="keyword">boolean</span> success)</span></span>&#123;</span><br><span class="line">        isSuccess = success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getqwe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;qweb&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        以上代码Model3中，只有一个成员变量即isSuccess，三个方法，分别是IDE自动生成 的isSuccess和setSuccess，另外是自己增加的一个符合getter命名规范的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Serializable Result With fastJson : &#123;<span class="string">&quot;qwe&quot;</span>:<span class="string">&quot;qweb&quot;</span>,<span class="string">&quot;success&quot;</span>:<span class="keyword">true</span>&#125;</span><br><span class="line">Serializable Result With Gson : &#123;<span class="string">&quot;isSuccess&quot;</span>:<span class="keyword">true</span>&#125;</span><br><span class="line">Serializable Result With jackson : &#123;<span class="string">&quot;success&quot;</span>:<span class="keyword">true</span>,<span class="string">&quot;qwe&quot;</span>:<span class="string">&quot;qweb&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>​        在fastjson和jackson的结果中，原来类中的isSuccess字段被序列化成success，并且其中还包含qwe值。而Gson中只有isSuccess字段。<br>​        我们可以得出结论：fastjson和jackson把对象序列化成json字符串的时候，是通过反射遍历出该类中的所有getter方法，得到getqwe和isSuccess，然后根据JavaBeans规则，他会认为这是两个属性qwe和success的值。直接序列化成json：{“qwe”:”qweb”,”success”:true}。但是Gson并不是这么做的，它是通过反射遍历类中的所有属性，并把其值序列化成json：{“isSuccess”:true}。</p>
<p>​        可以看到，由于不同的序列化工具，在进行序列化的时候使用到的策略是不一样的，所以，对于同一个类的同一个对象的序列化结果可能不同的。</p>
<p>​        现在，不同的序列化框架得到的json内容并不相同，如果对于同一个对象，我们使用fastjson进行序列化，再使用Gson反序列化会发生什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanMainTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Model3 model3 = <span class="keyword">new</span> Model3();</span><br><span class="line">        model3.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        System,out.println(gson.fromJson(JSON.toJSONString(model3),Model3.class))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model3</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1836697963736227954L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isSuccess;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccess</span><span class="params">(<span class="keyword">boolean</span> success)</span></span>&#123;</span><br><span class="line">        isSuccess = success;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringJoiner(<span class="string">&quot;, &quot;</span>,Model3.class.getSimpleName() + <span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>).add(<span class="string">&quot;isSuccess=&quot;</span> + isSuccess).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Model3[isSuccess=false]</span></span><br></pre></td></tr></table></figure>

<p>​        这和我们预期的结果完全相反，原因是因为JSON框架通过扫描所有getter后发现有一个isSuccess方法，然后根据JavaBeans的规范，解析出变量名为success，把model对象序列化成字符串后内容为{“success”:true}<br>​        根据{“success”:true}这个json串，Gson框架在通过解析后，通过反射寻找model类中success属性，但是Model类中只有isSuccess属性，所以，最终反序列化后的Model类中的对象中，isSuccess则会使用默认值false。<br>​        但是，以上代码发生在生产环境，这绝对是一个致命的问题。</p>
<p>​        所以，作为开发者，我们应该想办法尽量避免这种问题的发生，对于POJO的设计者来说，只需要做简单的一件事就可以解决这个问题了，那就是把isSuccess改为success。这样，该类里面的成员变量时success，getter方法是isSuccess，这是完全符合JavaBeans规范的。无论哪种序列化框架，执行结果都一样。这样从源头避免了这个问题。</p>
<p>​        所以，在定义POJO中的布尔类型的变量时，不要使用isSuccess这种形式，而要使用success！</p>
<p><strong>Boolean还是boolean</strong></p>
<p>​        boolean是基本数据类型，而Boolean是包装类型。那么，在定义一个成员变量的时候到底使用包装类型更好还是使用基本数据类型呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanMainTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Model1 model1 = <span class="keyword">new</span> Model1();</span><br><span class="line">        System.out.println(<span class="string">&quot;default model : &quot;</span> + model1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model1</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> failure;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringJoiner(<span class="string">&quot;, &quot;</span>, Model.class.getSimpleName() + <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>).add(<span class="string">&quot;success=&quot;</span>  +success).add(<span class="string">&quot;failure=&quot;</span> + failure).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//default model : Model[success=null,failure=false]</span></span><br></pre></td></tr></table></figure>

<p>​        可以看到，当我们没有设置Model对象的字段的值的时候，Boolean类型的变量会设置默认值为null，而boolean类型的变量会设置默认值为false。<br>​        即对象的默认值是null，boolean基本数据类型的默认值为false。</p>
<p>​        在Java开发手册中，对于POJO中如何选择变量的类型也有着一些规定：</p>
<p>关于基本数据类型与包装类型的使用标准如下：</p>
<ul>
<li>【强制】所有的POJO类属性必须使用包装数据类型</li>
<li>【强制】RPC方法的返回值和参数必须使用包装数据类型</li>
<li>【推荐】所有的局部变量使用基本数据类型</li>
</ul>
<p>说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显示地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。</p>
<p>正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。</p>
<p>反例：比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。</p>
<p>​        举一个扣费的例子，做一个扣费系统，扣费时需要从外部的定价系统中读取一个费率的值，我们预期该接口的返回值中会包含一个浮点型的费率字段。当我们取到这个值的时候就使用公式：金额*费率=费用 进行计算，计算结果进行划扣。<br>​        如果由于计费系统异常，它可能会返回一个默认值，如果这个字段是Double类型的话，该默认值为null，如果该字段是double类型的话，该默认值为0.0<br>​        如果扣费系统对于该费率返回值没做特殊处理的话，拿到null值进行计算会直接报错，阻断程序。拿到0.0可能就直接进行计算，得出接口0后进行扣费了。这种异常情况就无法被感知。<br>​        这种使用包装类型定义变量的方式，通过一异常来阻断程序，进而可以被识别到这种线上问题。如果使用基本数据类型的话，系统可能不会被报错，进而认为无异常。<br>​        以上，就是建议在POJO和RPC的返回值中使用包装类型的原因。</p>
<p><strong>总结</strong></p>
<p>​        在定义一个布尔类型的变量，尤其是一个给外部提供的接口返回值时，要使用success来命名，Java开发手册建议使用包装类来定义POJO和RPC返回值中的变量。但是这不是意味着可以随意的使用null，我们还是要尽量避免出现对null的处理。</p>
<hr>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="Error和-Exception"><a href="#Error和-Exception" class="headerlink" title="Error和 Exception"></a>Error和 Exception</h3><p>​        Exception和Error，两者都是Java异常处理的重要子类，各自都包含大量子类，均继承自Throwable类。<br>​        Error表示系统及错误，是Java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了提出运行外别无选择，它是Java虚拟机抛出的异常。<br>​        Exception表示程序需要捕捉、需要处理的异常，是由程序设计的不完善而出现的问题，程序必须处理的问题。</p>
<h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><p>​        Java中的异常，主要可以分为两大类，即受检异常(checked exception)和非受检异常(unchecked exception)。</p>
<p><strong>受检异常</strong></p>
<p>​        对于受检异常，如果一个方法在声明中声明了其要有受检异常的抛出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> throw new Exception</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>那么，我们在程序中调用他的时候，一定要对该异常进行处理(捕获或者向上抛出)，否则是无法编译通过的，这是一种强制规范。<br>        这种异常在IO操作中比较多。比如FileNotFoundException，当我们使用IO流处理一个文件的时候，有一种特殊情况，就是文件不存在，所以，在文件处理的接收定义时它会显示抛出FileNotFoundException，目的就是告诉这个方法的调用者，我这个方法不保证一定可以成功，是有可能找到对应的文件，你要明确的对这种情况做特殊的处理。<br>        所以说，当我们希望我们的方法调用者，明确的处理一些特殊情况的时候，就应该使用受检异常。</p>
<p><strong>非受检异常</strong></p>
<p>​        对于非受检异常来说，一般是运行时异常，继承自RuntimeException。在编写代码的时候，不需要现实的捕获，但是如果不捕获，在运行期如果发生异常就会中断程序的执行。<br>​        这种异常一般可以理解为是代码原因导致的，比如发生空指针、数组越界等。所以，只要代码写的没问题，这些异常都是可以避免的，也就不需要我们显示地进行处理。<br>​        试想一下，如果你要对所有可能发生空指针的地方做异常处理的话，那相当于你的所有代码都需要做这件事。</p>
<h3 id="异常相关关键字"><a href="#异常相关关键字" class="headerlink" title="异常相关关键字"></a>异常相关关键字</h3><p>​        throws、throw、try、catch、finally</p>
<ul>
<li>try：用来指定一块预防所有异常的程序</li>
<li>catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型</li>
<li>finally：为确保一段代码不管发生什么异常情况都要被执行</li>
<li>throw：用来明确地抛出一个异常</li>
<li>throws：用来声明一个方法可能抛出的各种异常</li>
</ul>
<h3 id="正确处理异常"><a href="#正确处理异常" class="headerlink" title="正确处理异常"></a>正确处理异常</h3><p>​        异常的方式有两种：1.自己处理；2.向上抛，交给调用者处理<br>​        异常，千万不能捕获之后什么也不做，或者只是使用e.printStacktrace<br>​        具体的处理方式的选择其实原则比较简明：自己明确的知道如何处理，就要处理掉；不知道如何处理的，就交给调用者处理。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>​        自定义异常就是开发人员自己定义的异常，一般通过继承Exception的子类的方式实现。<br>​        编写自定义异常类实际上是继承一个API标准异常类，用新定义的异常处理信息覆盖原有信息的过程。<br>​        这种用法在Web开发中也比较常见，一般可以用自定义业务异常。如余额不足、重复提交。这种自定义异常也有业务含义，更容易让上层理解和处理。</p>
<h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>​        “异常链”是Java中非常流行的异常处理概念，是指在进行一个异常处理时抛出了另外一个异常，由此产生了一个异常链条。<br>​        该技术大多用于将“受检查异常”(checked exception)封装成“非受检查异常”(unchecked exception)或者RuntimeException。<br>​        如果因为因为异常你决定抛出一个新的异常，你一定要包含原有的异常，这样，处理程序才可以通过getCause()和initCause()方法来访问异常最终根源。</p>
<p>​        从Jaava1.4版本开始，几乎所有的异常都支持异常链。<br>​        以下是Throwable中支持异常链的方法和构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Throwable <span class="title">getCause</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Throwable <span class="title">initCause</span><span class="params">(Throwable)</span></span></span><br><span class="line"><span class="function"><span class="title">Throwable</span><span class="params">(String, Throwable)</span></span></span><br><span class="line"><span class="function"><span class="title">Throwable</span><span class="params">(Throwable)</span></span></span><br></pre></td></tr></table></figure>

<p>​        initCause和Throwable构造函数的Throwable参数是导致当前异常的异常。getCsuse返回导致当前异常的异常，initCause设置当前异常的原因。</p>
<p>以下显示如何使用异常链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;    </span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SampleException(<span class="string">&quot;Other IOException&quot;</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        当捕获的IOException时，将创建一个新的SampleException异常，并附加原始的异常原因，并将异常链抛出到下一个更高级别的异常处理程序。</p>
<h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p>​        Java里，对于文件操作IO流，数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄漏等问题。<br>​        关闭资源的常用方法就是在finally块里释放，即调用close方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        String line;</span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;d:\\qwe.xml&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        <span class="comment">//handle exception</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="keyword">null</span>)&#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">            <span class="comment">//handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        从Java7开始，JDK提供了一种更好的方式关闭资源，使用try-with-resources语句，改写一下上面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;d:\\qwe.xml&quot;</span>)))&#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        <span class="comment">//handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下它的背后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    BufferedReader br;</span><br><span class="line">    Throwable throwable;</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;d:\\qwe.xml&quot;</span>));</span><br><span class="line">    throwable = <span class="keyword">null</span>;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Throwable throwable2)&#123;</span><br><span class="line">        throwable = throwable2;</span><br><span class="line">        <span class="keyword">throw</span> throwable2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(br != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">if</span>(throwable != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Throwable throwable1)&#123;</span><br><span class="line">                throwable.addSuppressed(throwable1);</span><br><span class="line">            &#125;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">            br.close();</span><br><span class="line">    	<span class="keyword">break</span> MISSING)BLOCK_LABEL_113;</span><br><span class="line">    	Exception exception;</span><br><span class="line">    	exception;</span><br><span class="line">    	<span class="keyword">if</span>(br != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">if</span>(throwable != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Throwable throwable3)&#123;</span><br><span class="line">                    throwable.addSuppressed(throwable3);</span><br><span class="line">                &#125;</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">                br.close();</span><br><span class="line">    	<span class="keyword">throw</span> exception;</span><br><span class="line">    	IOException ioexception;</span><br><span class="line">    	ioexception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        那些我们没有做的关闭资源的操作，编译器都帮我们做了。语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。</p>
<h3 id="finally和return的执行顺序"><a href="#finally和return的执行顺序" class="headerlink" title="finally和return的执行顺序"></a>finally和return的执行顺序</h3><p>​        try()里面有一个return语句，那么后面的finally{}里面的code会不会被执行，什么时候执行，是在return前还是return后？<br>​        如果try中有return语句，那么finally中的代码还是会执行。因为return表示的是要整个方法体返回，所以，finally中的语句会在return之前执行。<br>​        但是return前执行的finally块内，对数据修改效果对于引用类型和值类型会不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        ret++;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回0，finally内的修改效果不起作用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] f2()&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        ret[<span class="number">0</span>]++;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回[1]，finally内的修改作用起了作用</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><h3 id="Collection和Collections区别"><a href="#Collection和Collections区别" class="headerlink" title="Collection和Collections区别"></a>Collection和Collections区别</h3><p>​        Collection是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法。Collection接口在java类库中有很多具体的实现，是list，set等的父接口。</p>
<p>​        Collections是一个包装类，它包含了各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
<p>​        日常开发中，不仅要了解Java中的Collection及其子类的用法，还要了解Collections用法。可以提升很多处理集合类的效率。</p>
<h3 id="Set和List区别"><a href="#Set和List区别" class="headerlink" title="Set和List区别"></a>Set和List区别</h3><p>​        List，Set都是继承自Collection接口，都是用来存储一组相同类型的元素的。</p>
<p>​        List特点：元素有放入顺序，元素可重复。有顺序即先放入的元素排在前面。</p>
<p>​        Set特点：元素无放入顺序，元素不可重复。无顺序即先放入的元素不一定排在前面，不可重复即相同元素在set中只会保留一份。所以，有些场景下，set可以用来去重。不过需要注意的是，set在元素插入时是要有一定的方法来判断元素是否重复的。这个方法很重要，决定了set中可以保存哪些元素。</p>
<h3 id="ArrayList和LinkedList和Vector的区别"><a href="#ArrayList和LinkedList和Vector的区别" class="headerlink" title="ArrayList和LinkedList和Vector的区别"></a>ArrayList和LinkedList和Vector的区别</h3><p>​        List主要有ArrayList、LinkedList和Vector几种实现。</p>
<p>​        这三者都实现了List接口，使用方式也很相似，主要区别在于因为实现方式的不同，所以对不同的操作具有不同的效率。</p>
<p>​        ArrayList是一个可以改变大小的数组。当更多的元素加入到ArrayList中，其大小将会动态地增长，内部的元素可以直接通过get与set方法进行访问，因为ArrayList本质上就是一个数组。</p>
<p>​        LinkedList是一个双链表，在添加和删除时具有比ArrayList更好的性能，但get与set方面弱于ArrayList。</p>
<p>​        当然，这些对比都是指数据量很大或者操作很频繁的情况下的对比，如果数据量和运算量很小，那么对比将失去意义。</p>
<p>​        Vector和ArrayList类似，但属于强同步类，如果你的程序本身是线程安全的(thread-safe，没有多个线程之间共享一个集合/对象)，那么使用ArrayList是更好的选择。</p>
<p>​        Vector和ArrayList在更多元素添加进来时会请求更大的空间，Vector每次请求其大小的双倍空间，而ArrayList每次对size增长50%。</p>
<p>​        LinkedList还实现了Queue接口，该接口比List提供了更多的方法，包括offer()，peek()，poll()等</p>
<p>​        默认情况下ArrayList的初始容量非常小，所以如果可以预估数据量的话，分配一个较大的初始值属于最佳实践，这样可以减少调整大小的开销。</p>
<h3 id="ArrayList使用了transient关键字进行存储优化，而Vector没有，为什么？"><a href="#ArrayList使用了transient关键字进行存储优化，而Vector没有，为什么？" class="headerlink" title="ArrayList使用了transient关键字进行存储优化，而Vector没有，为什么？"></a>ArrayList使用了transient关键字进行存储优化，而Vector没有，为什么？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ArrayList</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">//防止序列化期间有修改</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">//写出非transient非static属性</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    <span class="comment">//写出元素个数</span></span><br><span class="line">    s.writeInt(elementData.length);</span><br><span class="line">    <span class="comment">//依次写出元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(modCount != expectedModCount)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        ArrayList实现了writeObject方法，可以看到只保存了非null的数组位置上的数据。即list的size个数的elementData。需要额外注意的是，ArrayList的实现，提供了fast-fail机制，可以提供弱一致性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vector</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> java.io.ObjectOutputStream.PutField fields = s.putFields();</span><br><span class="line">    <span class="keyword">final</span> Object[] data;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        fields.put(<span class="string">&quot;capacityIncrement&quot;</span>, capacityIncrement);</span><br><span class="line">        fields.put(<span class="string">&quot;elementCount&quot;</span>, elementCount);</span><br><span class="line">        data = elementData.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    fields.put(<span class="string">&quot;elementData&quot;</span>, data);</span><br><span class="line">    s.writeFields();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        Vector也实现了writeObject方法，但方法并没有实现像ArrayList一样进行优化存储，实现语句是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data = elementData.clone();</span><br></pre></td></tr></table></figure>

<p>​        clone()的时候会把null值也拷贝，所以保存相同内容的Vector与ArrayList，Vector的占用的字节比ArrayList要多。可以测试一下，序列化存储相同内容的Vector与ArrayList，分别到一个文本文件中。Vector需要243字节；ArrayList需要135字节。</p>
<p>​        ArrayList是非同步实现的一个单线程下较为高效的数据结构(相比Vector)。ArrayList只通过一个修改记录字段提供弱一致性，主要用在迭代器里，没有同步方法。即上面提到的Fast-fail机制。ArrayList的存储结构定义为transient，重写writeObject来实现自定义的序列化，优化了存储。</p>
<p>​        Vector是多线程环境下更为可靠的数据结构，所有方法都实现了同步。</p>
<p><strong>区别</strong></p>
<p>​        同步处理：Vector同步，ArrayList非同步，Vector缺省情况下增长原来一倍的数组长度，ArrayList是0.5倍。ArrayList：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)；ArrayList自动扩大容量为原来1.5倍(实现的时候，方法会传入一个期望的最小容量，若扩容后容量仍然小于最小容量，那么容量就为传入的最小容量。扩容的时候使用的Arrays.copyOf方法最终调用native方法进行新数组创建和数据拷贝)。Vector：int newCapacity = oldCapacity + ((capacityIncrement &gt; 0)? capacityIncrement : oldCapacity); Vector指定了initialCapacity，capacityIncrement来初始化的时候，每次增长capacityIncrement。</p>
<h3 id="SynchronizedList和Vector的区别"><a href="#SynchronizedList和Vector的区别" class="headerlink" title="SynchronizedList和Vector的区别"></a>SynchronizedList和Vector的区别</h3><p>​        Vector是java.util包中的一个类，SynchronizedList是java.util.Collections中的一个静态内部类。</p>
<p>​        在多线程的场景中可以直接使用Vector类，也可以使用Collections.synchronizedList(List list)方法来返回一个线程安全的List。那么，SynchronizedList和Vector有什么区别呢？为什么Java api要提供这两种线程安全的List的实现方式呢？</p>
<p>​        首先，Vector和ArrayList都是List的子类，他们底层的实现都是一样的。所以这里比较如下list1和list2的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List list2 = Collections.synchronizedList(list);</span><br><span class="line">Vector&lt;String&gt; list1 = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>一、比较几个重要的方法</strong></p>
<ul>
<li>add方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vector的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; elementCount)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">&quot;&gt;&quot;</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//synchronizedList的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mutex)&#123;</span><br><span class="line">        list.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，使用同步代码块的方式调用ArrayList的add()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ArrayList的add方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">priavte <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(elementData == DEFAULTCAPACITY_ELEMENTDATA)&#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        从上面的两段代码中发现有两处不同：1.Vector使用同步方法实现，synchronizedList使用同步代码块实现；2.两者扩充数组容量方式不一样(add方法在扩容方面的差别就是ArrayList和Vector的差别)。</p>
<ul>
<li>remove方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//synchronizedList的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mutex)&#123;</span><br><span class="line">        <span class="keyword">return</span> list.remove(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ArrayList类的remove方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    </span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vector的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexoutOfBoundsException(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        从remove方法中我们发现除了一个使用同步方法，一个使用同步代码块之外几乎无任何区别。</p>
<p>​        通过比较其他方法，我们发现，SynchronizedList里面实现的方法几乎都是使用同步代码块包上List的方法。如果该List是ArrayList，那么，SynchronizedList和Vector的一个比较明显区别就是一个使用了同步代码块。一个使用了同步方法。</p>
<p><strong>二、区别分析</strong></p>
<p><strong>数据增长区别</strong></p>
<p>​        从内部实现机制来讲ArrayList和Vector都是使用数组(Array)来控制集合中的对象。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组长度，vector缺省情况下自动增长原来一倍的长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。</p>
<p><strong>同步代码块和同步方法的区别</strong></p>
<ul>
<li>同步代码块在锁定的范围上可能比同步方法要小，一般来说锁的范围大小和性能是成反比的。</li>
<li>同步块可以更加精确的控制锁的作用域(所的作用域就是从锁被获取到其被释放的时间)，同步方法的锁的作用域就是整个方法。</li>
<li>静态代码块可以选择对哪个对象加锁，但是静态方法只能给this对象加锁。</li>
</ul>
<p>因为SynchronizedList只是使用同步代码块包裹了ArrayList的方法，而ArrayList和Vector中同名方法的方法体内容并无太大差异，所以在锁定范围和锁的作用域上两者并无区别。在锁定的对象区别上，SynchronizedList的同步代码块锁定的是mutex对象，Vector锁定的是this对象。那么mutex对象又是什么呢？其实SynchronizedList有一个构造函数可以传入一个Object，如果在调用的时候显示的传入一个对象，那么锁定的就是用户传入的对象。如果没有指定，那么锁定的也是this对象。</p>
<p>​        所以，SynchronizedList和Vector的区别目前为止有两点：1.如果使用add方法，它们的扩容机制不一样；2.SynchronizedList可以指定锁定的对象。<br>​        但是，SynchronizedList中实现的类并没有都使用synchronized同步代码块。其中有listIterator和listIterator(int index)并没有做同步处理。但是Vector却对该方法加了方法锁。所以在使用SynchronizedList进行遍历的时候要手动加锁。</p>
<p>​        之前的比较都是基于将ArrayList转成SynchronizedList。那么如果我们把LinkedList变成线程安全的，或者说我想要方便在中间插入和删除的同步的链表，那么我们可以将已有的LinkedList直接转成SynchronizedList，而不用改变它的底层的数据结构。而这一点是Vector无法做到的，因为他的底层是使用数组实现的，这个是无法更改的。</p>
<p>​        所以，最后，SynchronizedList和Vector最主要的区别：1.SynchronizedList有很好的扩展和兼容功能。它可以将所有的List子类转换成线程安全的类。2.使用SynchronizedList的时候，进行遍历的时候要手动进行同步处理。3.SynchronizedList可以指定锁定的对象。</p>
<h3 id="Set如何保证元素不重复？"><a href="#Set如何保证元素不重复？" class="headerlink" title="Set如何保证元素不重复？"></a>Set如何保证元素不重复？</h3><p>​        在Java的Set体系中，根据实现方式不同主要分为两大类：HashSet和TreeSet。</p>
<ul>
<li>TreeSet是二叉树实现的，TreeSet中的数据是自动排好序的，不允许放入null值</li>
<li>HashSet是哈希表实现的，HashSet中的数据是无需的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中的唯一约束。</li>
</ul>
<p>在HashSet中，基本的操作都是由HashMap底层实现的，因为HashSet底层是用HashMap存储数据的。当向HashSet中添加元素的时候，首先计算元素的hashcode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置为空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。</p>
<p>​        TreeSet的底层是TreeMap的keySet()，而TreeMap是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。<br>​        TreeMap是按key排序的，元素在插入TreeSet时compareTo()方法要被调用，所以TreeSet中的元素要实现Comparable接口。TreeSet作为一种Set，它不允许出现重复元素。TreeSet是用compareTo()来判断重复元素。</p>
<h3 id="HashMap、HashTable、ConcurrentHashMap区别"><a href="#HashMap、HashTable、ConcurrentHashMap区别" class="headerlink" title="HashMap、HashTable、ConcurrentHashMap区别"></a>HashMap、HashTable、ConcurrentHashMap区别</h3><p><strong>HashMap和HashTable有何不同？</strong></p>
<p>​        线程安全：HashTable中的方法是同步的，而HashMap中的方法在默认情况下是非同步的。在多线程并发的环境下，可以直接使用HashTable，但是要使用HashMap的话就要自己增加同步处理了。<br>​        继承关系：HashTable是基于陈旧的Dictionary类继承而来的。HashMap继承的抽象类AbstractMap实现了Map接口。<br>​        允不允许null值：HashTable中，key和value都不允许出现null值，否则会抛出NPE异常。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。<br>​        默认初始容量和扩容机制：HashTable中的hash数组初始大小是11，增加的方式是old*2+1。HashMap中的hash数组的默认大小为16，而且一定是2的指数。<br>​        哈希值的使用不同：HashTable直接使用对象的hashCode，HashMap重新计算hash值。<br>​        遍历方式的内部实现上不同：HashTable、HashMap都使用了Iterator。而由于历史原因，HashTable还使用了Enumeration的方式，HashMap实现了Iterator，支持fast-fail，HashTable的Iterator遍历支持fast-fail，用Enumeration不支持fast-fail。</p>
<p><strong>HashMap和ConcurrentHashMap的区别？</strong></p>
<p>​        ConcurrentHashMap和HashMap的实现方式不一样，虽然都是使用桶数组实现的，但是还是有区别的，ConcurrentHashMap对桶数组进行了分段，而HashMap并没有。<br>​        ConcurrentHashMap在每一个分段上都用锁进行了保护。HashMap没有锁机制，所以前者线程安全，后者不是线程安全的。</p>
<p>以上区别基于JDK1.8以前的版本。</p>
<h3 id="HashMap的容量、扩容"><a href="#HashMap的容量、扩容" class="headerlink" title="HashMap的容量、扩容"></a>HashMap的容量、扩容</h3><p>HashMap类中有以下主要成员变量：</p>
<ul>
<li>transient int size：记录了Map中KV对的个数</li>
<li>loadFactor：装载因子，用来衡量HashMap满的程度，loadFactor的默认值为0.75f(static final float DEFAULT_LOAD_FACTOR = 0.75f)</li>
<li>int threshold：临界值，当实际KV个数超过threshold时，HashMap会将容量扩容，threshold=容量* 装载因子</li>
<li>capacity：容量，如果不指定，默认容量为16(static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt;4;)</li>
</ul>
<p><strong>size和capacity</strong></p>
<p>​        HashMap中的size和capacity之间的区别其实解释起来也挺简单的，HashMap就像一个“桶”，那么capacity就是这个桶当前最多可以装多少元素，而size表示这个桶已经装了多少元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;wk&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; mapType = map.getClass();</span><br><span class="line">Method capacity = mapType.getDeclaredMethod(<span class="string">&quot;capacity&quot;</span>);</span><br><span class="line">capacity.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;capacity : &quot;</span> + capacity.invoke(map));</span><br><span class="line"></span><br><span class="line">Field size = mapType.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;size : &quot;</span> + size.get(map));</span><br></pre></td></tr></table></figure>

<p>​        我们定义了一个新的HashMap，并想其中put一个元素，然后同过反射的方式    打印capacity和size。输出结果为：capacity：16、size：1。</p>
<p>​        默认情况下，一个HashMap的容量(capacity)是16，设计为16的好处主要是可以使用按位与代替去模来提升hash的效率。</p>
<p>​        HashMap是具有扩容机制的，在一个HashMap第一次初始化的时候，默认情况下它的容量是16，当达到了扩容条件的时候，就需要进行扩容了，会从16扩容到32。</p>
<p>​        HashMap的重载的构造函数中，有一个是支持传入initialCapacity的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">1</span>);</span><br><span class="line">Class&lt;?&gt; mapType = map.getClass();</span><br><span class="line">Method capacity = mapType.getDeclaredMethod(<span class="string">&quot;capacity&quot;</span>);</span><br><span class="line">capacity.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;capacity : &quot;</span> + capacity.invoke(map));</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">7</span>);</span><br><span class="line">Class&lt;?&gt; mapType = map.getClass();</span><br><span class="line">Method capacity = mapType.getDeclaredMethod(<span class="string">&quot;capacity&quot;</span>);</span><br><span class="line">capacity.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;capacity : &quot;</span> + capacity.invoke(map));</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="number">9</span>);</span><br><span class="line">Class&lt;?&gt; mapType = map.getClass();</span><br><span class="line">Method capacity = mapType.getDeclaredMethod(<span class="string">&quot;capacity&quot;</span>);</span><br><span class="line">capacity.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;capacity : &quot;</span> + capacity.invoke(map));</span><br></pre></td></tr></table></figure>

<p>​        分别执行以上3段代码，分别输出：capacity：2、capacity：8、capacity：16<br>​        也就是说，默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(1-&gt;2、7-&gt;8、9-&gt;16)</p>
<p>​        这里有一个小建议：在初始化HashMap的时候，应该尽量指定其大小，尤其是当你已知map中存放的元素个数时。</p>
<p><strong>loadFactor和threshold</strong></p>
<p>​        HashMap有扩容机制，就是当达到扩容条件时会进行扩容，从16扩容到32、64、128…那么，这个扩容条件指的是什么呢？<br>​        其实，HashMap的扩容条件就是当HashMap中的元素个数(size)超过临界值(threshold)时就会自动扩容。在HashMap中，threshold = loadFactor * capacity。loadFactor是装载因子，表示HashMap满的程度，默认值为0.75f，设置为0.75有一好处，那就是0.75正好是3/4，而capacity又是2的幂。所以，两个数的乘积都是整数。<br>​        对于一个默认的HashMap来说，默认情况下，当期size大于12(16*0.75)时就会触发扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;wk1&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wk2&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wk3&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wk4&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wk5&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wk6&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wk7&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wk8&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wk9&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wk10&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wk11&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wk12&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; mapType = map.getClass();</span><br><span class="line">Method capacity = mapType.getDeclaredMethod(<span class="string">&quot;capacity&quot;</span>);</span><br><span class="line">capacity.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;capacity : &quot;</span> + capacity.invoke(map));</span><br><span class="line"></span><br><span class="line">Field size = mapType.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;size : &quot;</span> + size.get(map));</span><br><span class="line"></span><br><span class="line">Field threshold = mapType.getDeclaredField(<span class="string">&quot;threshold&quot;</span>);</span><br><span class="line">threshold.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;threshold : &quot;</span> + threshold.get(map));</span><br><span class="line"></span><br><span class="line">Field loadFactor = mapType.getDeclaredField(<span class="string">&quot;loadFactor&quot;</span>);</span><br><span class="line">loadFactor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;loadFactor : &quot;</span> + loadFactor.get(map));</span><br><span class="line"></span><br><span class="line">map.put(<span class="string">&quot;wk13&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; mapType = map.getClass();</span><br><span class="line">Method capacity = mapType.getDeclaredMethod(<span class="string">&quot;capacity&quot;</span>);</span><br><span class="line">capacity.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;capacity : &quot;</span> + capacity.invoke(map));</span><br><span class="line"></span><br><span class="line">Field size = mapType.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;size : &quot;</span> + size.get(map));</span><br><span class="line"></span><br><span class="line">Field threshold = mapType.getDeclaredField(<span class="string">&quot;threshold&quot;</span>);</span><br><span class="line">threshold.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;threshold : &quot;</span> + threshold.get(map));</span><br><span class="line"></span><br><span class="line">Field loadFactor = mapType.getDeclaredField(<span class="string">&quot;loadFactor&quot;</span>);</span><br><span class="line">loadFactor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;loadFactor : &quot;</span> + loadFactor.get(map));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">capacity : <span class="number">16</span></span><br><span class="line">size : <span class="number">12</span></span><br><span class="line">threshold : <span class="number">12</span></span><br><span class="line">loadFactor : <span class="number">0.75</span></span><br><span class="line"></span><br><span class="line">capacity : <span class="number">32</span></span><br><span class="line">size : <span class="number">13</span></span><br><span class="line">threshold : <span class="number">24</span></span><br><span class="line">loadFactor : <span class="number">0.75</span></span><br></pre></td></tr></table></figure>

<p>​        当HashMap中的元素个数达到了13的时候，capacity就从16扩容到32了。HashMap中还提供了一个在支持传入initialCapacity，loadFactor两个参数的方法，来初始化容量和装载因子。不过，一般不建议修改loadFactor的值。</p>
<p><strong>总结</strong></p>
<p>​        HashMap中size表示当前共有多少个KV对，capacity表示当前HashMap的容量是多少，默认值是16，每次扩容都是成倍的。loadFactor是装载因子，当Map中元素超过了loadFactor*capacity的值时，会触发扩容。loadFactor*capacity可以用threshold表示。</p>
<h3 id="HashMap中hash方法的原理"><a href="#HashMap中hash方法的原理" class="headerlink" title="HashMap中hash方法的原理"></a>HashMap中hash方法的原理</h3><p><strong>哈希</strong></p>
<p>​        Hash，一般翻译做“散列”，也直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变成固定长度的输出，该输出就是散列值。这是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入的值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
<p>​        所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列值函数计算出的散列值如果相同，输出值不一定相同。</p>
<p>​        若两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。</p>
<p>​        常见的Hash函数有以下几个：</p>
<ul>
<li>直接定址法：直接以关键字k或者k加上某个常数(k+c)作为哈希地址</li>
<li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址</li>
<li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。</li>
<li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</li>
<li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</li>
<li>伪随机数法：采用一个伪随机数当作哈希函数。</li>
</ul>
<p>上面介绍过碰撞，衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本都无法彻底避免碰撞，常见的解决的方法有以下几种：</p>
<ul>
<li>开放定址法：开放定址法就是一旦发生了冲突，就去寻找下一空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li>
<li>链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把关键字链在该单元为头结点的链表的尾部</li>
<li>再哈希法：当哈希地址发生冲突用其他的函数计算另外一个哈希函数地址，直到冲突不再产生为止。</li>
<li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li>
</ul>
<p><strong>HashMap的数据结构</strong></p>
<p>​        在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。上面我们提到过，常用的哈希函数的冲突解决办法中有一种方法叫做链地址法，其实就是将数组和链表组合在一起，发挥了两者的优势，我们可以理解为链表的数组。</p>
<p>​        它是由一个数组，数组的每一个成员是一个链表。该数据结构所容纳的所有元素均包换一个指针，用于元素间的链接。我们根据元素的自身特征把元素分配到不同的链表中去，反过来我们也是正通过这些特征找到正确的链表，再从链表中找出正确的元素。其中，根据元素特征计算元素数组下标的方法就是哈希算法，即本文的主角hash()函数。</p>
<p><strong>hash方法</strong></p>
<p>​        我们拿JDK1.7的HashMap为例，其中定义了一个final int hash(Object k)方法，其主要被以下方法引用。主要都是增加和删除方法，这不难理解，当我们要对一个链表数组中的某个元素进行增删的时候，首先要知道它应该保存在这个链表数组中的哪个位置，即它在这个数组中的下标。而hash()方法的功能就是根据Key来定位其在HashMap中的位置，HashTable、ConcurrentHashMap同理。 </p>
<p><strong>源码解析</strong></p>
<p>​        首先，在同一版本的JDK中，HashMap、HashTable以及ConcurrentHashMap里面的hash方法的实现是不同的。在不同的版本的JDK中也是有区别的。</p>
<p>​        我们知道，hash方法的功能是根据Key来定位K-V在链表数组中的位置的。也就是hash方法的输入应该是个Object类型的Key，输出应该是一个int类型的数组下标。<br>​        我们只要调用Object对象的hashCode()方法，该方法会返回一个整数，然后用这个数对HashMap或者HashTable的容量进行取模就行了。在具体实现上，由两个方法int hash(Object k)和int indexFor(int h, int length)来实现。但是考虑到效率等问题，HashMap的实现会稍微复杂一点。</p>
<ul>
<li>hash：该方法主要将Object转换成一个整型</li>
<li>indexFor：该方法主要将hash生成的整数型转换成链表数组的下标</li>
</ul>
<p><strong>HashMap In Java7</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap In Java7</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (k &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        indexFor方法其实主要是将hash生成的整型转换成链表数组中的下标。那么return h &amp; (length - 1); 是什么意思呢？其实，它就是取模。Java之所以使用位运算(&amp;)来代替取模运算(%)，最主要的考虑就是效率。位运算效率要比取模运算高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。<br>​        那么，为什么可以使用位运算来实现取模运算呢？这实现的原理如下：</p>
<p>$X%2^n = X&amp;(2^n -1)$，也就是说，一个数对$2^n$去模 == 一个数和$(2^n -1)$做按位与运算。</p>
<p>​        所以，return h &amp; (length - 1)；只要保证length的长度是$2^n$的话，就可以实现取模运算了。而HashMap中的length也确实是2的倍数，初始值是16，之后每次扩充为原来的2倍。</p>
<p>​        HashMap的数据是存储在链表数组里面的。在对HashMap进行插入/删除等操作时，都需要根据K-V对的键值定位到它应该保存在数组的那个下标中。而这个通过键值求取下标的操作就叫做哈希。HashMap的数组是有长度的，Java中规定这个长度只能是2的倍数，初始值为16。简单的做法是先求取出键值的hashcode，然后再将hashcode得到的int值对数组长度进行取模。为了考虑性能，Java总采用按位与操作实现取模操作。</p>
<p>​        接下来我们会发现，无论是用取模还是位运算都无法直接解决冲突较大的问题。例如：CA110000和00010000在对00001111进行按位与运算后的值是相等的。两个不同的键值，在对数组长度进行按位与运算后得到的结果相同，这就不发生了冲突了吗。那么如何解决这种冲突呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">h ^= k.hashCode();</span><br><span class="line">h ^= (k &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>​        这段代码是为了对Key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单点说，就是为了把高位的特征和低位的特征组合起来，降低哈希冲突的概率，也就是说，尽量做到任何一位的变化都能对最终得到的结果产生影响。</p>
<p>​        举个例子来说，向一个HashMap中put一个K-V对，Key值为“qwe”，经过简单的获取hashcode后值为“1011000110101110011111010011011”，如果当前HashTable的大小为16，即在不进行扰动计算的情况下，它最终得到的index结果计算为11。由于15的二进制扩展到32位为“00000000000000000000000000001111”，所以，一个数字在和它进行与操作的时候，前28位无论是什么，计算结果都一样。</p>
<p>​        经过扰动计算之后，就可以很好的避免了冲突。其实，使用位运算代替取模运算，除了性能之外，还有一个好处就是很好的解决符数的问题。因为我们知道，hashcode结果是int类型，而int类型取值范围为$-2^{31}$~$2^{31}-1$；这里面包含了符数的，对于一个符数取模还是有些麻烦的。如果使用二进制的位运算的话就可以很好的避免这个问题。首先，不管hashcode的值是正数还是符数。length-1这个值一定是个正数。那么，它的二进制的第一位一定是0，这样两个数按位与运算之后，第一位一定是个0，也就是，得到的结果一定是个正数。</p>
<p><strong>HashTable In Java7</strong></p>
<p>​        接下来看一下，线程安全的HashTable是如何实现的，和HashMap有何不同。下面是Java7中HashTable的hash方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hashSeed ^ k.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        只是对k做了简单的hash，取了一下其hashCode。而HashTable中也没有indexOf方法，取而代之的是这段代码：int index =  (hash &amp; 0x7FFFFFFF) % tab.length;也就是说，HashMap和HashTable对于计算数组下标这件事，采用了两种方法。HashMap采用的是位运算，而HashTable采用的是直接取模。<br>​        为什么要把hash值和0x7FFFFFFF做一次按位与操作呢？主要是因为为了保证得到的index的第一位为0，也就是为了得到一个正数。</p>
<p>​        HashMap之所以不用取模的原因是为了提高效率。有人认为，因为HashTable是个线程安全的类，本来就慢，所以Java并没有考虑效率问题，直接使用取模算法了呢？但是其实并不完全是，Java这样设计还有一定的考虑在，虽然这样效率确实是会比HashMap慢一些。其实，HashTable采用简单的取模是有一定的考虑在的，就是HashTable的构造函数和扩容函数了。HashTable默认的初始值大小为11，之后每次扩充为原来的2n+1。也就是说，HashTable的链表数组的默认大小是一个素数、奇数。之后每次扩充结果也是奇数。由于HashTable会尽量使用素数、奇数作为容量的大小。当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀。</p>
<p><strong>总结</strong></p>
<ul>
<li>HashMap默认的初始化大小16，之后每次扩充为原来的2倍。</li>
<li>HashTable默认的初始化大小为11，之后每次扩充为原来的2n+1。</li>
<li>当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀，所以单从这一点上看，HashTable的哈希表大小选择，似乎更高明。因为hash结果越分散效果越好。</li>
<li>在取模运算时，如果模数是2的幂，那么我们可以直接使用位运算来得到结果，效率要远远大于做除法。所以hash计算的效率上，又是HashMap更胜一筹。</li>
<li>但是，HashMap为了提高效率使用位运算代替哈希，这又，这又引入了哈希分布不均匀的问题，所以HashMap为了解决这个问题，又对hash算法做了一些改进，进行了扰动计算。</li>
</ul>
<p><strong>ConcurrentHashMap In Java7</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String))&#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    </span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br></pre></td></tr></table></figure>

<p>​        上面的ConcurrentHashMap的hash实现其实和HashMap如出一辙，都是通过位运算代替取模，然后对hashcode进行扰动。区别在于，ConcurrentHashMap使用了一种变种的Wang/Jenkins 哈希算法，其主要目的也是为了把高位和低位组合在一起，避免发生冲突。</p>
<p><strong>HashMap In Java8</strong></p>
<p>​        在Java8之前，HashMap和其他基于Map的类都是通过链地址法解决冲突，它们使用单向链表来存储相同的索引的元素。在最坏的情况下，这种方式将HashMap的get方法的性能从O(1)降低到了O(n)。为了解决在频繁冲突时hashmap性能降低的问题，Java8中使用平衡树来代替链表存储冲突的元素。这意味着我们可以将最坏情况下的性能从O(n)提高到O(logn)。</p>
<p>​        若恶意程序知道我们用的是Hash算法，则在纯链表情况下，它能发送大量请求导致哈希碰撞，然后不停的访问这些Key导致HashMap忙于进行线性查找，最终陷入瘫痪，即形成了拒绝服务攻击(Dos)。</p>
<p>​        关于Java8中的hash函数，原理和Java7中基本类似。Java8中这一步做了优化，只做一次16位右位移异或混合，而不是四次，但原理不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要从速度、功效、质量来考虑的。以上方法得到的int的hash值，然后再通过 h &amp; (table.length - 1)来得到该对象在数据中保存的位置。</p>
<p><strong>HashTable In Java8</strong></p>
<p>​        在Java8的HashTable中，已经有hash方法了。但是哈希的操作还是在的，比如在put方法中就有实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br></pre></td></tr></table></figure>

<p>这里和Java7中的实现几乎无差别。</p>
<p><strong>ConcurrentHashMap In Java8</strong></p>
<p>​        Java8中的求hash的方法改为了spread。实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>) &amp; HASH_BITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        Java8的ConcurrentHashMap同样是通过Key的哈希值与数组长度取模确定该Key在数组中的索引。同样为了避免不太好的Key的hashCode设计，它通过如下方法计算得到Key的最终哈希值。不同的是，Java8的ConcurrentHashMap作者认为引入红黑树后，即使哈希冲突比较严重，寻址效率也足够高，所以作者并未在哈希值的计算上做过多设计，只是将Key的hashCode值与其高16位做异或并保证最高位为0。</p>
<h3 id="为什么HashMap的默认容量设置为16"><a href="#为什么HashMap的默认容量设置为16" class="headerlink" title="为什么HashMap的默认容量设置为16"></a>为什么HashMap的默认容量设置为16</h3><p>​        集合是Java开发日常中经常会使用到的，而作为一种典型K-V结构的数据结构，HashMap对于Java开发者一定不陌生。在日常开发中，我们经常会像如下方式创建一个HashMap：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br></pre></td></tr></table></figure>

<p>​        此时，我们并没有给HashMap指定容量，那么这时候一个新创建的HashMap的默认容量是多少呢？为什么呢？</p>
<p><strong>什么是容量</strong></p>
<p>​        在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。HashMap就是将数组和链表组合在一起，发挥两者的优势，我们可以理解为链表的数组。</p>
<p>​        在HashMap中，有两个比较容易混淆的关键字段：size和capacity，这其中capacity就是Map的容量，而size我们称之为Map中的元素个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;wk&quot;</span>,<span class="string">&quot;qew&quot;</span>);</span><br><span class="line">Class&lt;?&gt; mapType = map.Class();</span><br><span class="line">Method capacity = mapType.getDeclaredMethod(<span class="string">&quot;capacity&quot;</span>);</span><br><span class="line">capacity.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;capacity : &quot;</span> + capacity.invoke(map));</span><br><span class="line"></span><br><span class="line">Field size = mapType.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">size.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;size : &quot;</span> + size.get(map));</span><br><span class="line"></span><br><span class="line"><span class="comment">//capacity : 16, size : 1</span></span><br></pre></td></tr></table></figure>

<p>​        上面我们定义了一个新的HashMap，并向其中put了一个元素，然后通过反射的方式打印capacity和size，其容量为16，已经存放的元素个数为1。</p>
<p><strong>容量与哈希</strong></p>
<p>​        容量就是HashMap中桶的个数，那么，当我们想要往一个HashMap中put一个元素的时候，需要通过一定的计算出应该把它放到哪个桶中，这个过程就叫做哈希(hash)，对应的就是HashMap中的hash方法。<br>​        hash方法的功能就是根据Key来定位这个K-V在链表数组中的位置的。也就是hash方法的输入应该是个Object类型的Key，输出应该是个int类型的数组下标。我们只要调用Object对象的hashCode()方法，该方法会返回一个整数，然后用这个数对HashMap容量进行取模就行了，再考虑到效率的问题，HashMap的hash方法的实现还是有一定的复杂的。</p>
<p><strong>hash的实现</strong></p>
<p>​        具体的实现上，由两个方法int hash(Object k)和int indexFor(int h, int length)来实现。hash：该方法主要将Object转换成一个整型；indexFor：该方法主要是将hash生成的整型转换成链表数组中的下标。</p>
<p>​        先来看indexFor方法，在Java7中该实现的细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        indexFor方法其实主要将hashcode换成链表数组中的下标。其中的两个参数h表示元素的hashcode值，length值表示HashMap的容量。那么return h &amp; (length - 1)是什么意思呢？其实，它就是取模。Java之所以使用位运算($)来代替取模运算(%)，最主要考虑的就是效率。位运算(&amp;)效率要比代替取模运算(%)高得多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。</p>
<p>​        那么，为什么可以使用位运算(&amp;)来实现取模运算(%)呢？这实现的原理如下：</p>
<p>$X % 2^n=X &amp; (2^{n}-1)$，从二进制角度来看，X/8相当于X&gt;&gt;3，把X右移3位，此时得到了X/8的商，而被移掉的部分(后三位)，则是X%8，也就是余数。</p>
<p>​        之所以可以做等价代替，前提要求是HashMap的容量一定是$2^n$。那么既然是$2^n$    ，为什么一定要是16呢？为什么不是4、8或者32呢？应该是个经验值(Experience Value)，既然设置一个默认的$2^n$作为初始值，那么就需要在效率和内存上做一个平衡。这个值既不能太小也不能太大。太小就有可能发生频繁扩容，影响效率；太大又浪费空间，不划算。故16作为了一个经验值被采用。</p>
<p>​        在JDK 8中，关于默认容量定义为：static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//aka 16 ，其故意把16写成了1 &lt;&lt; 4，就是提醒开发者，这个地方要2的幂。</p>
<p>​        那么，接下来分析一下，HashMap是如何保证其容量一定可以是$2^n$的呢？如果用户自己设置了的话又会是怎么样？HashMap在两个可能改变其容量的地方都做了兼容处理，分别指定容量初始化时及扩容时。</p>
<p><strong>指定容量初始化</strong> </p>
<p>​        当我们通过HashMap(int initialCapacity)设置初始容量的时候，HashMap并不一定会直接采用我们传入的值，而是经过计算，得到一个新值，目的是要提高hash效率。(1-&gt;1、3-&gt;4、7-&gt;8、9-&gt;16)</p>
<p>​        在JDK1.7和JDK1.8中，HashMap初始化这个容量的时机不同。JDK1.8中，在调用HashMap的构造函数定义HashMap的时候，就会进行容量的设定；而在JDK1.7中，要等一次put操作时才进行这一步操作。</p>
<p>​        看一下JDK是如何找到传入的指定值大的第一个2的幂的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">n | = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">n | = n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">n | = n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n | = n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">n | = n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​        上面的算法的目的就是：根据用户传入的容量值(代码中的cap)，通过计算，得到第一个比他大的2的幂并返回。<br>​        在5-&gt;8、9-&gt;16、19-&gt;32、37-&gt;64这些例子中都是主要经过了两个阶段：</p>
<ul>
<li>①5-&gt;7;②7-&gt;8</li>
<li>①9-&gt;15;②15-&gt;16</li>
<li>①37-&gt;63;②63-&gt;64</li>
</ul>
<p>对应以上的代码中，Step1①为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n | = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">n | = n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">n | = n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n | = n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">n | = n &gt;&gt;&gt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p>对应以上的代码中，Step2②为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​        对于Step2比较简单，就是做一下极限值的判断，然后把Step+1得到的数值+1；</p>
<p>​        对于Step1中，就是对二进制数依次右移，然后与原值取或，其目的是对于一个二进制，从第一个不为0的位开始，把后面的所有位设置成1。</p>
<p>​        但是还有一种特殊的情况套用以上公式不行，这些数字本身就是2的幂自身。例如数字4套用公式会得到8。</p>
<p><strong>扩容</strong></p>
<p>​        除了初始化的时候指定了HashMap的容量，在进行扩容的时候，其容量也可能会改变。HashMap有扩容机制，就是当达到了扩容条件时会进行扩容。HashMap的扩容条件就是当HashMap中的元素个数(size)超过了临界值(threshold)时就会自动扩容。在HashMap中，threshold = loadFactor  * capacity。loadFactor是装载因子，表示HashMap满的程度，默认值为0.75f，设置为0.75有个好处正好是3/4，而capacity又是2的幂。所以两个数的乘积都是整数。<br>​        对于一个默认的HashMap来说，默认情况下，当期size大于12(16*0.75)时就会出发扩容。下面是HashMap中扩容方法(resize)中的一段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPCITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">    newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​        从上面代码可以看出，扩容后的table大小变为原来的两倍，这一步执行之后，就会进行扩容后table的调整。可见，当HashMap中的元素个数(size)超过临界值(threshold)时就会自动扩容，扩容成原容量的2倍，即从16扩容到32、64、128…<br>​        所以，通过保证初始化容量均为2的幂，并且扩容时也是扩容到之前容量的2倍，所以，保证了HashMap的容量永远都是2的幂。</p>
<p><strong>总结</strong></p>
<p>​        HashMap做为一种数据结构，元素在put的过程中需要进行hash计算，目的是计算出该元素存放在HashMap中的具体位置。hash运算过程其实就是对目标元素的Key进行hashCode，再对Map的容量进行取模，而JDK的工程师为了提升取模的效率，使用了位运算取代取模运算的效率，使用位运算代替了取模运算，这就要求Map的容量一定是2的幂。<br>​        而作为默认容量，太小和太大都不适合，所以16就作为一个比较合适的经验值被采用了。为了保证任何情况下Map的容量都是2的幂，HashMap在两个地方都做了限制：首先是，若用户制定了初始容量，那么HashMap会计算出比该数大的第一个2的幂作为初始容量；另外，在扩容的时候，也是进行成倍扩容的，即4-&gt;8，8-&gt;16。</p>
<h3 id="为什么建议设置HashMap的初始容量，设置多少合适"><a href="#为什么建议设置HashMap的初始容量，设置多少合适" class="headerlink" title="为什么建议设置HashMap的初始容量，设置多少合适"></a>为什么建议设置HashMap的初始容量，设置多少合适</h3><p><strong>要设置HashMap的初始容量</strong></p>
<p>​        HashMap有扩容机制，就是当达到了扩容条件时会进行扩容；HashMap的扩容条件就是当HashMap中元素个数(size)超过了临界值(threshold)时就会自动扩容。在HashMap中，threshold = loadFactor  * capacity。</p>
<p>​        所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。所以，首先可以明确的是，我们建议开发者在创建HashMap的时候指定初始化容量，在《Java开发手册》中也是这么建议的。</p>
<p><strong>HashMap初始化容量设置多少合适</strong></p>
<p>​        有些人会自然想到，我准备塞多少个元素我就设置成多少呗，例如准备塞7个元素，那么就new HashMap(7)。这样的做法不仅不对，而且以上方式创建出来的Map的容量也不是7。<br>​        因为，当我们使用HashMap(int initialCapacity)来初始化容量的时候，HashMap并不会使用我们传进来的initialCapacity直接作为初始容量。JDK会默认帮我们计算一个相对合理的值当做初始容量，所谓合理的值就是找到第一个比用户传入的值打的2的幂。<br>​        也就是说，当我们new HashMap(7)创建HashMap的时候，JDK会计算，帮我们创建容量为8的Map；当我们new HashMap(9)创建HashMap的时候，JDK会计算，帮我们创建容量为16的Map。<br>​        但是，这个值看似合理，实际上并不尽然。因为HashMap在根据用户传入的capacity计算得到的默认容量，并没有考虑到loadFactor这个因素，只是简单机械的计算出一个大于这个数字的2的幂。<br>​        loadFactor是负载因子，当HashMap中的元素个数(size)超过threshold = loadFactor * capacity时，就会进行扩容。当我们设置的默认值是7，经过JDK处理之后，HashMap的容量会被设置成8，但是，这个HashMap在元素个数达到8*0.75 = 6的时候就会进行一次扩容，这明显是我们不希望见到的。<br>​        那么，到底设置成什么值较为合理呢？参考JDK8中putAll方法中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) ((<span class="keyword">float</span>) expectedSize / <span class="number">0.75F</span> + <span class="number">1.0F</span>);</span><br></pre></td></tr></table></figure>

<p>​        比如我们计划向HashMap中放入7个元素的时候，我们通过expectedSize / 0.75F + 1.0F计算，7/0.75 + 1 = 10，10经过JDK处理之后，会被设置成16，这就大大的减少了扩容的几率。<br>​        当HashMap内部维护的哈希表的容量达到75%时，会触发rehash，而rehash的过程是比较耗费时间的。所以初始化容量要设置成expectedSize / 0.75F + 1.0F的话，可以有效的减少冲突也可以减少误差。</p>
<p>​        所以，我们可以认为，当我们明确知道HashMap中的个数的时候，把默认值色设置为expectedSize / 0.75F + 1.0F是一个在性能上相对好的选择，但是，同时也会牺牲些内存。<br>​        这个算法在guava中有实现，开发的时候，可以直接通过Maps类创建一个HashMap：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = Maps.newHashMapWithExpectedSize(<span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<p>其代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt;<span class="function">HashMap&lt;K, V&gt; <span class="title">newHashMapWithExpectedSize</span><span class="params">(<span class="keyword">int</span> expectedSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashMap(capacity(expectedSize));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> expectedSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(expectedSize &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        CollectPreconditions.checkNonnegative(expectedSize, <span class="string">&quot;expectedSize&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> expectedSize + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expectedSize &lt; <span class="number">1073741824</span> ? (<span class="keyword">int</span>) ((<span class="keyword">float</span>) expectedSize / <span class="number">0.75F</span> + <span class="number">1.0F</span>) : <span class="number">2147483647</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        以上的操作是一种用内存换性能的做法，真正使用的时候，需要考虑到内存的影响。但，大多数情况下，我们认为内存是一种比较富裕的资源。但是话又说回来了，有些时候，我们到底要不要设置HashMap的初始值，这个值设置成多少，真的有那么大影响么？其实也不见得！<br>​        但是，大的性能优化，不就是一个一个的优化细节堆叠出来的么？</p>
<h3 id="Java8中stream相关用法"><a href="#Java8中stream相关用法" class="headerlink" title="Java8中stream相关用法"></a>Java8中stream相关用法</h3><p>​        在Java中，集合和数组是我们经常会用到的的数据结构，需要经常对他们做增、删、改、查、聚合、统计、过滤等操作。相比之下，关系型数据库中也同样有这些操作，但在Java8之前，集合和数组的处理并不是很便捷。<br>​        不过，这一问题在Java8中得到了改善，Java8API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p>
<p><strong>Stream介绍</strong></p>
<p>​        Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>​        这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。</p>
<p>​        Stream有以下特性及优点：</p>
<ul>
<li>无存储。Stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>
<li>为函数式编程而生。对于Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含过滤元素的新Stream。</li>
<li>惰式执行。Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li>可消费性。Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
<p>对于流的处理，主要有三种关键性操作：分别是流的创建、中间操作(intermediate operation)以及最终操作(terminal operation)。</p>
<p><strong>Stream的创建</strong></p>
<p>​        在Java8中，可以有多种方式来创建流。</p>
<ul>
<li>1.通过已有的集合来创建流</li>
</ul>
<p>在Java8中，除了增加了很多Stream相关的类以外，还对集合类自身做了增强，在其中增加了Stream方法，可以将一个集合类转换成流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;wk&quot;</span>, <span class="string">&quot;qwe&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = strings.stream();</span><br></pre></td></tr></table></figure>

<p>以上，通过一个已有的List创建一个流。除此之外，还有一个parallelStream方法，可以为集合创建一个并行流。这种通过集合创建出一个Stream的方式也是比较常用的一种方式。</p>
<ul>
<li>通过Stream创建流</li>
</ul>
<p>可以使用Stream类提供的方法，直接返回一个由指定元素组成的流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;wk&quot;</span>, <span class="string">&quot;qwe&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;helloworld&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如以上代码，直接通过of方法，创建并返回一个Stream。</p>
<p><strong>Stream中间操作</strong></p>
<p>​        Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每个中间操作就像流水线上的一个工人，每个工人都可以对流进行加工，加工后得到的结果还是一个流。<br>​        以下是常用的中间操作列表：</p>
<table>
<thead>
<tr>
<th align="center">Stream Operation</th>
<th align="center">Goal</th>
<th align="center">Input</th>
</tr>
</thead>
<tbody><tr>
<td align="center">filter</td>
<td align="center">Filter items according to a given predicate</td>
<td align="center">Predicate</td>
</tr>
<tr>
<td align="center">map</td>
<td align="center">Processes items and transforms</td>
<td align="center">Function</td>
</tr>
<tr>
<td align="center">limit</td>
<td align="center">Limit the results</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">sorted</td>
<td align="center">Sort items inside stream</td>
<td align="center">Comparator</td>
</tr>
<tr>
<td align="center">distinct</td>
<td align="center">Remove duplicate items according to equals method of the given type</td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>filter</strong></p>
<p>filter方法用于通过设置的条件过滤出元素。以下代码片段使用filter方法过滤掉空字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;wk&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;qwe&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;wkk&quot;</span>);</span><br><span class="line">Strings.stream().filter(string -&gt; !String.isEmpty()).forEach(System.out::println);</span><br><span class="line"><span class="comment">//wk, , qwe, w, wkk</span></span><br></pre></td></tr></table></figure>

<p><strong>map</strong></p>
<p>map方法用于映射每个元素到对应的结果，以下代码片段使用map输出了元素对应的平方数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().map(i -&gt; i*i).forEach(System.out::println);</span><br><span class="line"><span class="comment">//9,4,4,9,49,9,25</span></span><br></pre></td></tr></table></figure>

<p><strong>limit/skip</strong></p>
<p>limit返回Stream的前面n个元素；skip则是扔掉前n个元素。以下代码片段使用limit方法保留4个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asLsit(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,2,3</span></span><br></pre></td></tr></table></figure>

<p><strong>sorted</strong></p>
<p>sorted方法用于对流进行排序。以下代码片段使用sorted方法进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.,stream().sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">//2,2,3,3,3,5,7</span></span><br></pre></td></tr></table></figure>

<p><strong>distinct</strong></p>
<p>distinct主要用来去重，以下代码片段使用distinct对元素进行去重：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,7,5</span></span><br></pre></td></tr></table></figure>

<p>接下来是，当一个Stream先后通过filter、map、sort、limit以及distinct处理后发生了什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;wkwkwk&quot;</span>, <span class="string">&quot;wkhelloworld&quot;</span>, <span class="string">&quot;wkwkwk&quot;</span>, <span class="string">&quot;helloworld&quot;</span>,<span class="string">&quot;qew&quot;</span>);</span><br><span class="line">Stream s = strings.stream().filter(string -&gt; string.length() &lt;= <span class="number">6</span>).map(String::length).sorted().limit(<span class="number">3</span>).distinct();</span><br><span class="line"><span class="comment">//string-&gt;filter-&gt;[&quot;wkwkwk&quot;,&quot;wkwkwk&quot;,&#x27;qew&#x27;]</span></span><br><span class="line"><span class="comment">//-&gt;map-&gt;[6,6,3]</span></span><br><span class="line"><span class="comment">//-&gt;sorted-&gt;[3,6,6]</span></span><br><span class="line"><span class="comment">//-&gt;limit-&gt;[3,6,6]</span></span><br><span class="line"><span class="comment">//-&gt;distinct-&gt;[3,6]</span></span><br></pre></td></tr></table></figure>

<p><strong>Stream最终操作</strong></p>
<p>​        Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流元素个数、将流装换成集合。这就需要最终操作(terminal operation)。<br>​        最终操作会消耗流，产生一个最终结果，也就是说，在最终操作之后，不能再次使用流，也不能在使用任何中间操作，否则将抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: Stream has a already been operated upon or closed</span><br></pre></td></tr></table></figure>

<p>常用的最终操作如下图：</p>
<table>
<thead>
<tr>
<th align="center">STREAM OPERATION</th>
<th align="center">GOAL</th>
<th align="center">INPUT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">forEach</td>
<td align="center">For every item, outputs something</td>
<td align="center">Consumer</td>
</tr>
<tr>
<td align="center">count</td>
<td align="center">Counts current items</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">collect</td>
<td align="center">Reduces the stream into a desired collection</td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>forEach</strong></p>
<p>​        Stream提供了方法forEach来迭代流中的每个数据。以下代码片段使用forEach输出了10个随机数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>count</strong></p>
<p>count用来统计流中的元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;qwe&quot;</span>, <span class="string">&quot;asd&quot;</span>, <span class="string">&quot;zxc&quot;</span>, <span class="string">&quot;rty&quot;</span>);</span><br><span class="line">System.out.println(strings.stream().count());</span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p><strong>collect</strong></p>
<p>collect就是一个归约操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;qwe&quot;</span>, <span class="string">&quot;qweasd&quot;</span>, <span class="string">&quot;qwezxc&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">strings = strings.stream().filter(string -&gt; string.startsWith(<span class="string">&quot;qwe&quot;</span>)).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//qwe, qweasd, qwezxc</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>​        本节介绍了Java8中的Stream的用途，优点等。还介绍了Stream的几种用法，分别是Stream创建、中间操作和最终操作。<br>​        Stream的创建有两种方式，分别是通过集合类的stream方法、通过Stream的of方法。<br>​        Stream的中间操作可以用来处理Stream，中间操作的输入和输出都是Stream，中间操作可以是过滤、转换、排序等。<br>​        Stream的最终操作可以将Stream转成其他形式，如计算出流中元素的个数、将流装转换成集合、以及元素的遍历。</p>
<h3 id="Apache集合处理工具类的使用"><a href="#Apache集合处理工具类的使用" class="headerlink" title="Apache集合处理工具类的使用"></a>Apache集合处理工具类的使用</h3><p>​        Commons Collections增强了Java Collections Framework，他提供了几个功能，使收集处理变得容易，他提供了许多新的接口，实现和实用程序。Commons Collections的主要功能如下：</p>
<ul>
<li>Bag - Bag界面简化了每个对象具有多个副本的集合</li>
<li>BidiMap - BidiMap接口提供双向映射，可用于使用键或键查找值。</li>
<li>MapIterator - MapIterator接口提供简单而容易的迭代</li>
<li>Transforming Decorators - 转换装饰器可以在将集合添加到集合时更改集合的每个对象</li>
<li>Composite Collections - 在需要统一处理多个集合的情况下使用复合集合</li>
<li>Ordered Map - 有序地图保留添加元素的顺序</li>
<li>Ordered Set - 有序集保留了添加元素的顺序</li>
<li>Reference map - 参考图允许在密切控制下对键/值进行垃圾收集</li>
<li>Comparator implmentations - 可以使用许多Comparator实现</li>
<li>Iterator implementations - 许多Iterator实现都可用</li>
<li>Adapter Classes - 适配器类可用于将数组和枚举转换为集合</li>
<li>Utilities - 实用程序可用于测试测试或创建集合的典型集合论属性，例如union，intersection。支持关闭</li>
</ul>
<p><strong>Commons Collections - Bag</strong></p>
<p>​        Bag定义了一个集合，用于计算对象在集合中出现的次数。例如，Bag包含{a,a,b,c}，则getCount(“a”)将返回2，而uniqueSet()将返回唯一值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Bag;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.Bag.HashBag;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BagTester</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Bag&lt;String&gt; bag = <span class="keyword">new</span> HashBag&lt;&gt;();</span><br><span class="line">        bag.add(<span class="string">&quot;a&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        bag.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        bag.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        bag.add(<span class="string">&quot;d&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;d is present &quot;</span> + bag.getCount(<span class="string">&quot;d&quot;</span>) + <span class="string">&quot; times.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bag: &quot;</span> + bag);</span><br><span class="line">        System.out.println(<span class="string">&quot;Unique Set: &quot;</span> + bag.uniqueSet());</span><br><span class="line">        bag.remove(<span class="string">&quot;d&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2 occurents of d removed from bag: &quot;</span> + bag);</span><br><span class="line">        System.out.println(<span class="string">&quot;d is present &quot;</span> + bag.getCount(<span class="string">&quot;d&quot;</span>) + <span class="string">&quot; times.&quot;</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;bag: &quot;</span> + bag);</span><br><span class="line">        System.out.println(<span class="string">&quot;Unique Set: &quot;</span> + bag.uniqueSet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//d is present 3 times</span></span><br><span class="line"><span class="comment">//bag: [2:a,1:b,1:c,3:d]</span></span><br><span class="line"><span class="comment">//Unique Set: [a,b,c,d]</span></span><br><span class="line"><span class="comment">//2 occurences of d removerd from bag: [2:a,1:b,1:c1:d]</span></span><br><span class="line"><span class="comment">//d is present 1 times</span></span><br><span class="line"><span class="comment">//bag: [2:a,1:b,1:c1:d]</span></span><br><span class="line"><span class="comment">//Unique Set: [a,b,c,d]</span></span><br></pre></td></tr></table></figure>

<p><strong>Commons Collections - BidiMap</strong></p>
<p>使用双向映射，可以使用值查找键，并且可以使用键轻松查找值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.BidiMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.bidimap.TreeBidiMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BidiMapTester</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BidiMap&lt;String, String&gt; bidi = <span class="keyword">new</span> TreeBidiMap&lt;&gt;();</span><br><span class="line">        bidi.put(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        bidi.put(<span class="string">&quot;Two&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">        bidi.put(<span class="string">&quot;Three&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(bidi.get(<span class="string">&quot;One&quot;</span>));</span><br><span class="line">        System.out.println(bidi.getKey(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Original Map: &quot;</span> + bidi);</span><br><span class="line">        bidi.removeValue(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Modified Map: &quot;</span> + bidi);</span><br><span class="line">        BidiMap&lt;String, String&gt; inversedMap = bidi.inverseBidiMap();</span><br><span class="line">        System.out.println(<span class="string">&quot;Inversed Map: &quot;</span> + inversedMap);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//One</span></span><br><span class="line"><span class="comment">//Original Map: &#123;One=1, Three=3, Two=2&#125;</span></span><br><span class="line"><span class="comment">//Modified Map: &#123;Three=3, Two=2&#125;</span></span><br><span class="line"><span class="comment">//Inversed Map: &#123;2=Two, 3=Three&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Commons Collections - Maplterator</strong></p>
<p>​        JDK Map接口很难迭代，因为迭代要在EntrySet和KeySet对象上完成。Mapiterator提供了对Map的简单迭代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.IterableMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.MapIterator;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.map.HashedMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapIteratorTester</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        IterableMap&lt;String, String&gt; map = <span class="keyword">new</span> HashedMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;One&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;Two&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;Three&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;Four&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;5&quot;</span>, <span class="string">&quot;Five&quot;</span>);</span><br><span class="line">        MapIterator&lt;String, String&gt; iterator = map.mapIterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Object key = iterator.next();</span><br><span class="line">            Object value = iterator.getValue();</span><br><span class="line">            System.out.println(<span class="string">&quot;key: &quot;</span> + key);</span><br><span class="line">            System.out.println(<span class="string">&quot;Value: &quot;</span> + value);</span><br><span class="line">            iterator.setValue(value + <span class="string">&quot;_&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key: 3</span></span><br><span class="line"><span class="comment">//Value: Three</span></span><br><span class="line"><span class="comment">//key: 5</span></span><br><span class="line"><span class="comment">//Value: Five</span></span><br><span class="line"><span class="comment">//key: 2</span></span><br><span class="line"><span class="comment">//Value: Two</span></span><br><span class="line"><span class="comment">//key: 4</span></span><br><span class="line"><span class="comment">//Value: Four</span></span><br><span class="line"><span class="comment">//key : 1</span></span><br><span class="line"><span class="comment">//Value: One</span></span><br><span class="line"><span class="comment">//&#123;3=Three_, 5=Five_, 2=Two_, 4=Four_, 1=One_&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Commons Collections - OrderedMap</strong></p>
<p>​        OrderedMap是地图的新接口，用于保留添加元素的顺序。LinkedMap和ListOrderedMap是两个可用的实现。此接口支持Map的迭代器，并允许在Map中向前或向后迭代两个方向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.OrderedMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.map.LinkedMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderedMapTester</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        OrderedMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Two&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Three&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(map.firstkey());</span><br><span class="line">        System.out.println(map.nextKey(<span class="string">&quot;One&quot;</span>));</span><br><span class="line">        System.out.println(map.nextKey(<span class="string">&quot;Two&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//One</span></span><br><span class="line"><span class="comment">//Two</span></span><br><span class="line"><span class="comment">//Three</span></span><br></pre></td></tr></table></figure>

<p><strong>Commons Collections - Ignore NULL</strong></p>
<p>​        Apache Commons Collections库的CollectionUtils类为常见操作提供了各种实用方法，涵盖了广泛的用例。它有助于避免编写样板代码，这个库在JDK8之前非常有用，因为Java8的Stream API现在提供了类似的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionUtilsTester</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    CollectionUtils.addIgnoreNull(list, <span class="keyword">null</span>);</span><br><span class="line">    CollectionUtils.addIgnoreNull(list, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="keyword">if</span>(list.contains(<span class="keyword">null</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Null value is present&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Null value is Not present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[a]</span></span><br><span class="line"><span class="comment">//Null value is Not present</span></span><br></pre></td></tr></table></figure>

<p><strong>Merge &amp; Sort</strong></p>
<p>​        Apache Commons Collections库的CollectionUtils类为常见操作提供了各种实用方法，涵盖了广泛的用例。它有助于避免编写样板代码。这个在JDK8之前非常有用，因为Java8的Stream API 现在提供了类似的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionUtilsTester</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; sortedList1 = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">        List&lt;String&gt; sortedList2 = Arrays.asList(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;F&quot;</span>);</span><br><span class="line">        List&lt;String&gt; mergedList = CollectionUtils.collate(sortedList1, sortedList2);</span><br><span class="line">        System.out.println(mergedList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[A, B, C, D, E, F]</span></span><br></pre></td></tr></table></figure>

<p><strong>安全检查(Safe Empty Checks)</strong></p>
<p>​        Apache Commons Collections库的CollectionUtils类为常见操作提供了各种实用方法，涵盖了广泛的用例。它有助于避免编写样板代码，这个库在JDK8之前非常有用，因为Java8的Stream API现在提供了类似的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionUtilsTester</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = getList();</span><br><span class="line">        System.out.println(<span class="string">&quot;Non-Empty List Check: &quot;</span> + checkNotEmpty1(list));</span><br><span class="line">        System.out.println(<span class="string">&quot;Non-Empty List Check: &quot;</span> + checkNotEmpty2(list));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;String&gt; <span class="title">getList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkNotEmpty1</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(list == <span class="keyword">null</span> || list.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkNotEmpty2</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CollectionUtils.isNotEmpty(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Non-Empty List Check: false</span></span><br><span class="line"><span class="comment">//Non-Empty List Check: false</span></span><br></pre></td></tr></table></figure>

<p><strong>Commons Collections - Inclusion</strong></p>
<p>​        检查列表是否是另外一个列表的一部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionUtilsTester</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;List 1:&quot;</span> + list1);</span><br><span class="line">        System.out.println(<span class="string">&quot;List 1:&quot;</span> + list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Is List 2 contained in List 1: &quot;</span> + CollectionUtils.isSubCollection(list2,list1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//List 1: [A, A, A, C, B, B]</span></span><br><span class="line"><span class="comment">//List 2: [A, A, B, B]</span></span><br><span class="line"><span class="comment">//Is List 2 contained in List 1: true</span></span><br></pre></td></tr></table></figure>

<p><strong>Commons Collections - Intersection</strong></p>
<p>​        用于获取两个集合之间的公共对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionUtilsTester</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;List 1: &quot;</span> + list1);</span><br><span class="line">        System.out.println(<span class="string">&quot;List 2: &quot;</span> + list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Commons Objects of List 1 and List 2: &quot;</span> + CollectionUtils.intersection(list1, list2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//List 1: [A, A, A, C, B, B]</span></span><br><span class="line"><span class="comment">//List 2: [A, A, B, B]</span></span><br><span class="line"><span class="comment">//Commons Objects of List 1 and List 2: [A, A, B, B]</span></span><br></pre></td></tr></table></figure>

<p><strong>Commons Collections - Subtraction</strong></p>
<p>​        通过从其他集合中减去一个集合的对象来获取新集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionUtilsTester</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;List 1: &quot;</span> + list1);</span><br><span class="line">        System.out.println(<span class="string">&quot;List 2: &quot;</span> + list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;List 1 - List 2: &quot;</span> + CollectionUtils.subtract(list1, list2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//List 1: [A, A, A, C, B, B]</span></span><br><span class="line"><span class="comment">//List 2: [A, A, B, B]</span></span><br><span class="line"><span class="comment">//List 1 - List 2: [A, C]</span></span><br></pre></td></tr></table></figure>

<p><strong>Commons Collections - Union</strong></p>
<p>​        用于获取两个集合的并集：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionUtilsTester</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;List 1: &quot;</span> + list1);</span><br><span class="line">        System.out.println(<span class="string">&quot;List 2: &quot;</span> + list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;Union of List 1 and List 2: &quot;</span> + CollectionUtils.union(list1, list2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//List 1: [A, A, A, C, B, B]</span></span><br><span class="line"><span class="comment">//List 2: [A, A, B, B]</span></span><br><span class="line"><span class="comment">//Union of List 1 and List 2: [A, A, A, B, B, C]</span></span><br></pre></td></tr></table></figure>

<h3 id="Arrays-asList获得的List使用需要注意什么"><a href="#Arrays-asList获得的List使用需要注意什么" class="headerlink" title="Arrays.asList获得的List使用需要注意什么"></a>Arrays.asList获得的List使用需要注意什么</h3><ul>
<li>asList得到的只是一个Arrays的内部类，一个原来数据的视图List，因此如果对它进行增删操作会报错。</li>
<li>用ArrayList的构造器可以让其转变成真正的ArrayList</li>
</ul>
<h3 id="Collection如何迭代"><a href="#Collection如何迭代" class="headerlink" title="Collection如何迭代"></a>Collection如何迭代</h3><p>​        Collection的迭代有很多种方式：</p>
<ul>
<li>通过普通for循环迭代</li>
<li>通过增强for循环迭代</li>
<li>使用Iterator迭代</li>
<li>使用Stream迭代</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = ImmutableList.of(<span class="string">&quot;qwe&quot;</span>, <span class="string">&quot;wk&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通for循环遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for循环遍历</span></span><br><span class="line"><span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Iterator 遍历</span></span><br><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stream 遍历</span></span><br><span class="line">list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="Enumeration和Iterator区别"><a href="#Enumeration和Iterator区别" class="headerlink" title="Enumeration和Iterator区别"></a>Enumeration和Iterator区别</h3><ul>
<li>函数接口不同</li>
</ul>
<p>Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改；Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能进行数据的删除操作。</p>
<ul>
<li>Iterator支持fail-fast机制，而Enumeration不支持</li>
</ul>
<p>Enumeration是JDK1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步；而Iterator是JDK1.2才添加的接口，它为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一集合的内容进行操作时，就可能会产生fail-fast事件。</p>
<p>​        注意：Enumeration迭代器只能遍历Vector、Hashtable这种古老的集合，因此通常不要使用它，除非在某些极端情况下，不得不使用Enumeration，否则都应该选择Iterator迭代器。</p>
<h3 id="fail-fast和fail-safe"><a href="#fail-fast和fail-safe" class="headerlink" title="fail-fast和fail-safe"></a>fail-fast和fail-safe</h3><p><strong>什么是fail-fast</strong></p>
<p>​        在系统设计中，快速失效系统一种可以立即报告任何可能表明故障的情况的系统。快速失效系统通常设计用于停止正常操作，而不是试图继续可能存在缺陷的过程。这种设计通常会在操作中的多个检查系统的状态，因此可以及早检测到任何故障。快速失败模块的职责是检测错误，然后让系统的下一最高级别处理错误。<br>​        其实，就是在做系统设计的时候先考虑异常情况，一旦发生异常，直接停止并上报。</p>
<p>​        举一个最简单的fail-fast的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> divisor, <span class="keyword">int</span> dividend)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dividend == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;dividend can&#x27;t be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> divisor / dividend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上面的代码是一个对两个整数做除法的方法，在divide方法中，我们对被除数做了个简单的检查，如果其值为0，那么就直接抛出一个异常，并明确提示异常原因。这其实就是fail-fast理念的实际应用。<br>​        这样做的好处就是可以预先识别出一些错误情况，一方面可以避免执行复杂的其他代码，另外一方面，这种异常情况被识别之后也可以针对性的做一些单独处理。</p>
<p>​        在Java的集合类中运用了fail-fast机制进行设计，一旦使用不当，触发fail-fast机制设计的代码，就会发生非预期情况。</p>
<p><strong>集合类中的fail-fast</strong></p>
<p>​        我们通常说的Java中的fail-fast机制，默认指的是Java集合的一种错误检测机制。当多个线程对部分集合进行结构上的改变的操作时，有可能会产生fail-fast机制，这个时候就会抛出ConcurrentModificationException(CME)。<br>​        CME，当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。<br>​        很多时候正是因为代码中抛出CME，很多程序员就会困惑，明明自己的代码并没有在多线程环境中执行，为什么会抛出这种并发有关的异常呢？这种情况在什么情况下才会抛出呢？</p>
<p><strong>异常复现</strong></p>
<p>​        在Java中，如果在foreach循环里对某些集合元素进行元素的remove/add操作的时候，就会触发fail-fast机制，进而抛出CME。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;q&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String userName : userNames)&#123;</span><br><span class="line">    <span class="keyword">if</span>(userName.equals(<span class="string">&quot;wk&quot;</span>))&#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure>

<p>​        以上代码，使用增强for循环遍历元素，并尝试删除其中的wk字符串元素，运行以上代码，会抛出以下异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">at com.hollis.ForEach.main(ForEach.java:<span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p>​        同样的，在增强for循环中使用add方法添加元素，结果也会抛出同样的异常。<br>​        在深入原理之前，我们先尝试把foreach进行解语法糖，看一下foreach具体如何实现的。使用jad工具，对编译后的class进行反编译，得到以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">		add(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">		add(<span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">		add(<span class="string">&quot;HollisChuang&quot;</span>);</span><br><span class="line">		add(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line">	Iterator iterator = userNames.iterator();</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(!iterator.hasNext())</span><br><span class="line">    		<span class="keyword">break</span>;</span><br><span class="line">    	String userName = (String)iterator.next();</span><br><span class="line">    	<span class="keyword">if</span>(userName.equals(<span class="string">&quot;Hollis&quot;</span>))</span><br><span class="line">    		userNames.remove(userName);</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(userNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以发现，foreach其实是依赖了while循环和Iterator实现的。</p>
<p><strong>异常原理</strong></p>
<p>​        通过以上代码的异常堆栈，我们可以跟踪到真正抛出异常的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br></pre></td></tr></table></figure>

<p>该方法是在iterator.next()方法中调用的。我们看下该方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，该方法中对ModCount和expectedModCount进行了比较，如果二者不相等，则抛出CME。那么，modCount和expectedModCount是什么？是什么原因导致它们的值不相等的呢？</p>
<p>​        modCount是ArrayList中的一个成员变量。它表示该集合实际被修改的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;q&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当使用以上代码初始化集合之后该变量就有了，初始值为0。expectedModCount是ArrayList中的一个内部类——Itr中的成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator iterator = userNames.iterator();</span><br></pre></td></tr></table></figure>

<p>以上代码，既可以得到一个Itr类，该类实现了Iterator接口。expectedModCount表示这个迭代器预期该集合被修改的次数，其值随着Itr被创建而初始化，只有通过迭代器对集合进行操作，该值才会改变。<br>        那么，接着我们看下userNames.remove(userName);方法做了什么事情，为什么导致expectedModCount和modCount的值不一样。<br>        我们可以发现，remove方法核心逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它只修改了modCount，并没有对expectedModCount做任何操作。</p>
<p>​        简单总结一下，之所以会抛出CME异常，是因为我们的代码中使用了增强for循环，而在增强for循环中，遍历集合是通过Iterator进行的，但是元素的add/remove却是直接使用的集合类自己的方法。这就导致iterator在遍历的时候，会发现有一个元素在自己不知不觉的情况下就被删除了/添加了，就会抛出一个异常，用来提示用户，可能发生了并发修改！</p>
<p>​        所以，在使用Java集合类的时候，如果发生了CME，优先考虑fail-fast有关的情况，实际上这里并没有真的发生并发，只是Iterator使用了fail-fast的保护机制，只要它发现有某一次修改是未经过自己进行的，那么就会抛出异常。</p>
<p><strong>fail-safe</strong></p>
<p>​        为了避免触发fail-fast机制，导致异常，我们可以使用Java中提供的一些采用了fail-safe机制的集合类。<br>​        这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<br>​        java.util.concurrent包下的容器都是fail-safe的，可以在多线程下并发使用，并发修改。同时也可以在foreach中进行add/remove。</p>
<p>​        我们拿CopyOnWriteArrayList这个fail-safe的集合类来简单分析一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; userNames = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    userNames.iterator();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(String userName : userNames)&#123;</span><br><span class="line">        <span class="keyword">if</span>(userName.equals(<span class="string">&quot;wk&quot;</span>))&#123;</span><br><span class="line">            userNames.remove(userName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(userNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        以上代码，使用CopyOnWriteArrayList代替了ArrayList，就不会发生异常。<br>​        fail-safe集合的所有对集合的修改都是先拷贝一份副本，然后在副本集合上进行的，并不是在直接对原集合进行修改。并且这些修改方法，如add/remove都是通过加锁来控制并发的。<br>​        所以，CopyOnWriteArrayList中的迭代器在迭代过程中不需要做fail-fast的并发检测。但是，基于拷贝内容的优点是避免了CME，但同样地，迭代器并不能访问到修改后的内容，如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; userNames = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Iterator it = userNames.iterator();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(String userName : userNames)&#123;</span><br><span class="line">        <span class="keyword">if</span>(userName.equals(<span class="string">&quot;wk&quot;</span>))&#123;</span><br><span class="line">            userNames.remove(userName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(userNames);</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们得到CopyOnWriteArrayList的Iterator之后，通过for循环直接删除原数组中的值，最后在结尾处输出Iterator，结果发现内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[qwe, w]</span><br><span class="line">wk</span><br><span class="line">wk</span><br><span class="line">qwe</span><br><span class="line">w</span><br></pre></td></tr></table></figure>

<p>​        迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<p><strong>Copy-On-Write</strong></p>
<p>​        在了解了CopyOnWriteArrayList之后，可能会有这样的疑问：它的add/remove等方法都已经加锁了，还要copy一份再修改干嘛？同样是线程安全的集合，和Vector有什么区别呢？<br>​        Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。<br>​        CopyOnWirte容器即写时复制的容器。通俗理解是当我们往一个容器添加元素的时候，不能直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。<br>​        CopyOnWriteArrayList中的add/remove等写方法是需要加锁的，目的是为了避免Copy出N个副本出来，导致并发写。<br>​        但是，CopyOnWriteArrayList中的读方法是没有加锁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这样做的好处是我们可以对CopyOnWrite容器进行并发的读，当然，这里读到的数据可能不是最新的。因为写时复制的思想是通过延时更新的策略来实现数据的最终一致性的，并非强一致性。<br>​        所以CopyOnWrite容器是一种读写分离的思想，读和写不同的容器。而Vector在读写的时候使用同一个容器，读写互斥，同时只能做一件事儿。</p>
<h3 id="如何在遍历的同时删除ArrayList中的元素"><a href="#如何在遍历的同时删除ArrayList中的元素" class="headerlink" title="如何在遍历的同时删除ArrayList中的元素"></a>如何在遍历的同时删除ArrayList中的元素</h3><p><strong>直接使用普通for循环进行操作</strong></p>
<p>​        我们说不能再foreach中进行，但是使用普通的for循环还是可以的，因为普通的for循环并没有用到Iterator的遍历，所以压根就没有fail-fast的检验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;q&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(userNames.get(i).equals(<span class="string">&quot;wk&quot;</span>))&#123;</span><br><span class="line">        userNames.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure>

<p>​        这种方案其实存在一个问题，那就是remove操作会改变List中元素的下标，可能存在漏删的情况。</p>
<p><strong>直接使用Iterator进行操作</strong></p>
<p>​        除了直接使用普通的for循环以外，我们还可以直接使用Iterator提供remove方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;q&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Iterator iterator = userNames.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="keyword">if</span>(iterator.next().equals(<span class="string">&quot;wk&quot;</span>))&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure>

<p>​        如果直接使用Iterator提供的remove方法，那么就可以修改到expectedModCount的值。那么就不再抛出异常了。</p>
<p><strong>使用Java 8 中提供的filter过滤</strong></p>
<p>​        Java 8 中可以把集合转化成流，对于流有一种filter操作，可以对原始Stream进行某项测试，通过测试的元素被留下生成一个新的Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;q&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">userNames = userNames.stream().filter(userName -&gt; !=userName.equals(<span class="string">&quot;wk&quot;</span>)).collect(Collectors.toList());</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure>

<p><strong>使用增强for循环其实也可以</strong></p>
<p>​        如果，我们非常确定在一个集合中，某个即将删除的元素只包含一个的话，比如对Set进行操作，那么其实也是可以使用增强for循环的，只要在删除之后，立刻结束循环体，不要再继续进行遍历就可以了，也就是说不让代码执行到下一次的next方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;q&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String userName : userNames)&#123;</span><br><span class="line">    <span class="keyword">if</span>(username.equals(<span class="string">&quot;wk&quot;</span>))&#123;</span><br><span class="line">        userNames.remove(username);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure>

<p><strong>直接使用fail-safe的集合类</strong></p>
<p>​        在Java中，除了一些普通的集合类以外，还有一些采用了fail-safe机制的集合类。这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。<br>​        由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所做的修改并不能被迭代器检测到，所以不会触发CME。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConcurrentLinkedDeque&lt;String&gt; userNames = <span class="keyword">new</span> ConcurrentLinkedDeque&lt;String&gt;()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;q&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String userName : userNames)&#123;</span><br><span class="line">    <span class="keyword">if</span>(username.equals(<span class="string">&quot;wk&quot;</span>))&#123;</span><br><span class="line">        userNames.remove(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        基本拷贝内容的优点是避免了CME，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道。<br>​        java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>​        Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时惰性策略。从JDK1.5开始Java并发包中提供了两个使用CopyOnWrite机制实现的并发容器，它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。<br>​        CopyOnWriteArrayList相当于线程安全的ArrayList，CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新的元素add到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新的数组。<br>​        这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。<br>​        注意：CopyOnWriteArrayList的整个add操作都是在锁的保护下进行的，也就是说add方法是线程安全的。<br>​        CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和跟新场景。<br>​        和ArrayList不同的是，它具有以下特性：<br>支持高效率并发且是线程安全的，因为通常需要复制整个基础数组，所以可变操作(add()、set()、remove()等等)的开销很大，迭代器支持hasNext()、next()等不可变操作，但不支持可变remove()等操作，使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</p>
<h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><p>​        ConcurrentSkipListMap是一个内部使用跳表，并支持排序和并发的一个Map，是线程安全的。一般很少会用到，也是一个比较偏门的数据结构。</p>
<p><strong>简单介绍下跳表：</strong></p>
<p>​        跳表是一种允许在一个有顺序的序列中进行快速查询的数据结构。在普通的顺序链表中查询一个元素，需要从链表头部开始一个一个节点进行遍历，然后找到节点。跳表可以解决这种查询时间过长，跳表是一种“空间换时间”的概念用来提高查询效率的链表。</p>
<p>​        ConcurrentSkipListMap和ConcurrentHashMap的主要区别：1.底层实现方式不同，ConcurrentSkipListMap底层基于跳表，ConcurrentHashMap底层基于Hash桶和红黑树；2.ConcurrentHashMap不支持排序，ConcurrentSkipListMap支持排序。</p>
<hr>
<h2 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h2><h3 id="字符流、字节流"><a href="#字符流、字节流" class="headerlink" title="字符流、字节流"></a>字符流、字节流</h3><p><strong>字节与字符</strong></p>
<p>​        Bit最小的二进制单位，是计算机的操作部分。取值0或1</p>
<p>​        Byte(字节)是计算机操作数据的最小单位由8位bit组成取值(-128~127)</p>
<p>​        Char(字符)是用户的可读写的最小单位，在Java里面由16位bit组成取值(0~65535)</p>
<p><strong>字节流</strong></p>
<p>​        操作byte类型数据，主要操作类是OutputStream、InputStream的子类；不用缓冲区，直接对文件本身操作。</p>
<p><strong>字符流</strong></p>
<p>​        操作字符类型数据，主要操作类是Reader、Write的子类；使用缓冲区缓冲字符，不关闭流就不会输出任何内容。</p>
<p><strong>互相转换</strong></p>
<p>​        整个IO包实际上分为字节流和字符流，但是除了这两个流之外，还存在一组字节流-字符流的转换类。<br>​        OutputStreamWrite：是Write的子类，将输出的字符流变为字节流，即将一个字符流的输出对象变为字节流输出对象。<br>​        InputStreamReader：是Reader的子类，将输入的字节流变为字符流，即将一个字节流的输出对象变为字符流的输出对象。</p>
<h3 id="输入流、输出流"><a href="#输入流、输出流" class="headerlink" title="输入流、输出流"></a>输入流、输出流</h3><p>​        输入、输出，有一个参照物，参照物就是存储数据的介质。如果是把对象读入到介质中，这就是输入。从介质中向外读数据，这就是输出。<br>​        所以，输入流把数据写入存储介质的；输出流是从存储介质中把数据读取出来。</p>
<h3 id="字节流和字符流之间的相互转换"><a href="#字节流和字符流之间的相互转换" class="headerlink" title="字节流和字符流之间的相互转换"></a>字节流和字符流之间的相互转换</h3><p>​        想要实现字符流和字节流之间的相互转换需要用到两个类：</p>
<ul>
<li>OutputStreamWrite是字符流通向字节流的桥梁</li>
<li>InputStreamReader是字节流通向字符流的桥梁</li>
</ul>
<p><strong>字符流转换成字节流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    OutputStreamWrite osw = <span class="keyword">new</span> OutputStreamWrite(<span class="keyword">new</span> FileOutputStream(f), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    osw.write(<span class="string">&quot;我是字符流转换成字节流输出的&quot;</span>);</span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节流转换成字符流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    InputStreamReader inr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(f),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = inr.read(buf);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">    inr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h3><p>​        同步与异步描述的是被调用者的。如A调用B：如果是同步，B在接到A的调用后，会立即执行要做的事。A的本次调用可以得到结果。<br>​        如果是异步，B在接到A的调用后，不保证会立刻执行要做的事，但是保证会去做，B在做好了之后会通知A。A的本次调用得不到结果，但是B执行完之后会通知A。</p>
<h3 id="阻塞、非阻塞"><a href="#阻塞、非阻塞" class="headerlink" title="阻塞、非阻塞"></a>阻塞、非阻塞</h3><p>​        阻塞与非阻塞描述的是调用者。如A调用B：如果是阻塞，A在发出调用后，要一直等待，等着B返回结果。<br>​        如果是非阻塞，A在发出调用后，不需要等待，可以去做自己的事情。</p>
<p><strong>同步，异步胡阻塞，非阻塞之间的区别</strong></p>
<ul>
<li>同步和异步是描述被调用方的</li>
<li>阻塞和非阻塞是描述调用方的</li>
<li>同步不一定阻塞，异步不一定非阻塞，没有必然关系。</li>
</ul>
<h3 id="Linux-5种IO模型"><a href="#Linux-5种IO模型" class="headerlink" title="Linux 5种IO模型"></a>Linux 5种IO模型</h3><p><strong>阻塞式IO模型</strong></p>
<p>​        最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。<br>​        当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p>
<p>​        典型阻塞IO模型的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data = socket.read();</span><br></pre></td></tr></table></figure>

<p>​        如果数据没有就绪，就会一直阻塞在read方法中。</p>
<p><strong>非阻塞IO模型</strong></p>
<p>​        当用户线程发起一个read操作之后，并不需要等待，而是马上得到一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。<br>​        在非阻塞IO中，用户线程需要不断地询问内核数据是否就绪，也就是说非阻塞IO不会交出CPU，而会一直占用CPU。</p>
<p>​        典型的非阻塞IO模型一般如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    data = socket.read();</span><br><span class="line">    <span class="keyword">if</span>(data != error)&#123;</span><br><span class="line">        <span class="comment">//处理数据</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样就会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。</p>
<p><strong>IO复用模型</strong></p>
<p>​        多路复用IO模型是目前使用的比较多的模型。Java NIO实际上就是多路复用IO。<br>​        在多路复用IO模型中，会有一个线程不断去轮询多个socket状态，只有当socket真正有读写事件时，才会正真调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。<br>​        在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。<br>​        也许有些人会说，我们可以采用多线程+阻塞IO达到类似的效果，但是由于在多线程+ 阻塞IO中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。<br>​        而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。<br>​        多路复用IO为何比非阻塞IO模型的效率要高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。<br>​        要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事情相应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<p><strong>信号驱动IO模型</strong></p>
<p>​        在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p>
<p><strong>异步IO模型</strong></p>
<p>​        异步IO模型是比较理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其他的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何bolck。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就是说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时IO操作已经完成，可以直接去使用数据了。<br>​        在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已经完成。用户线程中不需要再次调用IO函数进行具体的读写，这点和信号驱动模型有所不同，在信号模型驱动中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用IO函数进行实际的读写操作。<br>​        注意，异步IO是需要操作系统的底层支持的，在Java7中，提供了Asynchronous IO。<br>​        前面四种IO模型实际上都属于同步IO，只有最后一种真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</p>
<h3 id="BIO、NIO和AIO的区别、三种IO的用法与原理"><a href="#BIO、NIO和AIO的区别、三种IO的用法与原理" class="headerlink" title="BIO、NIO和AIO的区别、三种IO的用法与原理"></a>BIO、NIO和AIO的区别、三种IO的用法与原理</h3><p><strong>IO</strong></p>
<p>​        什么是IO？它是指计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有I/O的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。</p>
<p>​        在Java编程中，直到最近一直使用流的方式完成I/O。所有I/O都被视为单个的字节的移动，通过一个stream的对象一次移动一个字节。流I/O用于和外部世界接触。它也在内部使用，用于对象转换为字节，然后再转换为对象。</p>
<p><strong>BIO</strong>    </p>
<p>​        Java BIO即Block I/O，同步并阻塞的IO。BIO就是传统的java.io包下面的代码实现。</p>
<p><strong>NIO</strong></p>
<p>​        什么是NIO？NIO与原来的I/O有同样的作用和目的，它们之间最重要的区别是数据打包和传输的方式。原来I/O以流的方式处理数据，而NIO以块的方式处理数据。<br>​        面向流的I/O系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的I/O通常非常慢。<br>​        一个面向块的I/O系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快的多。但是面向块的I/O缺少一些面向流的I/O所具有的优雅性和简单性。</p>
<p><strong>AIO</strong></p>
<p>​        Java AIO即Async非阻塞，是异步非阻塞的IO。</p>
<p><strong>区别及联系</strong></p>
<p>​        BIO(Blocking I/O)：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。<br>​        NIO(New I/O)：同时支持阻塞与非阻塞模式。<br>​        AIO(Asynchronous I/O)：异步非阻塞I/O模型。异步非阻塞与同步非阻塞区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对用的线程来处理。</p>
<p><strong>各自适用场景</strong></p>
<p>​        BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p>
<p>​        NIO方式适用于连接数目多且连接比较短(轻操作)的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p>
<p>​        AIO方式适用于连接数目多且连接比较长(重操作)的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
<p><strong>使用方式</strong></p>
<ul>
<li>使用BIO实现文件的读取与写入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Initializes the Object</span></span><br><span class="line">User1 user = <span class="keyword">new</span> User1();</span><br><span class="line">user.setName(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">user.setAge(<span class="number">22</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Write obj to File</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">    oos.writeObject(user);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    IOUtils.closeQuietly(oos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Read obj from File</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ois = <span class="keyword">new</span> ObjectInoutStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    User1 newUser = (User1) ois.readObject();</span><br><span class="line">    System.out.println(newUser);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrack();</span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">    e.printStackTrack();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    IOUtils.closeQuietly(ois);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        FileUtils.forceDelete(file);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用NIO实现文件的读取和写入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readNIO</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String pathname = <span class="string">&quot;C:\\Users\\adew\\Desktop\\jd-gui.cfg&quot;</span>;</span><br><span class="line">    FileInputStream fin = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fin = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(pathname));</span><br><span class="line">        FileChannel channel = fin.getChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">100</span>;<span class="comment">//字节</span></span><br><span class="line">        ByteBuffer bf = ByteBuffer.allocate(capacity);</span><br><span class="line">        System.out.println(<span class="string">&quot;限制是：&quot;</span> + bf.limit() + <span class="string">&quot;容量是：&quot;</span> + bf.capacity() + <span class="string">&quot;位置是：&quot;</span> + bf.position());</span><br><span class="line">        <span class="keyword">int</span> length = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((length = channel.read(bf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bf.clear();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = bf.array();</span><br><span class="line">            System.out.wirte(bytes, <span class="number">0</span>, length);</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(<span class="string">&quot;限制是：&quot;</span> + bf.limit() + <span class="string">&quot;容量是：&quot;</span> + bf.capacity() + <span class="string">&quot;位置是：&quot;</span> + bf.position());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fin != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                fin.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wirteNIO</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String filename = <span class="string">&quot;out.txt&quot;</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(filename));</span><br><span class="line">        FileChannel channel = fos.getChannel();</span><br><span class="line">        ByteBuffer src = Charset.forName(<span class="string">&quot;uft8&quot;</span>).encode(<span class="string">&quot;你好你好你好&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化容量和limit：&quot;</span> + src.capacity() + <span class="string">&quot;,&quot;</span> + src.limit());</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((length = channel.write(src)) != <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;写入长度：&quot;</span> + length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用AIO实现文件的读取和写入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFromFile</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Path file = Paths.get(<span class="string">&quot;/usr/a.txt&quot;</span>);</span><br><span class="line">        AsynchronousFileChannel channel = AsynchronousFileChannel.open(file);</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100_000</span>);</span><br><span class="line">        Future&lt;Integer&gt; result = channel.read(buffer, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!result.isDone())&#123;</span><br><span class="line">            ProfitCalculator.calculateTax();</span><br><span class="line">        &#125;</span><br><span class="line">        Integer bytesRead = result.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;Bytes read [&quot;</span> + <span class="string">&quot;bytesRead + &quot;</span> + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfitCalculator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProfitCalculator</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculateTax</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteToFile</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;/asynchronous.txt&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">        CompletionHandler&lt;Integer, Object&gt; handler = <span class="keyword">new</span> CompletionHandler&lt;Integer, Object&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Attachment：&quot;</span> + attachment + <span class="string">&quot; &quot;</span> + result + <span class="string">&quot; bytes written&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;CompletionHandler Thread ID: &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable e, Object attachment)</span></span>&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Arrachment: &quot;</span> + attachment + <span class="string">&quot; failed with:&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main Thread ID: &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        fileChannel.write(ByteBuffer.wrap(<span class="string">&quot;sample&quot;</span>.getBytes()), <span class="number">0</span>, <span class="string">&quot;First Write&quot;</span>, handler);</span><br><span class="line">        fileChannel.write(ByteBuffer.wrap(<span class="string">&quot;Box&quot;</span>.getBytes()), <span class="number">0</span>, <span class="string">&quot;Second Write&quot;</span>, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p>​        Netty是一种非阻塞I/O客户端-服务端框架，主要用于开发Java网络应用程序，如协议服务器和客户端。异步事件驱动的网络应用程序框架和工具用于简化网络编程，例如TCP和UDP套接字服务器。Netty包括了反应器编程模式的实现。Netty最初由JBoss开发，现在由Netty项目社区开发和维护。</p>
<p>​        除了作为异步网络应用框架，Netty还包括了对HTTP、HTTP2、DNS及其他协议的支持，涵盖了在Servlet容器内运行的能力、对WebSockets的支持、与Google Protocol Buffers的集成，对SSL/TLS的支持以及对应用于SPDY协议和消息压缩的支持。自2004年以来，Netty一直在被积极的开发。</p>
<p>​        从版本4.0.0开始，Netty在支持NIO和阻塞Java套接字的同时，还支持使用NIO.2作为后端。</p>
<p>​        本质：JBoss做的一个Jar包<br>​        目的：快速开发高性能、高可靠性的网络服务器和客户端程序<br>​        有点：提供异步的、事件驱动的网络应用程序框架和工具</p>
<hr>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h3><p>​        反射机制指的是程序在运行时能获取自身的信息。在Java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有属性和方法。</p>
<h3 id="反射有什么作用"><a href="#反射有什么作用" class="headerlink" title="反射有什么作用"></a>反射有什么作用</h3><ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时判断任意一个类所有具有的成员变量和方法</li>
<li>在运行时任意调用一个对象的方法</li>
<li>在运行时构造任意一个类的对象</li>
</ul>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>​        Java的Class类是Java反射机制的基础，通过Class类我们可以获得关于一个类的相关信息。<br>​        Java.lang.Class是一个比较特殊的类，它用于封装被装入到JVM中的类(包括类和接口)的信息。当一个类或接口被装入JVM时便会产生一个与之关联的java.lang.Class对象，可以通过这个Class对象对被装入类的详细信息进行访问。<br>​        虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。</p>
<h3 id="反射与工厂模式实现Spring-IOC"><a href="#反射与工厂模式实现Spring-IOC" class="headerlink" title="反射与工厂模式实现Spring IOC"></a>反射与工厂模式实现Spring IOC</h3><p><strong>反射机制概念</strong></p>
<p>​        我们考虑一个场景，如果我们在程序运行时，一个对象想要检视自己所拥有的成员属性，该如何操作？再考虑一个场景，如果我们想要在运行期获得某个类的Class信息如它的属性，构造方法、一般方法后再考虑是否创建它的对象，这种情况该怎么办？这就需要用到反射。<br>​        我们.java文件在编译之后会变成.class文件，这就像个镜面，本身是.java，在镜中是.class，他们其实是一样的；那么同理，我们看到镜子的反射是.class，就能通过反编译，了解到.java文件的本来面目。<br>​        对于反射，官方给出的概念是：反射是Java语言的一个特性，它允许程序在运行时来进行自我检查并且对内部的成员进行操作。例如它允许一个Java类获取它所有的成员变量和方法并且显示出来。<br>​        反射主要是指程序可以访问，检测和修改它本身状态的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关语义。在Java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。<br>​        反射是Java中的一种强大工具，能够使我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码链接。但是反射使用不当会成本很高！类中有什么信息，利用反射机制就能可以获得什么信息，不过前提是得知道类得名字。</p>
<p><strong>反射机制的作用</strong></p>
<pre><code>    * 在运行时判断任意一个对象所属的类
    * 在运行时获取类的对象
    * 在运行时访问java对象的属性，方法，构造方法等
</code></pre>
<p>​        首先要搞清楚为什么要用反射机制？直接创建对象不就可以了么？这就涉及到了动态与静态的概念。</p>
<p>​        静态编译：在编译时确定类型，绑定对象，即通过。<br>​        动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有效降低了类之间的耦合性。</p>
<p><strong>反射机制的优缺点</strong></p>
<p>​        反射机制的优点：可以实现动态创建对象和编译，体现出很大的灵活性。通过反射机制我们可以获得类的各种内容，进行反编译。对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。</p>
<p>​        例如，一个大型的软件，不可能一次就把它设计的很完美，把这个程序编译后，发布了，当发现需要跟新某些功能时，我们不可能要用户把以前的卸载掉，再重新安装新的版本，加入这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时动态地创建和编译，就可以实现该功能。</p>
<p>​        反射机制的缺点：对性能有影响。使用反射机制基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且让它满足我们的要求，这类操作总是慢于直接执行相同的操作。</p>
<p><strong>反射与工厂模式实现IOC</strong></p>
<p>​        Spring中的IOC的实现原理就是工厂模式加反射机制。首先我们先来看一下不用反射机制时的工厂模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造工厂</span></span><br><span class="line"><span class="comment">//也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> fruit <span class="title">getInstance</span><span class="params">(String fruitName)</span></span>&#123;</span><br><span class="line">        fruit f = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Apple&quot;</span>.equals(fruitName))&#123;</span><br><span class="line">            f = <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Orange&quot;</span>.equals(fruitName))&#123;</span><br><span class="line">            f = <span class="keyword">new</span> Orange();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        fruit f = Factory.getInstance(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">        f.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上面写法的缺点是当我们再添加一个子类的时候，就需要修改工厂类了。如果我们添加了太多的子类的时候，改动就会很多。下面用反射机制实现工厂模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span></span>&#123;</span><br><span class="line">        fruit f = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f = (fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        fruit f = Factory.getInstance(<span class="string">&quot;Reflect.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        现在就算我们添加任意多个子类的时候，工厂类都不需要修改。使用反射机制实现的工厂模式可以通过反射取得接口的实例，但是需要传入完整的包和类名。而用户也无法知道一个接口有多少个可以使用的子类，所以我们要通过属性文件的形式配置所需要的子类。</p>
<p>​        下面编写使用反射机制并结合属性文件的工厂模式即IOC。首先创建一个fruit.properties的资源文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">apple=Reflect.Apple</span><br><span class="line">orange=Reflect.Orange</span><br></pre></td></tr></table></figure>

<p>​        然后编写主类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作属性文件类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">init</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">getPro</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException</span>&#123;</span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;fruit.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f.exists())&#123;</span><br><span class="line">            pro.load(<span class="keyword">new</span> FileInputStream(f));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pro.setProperty(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;Reflect.Apple&quot;</span>);</span><br><span class="line">            pro.setProperty(<span class="string">&quot;orange&quot;</span>, <span class="string">&quot;Reflect.Orange&quot;</span>);</span><br><span class="line">            pro.store(<span class="keyword">new</span> FileOutputStream(f), <span class="string">&quot;FRUIT CLASS&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span></span>&#123;</span><br><span class="line">        fruit f = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            f = (fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException</span>&#123;</span><br><span class="line">        Properties pro = init.getPro();</span><br><span class="line">        fruit f = Factory.getInstance(pro.getProperty(<span class="string">&quot;apple&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Apple</span></span><br></pre></td></tr></table></figure>

<p><strong>IOC容器的技术剖析</strong></p>
<p>​        IOC中最基本的技术就是“反射(Reflection)”编程，通俗的来讲就是根据具体的类名来动态地生成对象，这种编程方式可以让对象在生成时才被决定到底是哪一种对象。只是在Spring中要产生的对象都在配置文件中给出定义，目的就是提高灵活性和可维护性。</p>
<p>​        目前C#、Java和PHP5等语言都支持反射，其中PHP5的技术书籍中，有时候也被翻译成“映射”。反射的应用是很广泛的，很多成熟的框架，比如像Java中的Hibernate、Spring框架，.NET中NHibernate、Spring.NET框架都把“反射”作为最基本的技术手段。</p>
<p>​        反射技术其实很早就出现了，但一直被忽略，没有被进一步的利用。当时的反射编程方式相对于正常的对象生成方式要慢至少10倍。现在的反射技术经过改良优化，已经非常成熟，反射方式生成对象和通常对象生成方式，速度已经相差不大了，大约1-2倍的差距。</p>
<p>​        我们可以将IOC容器的工作模式看作为工厂模式的升华，可以把IOC容器看作一个工厂，这个工厂里产生的对象都有配置文件中给出定义，然后利用编程语言提供的反射机制，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成的两者独立分隔开来，目的就是提高灵活性和可维护性。</p>
<p><strong>使用IOC框架应该注意什么</strong></p>
<p>​        使用IOC框架产品能够给我们的开发过程带来很大好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。</p>
<ul>
<li>软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。</li>
<li>由于IOC容器生成对象是通过反射方式，在运行效率上有一定的耗损。如果你要追求运行效率的话，就必须对此权衡。</li>
<li>具体到IOC框架产品(例如Spring)而言，需要进行大量的配置工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。</li>
<li>IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐形的风险。</li>
</ul>
<p>我们大体可以得出这样的结论：一些工作量不大的项目或产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，像WEB2.0网站就是这种情况。</p>
<hr>
<h2 id="枚举类型和泛型"><a href="#枚举类型和泛型" class="headerlink" title="枚举类型和泛型"></a>枚举类型和泛型</h2><h3 id="枚举的用法"><a href="#枚举的用法" class="headerlink" title="枚举的用法"></a>枚举的用法</h3><p><strong>背景</strong></p>
<p>​        在Java语言中还没有引入枚举类型之前，表示枚举类型的常用模式是声明一组具int 常量。之前我们通常利用public static final 方法定义的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPRING = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUMMER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUTUMN = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WINTER = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这种方法称为int枚举模式。可这种模式会出现什么问题呢？通常我们写出来的代码都会考虑它的安全性、易读性和可读性。首先我们来考虑一下它的安全性当然这种模式不是类型安全的。比如我们要设计一个函数，要求传入上面的某个值。但是使用int类型，我们无法保证传入的值为合法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getChineseSeason</span><span class="params">(<span class="keyword">int</span> season)</span></span>&#123;</span><br><span class="line">    StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">switch</span>(season)&#123;</span><br><span class="line">        <span class="keyword">case</span> Season.SPIRNG:</span><br><span class="line">            result.append(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Season.SUMMER:</span><br><span class="line">            result.append(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Season.AUTUMN:</span><br><span class="line">            result.append(<span class="string">&quot;秋天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Season.WINTER:</span><br><span class="line">            result.append(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result.append(<span class="string">&quot;地球上没有的季节&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.getChineseSeason(Season.SPRING));</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.getChineseSeason(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        程序getChineseSeason(Season.SPRING)是我们预期的使用方法，可是getChineseSeason(5)显然就不是了，而且编译会很通过，在运行时会出现什么情况，我们就不得而知了。这显然就不符合Java程序的类型安全。</p>
<p>​        接下来我们考虑一下这种模式的可读性。使用枚举的大多数场合，我们都需要方便得到枚举类型的字符串表达式。如果将int枚举常量打印出来，我们所见到的就是一组数字，这是没什么太大用处的。我们可能会想到使用String常量代替int常量。虽然它认为这些常量可以提供了打印的字符串，但他可能会导致性能问题，因为它依赖于字符串的比较操作，所以这种模式也是我们不期望的。从类型安全和程序的可读性两方面考虑，int和String枚举模式的缺点就显露出来了。幸运的是，从Java1.5开始，就提出了另一种可以替代的解决方案，可以避免int和String枚举模式的缺点，并提供了许多额外的好处。那就是枚举类型(enum type)。</p>
<p><strong>定义</strong></p>
<p>​        枚举类型(enum type)是指由一组固定的常量组成合法的类型。Java中由关键字enum来定义一个枚举类型。下面就是Java枚举类型的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    SPRING, SUMMER, AUTUMN, WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<p>​        Java定义枚举类型的语句很简约。它有以下特点：</p>
<ul>
<li>使用关键字enum</li>
<li>类型名称，例如这里的Season</li>
<li>一串允许的值，例如上述定义的春夏秋冬</li>
<li>枚举可以单独定义在一个文件中，也可以嵌在其他Java类中除了这样的基本要求外，用户还有一些其他选择</li>
<li>枚举可以实现一个或多个接口(Interface)</li>
<li>可以定义新的变量</li>
<li>可以定义新方法</li>
<li>可以定义根据具体枚举值而相异的类</li>
</ul>
<p><strong>应用场景</strong></p>
<p>​        在以背景中提到的类型安全为例，用枚举类型重写那段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    SPRING(<span class="number">1</span>), SUMMER(<span class="number">2</span>), AUTUMN(<span class="number">3</span>), WINTER(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(<span class="keyword">int</span> code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseSeason</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getChineseSeason</span><span class="params">(Season season)</span></span>&#123;</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">switch</span>(season)&#123;</span><br><span class="line">            <span class="keyword">case</span> SPRING:</span><br><span class="line">                result.append(<span class="string">&quot;[中文：春天，枚举常量：&quot;</span> + season.name() + <span class="string">&quot;,数据：&quot;</span> + season.getCode() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUMMER:</span><br><span class="line">                result.append(<span class="string">&quot;[中文：夏天，枚举常量：&quot;</span> + season.name() + <span class="string">&quot;,数据：&quot;</span> + season.getCode() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AUTUMN:</span><br><span class="line">                result.append(<span class="string">&quot;[中文：秋天，枚举常量：&quot;</span> + season.name() + <span class="string">&quot;,数据：&quot;</span> + season.getCode() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WINTER:</span><br><span class="line">                result.append(<span class="string">&quot;[中文：冬天，枚举常量：&quot;</span> + season.name() + <span class="string">&quot;,数据：&quot;</span> + season.getCode() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result.append(<span class="string">&quot;地球没有的季节&quot;</span> + season.name());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Season s: Season.values())&#123;</span><br><span class="line">            System.out.println(getChineseSeason(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(getChineseSeason(5))</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UseSeason useSeason = <span class="keyword">new</span> UseSeason();</span><br><span class="line">        useSeason.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        其中有一个问题，为什么我们要将域添加到枚举类型中呢？目的是想将数据与它的常量关联起来。如1代表春天；2代表夏天。</p>
<p><strong>总结</strong></p>
<p>​        什么时候该使用枚举呢？每当需要一组固定的常量的时候，如一周的天数、一年四季。或者是在我么并编译前就知道其包含的所有值得集合。Java1.5的枚举能够满足绝大部分程序员的要求，它的简明，易用的特点是很突出的。</p>
<p><strong>用法</strong></p>
<p>用法一：常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    RED, GREEN, BLACK, YELLOW</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Signal</span></span>&#123;</span><br><span class="line">    GREEN, TELLOW, RED</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficLight</span></span>&#123;</span><br><span class="line">    Signal color = Signal.RED;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(color)&#123;</span><br><span class="line">            <span class="keyword">case</span> RED:</span><br><span class="line">                color = Signal.GREEN;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YELLOW:</span><br><span class="line">                color = Signal.RED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREEN:</span><br><span class="line">                color = Signal.YELLOW;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法三：向枚举中添加新方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    RED(<span class="string">&quot;红色&quot;</span>, <span class="number">1</span>), GREEN(<span class="string">&quot;绿色&quot;</span>, <span class="number">2</span>), BLANK(<span class="string">&quot;白色&quot;</span>, <span class="number">3</span>), YELLOW(<span class="string">&quot;黄色&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Color c: Color.values())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c.getIndex() == index)&#123;</span><br><span class="line">                <span class="keyword">return</span> c.name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get、set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法四：覆盖枚举的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    RED(<span class="string">&quot;红色&quot;</span>, <span class="number">1</span>), GREEN(<span class="string">&quot;绿色&quot;</span>, <span class="number">2</span>), BLANK(<span class="string">&quot;白色&quot;</span>, <span class="number">3</span>), YELLOW(<span class="string">&quot;黄色&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index + <span class="string">&quot;_&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法五：实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Behaviour</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> <span class="keyword">implements</span> <span class="title">Behaviour</span></span>&#123;</span><br><span class="line">    RED(<span class="string">&quot;红色&quot;</span>, <span class="number">1</span>), GREEN(<span class="string">&quot;绿色&quot;</span>, <span class="number">2</span>), BLANK(<span class="string">&quot;白色&quot;</span>, <span class="number">3</span>), YELLOW(<span class="string">&quot;黄色&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.index + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法六：使用接口组织枚举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Coffee</span> <span class="keyword">implements</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">        BALCK_COFFEE, DECAF_COFFEE, LATTE, CAPPUCCINO</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Dessert</span> <span class="keyword">implements</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">        FRUIT, CAKE, GELATO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举的实现"><a href="#枚举的实现" class="headerlink" title="枚举的实现"></a>枚举的实现</h3><p>​        Java5提供了一种新的类型-Java的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。<br>​        那么枚举类到底是什么类呢？是enum？答案很明显不是，enum就和class一样，只是一个关键字，它并不是一个类，那么枚举是由什么类维护的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">t</span></span>&#123;</span><br><span class="line">    SPRING, SUMMER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        然后使用反编译，看看这段代码是怎么实现的，反编译后代码内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Enum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">T</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] values()&#123;</span><br><span class="line">        T at[];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        T at1[];</span><br><span class="line">        System.arraycopy(at = ENUM$VALUES, <span class="number">0</span>, at1 = <span class="keyword">new</span> T[i = at,length], <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">return</span> at1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">valueOf</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)Enum.valueOf(demo/T, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SPRING;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SUMMER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> T ENUM$VALUES[];</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        SPRING = <span class="keyword">new</span> T(<span class="string">&quot;SPIRNG&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        SUMMER = <span class="keyword">new</span> T(<span class="string">&quot;SUMMER&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        ENUM$VALUES = (<span class="keyword">new</span> T[] &#123;SPRING, SUMMER&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过反编译后代码我们可以看到，public final class T extends Enum， 说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类是不能被继承的。<br>​        当我们使用enum来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。</p>
<h3 id="枚举与单例"><a href="#枚举与单例" class="headerlink" title="枚举与单例"></a>枚举与单例</h3><p>​        我们知道，单例模式，一般有七种写法，那么这七种写法中，最好的是哪一种？为什么呢？</p>
<p><strong>哪种写单例的方式最好</strong></p>
<p>​        使用枚举实现单例的方法虽然还没有广泛的采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</p>
<p><strong>枚举单例写法简单</strong></p>
<p>​        各种方式实现单例的代码都比较复杂。主要原因是在考虑线程安全问题。我们简单对比下“双重检验锁”方式和枚举方式实现单例的代码。</p>
<p>“双重检验锁”实现单例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singletion == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举实现单例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        相比之下，枚举实现单例的代码会精简很多。<br>​        上面的双重锁校验的代码很是臃肿，是因为大部分代码都是在保证线程安全。为了在保证线程安全和锁的颗粒度之间做权衡；但是，这段代码还是有问题的，因为它无法解决反序列化会破化单例的问题。</p>
<p><strong>枚举可解决线程安全问题</strong></p>
<p>​        上面提到过，使用非枚举的方式实现单例，都要自己来保证线程安全，所以，这就导致其他方法必然是计较臃肿的。那么，为什么使用枚举就不需要解决线程安全问题呢？<br>​        其实，并不是使用枚举就不需要保证线程安全，只不过线程安全的保证不需要我们关心而已。也就是说，其实在“底层”还是做了线程安全方面的保证的。<br>​        那么，“底层”到底指的是什么？<br>​        枚举类中的各个枚举项是通过static来定义的：<a href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%AE%9E%E7%8E%B0">举例见</a></p>
<p>​        static类型的属性会在类被加载之后初始化，当一个Java类第一次被真正使用的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的(因为虚拟机在加载枚举的类的时候，会使用ClassLoader的loadClass方法，而这个方法使用同步代码块保证了线程安全)。所以，创建一个enum类型是线程安全的。<br>​        也就是说，我们的定义的一个枚举，在第一次被真正用到的时候，会被虚拟机加载并初始化，而这个初始化过程是线程安全的。而我们知道，解决单例的并发问题，主要解决的就是初始化过程中的线程安全问题。<br>​        所以，由于枚举的以上特性，枚举实现的单例是天生线程安全的。</p>
<p><strong>枚举可解决反序列化会破坏单例的问题</strong></p>
<p>​        前面提到过，就是使用双重检验锁实现的单例其实是存在一定的问题的，就是这种单例有可能被序列化锁破坏。那么对于序列化这件事情，为什么枚举又有无先天的优势了呢？<br>​        在序列化的时候Java仅仅是将枚举类对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。</p>
<p>​        普通的Java类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。所以，即使单例中构造函数是私有的，也会被反射给破坏掉。由于反序列化后的对象是重新new出来的，所以就破坏了单例。</p>
<p>​        但是，枚举的反序列化并不是通过反射实现的。所以，就不会发生由于反序列化导致的单例破坏问题。</p>
<p><strong>总结</strong></p>
<p>​        在所有的单例实现方式中，枚举是一种在代码写法上最简单的方式，之所以代码十分简洁，是因为Java给我们提供了enum关键字，我们便可以很方便的声明一个枚举类型，而不需要关心其初始化过程中的线程安全问题，因为枚举类在被虚拟机加载的时候会保证线程安全的被初始化。<br>​        初次之外，在序列化方面，Java中有明确规定，枚举的序列化和反序列化是有特殊定制的。这就可以避免反序列化过程中由于反射而导致的单例被破坏问题。</p>
<h3 id="Enum类"><a href="#Enum类" class="headerlink" title="Enum类"></a>Enum类</h3><p>​        Java中定义枚举是使用Enum关键字的，但是Java中其实还有一个java.lang.Enum类。这是一个抽象类，定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">paekage java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">Constable</span>, <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这个类我们在日常开发中不会用到，但是其实我们使用enum定义的枚举，其实现方式就是通过继承Enum类实现的。<br>​        当我们使用enum来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类不能被继承。</p>
<h3 id="Java枚举如何比较"><a href="#Java枚举如何比较" class="headerlink" title="Java枚举如何比较"></a>Java枚举如何比较</h3><p>​        Java枚举值比较用==和equals方法没什么区别，两个随便用都是一样的效果。因为枚举Enum类的equals方法默认实现就是通过==来比较的；类似的Enum的CompareTo方法比较的是Enum的ordinal顺序大小；类似的还有Enum的name方法和toString方法一样都返回的是Enum和name值。</p>
<h3 id="switch对枚举类的支持"><a href="#switch对枚举类的支持" class="headerlink" title="switch对枚举类的支持"></a>switch对枚举类的支持</h3><p>​        Java1.7之前switch参数可用类行为short、byte、int、char、枚举类之所以能使用其实是编译器层面实现的。<br>​        编译器会将枚举switch转换为类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(s.ordinal())&#123;</span><br><span class="line">        <span class="keyword">case</span> Status.START.ordinal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        所以实质还是int参数类型。</p>
<h3 id="枚举的序列化如何实现"><a href="#枚举的序列化如何实现" class="headerlink" title="枚举的序列化如何实现"></a>枚举的序列化如何实现</h3><p>​        关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。</p>
<p><strong>枚举是如何保证线程安全的</strong></p>
<p><a href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%AE%9E%E7%8E%B0">详见</a></p>
<p><strong>为什么用枚举实现的单例是最好的方式</strong></p>
<ul>
<li>枚举写法简单</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EasySingleton</span></span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        你可以通过EasySingleton.INSTANCE来访问。</p>
<ul>
<li>枚举自己处理序列化</li>
</ul>
<p>​        我们知道，以前所有的单例模式都有一个比较大的问题，就是一旦实现了Serializable接口之后，就不再是单例得了，因为，每次调用readObject()方法返回都是一个新创建出来的对象，有一种解决办法就是使用readResolve()来避免此事发生。但是，为了保证枚举类型像Java规范中说的那样，每一个枚举类型及其定义得枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。</p>
<p>​        在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。</p>
<p>​        看一下valueOf方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span></span>&#123;</span><br><span class="line">    T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">    <span class="keyword">if</span>(result != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Name is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No enum const &quot;</span> + enumType + <span class="string">&quot;.&quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        从代码中可以看到，代码会尝试从调用enumType这个Class对象的enumConstantDirectory()方法返回的map中获取名字为name的枚举对象，如果不存在就会抛出异常。再一步跟到enumConstantDirectory()方法，就会发现到最后会以反射的方式调用enumType这个类型的values()静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充enumType这个Class对象中的enumConstantDirectory属性。<br>​        所以，JVM对序列化有保证。</p>
<ul>
<li>枚举实例创建是thread-safe(线程安全)</li>
</ul>
<p>​        当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，创建一个enum类型是线程安全的。</p>
<h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>​        Java泛型(generics)是JDK5中引入的一个新特性，允许在定义类和接口时候使用参数类型(type parameter)。<br>​        声明的类型参数在使用的时候具体的类型替换。泛型最主要的应用是在JDK5中的新集合框架中。<br>​        泛型最大的好处是可以提高代码的复用性。以List接口为例，我们可以将String、Integer等类型放入List中，如不用泛型，存放String类型要写一个List接口，存放Integer要写另外一个List接口，泛型可以很好的解决这个问题。</p>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p><strong>一、各种语言中的编译器是如何处理泛型的</strong></p>
<p>​        通常情况下，一个编译器处理泛型有两种方式：</p>
<p>​        1.Code specialization。在实例化一个泛型类或泛型方法时都产生了一份新的目标代码(字节码or二进制代码)。例如，针对一个泛型list，可能需要针对string，integer，float产生三份目标代码。</p>
<p>​        2.Code sharing。对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。</p>
<p>​        C++中的模板(template)是典型的Code specialization实现。C++编译器会为每一个泛型类实例生成一份执行代码。执行代码中的integer list和string list 是两种不同的类型。这样会导致代码膨胀(code bloat)。c#里面泛型无论在程序源码中，编译后的IL中(Intermediate Language，中间语言，这个时候泛型是一个占位符)或是运行期的CLR中都是切实存在的，List&lt;int&gt;和List&lt;String&gt;就是两种不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型被称为真实泛型。Java语言中的泛型则不一样，它只是在程序源代码中存在，在编译后的字节码文件中，就已经被替换为原来的原生类型(Raw Type，也称为裸类型)了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList&lt;int&gt;与ArrayList&lt;String&gt;就是同一个类。所以说泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方式称为类型擦除，基于这种方法实现的泛型被称为伪泛型。</p>
<p>​        C++和C#是使用Code specialization的处理机制，前面提到，它有一个缺点，那就是会导致代码膨胀。另外一个弊端是在引用类型系统中，浪费空间，因为引用类型集合中元素本质上都是一个指针。没必要为每个类型都产生一份执行代码。而这也是Java编译器中采用Code sharing方式处理泛型的主要原因。</p>
<p>​        Java是通过Code sharing方式为每个泛型类创建唯一的字节码表示，并且将该泛型类型的实例都映射到这唯一的字节马上。将多种泛型类型实例映射到唯一的字节码表示是通过类型擦除(type erasure)实现的。</p>
<p><strong>二、什么是类型擦除</strong></p>
<p>​        前面多次提到这个词：类型擦除(type erasure)，那么到底什么是类型擦除呢？</p>
<p>​        类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节马上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。类型擦除可以简单的理解为将泛型Java代码转为普通的Java代码，只不过编译器更直接点，将泛型Java代码直接转换成普通Java字节码。类型擦除的主要过程如下：1.将所有的泛型参数用其最左边界(最顶级的父类型)类型替换；2.移除所有的类型参数</p>
<p><strong>三、Java编译器处理泛型的过程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Code 1:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wk&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;22&quot;</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反编译后的Code 1：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wk&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;22&quot;</span>);</span><br><span class="line">    System.out.println((String)map.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    System.out.println((String)map.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以发现泛型都不见了，程序又变成了Java泛型出现之前的写法，泛型类型都变回了原生类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Code 2:</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">A</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(A that)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumericValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">NumericValue</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumericValue</span><span class="params">(<span class="keyword">byte</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(NumericValue that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - that.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反编译后的Code 2：</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span><span class="params">(Object that)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumericValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumericValue</span><span class="params">(<span class="keyword">byte</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(NumericValue that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - that.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareTo((NumericValue)obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Code 3:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A extends Comparable&lt;A&gt;&gt; <span class="function">A <span class="title">max</span><span class="params">(Collection&lt;A&gt; xs)</span></span>&#123;</span><br><span class="line">        Iterator&lt;A&gt; xi = xs.iterator();</span><br><span class="line">        A w = xi.next();</span><br><span class="line">        <span class="keyword">while</span>(xi.hasNext())&#123;</span><br><span class="line">            A x = xi.next;</span><br><span class="line">            <span class="keyword">if</span>(w.compareTo(x) &lt; <span class="number">0</span>)</span><br><span class="line">                w = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反编译后的Code 3：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Collections</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">max</span><span class="params">(Collection xs)</span></span>&#123;</span><br><span class="line">        Iterator&lt;A&gt; xi = xs.iterator();</span><br><span class="line">        Comparable w = (Comparable)xi.next();</span><br><span class="line">        <span class="keyword">while</span>(xi.hasNext())&#123;</span><br><span class="line">            Comparable x = (Comparable)xi.next;</span><br><span class="line">            <span class="keyword">if</span>(w.compareTo(x) &lt; <span class="number">0</span>)</span><br><span class="line">                w = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        第二个泛型类Comparable&lt;A&gt;擦除后A被替换为最左边界的Object。Comparable&lt;NumericValue&gt;的类型参数NumericValue被擦除掉，但是这直接导致NumericValue没有实现接口Comparable的CompareTo(Object that)方法，于是编译器充当好人，添加了一个桥接方法。第三个实例中限定了类型参数的边界&lt;A extends Comparable&lt;A&gt;&gt;，A必须为Comparable&lt;A&gt;的子类，按照类型擦除的过程，先将所有的类型参数xi换为最左边界Comparable&lt;A&gt;，然后去掉参数类型A，得到最后的擦除结果。</p>
<p><strong>四、泛型带来的问题</strong></p>
<p>①当泛型遇到重载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这段代码，有两个重载的函数，因为他们的参数类型不同，一个是List&lt;String&gt;另一个是List&lt;Integer&gt;，但是，这段代码编译是通不过的。因为参数List&lt;String&gt;和List&lt;Integer&gt;编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样。</p>
<p>②当泛型遇到catch：</p>
<p>​        如果我们自定义了一个泛型异常类GenericException，那么，不要尝试用多个catch去匹配不同的异常类型，例如你想要分别获得GenericException、GenericException，这也是有问题的。</p>
<p>③当泛型内包含静态变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GT&lt;Integer&gt; gti = <span class="keyword">new</span> GT&lt;Integer&gt;();</span><br><span class="line">        gti.<span class="keyword">var</span> = <span class="number">1</span>;</span><br><span class="line">        GT&lt;String&gt; gts = <span class="keyword">new</span> GT&lt;String&gt;();</span><br><span class="line">        gts.<span class="keyword">var</span> = <span class="number">2</span>;</span><br><span class="line">        System.out.println(gti.<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GT</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nothing</span><span class="params">(T x)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        答案是2，由于经过类型擦除，所有泛型实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。</p>
<p><strong>五、总结</strong></p>
<ul>
<li>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。比如并不存在List&lt;String&gt;.class或者是List&lt;Integer&gt;.class，而只有List.class。</li>
<li>创建泛型对象时请指明类型，让编译器尽早的做参数检查</li>
<li>不要忽略编译器的警告信息，那意味着潜在的ClassCastException等着你</li>
<li>静态变量是被泛型类的所有实例所共享的。对于声明为MyClass&lt;T&gt;的类，访问其中的静态变量的方法仍然是MyClass.myStaticVar。不管是通过new MyClass&lt;String&gt;还是new MyClass&lt;Integer&gt;创建的对象，都是共享一个静态变量。</li>
<li>泛型的类型参数不能在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻进行的。由于类型信息被擦除，JVM无法区分两个异常类型MyException&lt;String&gt;和MyException&lt;Integer&gt;的。对于JVM来说，它们都是MyException类型的。也就无法执行与异常对应的catch语句。</li>
</ul>
<h3 id="泛型中K-T-V-E-object等的含义"><a href="#泛型中K-T-V-E-object等的含义" class="headerlink" title="泛型中K T V E? object等的含义"></a>泛型中K T V E? object等的含义</h3><ul>
<li>E —— Element(在集合中使用，因为集合中存放的是元素)</li>
<li>T —— Type(Java类)</li>
<li>V —— Value(值)</li>
<li>K —— Key(键)</li>
<li>N —— Number(数值类型)</li>
<li>？—— 表示不确定的java类型(无限制通配符类型)</li>
<li>S、U、V —— 2nd、3rd、4th types</li>
</ul>
<p>Object - 是所有类的根类，任何类的对象都可以设置给Object引用变量，使用的时候可能需要类型强制转换，但是用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。</p>
<h3 id="限定通配符和非限定通配符"><a href="#限定通配符和非限定通配符" class="headerlink" title="限定通配符和非限定通配符"></a>限定通配符和非限定通配符</h3><p>​        限定通配符对类型进行限制，泛型中有两种限定通配符：<br>​        表示类型的上界，格式为&lt;? extends T&gt;，即类型必须为T型类或T的子类；表示类型的下界，格式为&lt;? super T&gt;，即类型必须为T类型或者是T的父亲。<br>​        泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。<br>​        非限定通配符表示可以用任意泛型类型来代替，类行为&lt;T&gt;</p>
<h3 id="上下界限定符extends和super"><a href="#上下界限定符extends和super" class="headerlink" title="上下界限定符extends和super"></a>上下界限定符extends和super</h3><p>​        &lt;? extends T&gt;和&lt;? super T&gt;是Java泛型中的“通配符(Wildcards)”和“边界(Bounds)”的概念。&lt;? extends T&gt;：是指“上界通配符(Upper Bounds Wildcards)”，即泛型中的类必须为当前类的子类或当前类。&lt;? super T&gt;：是指“下界通配符(Lower Bounds Wildcards)”，即泛型中的类必须为当前类或者其父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExtends</span><span class="params">(List&lt;? extends Fruit&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//报错，extends为上界通配符，只能取值，不能放</span></span><br><span class="line">        <span class="comment">//因为Fruit的子类不只有Apple还有Banana，这里不确定具体的泛型到底是Apple还是Banana，所以放入任何一种类型都会报错</span></span><br><span class="line">        <span class="comment">//list.add(new Apple());</span></span><br><span class="line">        <span class="comment">//可以正常获取</span></span><br><span class="line">        Fruit fruit = list.get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSuper</span><span class="params">(List&lt;? <span class="keyword">super</span> Fruit&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//super为下界通配符，可以存放元素，但也只能存放当前类或者子类的实例，以当前的例子来讲</span></span><br><span class="line">        <span class="comment">//无法确定Fruit的父类是否只有Food一个(Object也是超级父类)</span></span><br><span class="line">        <span class="comment">//因此放入Food的实例编译不通过</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Apple());</span><br><span class="line">        <span class="comment">//list.add(new Food());</span></span><br><span class="line">        Object object = list.get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在testExtends方法中，因为泛型中用的是extends，在向list存放元素的时候，我们并不能确定List中的具体类型，即可能是Apple，也可能是Banana。因此调用add方法时，不论传入new Apple()还是new Banana()，都会出现编译错误。<br>​        理解了extends之后，再看super就很容易了，即我们不能确定testSuper方法的参数中泛型是Fruit的哪个父类，因此调用get方法时只能返回Object类型。结合extends可见，在获取泛型元素时，使用extends获取到的是泛型中的上边界的类型。<br>​        在使用泛型时，存储元素时用super，获取元素时，用extends。<br>​        频繁往外读取内容，适合用上界Extends；经常往里插入的，适合用下界Super。</p>
<h3 id="List-lt-Object-gt-和原始类型List之间的区别"><a href="#List-lt-Object-gt-和原始类型List之间的区别" class="headerlink" title="List&lt;Object&gt;和原始类型List之间的区别"></a>List&lt;Object&gt;和原始类型List之间的区别</h3><p>​        原始类型List和带参数类型List&lt;Object&gt;之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查。<br>​        通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String和Integer。<br>​        它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把List&lt;String&gt;传递给接收List&lt;Object&gt;的方法，因为会产生编译错误。<br>​        List&lt;?&gt;和List&lt;Object&gt;之间的区别是什么？List&lt;?&gt;是一个未知类型的List，而List&lt;Object&gt;其实是任意类型的List。你可以把List&lt;String&gt;,List&lt;Integer&gt;赋值给List&lt;?&gt;，却不能把List&lt;String&gt;赋值给List&lt;Object&gt;。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>​        所谓静态代理，就是代理类由程序员自己编写，在编译期就确定好了。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloSerivice</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSeriviceImpl</span> <span class="keyword">implements</span> <span class="title">HelloSerivice</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上面的代码比较简单，定义了一个接口和其实现类。这就是代理模式中的目标对象和目标对象接口。接下类定义代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSeriviceProxy</span> <span class="keyword">implements</span> <span class="title">HelloSerivice</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HelloSerivice target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloServiceProxy</span><span class="params">(HelloSerivice target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记录日志&quot;</span>);</span><br><span class="line">        target.say();</span><br><span class="line">        System.out.println(<span class="string">&quot;清除数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上面就是一个代理类，它也实现了目标对象的接口，并且扩展了say方法。下面是一个测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        HelloSerivice target = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        <span class="comment">//代理对象</span></span><br><span class="line">        HelloSeriviceProxy proxy = <span class="keyword">new</span> HelloSeriviceProxy(target);</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这就是一个简单的静态的代理模式的实现。代理模式中的所有角色(代理对象、目标对象、目标对象的接口)等都是在编译期就确定好的。<br>​        静态代理的真正用途 控制真实对象的访问权限 通过代理对象控制真实对象的使用权限。<br>​        避免创建大对象，通过使用一个代理小对象代表一个真实的大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速率。<br>​        增强真实对象的功能，这个比较简单，通过代理可以在调用真实对象的方法前后增加额外的功能。</p>
<h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p>​        静态代理具有一定的局限性，比如使用静态代理模式需要程序员手动写很多代码，这个过程是比较浪费时间和精力的。一旦需要代理的类中的方法比较多，或者需要同时代理多个对象的时候，这无疑会增加很大的复杂度。<br>​        动态代理中的代理类并不要求在编译期就确定，而是在运行期动态生成的，从而实现对目标对象的代理功能。<br>​        反射是动态代理的一种实现方式。</p>
<h3 id="动态代理和反射的关系"><a href="#动态代理和反射的关系" class="headerlink" title="动态代理和反射的关系"></a>动态代理和反射的关系</h3><p>​        反射是动态代理的一种实现方式。</p>
<h3 id="动态代理的几种实现方式"><a href="#动态代理的几种实现方式" class="headerlink" title="动态代理的几种实现方式"></a>动态代理的几种实现方式</h3><p>​        Java中，实现动态代理有两种方式：</p>
<ul>
<li>JDK动态代理：java.lang.reflect包中的Proxy类和InvocationHandler接口提供了生成动态代理类的能力</li>
<li>Cglib动态代理：Cglib(Code Genneration Library)是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展</li>
</ul>
<p>JDK动态代理和Cglib动态代理的区别是：JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用cglib实现。</p>
<p>​        Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为它们提供方法的interception(拦截)。Cglib包的底层是通过使用一个小儿快的字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
<p>​        Cglib与JDK动态代理最大的区别就是：使用JDK动态代理的对象必须实现一个或多个接口，使用cglib代理的对象则无需实现接口，达到代理类无侵入。</p>
<p><strong>Java实现动态代理的大致步骤</strong></p>
<p>​        1.定义一个委托类和公共接口。<br>​        2.自己定义一个类(调用处理器类，即实现InvocationHandler接口)，这个类的目的是指定运行时将生成的代理类需要完成的具体任务(包括Preprocess和Postprocess)，即代理类调用任何方法都会经过这个调用处理器类。<br>​        3.生成代理对象(当然也会生成代理类)，需要为它指定：1委托对象；2实现的一系列接口3调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。</p>
<p><strong>Java实现动态代理主要涉及哪几个类</strong></p>
<p>​        java.lang.reflect.Proxy：这是生成代理类的主类，通过Proxy类生成的代理类都继承了Proxy类，即DynamicProxyClass extends Proxy。<br>​        java.lang.reflect.InvocationHandler：这里称它为“调用处理器”，它是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现InvocationHandler接口。</p>
<p><strong>动态代理实现</strong></p>
<p>​        使用动态代理实现功能：不改变Test类的情况下，在方法target之前打印一句话，之后打印一句话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------add-----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK动态代理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHanler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        PerformanceMonior.begin(target.getClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        PerformanceMonior.end();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        UserService service = <span class="keyword">new</span> UserServiceImple();</span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span>  MyInvocationHandler(service);</span><br><span class="line">        UserService proxy = (UserService)handler.getProxy();</span><br><span class="line">        proxy.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>cglib动态代理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置需要创建子类的类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//通过字节码技术动态创建子类实例</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现MethodInterceptor接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代理&quot;</span>);</span><br><span class="line">        <span class="comment">//通过代理类调用父类中的方法</span></span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;后置代理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoCGLib</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">        <span class="comment">//通过子类的方式创建代理类</span></span><br><span class="line">        UserServiceImpl proxyImp = (UserServiceImpl)proxy.getProxy(UserServiceImpl.class);</span><br><span class="line">        proxyImp.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>​        SpringAOP中的动态代理主要有两种实现方式，JDK动态代理和CGLIB动态代理。<br>​        JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy接口。<br>​        如果目标类没有实现接口，那么SpringAOP会使用CGLIB来动态代理目标类。<br>​        CGLIB(Code Generation Library)，是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它无法使用CGLIB做动态代理。</p>
<hr>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="什么是序列化与反序列化"><a href="#什么是序列化与反序列化" class="headerlink" title="什么是序列化与反序列化"></a>什么是序列化与反序列化</h3><p>​        序列化是将对象转换成可传输格式的过程。是一种数据的持久化手段。一般广泛应用于网络传输，RMI和RPC等场景中。反序列化是序列化的逆过程。序列化是将对象的状态信息转换为可存储或传输的形式的过程。一般是以字节码或XML格式传输。而字节码或XML编码格式可以还原为完全相等的对象。这个相反的过程称为反序列化。</p>
<h3 id="Java如何实现序列化与反序列化"><a href="#Java如何实现序列化与反序列化" class="headerlink" title="Java如何实现序列化与反序列化"></a>Java如何实现序列化与反序列化</h3><p><strong>Java对象的序列化与反序列化</strong></p>
<p>​        在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用该对象。但是，我们创建出来的这些Java对象都是存在于JVM的堆内存中的。只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止运行，这些对象的状态就随之而丢失了。</p>
<p>​        但是在真实的应用场景中，我们需要将这些对象持久化下来，并且能够在需要的时候把对象重新读取出来。Java的对象序列化可以帮助我们实现该功能。</p>
<p>​        对象序列化机制(object serialization)是Java语言内建的一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并且可以在有需要的时候将这个字节数组通过反序列化的方式转换成对象。对象序列化可以很容易的在JVM中的活动对象和字节数组(流)之间进行转换。</p>
<p>​        在Java中，对象的序列化与反序列化被广泛应用到RMI(远程方法调用)及网络传输中。</p>
<p><strong>相关接口及类</strong></p>
<p>​        Java为了方便开发人员将Java对象进行序列化及反序列化提供了一套方便的API来支持。其中包括了如下的接口与类：</p>
<ul>
<li>java.io.Serializable</li>
<li>java.io.Externalizable</li>
<li>ObjectOutput</li>
<li>ObjectInput</li>
<li>ObjectOutStream</li>
<li>ObjectInputStream</li>
</ul>
<p><strong>Serializable 接口</strong></p>
<p>​        类通过实现java.io.Serializable接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。<br>​        当试图对一个对象进行序列化的时候，如果遇到不支持Serializable接口的对象。在此情况下，将抛出NotSerializableException。<br>​        如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该集成java.io.Serializable接口。下面是一个实现了java.io.Serializable接口的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> + </span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + <span class="keyword">this</span>.age + </span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过下面的代码进行序列化及反序列化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        User1 user = <span class="keyword">new</span> User1();</span><br><span class="line">        user.setName(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">25</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">//Write Obj to File</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            IOUtils.closeQuietly(oos);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Read Obj from File</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">            User1 newUser = (User1) ois.readObject();</span><br><span class="line">            System.out.println(newUser);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            IOUtils.closeQuietly(ois);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                FileUtils.forceDelete(file);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Externalizable接口</strong></p>
<p>​        除了Serializable之外，Java还提供了另外一个序列化接口Externalizable。<br>​        为了了解Externalizable接口和Serializable接口的区别，先来看代码，将上面的代码改成使用Externalizable的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> + </span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + <span class="keyword">this</span>.age + </span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalizableDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">//Write Obj to file</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">        User1 user = <span class="keyword">new</span> User1();</span><br><span class="line">        user.setName(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">23</span>);</span><br><span class="line">        oos.wirteObject(user);</span><br><span class="line">        <span class="comment">//Read Obj from file</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        User1 newInstance = (User1) ois.readObject();</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        System.out.println(newInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//User&#123;name=&#x27;null&#x27;,age=0&#125;</span></span><br></pre></td></tr></table></figure>

<p>​        通过上面的实例可以发现，对User1类进行序列化及反序列化之后得到的对象的所有属性的值都变成了默认值。也就是说，之前的那个对象的状态并没有被持久化下来。这就是Externalizable接口和Serializable接口的区别：</p>
<p>​        Externalizable继承了Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。由于上面的代码中，并没有在这两个方法中定义序列化的实现细节，所以输出的内容为空。还有一点值得注意的是：使用Externalizable进行序列化的时候，在读取对象时，会调用被序列化的无参构造去创建一个新的对象，然后再被保存对象的字段的值分别填充到新对象中。所以，实现Externalizable接口的类必须要提供一个public的无参构造器。</p>
<p>​        按照要求修改之后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> + </span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + <span class="keyword">this</span>.age + </span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalizableDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">//Write Obj to file</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">        User2 user = <span class="keyword">new</span> User2();</span><br><span class="line">        user.setName(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">23</span>);</span><br><span class="line">        oos.wirteObject(user);</span><br><span class="line">        <span class="comment">//Read Obj from file</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        User1 newInstance = (User2) ois.readObject();</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">        System.out.println(newInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//User&#123;name=&#x27;wk&#x27;,age=23&#125;</span></span><br></pre></td></tr></table></figure>

<p>​        这次，就把之前的对象状态持久化下来。如果User类中没有无参构造函数，在运行时抛出异常：java.io.InvalidClassException。</p>
<h3 id="Serializable和Externalizable有何不同"><a href="#Serializable和Externalizable有何不同" class="headerlink" title="Serializable和Externalizable有何不同"></a>Serializable和Externalizable有何不同</h3><p>​        Java中的类通过实现java.io.Serializable接口以启用其序列化功能。未实现此接口的类将无法使用其任何状态序列化和反序列化。<br>​        可序列化的所有子类型本身都是可序列化的。<br>​        序列化接口没有字段或方法，仅用于标识可序列化的语义。<br>​        当试图对一个对象进行序列化的时候，如果遇到不支持Serializable接口的对象。此情况下，将抛出NotSerializableExcepiton。<br>​        如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该集成java.io.Serializable接口。<br>​        Externalizable继承了Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。当使用Externalizable接口进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。若没有实现这两个方法中定义序列化实现的细节，那么序列化后，对象内容为空。实现Externalizable接口的类必须提供一个public的无参构造器。所以，实现Externalizable，并实现writeExternal()和readExternal()方法可以指定序列化哪些属性。</p>
<h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><p>​        序列化是将对象的状态信息转换为可存储或传输的形式的过程。<br>​        我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。<br>​        而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。把Java对象序列化成可存储或传输的形式(如二进制流)，比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。</p>
<p>​        但是，虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化ID是否一致，即serialVersionUID要求一致。</p>
<p>​        在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。<br>​        这样做的目的是为了保证安全，因为文件存储中的内容可能被篡改。</p>
<p>​        当实现java.io.Serializable接口的类没有显示地定义一个serialVersionUID变量时，Java序列化机制会根据编译的Class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，如果Class文件没有发生变化，就算再编译多次，serialVersionUID也不会变化的。<br>​        但是，如果发生了变化，那么这个文件对应的serialVersionUID也就会发生变化。</p>
<p>​        基于以上原理，如果我们一个类实现了Serializable接口，但是没有定义serialVersionUID，然后序列化。在序列化之后，由于某些原因，我们对该类做了变更，重新启动应用后，我们相对之前序列化过的对象进行反序列化的话就会报错。</p>
<h3 id="为什么serialVersionUID不能随便改"><a href="#为什么serialVersionUID不能随便改" class="headerlink" title="为什么serialVersionUID不能随便改"></a>为什么serialVersionUID不能随便改</h3><p>​        关于serialVersionUID。这个字段到底有什么用？如果不设置会怎么样？为什么《Java开发手册》中有以下规定：</p>
<p>​        【强制】序列化新增属性时，请不要修改serialVersionUID字段，避免反序列化失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。</p>
<p><strong>背景知识</strong></p>
<p>​        类通过实现java.io.Serializable接口以启用其序列化功能。未实现此接口的类将无法进行序列化或反序列化。可序列化类的所有子类型本身都是可以序列化的。<br>​        如果看过Serializable的源码，就会发现，它只是一个空的接口，里面什么东西都没有。Serializable接口没有方法或字段，仅用于标识可序列化的语义。但是，如果一个类没有实现这个接口，想要被序列化的话，就会抛出java.io.NotSerializableException异常。</p>
<p>​        它是怎么保证只有实现了该接口的方法才能进行序列化与反序列化的呢？原因是在执行序列化的过程中，会执行到以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">    writeString((String)obj, unshared);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray())&#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Enum)&#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Serializable)&#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(extendedDebugInfo)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">        cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfosStack.toString());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">throws</span> new <span class="title">NotSerializableException</span><span class="params">(cl.getName()</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在进行序列化操作时，会判断要被序列化的类是否为Enum、Array和Serializable类型，如果不是则直接抛出NotSerializableException。</p>
<p>​        Java中还提供了Externalizable接口，也可以实现它来提供序列化能力。Externalizable继承自Serializable，该接口中定义了两个抽象方法：writeExternal()和readExternal()。当使用Externalizable接口进行序列化与反序列化的时候需要开发人员重写writeExternal()和readExternal()方法。否则所有变量的值都会变成默认值。</p>
<p><strong>Transient</strong></p>
<p>​        transient关键字的作用是控制变量的序列化，在变量声明前加上改关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如int型是0，对象类型为null。</p>
<p><strong>自定义序列化策略</strong></p>
<p>​        在序列化过程中，如果被序列化的类中定义了writeObject和readObject方法，虚拟机会试图调用对象类里的writeObject和readObject方法，进行用户自定义的序列化和反序列化。如果没有这样的方法，则默认调用是ObjectOutputStream的defaultWriteObject方法以及ObjectInputStream的defaultReadObject方法。<br>​        用户自定义的writeObject和readObject方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。所以，对于一些特殊字段需要定义序列化的策略的时候，可以考虑使用transient修饰，并自己重写writeObject和readObject方法，如java.util.ArrayList中就有这样的实现。</p>
<p>​        我们随便找几个Java中实现了序列化接口的类，如String、Integer等，我们可以发现一个细节，那就是这些类除了实现了Serializable外，还定义了——serialVersionUID。</p>
<p><strong>什么是serialversionUID</strong></p>
<p><a href="#serialVersionUID">详见</a></p>
<p><strong>如果serialVersionUID变了会怎么样</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xiaohupao.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/4/5 15:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + <span class="keyword">this</span>.age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xiaohupao.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/4/5 15:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Initializes The Obj</span></span><br><span class="line">        User1 user1 = <span class="keyword">new</span> User1();</span><br><span class="line">        user1.setName(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        <span class="comment">//Write Obj to file</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">            oos.writeObject(user1);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(oos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        先执行以上代码，把User1对象写入到文件中。然后修改User1类，把serialVersionUID的值改为2L。然后执行以下代码，把文件中的对象反序列化出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xiaohupao.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Wukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/4/5 15:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemp1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file =  <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">            User1 newUser = (User1) ois.readObject();</span><br><span class="line">            System.out.println(newUser);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeQuietly(ois);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileUtils.forceDelete(file);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以发现抛出了一个java.io.InvalidClassException，并指出serialVersionUID不一致。<br>​        这是因为，在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidClassException。</p>
<p>​        这也是《Java开发手册》中规定，在兼容性升级中，在修改类的时候，不要修改serialversionUID的原因。除非是完全不兼容的两个版本。所以，serialVersionUID其实是验证版本一致性的。</p>
<p>​        如果一个类实现了Serializable接口，就必须手动添加一个 private static final long serialVersionUID变量，并设置初始值。</p>
<p><strong>为什么要明确一个serialVersionUID</strong></p>
<p>​        如果我们没有在类中明确定义一个serialVersionUID的话，看看会发生什么。<br>​        尝试修改上面demo代码，先使用以下类定义一个对象，该类中不定义serialVersionUID，将其写入文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        然后修改User1类，向其中添加一个属性。再尝试将其中文件中读取出来，并进行反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        同样抛出了InvalidClassException，并且指出两个serialVersionUID不同。从这里看出，系统自己添加了一个serialVersionUID。所以，一旦类实现了Serializable就建议明确的定义一个serialVersionUID。不然在修改类的时候，就会发生异常。</p>
<p>​        serialVersionUID有两种显示的生成方式：一是默认的1L，比如：private static final long serialVersionUID = 1L；二是根据类名、接口名、成员方法及属性等生成一个64位的哈希字段，例如：private static final long serialVersionUID = xxxxL；后面方式可以借助于IDE生成。</p>
<p><strong>背后原理</strong></p>
<p>​        反序列化的调用链如下：ObjectInputStream.readObject -&gt; readObject0 -&gt; readOrdinaryObject -&gt; readClassDesc -&gt; readNonProxyDesc -&gt; ObjectStreamClass.initNonProxy<br>​        在initNonProxy中，在反序列化过程中，对serialVersionUID做了比较，如果发现不相等，则直接抛出异常。<br>​        在getSerialVersionUID方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> getSerialVersionUID&#123;</span><br><span class="line">    <span class="keyword">if</span>(suid == <span class="keyword">null</span>)&#123;</span><br><span class="line">        suid = AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> PrivilegedAction&lt;Long&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Long <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> computerDefaultSUID(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> suid.longValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在没有定义serialVersionUID的时候，会调用computerDefaultSUID方法，生成一个默认的serialVersionUID。</p>
<p><strong>IDEA提示</strong></p>
<p>​        为了确保我们不会忘记定义serialVersionUID，可以调节以下IDEA的配置，在实现Serializable接口后，如果没有定义serialVersionUID的话，IDEA会进行提示。</p>
<p><strong>总结</strong></p>
<p>​        serialVersionUID是用来验证版本一致性的。所以在做兼容性升级时，不要改变类中serialVersionUID的值。<br>​        如果一个类实现了Serializable接口，一定要记得定义serialVersionUID，否则会发生异常。可以在IDEA中通过设置，让其提醒。之所以会发生异常，是因为反序列化中做了校验，并且如果没有明确定义的话，会根据类的属性自动生成一个。</p>
<h3 id="序列化底层原理"><a href="#序列化底层原理" class="headerlink" title="序列化底层原理"></a>序列化底层原理</h3><p>​        序列化是一种对象持久化的手段。普遍应用在网络传输、RMI等场景中。</p>
<p><strong>Java对象的序列化</strong></p>
<p>​        Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行后能够保持(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。<br>​        使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，在未来，再将这些字节组装成对象。需要注意地是，对象序列化保存的是对象的“状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。<br>​        除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。</p>
<p><strong>如何对Java对象进行序列化与反序列化</strong></p>
<p>​        在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个User类，用于序列化及反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SerialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> + </span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&#x27;\&#x27; &#x27;</span> + </span><br><span class="line">            <span class="string">&quot;,age=&quot;</span> + <span class="keyword">this</span>.age + </span><br><span class="line">            <span class="string">&quot;, gender=&quot;</span> + <span class="keyword">this</span>.gender +</span><br><span class="line">            <span class="string">&quot;,birthday=&quot;</span> + <span class="keyword">this</span>.birthday + </span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">        user.setGender(<span class="string">&quot;male&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">25</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Write Obj to File</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            IOUtils.closeQuietly(oos);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Read Obj From File</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">            User newUser = (User)ois.readObject();</span><br><span class="line">            System.out.println(newUser);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            FileUtils.forceDelete(file);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//User&#123;name=&#x27;wk&#x27;, age=23, gender=male, birthday=Tue Feb 06 13:00:00 CST</span></span><br><span class="line"><span class="number">2021</span>&#125;</span><br><span class="line"><span class="comment">//User&#123;name=&#x27;wk&#x27;, age=23, gender=null, birthday=Tue Feb 06 13:00:00 CST</span></span><br><span class="line"><span class="number">2021</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>序列化及反序列化相关知识</strong></p>
<ul>
<li>在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。</li>
<li>通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化。</li>
<li>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个序列化ID是否一致(就是private static final long serialVersionUID)。</li>
<li>序列化并不保存静态变量。</li>
<li>想要将父类对象也序列化，就需要让父类也是实现Serializable接口。</li>
<li>Transient关键字的作用是控制变量的序列化，在变量名声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如int型为0，对象型为null。</li>
<li>服务端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</li>
</ul>
<p><strong>ArrayList的序列化</strong></p>
<p>​        在介绍ArrayList序列化之前，先来考虑一个问题：如何自定义的序列化和反序列化策略？带着这个问题，我们来看java.util.ArrayList的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        省略了其他成员变量，从上面的代码中可以知道ArrayList实现了java.io.Serializable接口，那么我们就可以对它进行序列化及反序列化。因为elementData是transient的，所以我们认为这个成员变量不会被序列化而保留下来。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundExcption</span>&#123;</span><br><span class="line">    List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    StringList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    StringList.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    StringList.add(<span class="string">&quot;wk&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;init StringList&quot;</span> + stringList);</span><br><span class="line">    ObjectOutputStream objectOutputString = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;stringlist&quot;</span>));</span><br><span class="line">    objectOutputString.writeObject(stringList);</span><br><span class="line">    IOUtils.close(ObjectOutputStream);</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;stringlist&quot;</span>);</span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    List&lt;String&gt; newStringList = (List&lt;String&gt;)objectInputStream.readObject();</span><br><span class="line">    IOUtils.close(ObjectInputStream);</span><br><span class="line">    <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">        file.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;new StringList&quot;</span> + newStringList);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//init StringList[hello, world, wk]</span></span><br><span class="line"><span class="comment">//new StringList[hello, world, wk]</span></span><br></pre></td></tr></table></figure>

<p>​        了解ArrayList的人都知道，ArrayList底层是通过数组实现的。那么数组elementDate其实就是用来保存列表中的元素的。通过该属性的声明方式我们知道，它是无法通过序列化持久化下来的。那么为什么上述代码能通过序列化和反序列化把List中的元素保留下来呢？</p>
<p><strong>writeObject和readObject方法</strong></p>
<p>​        在ArrayList中定义了两个方法：writeObject和readObject。在序列化过程中，如果被序列化的类中定义了writeObject和readObject方法，虚拟机会试图调用对象类里的writeObject和readObject方法，进行用户自定义的序列化和反序列化。<br>​        如果没有这样的方法，则默认调用的是ObjectOutputStream的defaultWriteObject方法以及ObjectInputStream的defaultReadObject方法。<br>​        用户定义的writeObject和readObject方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。<br>​        来看一下这两个方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    <span class="comment">//Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="comment">//Read in capacity</span></span><br><span class="line">    s.readInt();</span><br><span class="line">    <span class="keyword">if</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">//Read in all elements in the proper order</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">//Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    <span class="comment">//Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    <span class="comment">//Write out all elements in the proper order</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(modCount != expectedModCount)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        为什么ArrayList要使用这种方式来实现序列化呢？</p>
<p><strong>why transient</strong></p>
<p>​        ArrayList实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化99个null元素。为了保证在序列化的时候不会将这么多null同时进行序列化，ArrayList把元素数组设为transient。</p>
<p><strong>why writeObject and readObject</strong></p>
<p>​        前面说过，为了防止一个包含大量空对象的数组被序列化，为了优化存储，所以，ArrayList使用transient来声明elementData。但是，作为一个集合，在序列化过程中还必须保证其中的元素可以被持久化下来，所以，通过重写writeObject和readObject方法的方式把其中的元素保留下来。<br>​        writeObject方法把elementData数组中的元素遍历的保留到输出流(ObjectOutputStream)中。readObject方法从输入流(ObjectInputStream)中读出对象并保存赋值到elementData数组中。<br>​        至此，我们先试着来回答刚刚提出的问题：如何自定义的序列化和反序列化策略？答：可以通过在被序列化的类中增加writeObject和readObject方法。那么问题又来了：虽然ArrayList中写了writeObject和readObject方法，但是这两个方法并没有显示的被调用啊。那么如果一个类中包含了writeObject和readObject方法，那么这两个方法是怎么被调用的呢？</p>
<p><strong>ObjectOutputStream</strong></p>
<p>​        从上面代码中，我们可以看出，对象的序列化过程通过ObjectOutputStream和ObjectInputStream来实现的，那么带着刚才的问题，我们来分析一下ArrayList中的writeObject和readObject方法到底是如何被调用的呢？</p>
<p>​        ObjectOutputStream的writeObject的调用栈：writeObject - - - &gt; writeObject0 - - - &gt; writeOrdinaryObject - - - &gt; wirteSerialData - - - &gt; invokeWriteObject<br>​        这里看一下invokeWriteObject：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeWriteObject</span><span class="params">(Object obj, ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException, UnsupportedOperationException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(writeObjectMethod != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            writeObjectMethod.invoke(obj, <span class="keyword">new</span> Object[] &#123;out&#125;);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InvocationTargetException ex)&#123;</span><br><span class="line">            Throwable th = ex.getTargetException();</span><br><span class="line">            <span class="keyword">if</span>(th <span class="keyword">instanceof</span> IOException)&#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) th;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                throwMiscException(th);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IllegalAccessException ex)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOprationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        其中writeObjectMethod.invoke(obj, new Object[] {out});是关键，通过反射的方式调用writeObjectMethod方法。官方是这么解释这个writeObjectMethod的：class-defined writeObject method, or null if none 在我们的例子中，这个方法就是我们在ArrayList中定义的writeObject方法。通过反射的方式被调用了。</p>
<p>​        至此，我们先试着来回答刚刚提出的问题：如果一个类中包含writeObject和readObject方法，那么这两个方法是怎么被调用的呢？答：在使用ObjectOutputStream的readObject方法时和ObjectInputStream的readObject方法时，会通过反射的方式调用。</p>
<p>​        至此，我们已经介绍完了ArrayList的序列化方式。那么，不知道有没有提出这样的问题：Serializable明明就是一个空接口，它是怎么保证只有实现该接口的方法才能进行序列化与反序列化的呢？<br>​        Serializable接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        若把类中继承Serializable的代码去掉，在执行序列化，将会抛出java.io.NotSerializableException。其实这个问题很好回答，我们回到刚刚ObjectOutputStream的writeObject的调用栈：write - -  - &gt;writeObject0 - - - &gt; writeOrdinaryObject - - - &gt;writeSerialData - - -&gt;invokeWriteObject<br>​        writeObject0方法中有这么一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Enum)&#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Serializable)&#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(extendedDebugInfo)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">            cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableExcpetion(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在序列化操作时，会判断要被序列化的类是否Enum、Array和Serializable类型，如果不是则直接抛出NotSerializableException。</p>
<p><strong>总结</strong></p>
<ul>
<li>如果一个类想被序列化，需要实现Serializable接口。否则将会抛出NotSerializableException异常，这是因为，在序列化操作过程中会对类进行检查，要求被序列化的类必须属于Enum、Array和Serializable类型其中的任何一种。</li>
<li>在变量声明前加上transient关键字，可以阻止该变量被序列化到文件中。</li>
<li>在类中增加writeObject和readObject方法可以实现自定义序列化策略。</li>
</ul>
<h3 id="序列化如何破坏单例模式"><a href="#序列化如何破坏单例模式" class="headerlink" title="序列化如何破坏单例模式"></a>序列化如何破坏单例模式</h3><p>​        单例模式，是设计模式中最简单的一种。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的选择方案。<br>​        但是，单例模式真的能够实现实例的唯一性吗？<br>​        答案是否定的，很多人都知道用反射可以破坏单例模式，除了反射以外，使用序列化与反序列化也同样会破坏单例。</p>
<p><strong>序列化对单例的破坏</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code1</span></span><br><span class="line"><span class="comment">//使用双重校验锁方式实现单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code2</span></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line"> 	       <span class="comment">//Write Obj to file</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">        oos.writeObject(Singleton.getSingleton());</span><br><span class="line">        <span class="comment">//Read obj from file</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(file);</span><br><span class="line">        Singleton newInstance = (Singleton) ois.readObject();</span><br><span class="line">        <span class="comment">//判断是否为同一个对象</span></span><br><span class="line">        System.out.println(newInstance == Singleton.getSingleton());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>​        输出结果为false，说明：通过对Singleton的序列化与反序列化得到的对象是一个新的对象，这就破坏了Singleton的单例性。<br>​        这里，在介绍如何解决这个问题之前，我们先来深入分析一下，为什么会这样？在反序列化的过程中到底发生了什么。</p>
<p><strong>ObjectInputStream</strong></p>
<p>​        对象的序列化过程是通过ObjectOutputStream和ObjectInputStream来实现的，那么分析一下ObjectInputStream的readObject方法执行情况到底是怎么样的。给出ObjectInputStream的readObject的调用栈：readObject - - -&gt;readObject0 - - -&gt;readOrdinaryObject - - -&gt;checkResolve。这里重点看一下readOrdinaryObject方法的代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code3</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">        <span class="keyword">throw</span>(IOException) <span class="keyword">new</span> InvalidClassException(desc.forClass().getName(), <span class="string">&quot;unable to creat instance&quot;</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp; desc.hasReadResolveMethod())&#123;</span><br><span class="line">        Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">        <span class="keyword">if</span>(unshared &amp;&amp; rep.getClass().isArray())&#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rep != obj)&#123;</span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上半部分创建obj对象，就是本方法要返回的对象，可以暂时理解为是ObjectInputStream的readObject返回的对象。obj = desc.isInstantiable() ? desc.newInstance() : null;解释为：desc.isInstantiable() 如果一个序列化的类可以在运行时被实例化，那么该方法返回true。desc.newInstance() 通过反射的方式调用无参构造方法新建一个对象。</p>
<p>​        所以到目前为止，也就可以解释，为什么序列化可以破坏单例了？答：序列化会通过反射调用无参数构造器创建一个新的对象。<br>​        那么接下来我们再看刚开始留下的问题，如何防止序列化/反序列化破坏单例模式。</p>
<p><strong>防止序列化破坏单例模式</strong></p>
<p>​        先给出解决方案，然后再具体分析原理：只要在Singleton类中定义readResolve就可以解决该问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code4</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singletion</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        运行测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line"> 	       <span class="comment">//Write Obj to file</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">        oos.writeObject(Singleton.getSingleton());</span><br><span class="line">        <span class="comment">//Read obj from file</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(file);</span><br><span class="line">        Singleton newInstance = (Singleton) ois.readObject();</span><br><span class="line">        <span class="comment">//判断是否为同一个对象</span></span><br><span class="line">        System.out.println(newInstance == Singleton.getSingleton());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>​        输出结果为true。具体原理，我们将分析code3中的第二段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp; desc.hasReadResolveMethod())&#123;</span><br><span class="line">        Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">        <span class="keyword">if</span>(unshared &amp;&amp; rep.getClass().isArray())&#123;</span><br><span class="line">            rep = cloneArray(rep);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rep != obj)&#123;</span><br><span class="line">            handles.setObject(passHandle, obj = rep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        hasReadResolveMethod：如果实现了serializable或者externalizable接口的类中包含了readResolve则返回true。<br>​        invokeReadResolve：通过反射的方式调用被反序列化的类的readResolve方法。所以，远离也清楚了，主要在Singleton中定义readResolve方法，并在该方法中指定要返回的对象的生成策略，就可以防止单例被破坏。</p>
<p><strong>总结</strong></p>
<p>​        在涉及到序列化的场景中，要格外注意它对单例的破坏。</p>
<h3 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h3><p>​        protocol Buffer(简称Protobuf)是Google出品的性能优异、跨语言、跨平台的序列化库。<br>​        2001年初，Protobuf首先在Google内部创建，我们将它称之为proto1，一直以来在Google的内部使用，其中也不断的演化，根据使用者的需求也添加很多新的功能，一些内部库依赖它。几乎每个Google的开发者都会使用它。<br>​        Google开始开源它的内部项目时，因为依赖的关系，所以他们首先把Protobuf开源出去。</p>
<h3 id="Apache-Commons-Collections的反序列化漏洞"><a href="#Apache-Commons-Collections的反序列化漏洞" class="headerlink" title="Apache-Commons-Collections的反序列化漏洞"></a>Apache-Commons-Collections的反序列化漏洞</h3><h3 id="fastjson的反序列化漏洞"><a href="#fastjson的反序列化漏洞" class="headerlink" title="fastjson的反序列化漏洞"></a>fastjson的反序列化漏洞</h3><hr>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>​        说简单点，就是定义其他注解的注解。比如Override这个注解，就不是一个元注解。而是通过元注解定义出来的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        其中@Target和@Retention就是元注解。<br>​        元注解有四个：@Target(表示该注解可以用于什么地方)、@Retention(表示在什么级别保存该注解信息)、@Documented(将次注解包含在javadoc中)、@Inherited(允许子类继承父类中的注解)。</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>​        除了元注解，都是自定义注解。通过元注解定义出来的注解。如我们常用的Override、Autowrite等。日常开发也可以自定义一个注解，这些都是自定义注解。</p>
<h3 id="Java中常用注解使用"><a href="#Java中常用注解使用" class="headerlink" title="Java中常用注解使用"></a>Java中常用注解使用</h3><ul>
<li>@Override：表示当前方法覆盖了父类的方法</li>
<li>@Deprecation：表示方法已经过时，方法上有横线，使用时会有警告</li>
<li>@SuppressWarnings：表示关闭一些警告信息(通知java编译器忽略特定的编译警告)</li>
<li>@SafeVarargs：表示专门为抑制堆污染警告提供的</li>
<li>@FunctionalInterface：表示用来指定某个接口必须是函数式接口，否则就会编译错误</li>
</ul>
<h3 id="注解与反射的结合"><a href="#注解与反射的结合" class="headerlink" title="注解与反射的结合"></a>注解与反射的结合</h3><p>​        注解和反射经常结合在一起使用，在很多框架的代码中都能看到他们结合使用的影子。<br>​        可以通过反射来判断类，方法，字段上是否有某个注解以及获取注解中的值，获取某个类中的方法上的注解代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clz = bean.getClass();</span><br><span class="line">Method[] methods = clz.getMethods();</span><br><span class="line"><span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">    <span class="keyword">if</span>(method.isAnnotationPresent(EnableAuth.class))&#123;</span><br><span class="line">        String name = method.getAnnotation(EnableAuth.class).name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过isAnnotationPresent判断是否存在某个注解，通过getAnnotation获取注解对象，然后获取值。</p>
<p>​        一个类的某些字段上被注解标识，在读取该属性的时候，将注解中的默认值赋给这些属性，没有标记的属性不赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;有注解&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        定义一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@MyAnno</span></span><br><span class="line">    <span class="keyword">private</span> String stra;</span><br><span class="line">    <span class="keyword">private</span> String strb;</span><br><span class="line">    <span class="keyword">private</span> String strc;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str1, String str2, String str3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.stra = str1;</span><br><span class="line">        <span class="keyword">this</span>.strb = str2;</span><br><span class="line">        <span class="keyword">this</span>.strc = str3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这里给str1加上注解，并利用反射解析并赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化全部无注解</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;无注解&quot;</span>, <span class="string">&quot;无注解&quot;</span>, <span class="string">&quot;无注解&quot;</span>);</span><br><span class="line">        <span class="comment">//解析注解</span></span><br><span class="line">        doAnnoTest(person);</span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doAnnoTest</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        Class clazz = obj.getClass();</span><br><span class="line">        Filed[] declareFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field : declareFields)&#123;</span><br><span class="line">            <span class="comment">//检查该类是否使用了注解</span></span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(MyAnno.class))&#123;</span><br><span class="line">                MyAnno anno = field.getAnnotation(MyAnno.class);</span><br><span class="line">                <span class="keyword">if</span>(anno != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    String fieldName = field.getName();</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        Method setMethod = clazz.getDeclaredMethod(<span class="string">&quot;set&quot;</span> + fieldName.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + fieldName.substring(<span class="number">1</span>), String.class);</span><br><span class="line">                        <span class="comment">//获取注解的属性</span></span><br><span class="line">                        String annoValue = anno.value();</span><br><span class="line">                        setMethod.invoke(obj, annoValue);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(NoSuchMethodException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(IllegalAccessException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InvocationTargetException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person(stra=有注解,strb=无注解，strc=无注解)</span></span><br></pre></td></tr></table></figure>

<p>​        当开发者使用了Annotation修饰了类、方法、Field等成员之后，这些Annotation不会自己生效，必须由开发者提供相应的代码来提取并处理Annotation信息。这些处理提取和处理Annotation的代码统称为APT(Annotation Processing Tool)。</p>
<p>​        注解的提取需要借助于Java的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。</p>
<h3 id="如何自定义一个注解？"><a href="#如何自定义一个注解？" class="headerlink" title="如何自定义一个注解？"></a>如何自定义一个注解？</h3><p>​        在Java中，类使用class定义，接口使用interface定义，注解和接口的定义差不多，增加了一个@符号，即@interface，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAuth&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        注解中可以定义成员变量，用于信息的描述，跟接口中方法的定义类似，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAuth&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        还可以添加默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAuth&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;wk&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上面的介绍只是完成自定义注解的第一步，开发中日常使用注解大部分sh用在类上的，方法上的，字段上，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAuth&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Target</strong></p>
<p>​        用于指定被修饰的注解修饰哪些程序单元，也就是上面说的类，方法，字段。</p>
<p><strong>Retention</strong></p>
<p>​        用于指定被修饰的注解被保留多长时间，分别SOURCE(注解仅存在于源码中，在class字节码文件不包含)，CLASS(默认的保留策略，注解会在class字节码文件中存在，但运行时无法获取)，RUNTIME(注解会在class字节码文件中存在，在运行时可以通过反射获取到)三种类型，如果要在程序运行过程中通过反射来获取注解的信息需要将Retention设置为RUNTIME。</p>
<p><strong>Documented</strong></p>
<p>​        用于指定被修饰的注解类将被Javadoc工具提取成文档。</p>
<p><strong>Inherited</strong></p>
<p>​        用于指定被修饰的注解类将具有继承性。</p>
<h3 id="Spring常用注解"><a href="#Spring常用注解" class="headerlink" title="Spring常用注解"></a>Spring常用注解</h3><ul>
<li>@Configuration：把一个类作为IOC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。</li>
<li>@Scope注解 作用域</li>
<li>@Lazy(true) 表示延迟初始化</li>
<li>@Service 用于标注业务层组件</li>
<li>@Controller 用于标注控制层组件</li>
<li>@Repository用于标注数据访问组件，即DAO组件</li>
<li>@Component 泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</li>
<li>@Scope 用于指定scope作用域的(用在类上)</li>
<li>@PostConstruct用于指定初始化方法(用在方法上)</li>
<li>@PreDestory用于指定销毁方法(用在方法上)</li>
<li>@DependsOn 定义Bean初始化及销毁时的顺序</li>
<li>@Primary 自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常。</li>
<li>@Autowired默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：@Autowired@Qualifier(“personDaoBean”)存在多个实例配合使用</li>
<li>@Resource默认按名称装配，当找不到于名称匹配的Bean才会按类型装配</li>
</ul>
<p><strong>Spring中的这几个注解有什么区别：@Component、@Repository、@Service、@Controller</strong></p>
<p>​        一、@Component指的是组件：@Controller、@Repository、@Service注解都被@Component修饰，用于代码中区分表现层，持久层和业务层的组件，代码中组件不好归类时可以使用@Component来标注。<br>​        二、当前版本只有区分的作用，未来版本可能会添加更丰富的功能。</p>
<hr>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="Junit"><a href="#Junit" class="headerlink" title="Junit"></a>Junit</h3><h3 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h3><h3 id="mockito"><a href="#mockito" class="headerlink" title="mockito"></a>mockito</h3><h3 id="内存数据库-H2"><a href="#内存数据库-H2" class="headerlink" title="内存数据库(H2)"></a>内存数据库(H2)</h3><hr>
<h2 id="API-amp-SPI"><a href="#API-amp-SPI" class="headerlink" title="API&amp;SPI"></a>API&amp;SPI</h2><h3 id="API和SPI的关系和区别"><a href="#API和SPI的关系和区别" class="headerlink" title="API和SPI的关系和区别"></a>API和SPI的关系和区别</h3><p>​        Java中区分API和SPI，通俗的讲：API和SPI都是相对的概念，他们的差别只在语义上，API直接被应用开发人员使用，SPI被框架扩展人员使用。<br>​        API Application Programming Interface。大多数情况下，都是实现方来指定接口的不同实现，调用方仅仅依赖却无权选择不同实现。<br>​        SPI Service Provider Interface。如果是调用方来指定接口，实现方来针对接口来实现不同的实现。调用方来选择自己需要的实现方。</p>
<h3 id="如何定义SPI"><a href="#如何定义SPI" class="headerlink" title="如何定义SPI"></a>如何定义SPI</h3><p>​        步骤1：定义一组接口(假设是org.foo.demo.IShout)，并写出接口的一个或多个实现，(假设是org.foo.demo.animal.Dog、org.foo.demo.animal.Cat)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IShout</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">IShout</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;miao miao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">IShout</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wang wang&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        步骤2：在src/main/resources/下建立 /META-INF/services目录，新增一个以接口命名的文件(org.foo.demo.IShout文件)，内容是要应用的实现类(这里是org.foo.demo.animal.Dog和org.foo.demo.animal.Cat，没行一个类)。</p>
<p>​        步骤3：使用ServiceLoader来加载配置文件中指定的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SPIMain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ServiceLoader&lt;IShout&gt; shouts = ServiceLoader.load(IShout.class);</span><br><span class="line">        <span class="keyword">for</span>(IShout s : shouts)&#123;</span><br><span class="line">            s.shout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SPI的实现原理"><a href="#SPI的实现原理" class="headerlink" title="SPI的实现原理"></a>SPI的实现原理</h3><p>​        看ServiceLoader类的签名类的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代表被加载的类或接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; setvice;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于定位，加载和实例化providers的类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建ServiceLoader时采用的访问控制上下文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缓存providers,按实例化的顺序排列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String, S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//懒查找迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LaxyIterator lookupIterator;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用程序调用ServiceLoader.load方法</strong></p>
<p>​        ServiceLoader.load方法内先创建一个新的ServiceLoader，并实例化该类中的成员变量，包括：</p>
<ul>
<li>loader(ClassLoader类型，类加载器)</li>
<li>acc(AccessControlContext类型，访问控制器)</li>
<li>providers(LinkedHashmap类型，用于缓存加载成功的类)</li>
<li>lookupIterator(实现迭代器功能)</li>
</ul>
<p><strong>应用程序通过迭代器接口获取对象实例</strong></p>
<p>​        ServiceLoader先判断成员变量providers对象中(LinkedHashMap类型)是否有缓存实例对象，如果有缓存，直接返回。如果没缓存，执行类的装载：</p>
<ul>
<li>读取META-INF/services/下的配置文件，获得所有能被实例化的类的名称</li>
<li>通过反射方法Class.forName()加载类对象，并用instance()方法将类实例化</li>
<li>把实例化后的类缓存到providers对象中(LinkedHashMap类型)</li>
<li>返回实例对象</li>
</ul>
<hr>
<h2 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h2><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><p>​        时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置决定时间，这就使得不同经度的地方的时间有所不同。1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。</p>
<p>​        世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日出、日落时间必定有所偏差。这些偏差就是所谓的时差。</p>
<h3 id="冬令时和夏令时"><a href="#冬令时和夏令时" class="headerlink" title="冬令时和夏令时"></a>冬令时和夏令时</h3><p>​        夏令时、冬令时的出现，是为了充分利用夏天的日照，所以时钟要往前拨快一小时，冬天再把表往回拨一小时。其中夏令时从3月第二个周日持续到11月第一个周日。</p>
<p>​        冬令时：北京和洛杉矶时差：16；北京和纽约时差：13<br>​        夏令时：北京和洛杉矶时差：15；北京和纽约时差：12</p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>​        时间戳(timestamp)，一个能表示一份数据在某个特定时间之前已经存在的、完整的、可验证的数据，通常是一个字符序列，唯一地标识某一刻时间。</p>
<p>​        时间戳是指格林威治时间1970年01月01日00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。通俗的讲，时间戳是一份能够表示一份数据在一个特定时间点已经存在的完整的可验证的数据。</p>
<h3 id="格林威治时间"><a href="#格林威治时间" class="headerlink" title="格林威治时间"></a>格林威治时间</h3><p>​        格林尼治平时(Greenwich Mean Time, GMT)是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时，因为本初子午线被定义为通过那里的经线。</p>
<h3 id="SimpleDateFormat的线程安全性问题"><a href="#SimpleDateFormat的线程安全性问题" class="headerlink" title="SimpleDateFormat的线程安全性问题"></a>SimpleDateFormat的线程安全性问题</h3><p>​        由于SimpleDateFormat比较常用，而且在一般情况下，一个应用中的时间显示模式都是一样的，所以很多人愿意使用如下方式定义SimpleDateFormat：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        simpleDateFormat.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(simpleDateFormat.format(Calender.getInstance().getTime()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这种定义方式，存在很大的安全隐患。</p>
<p><strong>问题重现</strong></p>
<p>​        我们来看一段代码，以下代码使用线程池来执行时间输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个全局的SimpleDateFormat</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="comment">//使用ThreadFactoryBuilder定义一个线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool =  <span class="keyword">new</span> ThreadPoolExecytor(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">    <span class="comment">//定义一个CountDownLatch，保证所有子线程执行完毕之后主线程再执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">100</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义一个线程安全的HashSet</span></span><br><span class="line">        Set&lt;String&gt; dates = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//获取当前时间</span></span><br><span class="line">            Calendar calendar = Calendar.getInstance();</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            pool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//时间增加</span></span><br><span class="line">                calendar.add(Calendar.DATE, finalI);</span><br><span class="line">                <span class="comment">//通过simpleDateFormat把时间转化为字符串</span></span><br><span class="line">                String dateString = simpleDateFormat.format(calendar.getTime());</span><br><span class="line">                <span class="comment">//把字符串放入Set中</span></span><br><span class="line">                dates.add(dateString);</span><br><span class="line">                <span class="comment">//countDown</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻塞，直到countDown数量为0</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(dates.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        以上代码，其实比较简单，很容易理解。就是循环一百次，每次循环的时候都在当前时间基础上增加一个天数(这个天数随着循环次数而变化)，然后把所有日期放入一个线程安全的、带有去重功能的Set中，然后输出Set中元素个数。</p>
<p>​        正常情况下，以上代码输出结果应该是100。但是实际执行结果是一个小于100的数字。原因就是因为SimpleDateFormat作为一个非线程安全的类，被当做了共享变量在多个线程中进行使用，这就出现了线程安全问题。</p>
<p>​        在Java开发手册的第一章第六节——并发处理中关于这一点也有明确说明：【强制】SimpleDateFormat是线程不安全的类，一般不要定义static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。</p>
<p>​        那么，接下我们就来看到底为什么，以及如何解决。</p>
<p><strong>线程不安全原因</strong></p>
<p>​        通过以上代码，我们发现了在并发场景中使用SipleDateFormat会有线程安全问题。</p>
<p>​        在SimpleDateFormat类中format方法的实现其实就能发现问题。SimpleDateFormat中的format方法在执行过程中，会使用一个calendar来保存时间。这其实就是问题的关键。</p>
<p>​        由于我们在声明SimpleDateFormat的时候，使用的是static定义的。那么这个SimpleDateFormat就是一个共享变量，随之，SimpleDateFormat中的calendar也就可以被多个线程访问到。</p>
<p>​        假设线程1刚刚执行完calendar.setTime把时间设置成2018-11-11，还没等执行完，线程2又执行了calendar.setTime把时间改为2018-11-12。这个时候线程1继续往下执行，拿到的calendar.getTime得到的时间就是线程2改过后的。</p>
<p>​        除了format方法以外，SimpleDateFormat的parse方法也有同样的问题。所以，不要把SimpleDateFormat作为一个共享变量使用。</p>
<p><strong>如何解决</strong></p>
<p>​        解决方法有很多，这里介绍三个比较常用的方法。</p>
<p>使用局部变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">        SimpleDateFromat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        calender.add(Calendar.DATE, finalI);</span><br><span class="line">        String dateString = simpleDateFormat.format(calender.getTime());</span><br><span class="line">        dates.add(dateString);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        SimpleDateFormat变成了局部变量，就不会被多个线程同时访问到了，就避免了线程安全问题。</p>
<p>加同步锁</p>
<p>​        除了改成局部变量之外，还有一种方法大家可能比较熟悉，就是对于共享变量进行加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(simpleDateFormat)&#123;</span><br><span class="line">            SimpleDateFromat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">            calender.add(Calendar.DATE, finalI);</span><br><span class="line">            String dateString = simpleDateFormat.format(calender.getTime());</span><br><span class="line">            dates.add(dateString);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        通过加锁，使多个线程排队顺序执行。避免了并发导致的线程安全问题。其实以上代码还有可以改进的地方，就是可以把颗粒度再设置的小一点，可以只对simpleDateFormat.format这一行加锁，这样效率更高一些。</p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC基本使用</title>
    <url>/2021/05/13/SpringMVC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h2><p>​        Spring为展现层提供的基于MVC设计理念的优秀的Web框架，是目前最主流的MVC框架之一。一种轻量级的、基于MVC的Web层应用框架。它能让我们对请求数据的出来，响应数据的处理，页面的跳转等等常见的Web操作变得更加简单方便。</p>
 <span id="more"></span> 

<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>将项目变成Web项目，将生成的目录名字改为webapp，检查Web目录的位置是否正确</p>
<p><strong>①导入相关依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--端口号 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>81<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--项目路径--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--解决get请求中文乱码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jsp依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--springmvc的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--帮助进行json转换--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>②配置web.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            为DispatcherServlet提供初始化参数的</span></span><br><span class="line"><span class="comment">            设置springmvc配置文件的路径</span></span><br><span class="line"><span class="comment">                name是固定的，必须是contextConfigLocation</span></span><br><span class="line"><span class="comment">                value指的是SpringMVC配置文件的位置</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            指定项目启动就初始化DispatcherServlet</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">             /           表示当前servlet映射除jsp之外的所有请求（包含静态资源）</span></span><br><span class="line"><span class="comment">             *.do        表示.do结尾的请求路径才能被SpringMVC处理(老项目会出现)</span></span><br><span class="line"><span class="comment">             /*          表示当前servlet映射所有请求（包含静态资源,jsp），不应该使用其配置DispatcherServlet</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--乱码处理过滤器，由SpringMVC提供--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 处理post请求乱码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- name固定不变，value值根据需要设置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所有请求都设置utf-8的编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>③配置springMVC</strong></p>
<p>在resources目录下创建mvc的配置文件spring-mvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            SpringMVC只扫描controller包即可</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.xiaohupao.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 解决静态资源访问问题，如果不加mvc:annotation-driven会导致无法访问handler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--解决响应乱码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>④创建测试用的jsp页面</strong></p>
<p>在webapp下创建success.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    成功</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>⑤编写Controller</strong></p>
<p>定义一个类，在类上加上@Controller注解，声明其是一个Controller。主要要创建在之前注解扫描所配置的包下。</p>
<p>然后定义一个方法，在方法上加上@RequestMapping来指定哪些请求会被该方法所处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置请求映射规则-RequestMapping"><a href="#设置请求映射规则-RequestMapping" class="headerlink" title="设置请求映射规则@RequestMapping"></a>设置请求映射规则@RequestMapping</h2><p>该注解可以加到方法上或者是类上。我们可以用其来设定所能匹配请求的要求。只有符合了设置的要求，请求才能被加了该注解的方法或类处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;path&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定请求路径"><a href="#指定请求路径" class="headerlink" title="指定请求路径"></a>指定请求路径</h3><p>path或者value属性都可以用来指定请求路径。</p>
<p>例如：我们期望让请求的资源路径为/test/testPath的请求能够被testPath方法处理则可以写如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testpath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定请求方式"><a href="#指定请求方式" class="headerlink" title="指定请求方式"></a>指定请求方式</h3><p>method属性可以用来指定可处理的请求方式。</p>
<p>例如：我们期望让请求的资源路径为/test/testMethod的POST请求能够被testMethod方法处理，则可以写如下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/test/testMethod&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：我们也可以运用如下注解来进行替换</p>
<ul>
<li>@PostMapping 等价于 @RequestMapping(method = RequestMethod.POST)</li>
<li>@GetMapping 等价于 @RequestMapping(method = RequestMethod.GET)</li>
<li>@PutMapping 等价于 @RequestMapping(method = RequestMethod.PUT)</li>
<li>@DeleteMapping 等价于 @RequestMapping(method = RequestMethod.DELETE)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/testMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定请求参数"><a href="#指定请求参数" class="headerlink" title="指定请求参数"></a>指定请求参数</h3><p>我们可以使用params属性来对请求参数进行一些限制。可以要求必须具有某些参数，或是某些参数必是某个值，或者是某些参数必须不是某个值。</p>
<p><strong>要求必须有某参数</strong></p>
<p>例如：我们期望让请求参数的资源路径为/test/testParams的GET请求，并且请求参数具有code参数的请求能够被testParams方法处理。则可以写如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/testMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//若参数多个，则用数组的形式</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testParams&quot;, params = &quot;code&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testParams处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要求必须没有某参数</strong></p>
<p>使用!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/testMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testParams&quot;, params = &quot;!code&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testParams处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要求参数必须是某个值或者必须不是某个值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/testMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testParams&quot;, params = &quot;code=xiaohupao&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testParams处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/testMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testParams&quot;, params = &quot;code!=xiaohupao&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testParams处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="请求头的限制"><a href="#请求头的限制" class="headerlink" title="请求头的限制"></a>请求头的限制</h3><p>我们可以使用headers属性来对请求头进行一些限制</p>
<p>例如：我们期望让请求的资源路径为/test/testHeaders的GET请求，并且请求头中具有deviceType的请求能够被testHeaders方法处理。则可以写如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/testMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testParams&quot;, params = &quot;code&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testParams处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testHeaders&quot;, headers = &quot;deviceType&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testHeaders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testHeaders处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是要求不能有deviceType这个请求头可以把它改成如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/testMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testParams&quot;, params = &quot;code&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testParams处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testHeaders&quot;, headers = &quot;!deviceType&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testHeaders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testHeaders处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要求有deviceType这个请求头，并且其值必须是某个值可以改成如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/testMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testParams&quot;, params = &quot;code&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testParams处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testHeaders&quot;, headers = &quot;deviceType=ios&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testHeaders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testHeaders处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要求有deviceType这个请求头，并且其值必须不是某个值可以改成如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/testMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testParams&quot;, params = &quot;code&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testParams处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testHeaders&quot;, headers = &quot;deviceType!=ios&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testHeaders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testHeaders处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定请求头Content-Type"><a href="#指定请求头Content-Type" class="headerlink" title="指定请求头Content-Type"></a>指定请求头Content-Type</h3><p>我们可以使用consumes属性来对Content-Type这个请求头进行一些限制。</p>
<p>例如：我们期望让请求的资源路径为/test/testConsumes的POST请求，并且请求头中的Content-Type头必须为multipart/from-data的请求能够被testConsumes方法处理。则可以写如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/testMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testParams&quot;, params = &quot;code&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testParams处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testHeaders&quot;, headers = &quot;deviceType&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testHeaders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testHeaders处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/test/testConsumes&quot;, consumes = &quot;multipart/from-data&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testConsumes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testConsumes&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：如果我们要求请求头Content-Type的值必须不能为某个multipart/from-data则可以改成如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/13 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello.html&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/testPath&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testPath&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/testMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testParams&quot;, params = &quot;code&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testParams</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testParams处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test/testHeaders&quot;, headers = &quot;deviceType&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testHeaders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testHeaders处理了请求&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/test/testConsumes&quot;, consumes = &quot;!multipart/from-data&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testConsumes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testConsumes&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RestFul风格"><a href="#RestFul风格" class="headerlink" title="RestFul风格"></a>RestFul风格</h2><p>RestFul是一种网络应用程序的设计风格和开发方式。现在很多互联网的网络接口定义都会符合风格。</p>
<p>主要规则如下：</p>
<ul>
<li>每一个URL代表一种资源</li>
<li>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源、POST用来新建资源、PUT用来跟新资源、DELETE用来删除资源；</li>
<li>简单参数例如id等写到url路径上 例如：/user/1 HTTP GET：获取id=1的user信息 /user/1 HTTP DELETE ：删除id=1的user信息</li>
<li>复杂的参数转换成json或者xml写到请求中。</li>
</ul>
<h2 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h2><h3 id="获取路径参数"><a href="#获取路径参数" class="headerlink" title="获取路径参数"></a>获取路径参数</h3><p>RestFul风格的接口一些参数是在请求路径上的。类似：/user/1 这里的1就是id。如果我们想要获取这种格式的数据可以使用@PathVariable来实现。</p>
<p>例如：要求定义一个RestFul风格的接口，该接口可以用来根据id查询用户。请求路径要求为/user，请求方式要求为GET。而请求参数id要写在请求路径上，例如/user/1 这里的1就是id。我们可以定义如下方法，通过如下方式来获取参数路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/14 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserById&quot;</span>);</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET http://localhost:81/user/1</span><br><span class="line"></span><br><span class="line">findUserById</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>例如：如果这个接口，根据id和username查询用户。请求路径要求为/user，请求方式为GET。请求参数为id和name要写在请求路径上，例如：/user/1/xiaohupao 这里1就是id，xiaohupao是name。我们可以定义如下的方法，通过如下方式来获取路径参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/14 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserById&quot;</span>);</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserByIdAndName</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, <span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserByIdAndName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot;, name: &quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET http://localhost:81/user/1/xiaohupao</span><br><span class="line"></span><br><span class="line">findUserByIdAndName</span><br><span class="line">id: 1, name: xiaohupao</span><br></pre></td></tr></table></figure>

<h3 id="获取请求体中的Json参数"><a href="#获取请求体中的Json参数" class="headerlink" title="获取请求体中的Json参数"></a>获取请求体中的Json参数</h3><p>RestFul风格的接口一些比较复杂的参数会转换成json通过请求体传递过来。这时候我们可以用@RequestBody注解获取请求体中的数据。</p>
<p><strong>配置</strong></p>
<p>SpringMVC可以帮我们把json数据换成我们需要的类型，但是需要一些基本配置。SpringMVC默认会使用jackson来进行json解析。所以我们需要导入jackson的依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--帮助进行json转换--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后还要配置注解驱动</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--解决响应乱码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<p><strong>获取参数封装成实体对象</strong></p>
<p>例如：我们要求定义一个RestFul风格的接口，该接口可以用来新建用户，请求路径要求为/user，请求方式要求为POST。用户数据会转换成json通过请求体传递：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xiaohupao.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.xiaohupao.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/14 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserById&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserByIdAndName</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, <span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserByIdAndName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot;, name: &quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insertUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insertUser&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xiaohupao.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/14 16:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Body raw JSON</span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;:1025,</span><br><span class="line">    &quot;name&quot;:&quot;576&quot;,</span><br><span class="line">    &quot;age&quot;:23</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insertUser</span><br><span class="line">User(id=1025, name=576, age=23)</span><br></pre></td></tr></table></figure>

<p><strong>获取参数封装成Map集合</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xiaohupao.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.xiaohupao.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/14 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserById&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserByIdAndName</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, <span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserByIdAndName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot;, name: &quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insertUser</span><span class="params">(<span class="meta">@RequestBody</span> Map map)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insertUser&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Body raw JSON</span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;:1025,</span><br><span class="line">    &quot;name&quot;:&quot;576&quot;,</span><br><span class="line">    &quot;age&quot;:23</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insertUser</span><br><span class="line">User(id=1025, name=576, age=23)</span><br></pre></td></tr></table></figure>

<p><strong>获取的JSON数据转换成List</strong></p>
<p>例如：如果请求体传递过来的数据是一个User集合转换成的JSON，则可以按照如下写法：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;id&quot;:1025, &quot;name&quot;:&quot;576, &quot;age&quot;:23&#125;,&#123;&quot;id&quot;:221, &quot;name&quot;:&quot;95&quot;, &quot;age&quot;:25&#125;,&#123;&quot;id&quot;:222, &quot;name&quot;:&quot;xiaohupao&quot;, &quot;age&quot;:25&#125;]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xiaohupao.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.xiaohupao.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/14 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserById&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserByIdAndName</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, <span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserByIdAndName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot;, name: &quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insertUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insertUser&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/users&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insertUsers</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; users)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insertUsers&quot;</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">insertUsers</span><br><span class="line">[User(id=1025, name=576, age=23), User(id=221, name=95, age=25), User(id=222, name=xiaohupao, age=25)]</span><br></pre></td></tr></table></figure>

<p><strong>获取JSON数据的注意事项</strong></p>
<p>如果需要@RequestBody来获取请求体中json并且进行转换，要求请求头Content-Type的值要为application/json</p>
<h3 id="获取QueryString格式参数"><a href="#获取QueryString格式参数" class="headerlink" title="获取QueryString格式参数"></a>获取QueryString格式参数</h3><p>如果接受参数是使用QueryString的格式的话，我们也可以使用SpringMVC快速获取参数。我们可以使用@RequestParam来获取QueryString格式的参数。</p>
<p><strong>使用</strong></p>
<p><strong>参数单独的获取</strong></p>
<p>在方法中定义方法参数，方法参数名要和请求参数名一致，这种情况下我们可以省略@RequestParam注解。如果方法参数名和请求参数名不一致，我们可以加上@RequestParam注解</p>
<p>例如：要求定义个接口，该接口的请求路径为/testRequestParam，请求方式无要求。参数为id和name和likes。使用QueryString格式传递。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xiaohupao.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.xiaohupao.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/14 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserById&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserByIdAndName</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, <span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserByIdAndName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot;, name: &quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insertUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insertUser&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/users&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insertUsers</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; users)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insertUsers&quot;</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/testRequestPara&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Integer id, <span class="meta">@RequestParam(&quot;name&quot;)</span> String name, <span class="meta">@RequestParam(&quot;likes&quot;)</span> String[] likes)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testRequestParam&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot;, name: &quot;</span> + name + <span class="string">&quot;,likes: &quot;</span> + Arrays.toString(likes));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET http://localhost:81//testRequestPara?id=221<span class="built_in">&amp;</span>name=xiaohupao<span class="built_in">&amp;</span>likes=Game<span class="built_in">&amp;</span>likes=Game</span><br><span class="line"></span><br><span class="line">testRequestParam</span><br><span class="line">id: 221, name: xiaohupao,likes: [Game, Game]</span><br></pre></td></tr></table></figure>

<p><strong>多个参数封装成对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xiaohupao.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.xiaohupao.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/14 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserById&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findUserByIdAndName</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, <span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findUserByIdAndName&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot;, name: &quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insertUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insertUser&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/users&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insertUsers</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; users)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insertUsers&quot;</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/testRequestPara&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Integer id, <span class="meta">@RequestParam(&quot;name&quot;)</span> String name, <span class="meta">@RequestParam(&quot;likes&quot;)</span> String[] likes)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testRequestParam&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot;, name: &quot;</span> + name + <span class="string">&quot;,likes: &quot;</span> + Arrays.toString(likes));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/testRequestParas&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestParams</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testRequestParams&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET http://localhost:81//testRequestParas?id=221<span class="built_in">&amp;</span>age=25<span class="built_in">&amp;</span>name=xiaohupao</span><br><span class="line"></span><br><span class="line">testRequestParams</span><br><span class="line">User(id=221, name=xiaohupao, age=25)</span><br></pre></td></tr></table></figure>

<h3 id="相关注解其他属性"><a href="#相关注解其他属性" class="headerlink" title="相关注解其他属性"></a>相关注解其他属性</h3><h4 id="required"><a href="#required" class="headerlink" title="required"></a>required</h4><p>代表是否必须，默认值为true(也就是必须要有对应的参数，如果没有就会报错)。如果对应的参数可传可不传，则可以设置为false。</p>
<h4 id="defaultValue"><a href="#defaultValue" class="headerlink" title="defaultValue"></a>defaultValue</h4><p>如果对应的参数没有，则可以使用defaultValue属性设置默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/testRequestPara&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(<span class="meta">@RequestParam(value = &quot;id&quot;, required = false, defaultValue = &quot;576&quot;)</span> Integer id, <span class="meta">@RequestParam(&quot;name&quot;)</span> String name, <span class="meta">@RequestParam(&quot;likes&quot;)</span> String[] likes)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testRequestParam&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;id: &quot;</span> + id + <span class="string">&quot;, name: &quot;</span> + name + <span class="string">&quot;,likes: &quot;</span> + Arrays.toString(likes));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET http://localhost:81//testRequestPara?age=25<span class="built_in">&amp;</span>name=xiaohupao<span class="built_in">&amp;</span>likes=Game<span class="built_in">&amp;</span>likes=Game</span><br><span class="line"></span><br><span class="line">testRequestParam</span><br><span class="line">id: 576, name: xiaohupao,likes: [Game, Game]</span><br></pre></td></tr></table></figure>

<h2 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h2><p>虽然获取参数看起来非常轻松，但是在这个过程中是有可能出现一些问题的。例如：请求参数为success=1我们期望把这个参数获取出来赋值给一个boolean类型的变量。这里就涉及到String-&gt;Boolean类型的转换了。实际上SPringMVC中内置了很多类型转换器来进行类型转换。也有专门进行String-&gt;Boolean类型转换的转换器StringToBooleanConverter。</p>
<p>如果是符合SpringMVC内置转换器的转换规则就可以很轻松的实现转换。但是如果不符合转换器的规则呢？</p>
<p>例如，请求参数为birthday=2004-12-12我们期望把这个请求参数取出来赋值给一个Date类型的变量，就不符合内置的规则了。内置的可以把2004/12/12这种格式进行转换。这种情况下我们就可以选择自定义类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.core.convert.support;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToBooleanConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; trueValues = <span class="keyword">new</span> HashSet(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; falseValues = <span class="keyword">new</span> HashSet(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    StringToBooleanConverter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        String value = source.trim();</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value = value.toLowerCase();</span><br><span class="line">            <span class="keyword">if</span> (trueValues.contains(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (falseValues.contains(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid boolean value &#x27;&quot;</span> + source + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        trueValues.add(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        trueValues.add(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">        trueValues.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        trueValues.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        falseValues.add(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        falseValues.add(<span class="string">&quot;off&quot;</span>);</span><br><span class="line">        falseValues.add(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">        falseValues.add(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/18 16:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/testConverter&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testConverter</span><span class="params">(<span class="meta">@RequestParam(value = &quot;success&quot;)</span> Boolean success)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testConverter&quot;</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET http://localhost:81/testConverter?success=1</span><br><span class="line"></span><br><span class="line">testConverter</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/18 16:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/testConverter&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testConverter</span><span class="params">(<span class="meta">@RequestParam(value = &quot;success&quot;)</span> Boolean success)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testConverter&quot;</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/testDateConverter&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testDateConverter</span><span class="params">(<span class="meta">@RequestParam(value = &quot;birthday&quot;)</span> Date birthday)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testDateConverter&quot;</span>);</span><br><span class="line">        System.out.println(birthday);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">GET http://localhost:81/testDateConverter?birthday=1998/10/25</span><br><span class="line"></span><br><span class="line">testDateConverter</span><br><span class="line">Sun Oct 25 00:00:00 CST 1998</span><br></pre></td></tr></table></figure>

<h3 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h3><p><strong>①创建类实现Converter接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.xiaohupao.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/18 17:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String-&gt;Date 1998-10-25</span></span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = simpleDateFormat.parse(source);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>②实现Converter方法</strong></p>
<p>见上</p>
<p><strong>③配置让SpringMVC使用自己定义转换器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--解决响应乱码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;myConversionService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myConversionService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.xiaohupao.converter.StringToDateConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="日期转换简便解决方案"><a href="#日期转换简便解决方案" class="headerlink" title="日期转换简便解决方案"></a>日期转换简便解决方案</h3><p>在参数前加上@DateTimeFormat注解，设置其中属性patten。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: xiaohupao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/5/18 16:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/testConverter&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testConverter</span><span class="params">(<span class="meta">@RequestParam(value = &quot;success&quot;)</span> Boolean success)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testConverter&quot;</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/testDateConverter&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testDateConverter</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> <span class="meta">@RequestParam(value = &quot;birthday&quot;)</span> Date birthday)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testDateConverter&quot;</span>);</span><br><span class="line">        System.out.println(birthday);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《On Java 8》-- 第十一章 内部类</title>
    <url>/2021/05/14/%E9%98%85%E8%AF%BB%E3%80%8AOn-Java-8%E3%80%8B-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一个定义在另一个类中的类，叫作内部类。</p>
<p>​        内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可见性。然而必须要了解，内部类与组合是完全不同的概念，这一点很重要。在最初，内部类看起来就像是一种代码隐藏机制：将类置于其他类的内部。但是，你将会了解到，内部类远不止如此，它了解外部类，并能与之通信，而且你用内部类写出的代码更加优雅而清晰，尽管并不总是这样(而且Java8的Lambda表达式和方法引用减少了编写内部类的需求)。</p>
<p>​        最初，内部类可能看起来有些奇怪，而且要花些时间才能在设计中轻松地使用它们。对内部类的需求并非总是很明显的，但是在描述完内部类的基本语法与语义之后，就能明白使用内部类的好处了。</p>
 <span id="more"></span> 

<h2 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h2><p>​        创建内部类的方式就如同你想的一样——把类的定义置于外部类的里面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel1.java</span></span><br><span class="line"><span class="comment">// Creating inner classes</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel1</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">      </span><br><span class="line">        Destination(String whereTo) &#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Using inner classes looks just like</span></span><br><span class="line">    <span class="comment">// using any other class, within Parcel1:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</span><br><span class="line">        Contents c = <span class="keyword">new</span> Contents();</span><br><span class="line">        Destination d = <span class="keyword">new</span> Destination(dest);</span><br><span class="line">        System.out.println(d.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel1 p = <span class="keyword">new</span> Parcel1();</span><br><span class="line">        p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Tasmania</span></span><br></pre></td></tr></table></figure>

<p>​        当我们在ship()方法里面使用内部类的时候，与使用普通类没什么不同。在这里，明显的区别只是内部类的名字是嵌套在Parcel1里面的。</p>
<p>​        更典型的情况是，外部类将有一个方法，该方法返回了一个指向内部类的引用，就像to()和contents()方法中看到的那样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel2.java</span></span><br><span class="line"><span class="comment">// Returning a reference to an inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel2</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">      </span><br><span class="line">        Destination(String whereTo) &#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">to</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination(s);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ship</span><span class="params">(String dest)</span> </span>&#123;</span><br><span class="line">        Contents c = contents();</span><br><span class="line">        Destination d = to(dest);</span><br><span class="line">        System.out.println(d.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel2 p = <span class="keyword">new</span> Parcel2();</span><br><span class="line">        p.ship(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">        Parcel2 q = <span class="keyword">new</span> Parcel2();</span><br><span class="line">        <span class="comment">// Defining references to inner classes:</span></span><br><span class="line">        Parcel2.Contents c = q.contents();</span><br><span class="line">        Parcel2.Destination d = q.to(<span class="string">&quot;Borneo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Tasmania</span></span><br></pre></td></tr></table></figure>

<p>​        如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像在main()方法中那样，具体地指明这个对象的类型：OuterClassName.InnerClassName。在外部类的静态方法中也可以直接指明类型InnerClassName，在其他类中需要指明OuterClassName.InnerClassName。</p>
<h2 id="链接外部类"><a href="#链接外部类" class="headerlink" title="链接外部类"></a>链接外部类</h2><p>​        到目前为止，内部类似乎还只是一种名字隐藏和组织代码的模式。这些是很有用的，但还不是最引人注目的，它还有其他的用途。当生成一个内部类的对象时，此对象与制造它的外部对象(enclosing object)之间就有了一种联系，所以它能访问其他外部对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有外部类的所有元素的访问权。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Sequence.java</span></span><br><span class="line"><span class="comment">// Holds a sequence of Objects</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(next &lt; items.length)</span><br><span class="line">            items[next++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i == items.length; &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> items[i]; &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>(i &lt; items.length) i++; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            sequence.add(Integer.toString(i));</span><br><span class="line">        Selector selector = sequence.selector();</span><br><span class="line">        <span class="keyword">while</span>(!selector.end()) &#123;</span><br><span class="line">            System.out.print(selector.current() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            selector.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>

<p>​        Sequence类只是一个固定大小的Object的数组，以类的形式包装了起来。可以调用add()在序列末尾增加新的Object(只要还有空间)，要获取Sequence中的每一个对象，可以使用Selector接口。这是“迭代器”设计模式的一个例子。Selector允许你检查序列是否到末尾了(end())，访问当前对象(current())，以及移到序列中的下一个对象(next())。因为Selector是一个接口，所以别的类可以按它们自己的方式来实现这个接口，并且其他方法能以此接口为参数，来生成更加通用的代码。</p>
<p>​        这里，SequenceSelector是提供Selector功能的private类。可以看到，在main()中创建一个Sequence，并向其中添加了一些String对象。然后通过调用selector()获取一个Selector，并用它在Sequence中移动和选择每一个元素。最初看到SequenceSelector，可能觉得它只是一个内部类罢了。但请仔细观察它，注意方法end()，current()和next()都用到了items，这是一个引用，它并不是SequenceSelector的一部分，而是外部类的一个private字段。然而内部类可以访问其他外部类的方法和字段，就像自己拥有它们似的，这带来了很大的方便，就如前面的例子所示。</p>
<p>​        所以内部类自动拥有对其外部类所有成员的访问权。这是如何做到的呢？当某个外部类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用。然后，在你访问此外部类的成员时，就用那个引用来选择外部类的成员。幸运的是，编译器会帮你处理所有的细节，但你现在可以看到：内部类的对象只能在与其外部类的对象相关联的情况下才能被创建(就像你应该看到的，内部类是非static类时)。构建内部类对象时，需要一个指向其外部类对象的引用，如果编译器访问不到这个引用就会报错。不过绝大多数时候这都无需程序员操心。</p>
<h2 id="使用-this和-new"><a href="#使用-this和-new" class="headerlink" title="使用.this和.new"></a>使用.this和.new</h2><p>​        如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就知晓并受到检查，因此没有任何运行时开销。下面的示例展示了如何使用.this：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/DotThis.java</span></span><br><span class="line"><span class="comment">// Accessing the outer-class object</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotThis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>); &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> DotThis <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DotThis.<span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// A plain &quot;this&quot; would be Inner&#x27;s &quot;this&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Inner(); &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotThis dt = <span class="keyword">new</span> DotThis();</span><br><span class="line">        DotThis.Inner dti = dt.inner();</span><br><span class="line">        dti.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DotThis.f()</span></span><br></pre></td></tr></table></figure>

<p>​        有时你可能想要告知某些其他对象，去创建某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这是需要使用.new语法，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/DotNew.java</span></span><br><span class="line"><span class="comment">// Creating an inner class directly using .new syntax</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotNew dn = <span class="keyword">new</span> DotNew();</span><br><span class="line">        DotNew.Inner dni = dn.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        想要直接创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字DotNew，而是必须使用外部类的对象来创建该内部类对象，就像在上面的程序中所看到的那样。这也解决了内部类名字作用域的问题，因此你不必声明(实际上你不能声明)dn.newDotNew.Inner。</p>
<p>​        下面你可以看到将.new应用于Parcel的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel3.java</span></span><br><span class="line"><span class="comment">// Using .new to create instances of inner classes</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel3</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        Destination(String whereTo) &#123; label = whereTo; &#125;</span><br><span class="line">        <span class="function">String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel3 p = <span class="keyword">new</span> Parcel3();</span><br><span class="line">        <span class="comment">// Must use instance of outer class</span></span><br><span class="line">        <span class="comment">// to create an instance of the inner class:</span></span><br><span class="line">        Parcel3.Contents c = p.<span class="function">new <span class="title">Contents</span><span class="params">()</span></span>;</span><br><span class="line">        Parcel3.Destination d =</span><br><span class="line">                p.<span class="function">new <span class="title">Destination</span><span class="params">(<span class="string">&quot;Tasmania&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到建它的外部类对象上。但是，如果你创建的是嵌套类(静态内部类)，那么它就不需要对外部对象的引用。</p>
<h2 id="内部类与向上转型"><a href="#内部类与向上转型" class="headerlink" title="内部类与向上转型"></a>内部类与向上转型</h2><p>​        当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。(从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。)这是因为此内部类-某个接口的实现-能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能很方便地隐藏实现细节。</p>
<p>​        我们可以创建前一个示例的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Destination.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Contents.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        现在Contents和Destination表示客户端程序员可用的接口。记住，接口的所有成员自动被设置为public。</p>
<p>​        当取得了一个指向基类或接口的引用，甚至可能无法找出它确切的类型，看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/TestParcel.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcel4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PContents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParcel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel4 p = <span class="keyword">new</span> Parcel4();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">        <span class="comment">// Illegal -- can&#x27;t access private class:</span></span><br><span class="line">        <span class="comment">//- Parcel4.PContents pc = p.new PContents();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在Parcel4中，内部类PContents是private，所以除了Parcel4，没有人能访问它。普通(非内部)类的访问权限不能被设为private或者protected；它们只能设置为public或package访问权限。</p>
<p>​        PDestination是protected，所以只有Parcel4及其子类、还有与Parcel4同一个包中的类能访问PDestination，其它类都不能访问PDestination，这意味着，如果客户端程序员想了解或访问这些成员，那是要受到限制的。实际上，甚至不能向下转型成private内部类，因为不能访问其名字，就像在TestParcel类中看到的那样。</p>
<p>​        private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，完全隐藏了实现的细节。此外，从客户端程序员的角度来看，由于不能访问任何新增的、原本不属于公共接口的方法，所以扩展接口是没有价值的。这也给Java编译器提供了生成高效代码的机会。</p>
<h2 id="内部类方法和作用域"><a href="#内部类方法和作用域" class="headerlink" title="内部类方法和作用域"></a>内部类方法和作用域</h2><p>​        到目前为止，读者所看到的只是内部类的典型用途。通常，如果所读、写的代码包含了内部类，那么它们都是“平凡的”内部类。简单并且容易理解。然而，内部类的语法重写了大量其他的更加难以理解的技术。例如，可以在一个方法里面或者在任意的作用域内定义内部类。</p>
<p>​        这么做有两个理由：</p>
<ul>
<li>1.如前所示，你实现了某些类型的接口，于是可以创建并返回对其的引用。</li>
<li>2.你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。</li>
</ul>
<p>​        在后面的例子中，先前的代码将被修改，以用来实现：</p>
<ul>
<li>一个定义在方法中的类。</li>
<li>一个定义在作用域内的类，此作用域在方法的内部。</li>
<li>一个实现了接口的匿名类。</li>
<li>一个匿名类，它扩展了没有默认构造器的类。</li>
<li>一个匿名类，它执行字段初始化。</li>
<li>一个匿名类，它通过实例初始化实现构造(匿名内部类不可能有构造器)。</li>
</ul>
<p>​        第一个例子展示了在方法的作用域(而不是在其他类的作用域内)创建一个完整的类。这被称作局部内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel5.java</span></span><br><span class="line"><span class="comment">// Nesting a class within a method</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> String label;</span><br><span class="line">          </span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel5 p = <span class="keyword">new</span> Parcel5();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        PDestination类是destination()方法的一部分，而不是Parcel5的一部分。所以，在destination()之外不能访问PDestination，注意出现在return语句中的向上转型-返回的是Destination的引用，它是PDestination的基类。当然，在destination()中定义了内部类PDestination，并不意味着一旦destination()方法执行完毕，PDestination就不可用了。</p>
<p>​        你可以在同一个子目录下的任意类中对某个内部类使用类标识符PDestination，这并不会有命名冲突。</p>
<p>​        下面的例子展示了如何在任意的作用域内嵌入一个内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel6.java</span></span><br><span class="line"><span class="comment">// Nesting a class within a scope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span> </span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                TrackingSlip(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">&quot;slip&quot;</span>);</span><br><span class="line">            String s = ts.getSlip();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Can&#x27;t use it here! Out of scope:</span></span><br><span class="line">        <span class="comment">//- TrackingSlip ts = new TrackingSlip(&quot;x&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span> </span>&#123; internalTracking(<span class="keyword">true</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel6 p = <span class="keyword">new</span> Parcel6();</span><br><span class="line">        p.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        TrackingSlip类被嵌入在if语句的作用域内，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了。然而，在定义TrackingSlip的作用域之外，它是不可用的，除此之外，它与普通的类一样。</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>​        下面的例子看起来有点奇怪：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel7.java</span></span><br><span class="line"><span class="comment">// Returning an instance of an anonymous inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123; <span class="comment">// Insert class definition</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">          </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">        &#125;; <span class="comment">// Semicolon required</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7 p = <span class="keyword">new</span> Parcel7();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        contents()方法将返回值的生成与表示这个返回值的类的定义结合在一起！另外，这个类是匿名的，它没有名字。更糟的是，看起来似乎是你正要创建一个Contents对象。但是然后(在到达语句结束的分号之前)你却说：“等一等，我想在这里插入一个类的定义。”</p>
<p>​        这种奇怪的语法指的是：“创建一个继承自Contents的匿名类的对象。”通过new表达式返回的引用被自动向上转型对Contents的引用。上述匿名内部类的语法是下述形式的简化形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel7b.java</span></span><br><span class="line"><span class="comment">// Expanded version of Parcel7.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel7b</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyContents();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel7b p = <span class="keyword">new</span> Parcel7b();</span><br><span class="line">        Contents c = p.contents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        在这个匿名内部类中，使用了默认的构造器来生成Contents。下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel8.java</span></span><br><span class="line"><span class="comment">// Calling the base-class constructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Base constructor call:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x) &#123; <span class="comment">// [1]</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.value() * <span class="number">47</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">// [2]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel8 p = <span class="keyword">new</span> Parcel8();</span><br><span class="line">        Wrapping w = p.wrapping(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        [1]将合适的参数传递给基类的构造器。[2]在匿名内部类末尾的分号，并不是用来标记此内部类结束的。实际上，它标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。因此，这与别的地方使用分号是一致的。</p>
<p>​        尽管Wrapping只是一个具有具体实现的普通类，但它还是被导出类当作公共“接口”来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Wrapping.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; i = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        为了多样性，Wrapping拥有一个要求传递一个参数的构造器。</p>
<p>​        在匿名类中定义字段时，还能够对其执行初始化操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel9.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel9</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Argument must be final or &quot;effectively final&quot;</span></span><br><span class="line">    <span class="comment">// to use within the anonymous inner class:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</span><br><span class="line">            <span class="keyword">private</span> String label = dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel9 p = <span class="keyword">new</span> Parcel9();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果在定义一个匿名内部类时，它要使用一个外部环境(在本匿名内部类之外定义)对象，那么编译器会要求其(该对象)参数引用的是final或者是“effectively final”(也就是说，该参数在初始化后不能被重新赋值，所以可以当作final)的，就像你在destination()的参数中看到的那样。这里省略掉final也没问题，但通常加上final作为提醒比较好。</p>
<p>​        如果只是简单地给一个字段赋值，那么此例中的方法是很好的。但是，如果想做一些类似构造器的行为，该怎么办呢？在匿名类中不可能有命名构造器(因为它根本没名字！)，但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/AnonymousConstructor.java</span></span><br><span class="line"><span class="comment">// Creating a constructor for an anonymous inner class</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    Base(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Base constructor, i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Base <span class="title">getBase</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Base(i) &#123;</span><br><span class="line">            &#123; System.out.println(</span><br><span class="line">                    <span class="string">&quot;Inside instance initializer&quot;</span>); &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;In anonymous f()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Base base = getBase(<span class="number">47</span>);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Base constructor, i = 47</span></span><br><span class="line"><span class="comment">//Inside instance initializer</span></span><br><span class="line"><span class="comment">//In anonymous f()</span></span><br></pre></td></tr></table></figure>

<p>​        在此例中，不要求变量i一定是final的。因为i被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。</p>
<p>​        下例是带实例初始化的“parcel”形式。注意destination()的参数必须是final的，因为它们是在匿名类内部使用的(即使不加final，Java8编译期也会为我们自动加上final，以保证数据的一致性)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel10.java</span></span><br><span class="line"><span class="comment">// Using &quot;instance initialization&quot; to perform</span></span><br><span class="line"><span class="comment">// construction on an anonymous inner class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel10</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Destination</span><br><span class="line">    destination(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="keyword">float</span> price) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            <span class="comment">// Instance initialization for each object:</span></span><br><span class="line">            &#123;</span><br><span class="line">                cost = Math.round(price);</span><br><span class="line">                <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)</span><br><span class="line">                    System.out.println(<span class="string">&quot;Over budget!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> String label = dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel10 p = <span class="keyword">new</span> Parcel10();</span><br><span class="line">        Destination d = p.destination(<span class="string">&quot;Tasmania&quot;</span>, <span class="number">101.395F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Over budget!</span></span><br></pre></td></tr></table></figure>

<p>​        在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分来执行(就是if语句)。所以对于匿名内部类而言，实例初始化的实际效果就是构造器。当然它受到了限制-你不能重载实例初始化方法，所以你仅有一个这样的构造器。</p>
<p>​        匿名内部类与正规的继承相比有些受限，因为匿名内部类要么继承类，要么实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。</p>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>​        如果不需要内部类对象与其外部类之间有联系，那么可以将内部类声明为static，则通常称为嵌套类。想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外部类对象。当然，当内部类是static的时，就不是这样了。嵌套类意味着：</p>
<ul>
<li>1.创建嵌套类的对象时，不需要其外部类的对象。</li>
<li>2.不能从嵌套类的对象中访问非静态的外部类对象。</li>
</ul>
<p>​        嵌套类与普通的内部类还有一个区别。普通内部类的字段和方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Parcel11.java</span></span><br><span class="line"><span class="comment">// Nested classes (static inner classes)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel11</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelDestination</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ParcelDestination</span><span class="params">(String whereTo)</span> </span>&#123;</span><br><span class="line">            label = whereTo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> label; &#125;</span><br><span class="line">        <span class="comment">// Nested classes can contain other static elements:</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherLevel</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title">destination</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelContents();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Contents c = contents();</span><br><span class="line">        Destination d = destination(<span class="string">&quot;Tasmania&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在main()中，没有任何Parcel11的对象是必须的；而是使用选取static成员的普通语法来调用方法-这些方法返回对Contents和Destination的引用。</p>
<p>​        就像你在本章前面看到的那样，在一个普通的(非static)内部类中，通过一个特殊的this引用可以链接到其外部类的对象。嵌套类就没有这个特殊的this引用，这使得它类似于一个static方法。</p>
<h3 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h3><p>​        嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是public和static的。因为类是static的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。你甚至可以在内部类中实现其外部接口，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/ClassInInterface.java</span></span><br><span class="line"><span class="comment">// &#123;java ClassInInterface$Test&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Howdy!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Test().howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Howdy!</span></span><br></pre></td></tr></table></figure>

<p>​        如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所化公用，那么使用接口内部的嵌套类会显得很方便。</p>
<p>​        我们建议过，在每个类中都写一个main()方法，用来测试这个类。这样做有一个缺点：那就是必须带着那些已编译过的额外代码。如果这对你是个麻烦，那就可以使用嵌套类来放置测试代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/TestBed.java</span></span><br><span class="line"><span class="comment">// Putting test code in a nested class</span></span><br><span class="line"><span class="comment">// &#123;java TestBed$Tester&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBed</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;f()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            TestBed t = <span class="keyword">new</span> TestBed();</span><br><span class="line">            t.f();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f()</span></span><br></pre></td></tr></table></figure>

<p>​        这生成了一个独立的类TestBed$Tester(要运行这个程序，执行java TestBed$Tester，在Unix/Linux系统中需要转义$)。你可以使用这个类测试，但是不必在发布的产品中包含它，可以在打包产品前删除TestBed$Tester.class。</p>
<h3 id="从多层嵌套类中访问外部类的成员"><a href="#从多层嵌套类中访问外部类的成员" class="headerlink" title="从多层嵌套类中访问外部类的成员"></a>从多层嵌套类中访问外部类的成员</h3><p>​        一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外部类的所有成员，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/MultiNestingAccess.java</span></span><br><span class="line"><span class="comment">// Nested classes can access all members of all</span></span><br><span class="line"><span class="comment">// levels of the classes they are nested within</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                g();</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiNestingAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MNA mna = <span class="keyword">new</span> MNA();</span><br><span class="line">        MNA.A mnaa = mna.<span class="function">new <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">        MNA.A.B mnaab = mnaa.<span class="function">new <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">        mnaab.h();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以看到在MNA.A.B中，调用方法g()和f()不需要任何条件(即使它们被定义为private)。这个例子同时展示了如何从不同的类里创建多层嵌套的内部类对象的基本语法。“.new”语法能产生正确的作用域，所以不必在调用构造器时限定类名。</p>
<h2 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h2><p>​        至此，我们已经看到了许多描述内部类的语法和语义，但是这并不能回答“为什么需要内部类”这个问题。那么，Java设计者为什么会如此费心地增加这项基本的语言特性呢？</p>
<p>​        一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外部类的对象。所以可以认为内部类提供了某种进入其外部类的窗口。</p>
<p>​        内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外部类实现那个接口呢？答案是：“如果这能满足需求，那么就应该这么做。”那么内部类实现一个接口与外部类实现这个接口有什么区别呢？答案是：后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是：每个内部类都能独立地继承自一个(接口的)实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都是没有影响。</p>
<p>​        如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型(类或接口)。</p>
<p>​        为了看到更多的细节，让我们考虑这样一种情形：即必须在一个类中以某种方式实现两个接口。由于接口的灵活性，你有两种选择；使用单一类，或者使用内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/mui/MultiInterfaces.java</span></span><br><span class="line"><span class="comment">// Two ways a class can implement multiple interfaces</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.mui.MultiInterfaces&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses.mui;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">makeB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Anonymous inner class:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B() &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiInterfaces</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        X x = <span class="keyword">new</span> X();</span><br><span class="line">        Y y = <span class="keyword">new</span> Y();</span><br><span class="line">        takesA(x);</span><br><span class="line">        takesA(y);</span><br><span class="line">        takesB(x);</span><br><span class="line">        takesB(y.makeB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这里假设在两种方式下的代码结构的确有逻辑意义。然而遇到问题的时候，通常问题本身就能给出某些指引，告诉你是应该使用单一类，还是使用内部类。但如果没有任何其他限制，从实现的观点来看，前面的例子并没有什么区别，它们都能正常运作。</p>
<p>​        如果拥有的是抽象类或具体的类，而不是接口，那就只能使用内部类才能实现多继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/MultiImplementation.java</span></span><br><span class="line"><span class="comment">// For concrete or abstract classes, inner classes</span></span><br><span class="line"><span class="comment">// produce &quot;multiple implementation inheritance&quot;</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.MultiImplementation&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> <span class="keyword">extends</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">makeE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> E() &#123;&#125;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiImplementation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesD</span><span class="params">(D d)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">takesE</span><span class="params">(E e)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Z z = <span class="keyword">new</span> Z();</span><br><span class="line">        takesD(z);</span><br><span class="line">        takesE(z.makeE());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性：</p>
<ul>
<li>1.内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立。</li>
<li>2.在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。</li>
<li>3.创建内部类对象的时刻并不依赖于外部类对象的创建</li>
<li>4.内部类并没有令人迷惑的“is-a”关系，它就是一个独立的实体。</li>
</ul>
<p>​        举个例子，如果Sequcence.java不使用内部类，就必须声明“Sequence是一个Selector”，对于某个特定的Sequence只能有一个Selector，然而使用内部类很容易就能拥有另一个方法reverseSelector()，用它来生成一个反向遍历序列的Selector，只有内部类才有这种灵活性。</p>
<h3 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h3><p>​        闭包(closure)是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外部类对象(创建内部类的作用域)的信息，还自动拥有一个指向此外部类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。</p>
<p>​        在Java8之前，内部类是实现闭包的唯一方式。在Java8中，我们可以使用lambda表达式来实现闭包行为，并且语法更加优雅和简洁。尽管相对于内部类，你可能更喜欢使用lambda表达式实现闭包，但你会看到并需要理解那些在Java8之前通过内部类方式实现闭包的代码，因此仍然有必要来理解这种方式。</p>
<p>​        Java最引人争议的问题之一就是，人们认为Java应该包含某种类似指针机制，以允许回调(callback)。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始对象。如果回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。</p>
<p>​        通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/Callbacks.java</span></span><br><span class="line"><span class="comment">// Using inner classes for callbacks</span></span><br><span class="line"><span class="comment">// &#123;java innerclasses.Callbacks&#125;</span></span><br><span class="line"><span class="keyword">package</span> innerclasses;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Very simple to just implement the interface:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Other operation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span> </span>&#123; mi.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If your class must implement increment() in</span></span><br><span class="line"><span class="comment">// some other way, you must use an inner class:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise</span></span><br><span class="line">            <span class="comment">// you&#x27;ll get an infinite recursion:</span></span><br><span class="line">            Callee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line">    Caller(Incrementable cbh) &#123;</span><br><span class="line">        callbackReference = cbh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123; callbackReference.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callee1 c1 = <span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2 = <span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        Caller caller1 = <span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2 =</span><br><span class="line">                <span class="keyword">new</span> Caller(c2.getCallbackReference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Other operation</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//Other operation</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//Other operation</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>​        这个例子进一步展示了外部类实现一个接口与内部类实现此接口的区别。就代码而言，Callee1更简单的解决方式。Callee2继承自MyIncrement，后者已经有了一个不同的increment()方法，并且与Incementable接口期望的increment()方法完全不相关。所以Callee2继承了MyIncrement，就不能为了Incrementable的用途而重写increment()方法，于是只能使用内部类独立地实现Incrementable，还要注意，当创建了一个内部类时，并没有在外部类的接口中添加东西，也没有修改外部类的接口。</p>
<p>​        注意，在Callee2中除了getCallbackReference()以外，其他成员都是private的。要想建立与外部世界的任何连接，接口Incrementable都是必须的。在这里可以看到，interface是如何允许接口与接口的实现完全独立的。内部类Closur实现了Incrementable，以提供一个返回Callee2的“钩子”(hook)-而且是一个安全的钩子。无论谁获得此Incrementable的引用，都只能调用increment()，除此之外没有其他功能。</p>
<p>​        Caller的构造器需要一个Incrementable的引用作为参数，然后在以后的某个时刻，Caller对象可以使用此引用回调Caller类。</p>
<p>​        回调的价值在于它的灵活性-可以在运行时动态地决定需要调用什么方法。例如，在图形界面实现GUI功能的时候，到处都用到回调。</p>
<h3 id="内部类与控制框架"><a href="#内部类与控制框架" class="headerlink" title="内部类与控制框架"></a>内部类与控制框架</h3><p>​        在将要介绍的控制框架(control framework)中，可以看到更多使用内部类的具体例子。</p>
<p>​        应用程序框架(application framework)就是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并重写某些方法。你在重写的方法中写的代码定制了该应用程序框架提供的通用解决方案，来解决你的具体问题。这是设计模式模板方法的一个例子，模板方法包含算法的基本结构，而且会调用一个或多个可重写的方法来完成该算法的运算。设计模式总是将变化的事物与保持不变的事物分离开，在这个模式中，模板方法是保持不变的事物，而可重写的方法就是变化的事物。</p>
<p>​        控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统被称作事件驱动系统。应用程序设计中常见的问题之一是图形化用户接口(GUI)，它几乎完全是事件驱动的系统。</p>
<p>​        要理解内部类是如何允许简单的创建过程以及如何使用控制框架的，请考虑这样一个控制框架，它的工作就是在事件“就绪ready()”的时候执行事件。虽然“就绪”可以指任何事，但在本例中是指基于时间触发的事件。下面是一个控制框架，它不包含具体的控制信息。那些信息是通过继承(当算法的action()部分被实现时)来提供的。</p>
<p>​        这里是描述了所有控制事件的接口。之所以用抽象类代替真正的接口，是因为默认行为都是根据时间来执行控制的。也因此包含了一些具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/controller/Event.java</span></span><br><span class="line"><span class="comment">// The common methods for any control event</span></span><br><span class="line"><span class="keyword">package</span> innerclasses.controller;</span><br><span class="line"><span class="keyword">import</span> java.time.*; <span class="comment">// Java 8 time classes</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Instant eventTime;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Duration delayTime;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(<span class="keyword">long</span> millisecondDelay)</span> </span>&#123;</span><br><span class="line">        delayTime = Duration.ofMillis(millisecondDelay);</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="comment">// Allows restarting</span></span><br><span class="line">        eventTime = Instant.now().plus(delayTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.now().isAfter(eventTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        当希望运行Event并随后调用start()时，那么构造器就会捕获(从对象创建的时刻开始的)时间，此时间是这样得来的：start()获取当前时间，然后加上一个延迟时间，这样生成触发事件的事件。start()是一个独立的方法，而没有包含在构造器内，因为这样就可以在事件运行以后重新启动计时器，也就是能够重复使用Event对象。例如，如果想要重复一个事件，只需简单地在action()中调用start()方法。</p>
<p>​        ready()告诉你何时可以运行action()方法了。当然，可以在派生类中重写ready()方法，使得Event能够基于时间以外的其他因素而触发。</p>
<p>​        下面的文件包含了一个用来管理并触发事件的实际控制框架。Event对象被保存在List&lt;Event&gt;类型的容器对象中。我们只需要知道add()方法用来将一个Event添加到List尾端，size()方法用来得到List中元素的个数，foreach语法用来连续获取List中的Event，remove()方法用来从List中移除指定的Event。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/controller/Controller.java</span></span><br><span class="line"><span class="comment">// The reusable framework for control systems</span></span><br><span class="line"><span class="keyword">package</span> innerclasses.controller;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A class from java.util to hold Event objects:</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Event&gt; eventList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEvent</span><span class="params">(Event c)</span> </span>&#123; eventList.add(c); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(eventList.size() &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// Make a copy so you&#x27;re not modifying the list</span></span><br><span class="line">            <span class="comment">// while you&#x27;re selecting the elements in it:</span></span><br><span class="line">            <span class="keyword">for</span>(Event e : <span class="keyword">new</span> ArrayList&lt;&gt;(eventList))</span><br><span class="line">                <span class="keyword">if</span>(e.ready()) &#123;</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                    e.action();</span><br><span class="line">                    eventList.remove(e);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        run()方法循环遍历eventList，寻找就绪的(ready())、要运行的Event对象。对找到的每一个就绪的(ready())事件，使用对象的toString()打印其信息，并调用其action()方法，然后从列表中移除此Event。</p>
<p>​        注意，在目前的设计中你并不知道Event到底做了什么。这正是此设计的关键所在——“使变化的事物与不变的事物相互分离”。用我的话说，“变化向量”就是各种不同的Event对象所具有的不同行为，而你通过创建不同的Event子类来表现不同的行为。</p>
<p>​        这正是内部类要做的事情，内部类允许：</p>
<ul>
<li>1.控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所需的各种不同的action()。</li>
<li>2.内部类能够很容易地访问外部类的任意成员，所以可以避免这种实现变得笨拙。如果没有这种能力，代码将变得令人讨厌，以至于你肯定会选择别的方法。</li>
</ul>
<p>​        考虑此控制框架的一个特定实现，如控制温室的运作：控制灯光、水、温度调节器的开关，以及响铃和重新启动系统，每个行为都是完全不同的。控制框架的设计使得分离这些不同的代码变得非常容易。使得内部类，可以在单一的类里面产生对同一个基类Event的多种派生版本。对于温室系统的每一种行为，都继承创建一个新的Event内部类，并在要实现的action()中编写控制代码。</p>
<p>​        作为典型的应用程序框架，GreenhouseControls类继承自Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/GreenhouseControls.java</span></span><br><span class="line"><span class="comment">// This produces a specific application of the</span></span><br><span class="line"><span class="comment">// control system, all in a single class. Inner</span></span><br><span class="line"><span class="comment">// classes allow you to encapsulate different</span></span><br><span class="line"><span class="comment">// functionality for each type of event.</span></span><br><span class="line"><span class="keyword">import</span> innerclasses.controller.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenhouseControls</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> light = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOn</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LightOn</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here to</span></span><br><span class="line">            <span class="comment">// physically turn on the light.</span></span><br><span class="line">            light = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Light is on&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOff</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LightOff</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here to</span></span><br><span class="line">            <span class="comment">// physically turn off the light.</span></span><br><span class="line">            light = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Light is off&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> water = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterOn</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WaterOn</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here.</span></span><br><span class="line">            water = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Greenhouse water is on&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterOff</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WaterOff</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here.</span></span><br><span class="line">            water = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Greenhouse water is off&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String thermostat = <span class="string">&quot;Day&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThermostatNight</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThermostatNight</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here.</span></span><br><span class="line">            thermostat = <span class="string">&quot;Night&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Thermostat on night setting&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThermostatDay</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThermostatDay</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Put hardware control code here.</span></span><br><span class="line">            thermostat = <span class="string">&quot;Day&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Thermostat on day setting&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// An example of an action() that inserts a</span></span><br><span class="line">    <span class="comment">// new one of itself into the event list:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bell</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bell</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            addEvent(<span class="keyword">new</span> Bell(delayTime.toMillis()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Bing!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Restart</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Event[] eventList;</span><br><span class="line">        <span class="keyword">public</span></span><br><span class="line">        Restart(<span class="keyword">long</span> delayTime, Event[] eventList) &#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">            <span class="keyword">this</span>.eventList = eventList;</span><br><span class="line">            <span class="keyword">for</span>(Event e : eventList)</span><br><span class="line">                addEvent(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(Event e : eventList) &#123;</span><br><span class="line">                e.start(); <span class="comment">// Rerun each event</span></span><br><span class="line">                addEvent(e);</span><br><span class="line">            &#125;</span><br><span class="line">            start(); <span class="comment">// Rerun this Event</span></span><br><span class="line">            addEvent(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Restarting system&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Terminate</span> <span class="keyword">extends</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Terminate</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123; System.exit(<span class="number">0</span>); &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Terminating&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        注意，light，water和thermostat都属于外部类GreenhouseControls，而这些内部类能够自由地访问那些字段，无需限定条件或特殊许可。而且，action()方法通常都涉及对某种硬件的控制。</p>
<p>​        大多数Event类看起来都很相似，但是Bell和Restart则比较特别。Bell控制响铃，然后在事件列表中增加一个Bell对象，于是过一会儿它可以再次响铃。读者可能注意到内部类是多么像多重继承：Bell和Restart有Event的所有方法，并且似乎也有外部类GreenhouseContrlos的所有方法。</p>
<p>​        一个由Event对象组成的数组被递交给Restart，该数组要加到控制器上。由于Restart()也是一个Event对象添加到Restart.action()中，以便系统能够有规律地重新启动自己。</p>
<p>​        下面的类通过创建一个GreenhouseControls对象，并添加各种不同的Event对象来配置该系统，这是命令设计模式的一个例子-eventList中的每个对象都被封装成对象的请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/GreenhouseController.java</span></span><br><span class="line"><span class="comment">// Configure and execute the greenhouse system</span></span><br><span class="line"><span class="keyword">import</span> innerclasses.controller.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenhouseController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GreenhouseControls gc = <span class="keyword">new</span> GreenhouseControls();</span><br><span class="line">        <span class="comment">// Instead of using code, you could parse</span></span><br><span class="line">        <span class="comment">// configuration information from a text file:</span></span><br><span class="line">        gc.addEvent(gc.<span class="function">new <span class="title">Bell</span><span class="params">(<span class="number">900</span>)</span>)</span>;</span><br><span class="line">        Event[] eventList = &#123;</span><br><span class="line">                gc.<span class="function">new <span class="title">ThermostatNight</span><span class="params">(<span class="number">0</span>)</span>,</span></span><br><span class="line"><span class="function">                gc.new <span class="title">LightOn</span><span class="params">(<span class="number">200</span>)</span>,</span></span><br><span class="line"><span class="function">                gc.new <span class="title">LightOff</span><span class="params">(<span class="number">400</span>)</span>,</span></span><br><span class="line"><span class="function">                gc.new <span class="title">WaterOn</span><span class="params">(<span class="number">600</span>)</span>,</span></span><br><span class="line"><span class="function">                gc.new <span class="title">WaterOff</span><span class="params">(<span class="number">800</span>)</span>,</span></span><br><span class="line"><span class="function">                gc.new <span class="title">ThermostatDay</span><span class="params">(<span class="number">1400</span>)</span></span></span><br><span class="line"><span class="function">        &#125;</span>;</span><br><span class="line">        gc.addEvent(gc.<span class="function">new <span class="title">Restart</span><span class="params">(<span class="number">2000</span>, eventList)</span>)</span>;</span><br><span class="line">        gc.addEvent(</span><br><span class="line">                <span class="keyword">new</span> GreenhouseControls.Terminate(<span class="number">5000</span>));</span><br><span class="line">        gc.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Thermostat on night setting 0</span></span><br><span class="line"><span class="comment">//Light is on 200</span></span><br><span class="line"><span class="comment">//Light is off 400</span></span><br><span class="line"><span class="comment">//Greenhouse water is on 600</span></span><br><span class="line"><span class="comment">//Greenhouse water is off 800</span></span><br><span class="line"><span class="comment">//Bing! 900</span></span><br><span class="line"><span class="comment">//Thermostat on day setting 1400</span></span><br><span class="line"><span class="comment">//Bing! 1800</span></span><br><span class="line"><span class="comment">//Restarting system 2000</span></span><br><span class="line"><span class="comment">//Thermostat on night setting 2000</span></span><br><span class="line"><span class="comment">//Light is on 2200</span></span><br><span class="line"><span class="comment">//Light is off 2400</span></span><br><span class="line"><span class="comment">//Greenhouse water is on 2600</span></span><br><span class="line"><span class="comment">//Bing! 2700</span></span><br><span class="line"><span class="comment">//Greenhouse water is off 2800</span></span><br><span class="line"><span class="comment">//Thermostat on day setting 3400</span></span><br><span class="line"><span class="comment">//Bing! 3600</span></span><br><span class="line"><span class="comment">//Restarting system 4000</span></span><br><span class="line"><span class="comment">//Thermostat on night setting 4000</span></span><br><span class="line"><span class="comment">//Light is on 4200</span></span><br><span class="line"><span class="comment">//Light is off 4400</span></span><br><span class="line"><span class="comment">//Bing! 4500</span></span><br><span class="line"><span class="comment">//Greenhouse water is on 4600</span></span><br><span class="line"><span class="comment">//Greenhouse water is off 4800</span></span><br><span class="line"><span class="comment">//Terminating 5000</span></span><br></pre></td></tr></table></figure>

<p>​        这个类的作用是初始化系统，所以它添加了所有相应的事件。Restart事件反复运行，而且它每次都会将eventList加载到GreenhouseControls对象中。如果提供了命令行参数，系统会以它作为毫秒数，决定什么时候终止程序。</p>
<h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><p>​        因为内部类的构造器必须连接到指向外部类对象的引用，所以在继承内部类的时候，事情会变的有点复杂。问题在于，那个指向外部类对象的“秘密的”引用必须被初始化，而在派生类中不再存在可连接的默认对象。要解决这个问题，必须使用特殊的语法明确说清它们之间的关联：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/InheritInner.java</span></span><br><span class="line"><span class="comment">// Inheriting an inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//- InheritInner() &#123;&#125; // Won&#x27;t compile</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner ii = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以看到，InheritInner只继承自内部类，而不是外部类。但是要生成一个构造器时，默认的构造器并不算好，而且不能只是传递一个指向外部类对象的引用。此外，必须在构造器内使用如下语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">enclosingClassReference.<span class="keyword">super</span>();</span><br></pre></td></tr></table></figure>

<p>​        这样才提供了必要的引用，然后程序才能编译通过。</p>
<h2 id="内部类可以被重写么？"><a href="#内部类可以被重写么？" class="headerlink" title="内部类可以被重写么？"></a>内部类可以被重写么？</h2><p>​        如果创建了一个内部类，然后继承其外部类并重新定义此内部类时，会发生什么呢？也就是说，内部类可以被重写么？这看起来似乎是个很有用的思想，但是“重写”内部类就好像它是一个外部类的一个方法，其实并不起什么作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg.java</span></span><br><span class="line"><span class="comment">// An inner class cannot be overridden like a method</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Egg() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New Egg()&quot;</span>);</span><br><span class="line">        y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//New Egg()</span></span><br><span class="line"><span class="comment">//Egg.Yolk()</span></span><br></pre></td></tr></table></figure>

<p>​        默认的无参构造器是编译器自动生成的，这里是调用基类的默认构造器。你可能认为既然创建了BigEgg的对象，那么所使用的应该是“重写后”的Yolk版本，但从输出中可以看到实际情况并不是这样的。</p>
<p>​        这个例子说明：当继承某个外部类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。当然，明确地继承某个内部类也是可以的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/BigEgg2.java</span></span><br><span class="line"><span class="comment">// Proper inheritance of an inner class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Egg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Yolk y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    Egg2() &#123; System.out.println(<span class="string">&quot;New Egg2()&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertYolk</span><span class="params">(Yolk yy)</span> </span>&#123; y = yy; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; y.f(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg2</span> <span class="keyword">extends</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> <span class="keyword">extends</span> <span class="title">Egg2</span>.<span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BigEgg2.Yolk.f()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigEgg2</span><span class="params">()</span> </span>&#123; insertYolk(<span class="keyword">new</span> Yolk()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Egg2 e2 = <span class="keyword">new</span> BigEgg2();</span><br><span class="line">        e2.g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Egg2.Yolk()</span></span><br><span class="line"><span class="comment">//New Egg2()</span></span><br><span class="line"><span class="comment">//Egg2.Yolk()</span></span><br><span class="line"><span class="comment">//BigEgg2.Yolk()</span></span><br><span class="line"><span class="comment">//BigEgg2.Yolk.f()</span></span><br></pre></td></tr></table></figure>

<p>​        现在BigEgg2.Yolk通过extends Egg2.Yolk明确地继承了此内部类，并且重写了其中的方法。insertYolk()方法允许BigEgg2将它自己的Yolk对象向上转型为Egg2中的引用y。所以当g()调用y.f()时，重写后的新版的f()被执行。第二次调用Egg2.Yolk()，结果是BigEgg2.Yolk的构造器调用了其基类的构造器。可以看到在调用g()的时候，新版的f()被调用了。</p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>​        前面提到过，可以在代码块里创建内部类，典型的方式是在一个方法体里面创建。局部内部类不能有访问说明符，因为它不是外部类的一部分；但它可以访问当前代码块内的常量，以及此外部类的所有成员。下面的例子对局部内部类与匿名内部类的创建进行了比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// innerclasses/LocalInnerClass.java</span></span><br><span class="line"><span class="comment">// Holds a sequence of Objects</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A local inner class:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">            LocalCounter() &#123;</span><br><span class="line">                <span class="comment">// Local inner class can have a constructor</span></span><br><span class="line">                System.out.println(<span class="string">&quot;LocalCounter()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.print(name); <span class="comment">// Access local final</span></span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Repeat, but with an anonymous inner class:</span></span><br><span class="line">    <span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Counter() &#123;</span><br><span class="line">            <span class="comment">// Anonymous inner class cannot have a named</span></span><br><span class="line">            <span class="comment">// constructor, only an instance initializer:</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Counter()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.print(name); <span class="comment">// Access local final</span></span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalInnerClass lic = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">        Counter</span><br><span class="line">                c1 = lic.getCounter(<span class="string">&quot;Local inner &quot;</span>),</span><br><span class="line">                c2 = lic.getCounter2(<span class="string">&quot;Anonymous inner &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            System.out.println(c1.next());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            System.out.println(c2.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LocalCounter()</span></span><br><span class="line"><span class="comment">//Counter()</span></span><br><span class="line"><span class="comment">//Local inner 0</span></span><br><span class="line"><span class="comment">//Local inner 1</span></span><br><span class="line"><span class="comment">//Local inner 2</span></span><br><span class="line"><span class="comment">//Local inner 3</span></span><br><span class="line"><span class="comment">//Local inner 4</span></span><br><span class="line"><span class="comment">//Anonymous inner 5</span></span><br><span class="line"><span class="comment">//Anonymous inner 6</span></span><br><span class="line"><span class="comment">//Anonymous inner 7</span></span><br><span class="line"><span class="comment">//Anonymous inner 8</span></span><br><span class="line"><span class="comment">//Anonymous inner 9</span></span><br></pre></td></tr></table></figure>

<p>​        Counter返回的是序列中的下一个值。我们分别使用局部内部类和匿名内部类实现了这个功能，它们具有相同的行为和能力，既然局部内部类的名字在方法外是不可见的，那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能使用实例初始化。所以使用局部内部类而不使用匿名内部类的另一个理由是，需要不止一个该内部类的对象。</p>
<h2 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a>内部类标识符</h2><p>​        由于编译后每个类都会产生一个.class文件，其中包含了如何创建该类型的对象的全部信息(此信息产生了一个“meta-class”，叫作Class对象)。</p>
<p>​        你可能猜到了，内部类也必须生成一个.class文件以包含它们的Class对象信息。这些类文件的命名有严格的规则：外部类的名字，加上“$”，再加上内部类的名字。例如，LocallnnerClass.java生成的.class文件包括：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Counter.class</span><br><span class="line">LocalInnerClass$<span class="number">1.</span>class</span><br><span class="line">LocalInnerClass$1LocalCounter.class</span><br><span class="line">LocalInnerClass.class</span><br></pre></td></tr></table></figure>

<p>​        如果内部类是匿名的，编译期会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外部类标识符与“$”的后面。</p>
<p>​        虽然这种命名格式简单而直接，但它还是很健壮的，足以应对绝大多数情况。因为这是Java的标准命名方式，所以产生的文件自动都是平台无关的。(注意，为了保证你的内部类能起作用，Java编译期会尽可能地转换它们。)</p>
]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>《On Java 8》</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的基本使用</title>
    <url>/2021/05/15/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
 <span id="more"></span> 

<h2 id="初始化git本地仓库"><a href="#初始化git本地仓库" class="headerlink" title="初始化git本地仓库"></a>初始化git本地仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h2 id="查看工作目录和暂存区文件状态"><a href="#查看工作目录和暂存区文件状态" class="headerlink" title="查看工作目录和暂存区文件状态"></a>查看工作目录和暂存区文件状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<h2 id="添加工作目录文件到暂存区"><a href="#添加工作目录文件到暂存区" class="headerlink" title="添加工作目录文件到暂存区"></a>添加工作目录文件到暂存区</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt; #添加指定文件到暂存区</span><br><span class="line">git add . #添加当前目录中的所有文件到暂存区</span><br></pre></td></tr></table></figure>

<h2 id="移除暂存区中的文件"><a href="#移除暂存区中的文件" class="headerlink" title="移除暂存区中的文件"></a>移除暂存区中的文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm &lt;file_path&gt; #删除暂存区或分支上的文件，同时工作区也不需要这个文件</span><br><span class="line">git rm --cache &lt;file_path&gt; # 删除暂存区或分支上的文件，但本地又需要使用，只是不希望这个文件被版本控制。</span><br></pre></td></tr></table></figure>



<h2 id="提交暂存区文件到本地仓库"><a href="#提交暂存区文件到本地仓库" class="headerlink" title="提交暂存区文件到本地仓库"></a>提交暂存区文件到本地仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit</span><br><span class="line">git commit -m&#x27;提交的日志信息&#x27; #提交并记录对本地仓库的更改</span><br></pre></td></tr></table></figure>

<h2 id="查看提交的日志信息"><a href="#查看提交的日志信息" class="headerlink" title="查看提交的日志信息"></a>查看提交的日志信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">git log --pretty=oneline #在一行中显式日志</span><br><span class="line">git log --graph --pretty=online #图形化日志</span><br><span class="line">git log -3 --pretty=oneline #在一行中显式最近三次提交的日志</span><br><span class="line">git reflog #查看所有日志</span><br></pre></td></tr></table></figure>

<h2 id="查看本地仓库和工作区之间的更改"><a href="#查看本地仓库和工作区之间的更改" class="headerlink" title="查看本地仓库和工作区之间的更改"></a>查看本地仓库和工作区之间的更改</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff HEAD -- &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>--- 表变动之前的文件；+++表变动后的文件。变动的位置用两个@作为起始和结束</p>
<h2 id="从暂存区中撤销到工作区"><a href="#从暂存区中撤销到工作区" class="headerlink" title="从暂存区中撤销到工作区"></a>从暂存区中撤销到工作区</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git restore --staged &lt;file&gt;</span><br></pre></td></tr></table></figure>

<h2 id="撤销上一次操作"><a href="#撤销上一次操作" class="headerlink" title="撤销上一次操作"></a>撤销上一次操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt; #撤销上一次的操作</span><br></pre></td></tr></table></figure>

<h2 id="本地仓库版本回退"><a href="#本地仓库版本回退" class="headerlink" title="本地仓库版本回退"></a>本地仓库版本回退</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^ #回退到上一个版本</span><br><span class="line">git reset --hard HEAD^^ #回退两个版本</span><br><span class="line">git reset --hard HEAD~2 #回退两个版本</span><br><span class="line">git reset --hard &lt;版本的唯一标识id&gt; #回退或前进到指定id的版本</span><br></pre></td></tr></table></figure>

<h2 id="查看git本地仓库中的文件目录"><a href="#查看git本地仓库中的文件目录" class="headerlink" title="查看git本地仓库中的文件目录"></a>查看git本地仓库中的文件目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git ls-files</span><br></pre></td></tr></table></figure>

<h2 id="从本地仓库中拉取文件到工作目录"><a href="#从本地仓库中拉取文件到工作目录" class="headerlink" title="从本地仓库中拉取文件到工作目录"></a>从本地仓库中拉取文件到工作目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout</span><br></pre></td></tr></table></figure>

<h2 id="从本地仓库中删除指定文件"><a href="#从本地仓库中删除指定文件" class="headerlink" title="从本地仓库中删除指定文件"></a>从本地仓库中删除指定文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br></pre></td></tr></table></figure>

<h2 id="git查看远程仓库地址："><a href="#git查看远程仓库地址：" class="headerlink" title="git查看远程仓库地址："></a>git查看远程仓库地址：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<h2 id="使用本地Git客户端生成SSH公钥与私钥"><a href="#使用本地Git客户端生成SSH公钥与私钥" class="headerlink" title="使用本地Git客户端生成SSH公钥与私钥"></a>使用本地Git客户端生成SSH公钥与私钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="检查测试链接"><a href="#检查测试链接" class="headerlink" title="检查测试链接"></a>检查测试链接</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<h2 id="绑定远程仓库"><a href="#绑定远程仓库" class="headerlink" title="绑定远程仓库"></a>绑定远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;ssh&gt;</span><br></pre></td></tr></table></figure>

<h2 id="将本地仓库推送到远程仓库"><a href="#将本地仓库推送到远程仓库" class="headerlink" title="将本地仓库推送到远程仓库"></a>将本地仓库推送到远程仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master #首次推送</span><br><span class="line">git push #推送</span><br><span class="line">git push origin &lt;branch_name&gt; #推送本地分支到指定远程分支</span><br></pre></td></tr></table></figure>

<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch&gt; #切换分支</span><br><span class="line">git checkout -b &lt;new_branch&gt; #新建分支并切换到新建分支</span><br></pre></td></tr></table></figure>

<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branch&gt; #删除本地分支</span><br><span class="line">git push origin :&lt;remote_branch&gt; #删除远程分支(本地分支还在)</span><br></pre></td></tr></table></figure>

<h2 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch #查看本地分支</span><br><span class="line">git branch -a #查看本地和远程分支</span><br></pre></td></tr></table></figure>

<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<h2 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m|-M &lt;oldbranch&gt; &lt;newbranch&gt;</span><br></pre></td></tr></table></figure>

<p>若newbranch名字分支已经存在，则需要使用-M为强制重命名，否则，使用-m进行重命名。</p>
<h2 id="拉取远程仓库指定分支并在本地创建分支"><a href="#拉取远程仓库指定分支并在本地创建分支" class="headerlink" title="拉取远程仓库指定分支并在本地创建分支"></a>拉取远程仓库指定分支并在本地创建分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;</span><br></pre></td></tr></table></figure>

<h2 id="获取远程仓库中最新的状态"><a href="#获取远程仓库中最新的状态" class="headerlink" title="获取远程仓库中最新的状态"></a>获取远程仓库中最新的状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>

<h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag &lt;tag_name&gt;</span><br><span class="line">git tag &lt;tag_name&gt; &lt;指定id版本&gt;</span><br></pre></td></tr></table></figure>

<h2 id="添加标签并指定标签描述信息"><a href="#添加标签并指定标签描述信息" class="headerlink" title="添加标签并指定标签描述信息"></a>添加标签并指定标签描述信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -a &lt;tag_name&gt; -m&#x27;XXX&#x27;</span><br><span class="line">git tag -a &lt;tag_name&gt; -m&#x27;XXX&#x27; &lt;指定id版本&gt;</span><br></pre></td></tr></table></figure>

<h2 id="查看所有的标签"><a href="#查看所有的标签" class="headerlink" title="查看所有的标签"></a>查看所有的标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>

<h2 id="删除一个本地标签"><a href="#删除一个本地标签" class="headerlink" title="删除一个本地标签"></a>删除一个本地标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -d &lt;tag_name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="推送本地标签到远程"><a href="#推送本地标签到远程" class="headerlink" title="推送本地标签到远程"></a>推送本地标签到远程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin &lt;tag_name&gt; #推送本地标签到远程</span><br><span class="line">git push origin --tags #推送全部未推送过的本地标签到远程</span><br></pre></td></tr></table></figure>

<h2 id="删除一个远程标签"><a href="#删除一个远程标签" class="headerlink" title="删除一个远程标签"></a>删除一个远程标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/&lt;tag_name&gt; #远程删除，但本地的还在</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读《On Java 8》-- 第十二章 集合</title>
    <url>/2021/05/18/%E9%98%85%E8%AF%BB%E3%80%8AOn-Java-8%E3%80%8B-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>通常，程序总是根据运行时才知道的某些条件去创建新的对象。在此之前，无法知道所需对象的数量甚至去确切类型。为了解决这个普遍的编程问题，需要在任意时刻和任意位置创建任意数量的对象。因此，不能依靠创建命名的引用来持有每一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyType aReference;</span><br></pre></td></tr></table></figure>

<p>​        因为从来不会知道实际需要多少个这样的引用。</p>
<p>​        大多数编程语言都提供了某种方法来解决这个基本问题。Java有多种方式保存对象(确切的说，是对象的引用)。例如前边曾经学习过的数组，它是编译期支持的类型。数组是保存一组对象的最有效的方式，如果想要保存一组基本类型数据，也推荐使用数组。但是数组具有固定的大小尺寸，而且在更一般的情况下，在写程序的时候并不知道你需要多少个对象，或者是否需要更复杂的方式来存储对象，因此数组尺寸固定这一限制就显得太过受限了。</p>
<p>​        java.util库提供了一套相当完整的集合类(collection classes)来解决这个问题，其中基本的类型有List、Set、Queue和Map。这些类型也被称作容器类(container classes)，但我将使用Java类库使用的术语。集合提供了完善的方法来保存对象，可以使用这些工具来解决大量的问题。</p>
<p>​        集合还有一些其它特性。例如，Set对于每个值都只保存一个对象，Map是一个关联数组，允许将某些对象与其他对象关联起来。Java集合类都可以自动地调整自己的大小。因此，与数组不同，在编程时，可以将任意数量的对象放置在集合中，而不用关心集合应该有多大。</p>
 <span id="more"></span> 

<h2 id="泛型和类型安全的集合"><a href="#泛型和类型安全的集合" class="headerlink" title="泛型和类型安全的集合"></a>泛型和类型安全的集合</h2><p>​        使用Java5之前的集合的一个主要问题是编译器允许你向集合中插入不正确的类型。例如，考虑一个Apple对象的集合，这里使用最基本最可靠的ArrayList。现在，可以把ArrayList看作“可以自动扩充自身尺寸的数组”来看待。使用ArrayList相当简单：创建一个实例，用add()插入对象；然后用get()来访问这些对象，此时需要使用索引，就像数组那样，但是不需要方括号。ArrayList还有一个size()方法，来说明集合中包含了多少个元素，所以不会不小心因数组越界而引发错误。</p>
<p>​        在本例中，Apple和Orange都被放到了集合中，然后将它们取出。正常情况下，Java编译期会给出警告，因为这个示例没有使用泛型。在这里，使用特定的注解来抑制警告信息。注解以“@”符号开头，可以带参数。这里的@SuppressWarning注解及其参数表示只抑制“unchecked”类型的警告：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/ApplesAndOrangesWithoutGenerics.java</span></span><br><span class="line"><span class="comment">// Simple collection use (suppressing compiler warnings)</span></span><br><span class="line"><span class="comment">// &#123;ThrowsException&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplesAndOrangesWithoutGenerics</span> </span>&#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList apples = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="comment">// No problem adding an Orange to apples:</span></span><br><span class="line">    apples.add(<span class="keyword">new</span> Orange());</span><br><span class="line">    <span class="keyword">for</span>(Object apple : apples) &#123;</span><br><span class="line">      ((Apple) apple).id();</span><br><span class="line">      <span class="comment">// Orange is detected only at run time</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">___[ Error Output ]___</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot;</span></span><br><span class="line"><span class="comment">java.lang.ClassCastException: Orange cannot be cast to Apple</span></span><br><span class="line"><span class="comment">        at ApplesAndOrangesWithoutGenerics.main(ApplesAndOrangesWithoutGenerics.java:23)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        Apple和Orange是截然不同的，它们除了都是Object之外没有任何共同点(如果一个类没有显示地声明继承自哪个类，那么它就自动继承自Object)。因为ArrayList保存的是Object，所以不仅可以通过ArrayList的add()方法将Apple对象放入这个集合，而且可以放入Orange对象，这无论在编译期还是运行期都不会有问题。当使用ArrayList的get()方法来取出你认为是Apple的对象时，得到的只是Object引用，必须将其转型为Apple。然后需要将整个表达式用括号括起来，以便在调用Apple的id()方法之前，强制转型。否则，将会产生语法错误。</p>
<p>​        在运行时，当尝试将Orange对象转为Apple时，会出现输出中显式的错误。</p>
<p>​        在泛型章节中，你将了解到使用Java泛型来创建类可能很复杂。但是，使用预先定义的泛型类却相当简单。例如，要定义一个用于保存Apple对象的ArrayList，只需要使用ArrayList&lt;Apple&gt;来代替ArrayList。尖括号括起来的是参数类型，它指定了这个集合实例可以保存的类型。</p>
<p>​        通过使用泛型，就可以在编译期防止将错误类型的对象放置到集合中。下面还是这个示例，但是使用了泛型:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/ApplesAndOrangesWithGenerics.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplesAndOrangesWithGenerics</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">      apples.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    <span class="comment">// Compile-time error:</span></span><br><span class="line">    <span class="comment">// apples.add(new Orange());</span></span><br><span class="line">    <span class="keyword">for</span>(Apple apple : apples) &#123;</span><br><span class="line">      System.out.println(apple.id());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        在apples定义的右侧，可以看到new ArrayList&lt;&gt;()。这有时被称为“菱形语法”(diamond syntax)。在Java7之前，必须要在两端都进行类型声明，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br></pre></td></tr></table></figure>

<p>​        随着类型变得越来越复杂，这种重复产生的代码非常混乱且难以阅读。程序员发现所有类型信息都可以从左侧获得，因此，编译器没有理由强迫右侧再重复这些。虽然类型推断(type inference)只是个很小的请求，Java语言团队仍然欣然接受并进行了改进。</p>
<p>​        有了ArrayList声明中的类型指定，编译器会阻止将Orange放入apples，因此，这会成为一个编译期错误而不是运行时错误。</p>
<p>​        使用泛型，从List中获取元素不需要强制类型转换。因为List知道它持有什么类型，因此当调用get()时，它会替你执行转型。因此，使用泛型，你不仅知道编译器将检查放入集合的对象类型，而且在使用集合中的对象时也可以获得更清晰的语法。</p>
<p>​        当指定了某个类型为泛型参数时，并不仅限于只能将确切类型的对象放入集合中。向上转型也可以像作用于其他类型一样作用于泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collections/GenericsAndUpcasting.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrannySmith</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gala</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fuji</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Braeburn</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsAndUpcasting</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    apples.add(<span class="keyword">new</span> GrannySmith());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Gala());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Fuji());</span><br><span class="line">    apples.add(<span class="keyword">new</span> Braeburn());</span><br><span class="line">    <span class="keyword">for</span>(Apple apple : apples)</span><br><span class="line">      System.out.println(apple);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">GrannySmith@15db9742</span></span><br><span class="line"><span class="comment">Gala@6d06d69c</span></span><br><span class="line"><span class="comment">Fuji@7852e922</span></span><br><span class="line"><span class="comment">Braeburn@4e25154f</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​        因此，可以将Apple的子类型添加到被指定为保存Apple对象的集合中。</p>
<p>​        程序输出的是从Object默认的toString()方法产生的，该方法打印类名，后边跟着对象的散列码的无符号十六进制表示(这个散列码是通过hashCode()方法产生的)。</p>
]]></content>
  </entry>
</search>
