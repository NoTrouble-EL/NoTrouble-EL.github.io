<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-big-counter.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据结构与算法," />










<meta name="description" content="算法与算法分析 算法效率以下两个方面来考虑： 时间效率：指的是算法所耗费的时间 空间效率：指的是算法执行过程中所消耗的存储空间   时间效率和空间效率有时候是矛盾的">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://yoursite.com/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="NoTrouble&#39;s Blog">
<meta property="og:description" content="算法与算法分析 算法效率以下两个方面来考虑： 时间效率：指的是算法所耗费的时间 空间效率：指的是算法执行过程中所消耗的存储空间   时间效率和空间效率有时候是矛盾的">
<meta property="og:locale">
<meta property="article:published_time" content="2021-04-13T14:26:36.000Z">
<meta property="article:modified_time" content="2021-04-13T14:26:36.000Z">
<meta property="article:author" content="NoTrouble">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/04/13/数据结构与算法/"/>





  <title>数据结构与算法 | NoTrouble's Blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">NoTrouble's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我们一路奋战，不是为了改变世界，而是为了不让世界改变我们</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-playlist">
          <a href="/playlist/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-music"></i> <br />
            
            歌单
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wk.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NoTrouble's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构与算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-13T22:26:36+08:00">
                2021-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="算法与算法分析"><a href="#算法与算法分析" class="headerlink" title="算法与算法分析"></a>算法与算法分析</h2><ul>
<li>算法效率以下两个方面来考虑：<ul>
<li><strong>时间效率</strong>：指的是算法所耗费的时间</li>
<li><strong>空间效率</strong>：指的是算法执行过程中所消耗的存储空间</li>
</ul>
</li>
<li><strong>时间效率和空间效率有时候是矛盾的</strong></li>
</ul>
 <span id="more"></span> 

<h3 id="算法时间效率度量"><a href="#算法时间效率度量" class="headerlink" title="算法时间效率度量"></a>算法时间效率度量</h3><ul>
<li>算法时间效率可以依据该算法编制的程序在计算机上执行所消耗的时间来度量</li>
<li>两种度量方式<ul>
<li>事后统计<ul>
<li>将算法实现，测算其时间和空间开销</li>
<li>缺点：编写程序实现算法将花费较多的时间和精力；所得实验结果依赖于计算机得软硬件等环境因素，掩盖算法本身的优劣</li>
</ul>
</li>
<li>事前分析<ul>
<li>对算法所消耗资源的一种估算方法</li>
<li>一个算法的运行时间是指一个算法在计算机上运行所消耗的时间大致可以等于计算机执行一种简单的操作所需的时间与算法中进行的简单操作次数乘积。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>算法的运行时间 = 一个简单操作所需的时间 x 简单操作次数</strong><br><strong>算法的运行时间 = $\sum$每条语句执行的次数 x 该语句执行一次所需要的时间</strong><br><strong>算法的运行时间 = $\sum$每条语句频度 x 该语句执行一次所需要的时间</strong></p>
<p>​        每条语句执行的一次所需要的时间，一般是随机器而异的。取决于机器的指令性能、速度以及编码的代码质量。是由机器本身软硬件环境决定的，它与算法无关。<br>​        所以，我们可以假设执行每条语句所需要的时间均为单位时间。此时对算法的运行时间的讨论就可以转化为该算法中所有语句的执行次数，即频度之和。<br>​        这就可以独立于不同机器的软硬件环境来分析算法的时间性能了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//矩阵乘法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] MatrixMultiplication(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//n+1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;<span class="comment">//n(n+1)次</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;<span class="comment">//n*n(n+1)次</span></span><br><span class="line">                c[i][j] += a[i][k] * b[k][j];<span class="comment">//n*n*n次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        我们把算法所消耗的时间定义为该算法中每条语句的频度之和，则上述算法的时间消耗T(n)为：$2n^3+3n^2+2n+1$</p>
<p><strong>算法时间复杂度的渐进表示法</strong></p>
<ul>
<li>为了便于比较不同算法的时间效率，我们仅比较它们的数量级。</li>
<li>若有某个辅助函数f(n)，使得当n趋近于无穷大时，$T(n)/f(n)$的极限为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作$T(n)=O(f(n))$，称$O(f(n))$为算法的渐进时间复杂度(O是数量级的符号)，简称时间复杂度。</li>
<li>一般情况下，不必计算所有操作的执行次数，而只考虑算法中基本操作执行的次数，它是问题规模n的某个函数，用$T(n)$表示。</li>
</ul>
<p>上述矩阵相乘问题的时间复杂度为$O(n^3)$</p>
<h3 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h3><p>​        算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度记为：$T(n)=O(f(n))$</p>
<h3 id="分析算法时间复杂度的基本方法"><a href="#分析算法时间复杂度的基本方法" class="headerlink" title="分析算法时间复杂度的基本方法"></a>分析算法时间复杂度的基本方法</h3><p>定理1.1 若$f(n)=a_mn^m+a_{m-1}n^{m-1}+…+a_1n+a_0$是m次多项式，则$T(n)=O(n^m)$</p>
<ul>
<li>找出语句频度最大的那条语句作为基本语句</li>
<li>计算基本语句的频度得到问题规模n的某个函数$f(n)$</li>
<li>取其数量级用符号“O”表示</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        c[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">            c[i][j] = c[i][j]+a[i][k] * b[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>\sum_{i=1}^{n}\sum_{j=1}^{n}\sum_{k=1}^n1=\sum_{i=1}^{n}\sum_{j=1}^{n}n=\sum_{i=1}^{n}n^2=n^3<br>$$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">1</span>;k &lt;= j; k++)</span><br><span class="line">            x=x+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>$$<br>\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^j1=\sum_{i=1}^n\sum_{j=1}^ij=\sum_{i=1}^n\frac{(1+i)i}{2}=\frac{1}{2}(\sum_{i=1}^ni^2+\sum_{i=1}^ni)=(\frac{1}{2})(\frac{n(n+1)(2n+1)}{6}+\frac{n(n+1)}{2})=\frac{n(n+1)(n+2)}{6}<br>$$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例3</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">    i = i * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>$$<br>2^{f(n)} &lt;= n;f(n)&lt;=log_2n;T(n)=log_2n<br>$$</p>
<h3 id="算法时间复杂度计算"><a href="#算法时间复杂度计算" class="headerlink" title="算法时间复杂度计算"></a>算法时间复杂度计算</h3><p>​        请注意：有的情况下，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]==e) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>最好情况：1次</li>
<li>最坏情况：n次</li>
<li>平均时间复杂度为：$O(n)$</li>
</ul>
<p>最坏时间复杂度：指在最坏情况下，算法的时间复杂度<br>平均时间复杂度：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间<br>最好时间复杂度：指在最好情况下，算法的时间复杂度</p>
<p>​        一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p>
<p>​        对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大O加法法则和乘法法则，计算算法的时间复杂度：<br>​        加法规则：$T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))$<br>​        乘法法则：<br>$T(n)=T_1(n)\times T_2(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$</p>
<h3 id="算法时间效率的比较"><a href="#算法时间效率的比较" class="headerlink" title="算法时间效率的比较"></a>算法时间效率的比较</h3><p>​        当n取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊。</p>
<p><strong>时间复杂度$T(n)$按数量级递增顺序</strong></p>
<p>​        常数阶-&gt; 对数阶 -&gt; 线性阶 -&gt; 线性对数阶 -&gt; 平方阶 -&gt; 立方阶 -&gt; … -&gt;K方阶 -&gt; 指数阶。</p>
<h3 id="渐进空间复杂度"><a href="#渐进空间复杂度" class="headerlink" title="渐进空间复杂度"></a>渐进空间复杂度</h3><p>​        空间复杂度：算法所需要存储空间的度量，记作：$S(n)=O(f(n))$，其中n为问题的规模大小。<br>​        算法要占据的空间：算法本身要占据的空间，输入/输出，指令，常数，变量等；算法要使用的<strong>辅助空间</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code1</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    t=a[i];</span><br><span class="line">    a[i]=a[n-i<span class="number">-1</span>];</span><br><span class="line">    a[n-i<span class="number">-1</span>]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//code2</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    b[i]=a[n-i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    a[i]=b[i];</span><br></pre></td></tr></table></figure>

<p>​        code1中$S(n)=O(1)$原地工作，code2中$S(n)=O(n)$。</p>
<h3 id="设计好算法的过程"><a href="#设计好算法的过程" class="headerlink" title="设计好算法的过程"></a>设计好算法的过程</h3><p>抽象数据类型=数据的逻辑结构+抽象运算<br>        数据的逻辑结构可以有多种数据的存储结构；基于不同的数据存储结构可以有不同的算法；不同的算法考虑其渐进的时间复杂度和渐进的空间复杂度；最后得出好的算法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[数据结构]--&gt;B[数据的逻辑结构]</span><br><span class="line">A[数据结构]--&gt;C[数据的存储结构]</span><br><span class="line">A[数据结构]--&gt;D[数据的运算]</span><br><span class="line">B[数据的逻辑结构]--&gt;E[线性结构]</span><br><span class="line">B[数据的逻辑结构]--&gt;F[非线性结构]</span><br><span class="line">E[线性结构]--&gt;G[线性表]</span><br><span class="line">E[线性结构]--&gt;H[栈--特殊的线性表]</span><br><span class="line">E[线性结构]--&gt;I[队列--特殊的线性表]</span><br><span class="line">E[线性结构]--&gt;J[字符串-数组-广义表]</span><br><span class="line">F[非线性结构]--&gt;K[树形结构]</span><br><span class="line">F[非线性结构]--&gt;L[图形结构]</span><br><span class="line">C[数据的存储结构]--&gt;M[顺序存储]</span><br><span class="line">C[数据的存储结构]--&gt;N[链式存储]</span><br><span class="line">D[数据的运算]--&gt;O[检索-排序-插入-删除-修改]</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h3><ul>
<li>线性表(Linear List)：由$n(n&gt;=0)$个数据元素(结点)$a_1,…,a_n$组成的有限序列</li>
<li>其中数据元素的个数为n定义为表的长度</li>
<li>当n=0时称为空表</li>
<li>将非空的线性表(n&gt;0)记作：$(a_1,a_2,…,a_n)$</li>
<li>这里的数据元素$a_i(1&lt;=i&lt;=n)$只是一个抽象的符号，其具体含义在不同的情况下可以不同</li>
</ul>
<p>同一线性表中的元素必定具有相同特性，数据元素间的关系是线性关系。</p>
<p><strong>线性表的逻辑特征</strong></p>
<ul>
<li>从非空的线性表，有且仅有一个开始结点$a_1$，它没有直接前驱，而仅有一个直接后继$a_2$；</li>
<li>有且仅有一个终端结点$a_n$，它没有直接后继，而仅有一个直接前驱$a_{n-1}$</li>
<li>其余的内部结点$a_i(2&lt;=i&lt;=n-1)$都有仅有一个直接前驱$a_{i-1}$和一个直接后继$a_{i+1}$。</li>
</ul>
<p><strong>线性表是一种典型的线性结构。</strong></p>
<h3 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a>案例引入</h3><p>​        <strong>一元多项式的运算：实现两个多项式加、减、乘运算</strong></p>
<p>$P_n(x)=p_0+p_1x+p_2x^2+…+p_nx^n$</p>
<p>例如：$P(x)=10+5z-4x^2+3x^3+2x^4$用数组来表示[10, 5, -4, 3, 2]</p>
<p>$R_n(x)=P_n(x)+Q_m(x)$-&gt;线性表$R=(p_0+q_0,p_1+q_1,…,p_m+q_m,p_{m+1},…p_n)$</p>
<p>​        <strong>稀疏多项式的运算：</strong></p>
<p>$S(x)=1+3x^{10000}+2x^{20000}$</p>
<p>例如：$A(x)=7+3x+9x^8+5z^{17}$$B(X)=8x+22x^7-9x^8$</p>
<p>线性表$A=((7,0),(3,1),(9,8),(5,17))$；线性表$B=((8,1),(22,7),(-9,8))$</p>
<p>$P_n(x)=p_1x^{e1}+p_2x^{e2}+…+p_mx^{em}$-&gt;线性表$P=((p_1,e_1),(p_2,e_2),…,(p_m,e_m))$</p>
<p>​        <strong>图书信息管理系统：</strong>需要的功能：查找、插入、删除、修改、排序、计数</p>
<p><strong>总结</strong></p>
<p>​        线性表中数据元素的类型可以为简单类型，也可以为复杂类型。许多实际应用问题所涉及的基本操作有很大相似性，不应为每个具体应用单独编写一个程序。从具体应用中抽象出共性的逻辑结构和基本操作(抽象数据类型)，然后实现其存储结构和基本操作。</p>
<h3 id="线性的类型定义"><a href="#线性的类型定义" class="headerlink" title="线性的类型定义"></a>线性的类型定义</h3><p><strong>基本操作</strong></p>
<ul>
<li>InitList(&amp;L)：构造一个空的线性表L</li>
<li>DestroyList(&amp;L)：销毁线性表L</li>
<li>ClearList(&amp;L)：将线性表L重置为空表</li>
<li>ListEmpty(&amp;L)：若线性表L为空表，则返回true；否则返回false</li>
<li>ListLength(&amp;L)：返回线性表L中的数据元素个数</li>
<li>GetElem(L,i,&amp;e)：用e返回线性表L中第i个数据元素的值</li>
<li>LocateElem(L,e,compare())：返回L中第一个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0。</li>
<li>PriorElem(L,cur_e,&amp;pre_e)：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义</li>
<li>NextElem(L,cur_e,&amp;next_e)：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败；next_e无意义</li>
<li>ListInsert(&amp;L,i,e)：在L的第i个位置之前插入新的数据元素e，L的长度+1</li>
<li>ListDelete(&amp;L,i,&amp;e)：删除L的第i个数据元素，并用e返回其值，L的长度-1</li>
<li>ListTraverse(&amp;L,visited())：依次对线性表中每个元素调用visited()</li>
</ul>
<p>以上所提及的运算是逻辑结构上定义的运算。只要给出这些运算的功能是“做什么”，至于“如何做”等实现细节，只有待确定了存储结构之后才考虑。</p>
<h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><p><strong>顺序存储结构</strong></p>
<p>​        线性表的顺序表示又称为顺序存储结构或顺序映像。<br>​        <strong>顺序存储定义</strong>：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。线性表顺序存储结构占用一片连续的存储空间。知道某个元素的存储位置就可以计算其他元素的存储位置。</p>
<p><strong>顺序表中元素存储位置的计算</strong></p>
<p>​        假设线性表的每个元素需占l个存储单元，则第i+1个数据元素的存储位置和第i个数据元素的存储位置之间满足关系：$LOC(a_{i+1})=LOC(a_i) + l$。由此，所有数据元素的存储位置均可由第一个数据元素的存储位置得到：$LOC(a_i)=LOC(a_1) +(i-1)\times l$</p>
<p>​        顺序表的特点：以物理位置相邻表示逻辑关系。任一元素均可随机存取。</p>
<p><strong>顺序表的顺序存储表示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType elem[LIST_INIT_SIZE];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>多项式的顺序存储结构类型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> p;<span class="comment">//系数</span></span><br><span class="line">    <span class="keyword">int</span> e;<span class="comment">//指数</span></span><br><span class="line">&#125;Polynomial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Polynomial *elem;<span class="comment">//存储空间基地址</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//多项式中当前项的个数</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p><strong>顺序表基本操作的实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.elem= <span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.elem) <span class="keyword">delete</span> L.elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(SqList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SqList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的取值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=L.elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机存取</span></span><br></pre></td></tr></table></figure>

<p><strong>顺序表的查找</strong></p>
<p>​        在线性表L中查找与指定值e相同的数据元素的位置；从表的一端开始，逐个进行记录关键字和给定值的比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(L.elem[i] == e) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最坏时间复杂度：O(N);空间复杂度：O(1)</span></span><br></pre></td></tr></table></figure>

<p>​        平均查找长度ASL(Average Search Length)：为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值叫做查找算法的平均查找长度。<br>$$<br>ASL=\sum_{i=1}^n P_iC_i<br>$$<br>若每个记录的查找概率相等则：<br>$$<br>ASL=\sum_{i=1}^n\frac{1}{n}C_i=\frac{1}{n}\frac{(1+n)n}{2}=\frac{n+1}{2}<br>$$<br>顺序表的平均查找时间复杂度为O(n)</p>
<p><strong>顺序表的插入</strong></p>
<p>插入不同的位置：插入位置在最后，插入位置在中间，插入位置在最前面。</p>
<p>算法思想：①判断插入位置是否合理；②判断顺序表存储空间是否满，若已满返回ERROR；③将第n至第i位的元素依次向后移动一个位置，空出第i个位置；④将要插入的新元素e放入第i个位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(L.length==MAXSIZE) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span>(j=L.length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">        L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line">    L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序表的插入算法分析：</strong></p>
<ul>
<li>若插入在尾节点之后，则根本无需移动</li>
<li>若插入在首结点之前，则表中元素全部后移</li>
<li>考虑在各种位置插入的平均移动次数为：</li>
</ul>
<p>$$<br>E_{ins}=\frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac{1}{n+1}\frac{n(n+1)}{2}=\frac{n}{2}<br>$$</p>
<p>顺序表插入算法的平均时间复杂度为O(n)</p>
<p><strong>顺序表的删除</strong></p>
<p>删除不同的位置：删除位置在最后，删除位置在中间，删除位置在最前面</p>
<p>算法思想：①判断删除位置i是否合法；②将删除的元素保留；③将第i+1至第n位的元素依次向前移动一个位置；④表长减一，删除成功返回OK</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListRemove_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span>(j=i; j&lt;=L.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        L.elem[j<span class="number">-1</span>]=L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序表的删除算法分析：</strong></p>
<ul>
<li>若删除尾节点，则根本无序移动</li>
<li>若删除首结点，则表中n-1个元素全部前移</li>
<li>若要考虑在各种位置上的平均移动次数为：</li>
</ul>
<p>$$<br>E_{del}=\frac{1}{n}\sum_{i=1}^n(n-i)=\frac{1}{n}\frac{(0+n-1)n}{2}=\frac{n-1}{2}<br>$$</p>
<p>顺序表的删除算法的平均时间复杂度为：O(n)</p>
<p><strong>总结：</strong></p>
<p>​        顺序表的特点：①利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致；②在访问线性表时，可以快速计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等。这种存取元素的方法被称为随机存取法。</p>
<p>​        顺序表的操作算法分析：<br>时间复杂度：插入、查找、删除算法的平均时间复杂度为O(n)<br>空间复杂度：显然，顺序表操作算法的空间复杂度S(n)=O(1)</p>
<p>顺序表的优点：</p>
<ul>
<li>存储密度大(结点本身所占存储量/结点结构所占存储量)</li>
<li>可以随机存取表中任一元素</li>
</ul>
<p>顺序表的缺点：</p>
<ul>
<li>在插入、删除某一个元素时，需要移动大量元素</li>
<li>浪费存储空间</li>
<li>属于静态存储形式，数据元素的个数不能自由扩张</li>
</ul>
<h3 id="线性表的链式表示和实现"><a href="#线性表的链式表示和实现" class="headerlink" title="线性表的链式表示和实现"></a>线性表的链式表示和实现</h3><p><strong>链式存储结构</strong></p>
<p>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻<br>线性表的链式表示又称为非顺序映像或链式映像。</p>
<ul>
<li>用一组物理位置任意的存储单元来存放线性表的数据元素。</li>
<li>这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上的。</li>
<li>链表中元素的逻辑次序和物理次序不一定相同。</li>
</ul>
<p><strong>与链式存储有关的术语</strong></p>
<ul>
<li>结点：数据元素的存储映像。由数据域和指针域两部分组成</li>
<li>链表：n个结点由指针链组成的一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构。</li>
</ul>
<p><strong>单链表、双链表、循环链表：</strong></p>
<ul>
<li>结点只有一个指针域的链表，称为单链表或线性链表</li>
<li>结点有两个指针域的链表，称为双链表</li>
<li>首尾相接的链表称为循环链表</li>
</ul>
<p><strong>头指针、头结点和首元结点：</strong></p>
<ul>
<li>头指针：是指向链表中第一个结点的指针</li>
<li>首元结点：是指链表中存储第一个数据元素$a_1$的结点</li>
<li>头结点：是在链表的首元结点之前附设的一个结点</li>
</ul>
<p><strong>链表的存储结构示意图有以下两种形式：</strong></p>
<ul>
<li>不带头结点</li>
<li>带头结点</li>
</ul>
<p><strong>如何表示空表？</strong></p>
<p>无头结点时，头指针为空时表示空表；有头结点时，当头结点的指针域为空表示空表。</p>
<p><strong>链表中设置头结点有什么好处？</strong></p>
<ul>
<li>便于首元结点的处理：首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理。</li>
<li>便于空表和非空表的统一处理：无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。</li>
</ul>
<p><strong>头结点的数据域内装的是什么？</strong></p>
<p>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。</p>
<p><strong>链表(链式存储结构)的特点：</strong></p>
<ul>
<li>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻</li>
<li>访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等</li>
</ul>
<h4 id="单链表的定义和表示"><a href="#单链表的定义和表示" class="headerlink" title="单链表的定义和表示"></a>单链表的定义和表示</h4><p>单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名若头指针名是L，则把链表称为表L。</p>
<p><strong>单链表的存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">next</span>;</span><span class="comment">//结点的指针域</span></span><br><span class="line">&#125;Lnode, *LinkList;</span><br></pre></td></tr></table></figure>

<p>例如，存储学生学号、姓名、成绩的单链表结点类型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Struct student&#123;</span><br><span class="line">    <span class="keyword">char</span> num[<span class="number">8</span>];<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">8</span>];<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> score;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;Lnode, *LinkList;</span><br></pre></td></tr></table></figure>

<p><strong>单链表基本操作的实现</strong></p>
<p><strong>单链表的初始化：</strong>构造一个空表<br>算法步骤：①生成新结点作为头结点，用头指针L指向头结点；②将头结点的指针域置空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断链表是否为空：</strong><br>算法思路：判断头结点指针域是否为空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单链表的销毁：</strong>链表销毁后不存在<br>算法思路：从头指针开始，依次释放所有结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    Lnode *p;</span><br><span class="line">    <span class="keyword">while</span>(L)&#123;</span><br><span class="line">        p=L;</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>清空链表：</strong>链表仍存在，但链表中无元素，成为空链表(头指针和头结点仍然在)<br>算法思路：依次释放所有结点，并将头结点指针域设置为空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">clearList_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    Lnode *p, *q;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        q=p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p=q;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>求单链表的表长</strong><br>算法思路：从首元结点开始，依次计数所有结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength_L</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取值</strong>——取单链表中的第i个元素的内容<br>算法思路：从链表的头指针出发，顺着链域next逐个结点向下搜索，直到搜索到第i哥结点为止。因此，链表不是随机存取结构。<br>算法步骤：①从第一个结点顺链扫描，用指针p指向当前扫描到的结点，p初值p=L-&gt;next；②j做计数器，累计当前扫描过的结点数，j初值为1；③当p指向扫描到的下一结点，计数器j+1；④当j==i时，p所指的结点就是要找的第i个结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">getElem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>, j&lt;i &amp;&amp; p; j++)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找：</strong>①按值查找，根据指定数据获取该数据所在的位置；②按值查找，根据指定数据获取该数据所在的位置序号。</p>
<p>按值查找：<br>算法步骤：①从第一个结点起，依次和e相比较；②如果找到一个其值与e相等的数据元素，则返回其在链表中的“位置”或地址；③如果查遍整个链表都没有找到其值和e相等的元素，则返回0或“NULL”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Lnode *<span class="title">LocateElem_L</span><span class="params">(LinkList L, Elemtype e)</span></span>&#123;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp;p-&gt;data!=e)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateELem_L</span><span class="params">(LinkList L, Elemtype e)</span></span>&#123;</span><br><span class="line">    p=L-&gt;next;j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data!=e)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p) <span class="keyword">return</span> j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入</strong>—在第i个结点前插入值为e的新结点</p>
<p>算法步骤：①首先找到$a_{i-1}$的存储位置p；②生成一个数据域为e的新结点s；③插入新结点：(1)新结点的指针域指向结点$a_i$【s-&gt;next=p-&gt;next】；(2)结点$a_{i-1}$的指针域指向新结点【p-&gt;next = s】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    p=L;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">    s=<span class="keyword">new</span> LNode;</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong>——删除第i个结点<br>算法步骤：①首先找到$a_{i-1}$的存储位置p，保存要删除的$a_i$的值；②令p-&gt;next指向$a_{i+1}$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    p=L;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next  &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        ==j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="number">-1</span>)<span class="keyword">return</span> ERROR;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    e=q-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单链表的查找、插入、删除算法时间效率分析</strong></p>
<p>查找：O(n)；插入和删除：O(1)，但是，如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n)。</p>
<p><strong>单链表的建立</strong></p>
<p>头插法：每次把新元素插在链表头部，也叫前插法。</p>
<p>算法步骤：①从一个空表开始，重复读入数据；②生成新结点，将读入数据存放到新结点的数据域中；③从最后一个结点开始，依次将各结点插入到链表的前端</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_H</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">        p=<span class="keyword">new</span> LNode;</span><br><span class="line">        cin&gt;&gt;p-&gt;data;</span><br><span class="line">        p-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为：O(n)</p>
<p>尾插法：元素插入在链表尾部，也叫后插法。</p>
<p>算法步骤：①从一个空表L开始，将新结点逐个插入到链表的尾部，尾指针r指向链表的尾节点；②初始化，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾节点后，r指向新结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_R</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r=L;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        p=<span class="keyword">new</span> LNode;</span><br><span class="line">        cin&gt;&gt;p-&gt;data;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next=p;</span><br><span class="line">        r=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环链表</strong></p>
<p>​        循环链表是一种头尾相接的链表。</p>
<p>优点：从表中的任一结点出发均可以找到表中其他结点。</p>
<p>注意：由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p-&gt;next是否为空，而是判断它们是否等于头指针。</p>
<p><strong>带尾指针的循环链表的合并</strong></p>
<p>分析操作：p存表头结点、Tb表头链接到Ta表尾，释放Tb表头结点，修改指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Connect</span><span class="params">(LinkList Ta, Linklist Tb)</span></span>&#123;</span><br><span class="line">    p=Ta-&gt;next;</span><br><span class="line">    Ta-&gt;next=Tb-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> Tb-&gt;next;</span><br><span class="line">    Tb-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> Tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为：O(1)</p>
<p><strong>双向链表</strong></p>
<p>双向链表：在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了有两个方向不同的链，故称为双向链表。</p>
<p>双向链表的结构定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure>

<p><strong>双向循环链表</strong></p>
<p>和单链表的循环链表类似，双向链表也可以有循环表：让头结点的前驱指针指向链表的最后一个结点；让最后一个结点的后继指针指向头结点。</p>
<p>双向链表结构的对称性：p-&gt;prior-&gt;next=p=p-&gt;next-&gt;prior</p>
<p>在双向链表中有些操作(如：ListLength、GetElem等)，因仅涉及一个方向的指针，故它们的算法与线性链表的相同。但在插入、删除时，则需要同时修改两个方向上的指针，两者的操作的时间复杂度均为O(n)。</p>
<p><strong>双向链表的插入</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L, Int i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(p=<span class="built_in">GetElemp_DuL</span>(L,i))) ERROR;</span><br><span class="line">    s=<span class="keyword">new</span> DuLNode;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;prior=p-&gt;prior;</span><br><span class="line">    s-&gt;next=p;</span><br><span class="line">    p-&gt;prior-&gt;next=s;</span><br><span class="line">    p-&gt;prior=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双向链表的删除</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDelete_DuL</span><span class="params">(DuLink &amp;L, Int i, Elemtyle &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(p=<span class="built_in">GetElemP_DuL</span>(L,i))) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单链表、循环链表、双向链表的时间效率比较</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>查找表头结点(首元结点)</th>
<th>查找表尾结点</th>
<th>查找结点*p的前驱结点</th>
</tr>
</thead>
<tbody><tr>
<td>带头结点的单链表L</td>
<td>L-&gt;next时间复杂度O(1)</td>
<td>从L-&gt;next依次向后遍历时间复杂度O(n)</td>
<td>通过p-&gt;next无法找到其前驱</td>
</tr>
<tr>
<td>带头结点仅设头指针L的循环单链表</td>
<td>L-&gt;next时间复杂度O(1)</td>
<td>从L-&gt;next依次向后遍历时间复杂度O(n)</td>
<td>通过p-&gt;next可以找到其前驱时间复杂度O(n)</td>
</tr>
<tr>
<td>带头结点仅设尾指针R的循环单链表</td>
<td>R-&gt;next时间复杂度O(1)</td>
<td>R时间复杂度为O(1)</td>
<td>通过p-&gt;next可以找到其前驱时间复杂度O(n)</td>
</tr>
<tr>
<td>带头结点的双向循环链表L</td>
<td>L-&gt;next时间复杂度O(1)</td>
<td>L-&gt;prior时间复杂度O(1)</td>
<td>p-&gt;prior时间复杂度O(1)</td>
</tr>
</tbody></table>
<h3 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h3><ul>
<li>链式存储结构的优点：<ul>
<li>结点空间可以动态申请和释放</li>
<li>数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素</li>
</ul>
</li>
<li>链式存储的缺点：<ul>
<li>存储密度小，每个结点的指针域需要额外占用存储空间。当每个结点的数据域所占字节不多时，指针域所占存储空间的必重显得很大。<ul>
<li>存储密度：是指结点数据本身所占的存储量和整个结点结构中所占的存储量之比。</li>
</ul>
</li>
<li>链式存储结构是非随机存取结构。对任一结点的操作都要从头指针依指针链查找到该结点，这增加了散发的复杂度。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>比较项目</th>
<th>存储结构</th>
<th>顺序表</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>空间</td>
<td>存储空间</td>
<td>预先分配，会导致空间闲置或溢出现象</td>
<td>动态分配，不会出现存储空间闲置或溢出现象</td>
</tr>
<tr>
<td></td>
<td>存储密度</td>
<td>不用为表示结点间的逻辑关系而增加额外的存储开销，存储密度等于1</td>
<td>需要借助指针来体现元素间的逻辑关系，存储密度小于1</td>
</tr>
<tr>
<td>时间</td>
<td>存取元素</td>
<td>随机存取，按位置访问元素的时间复杂度为O(1)</td>
<td>顺序存取，按位置访问元素时间复杂度为O(n)</td>
</tr>
<tr>
<td></td>
<td>插入和删除</td>
<td>平均移动约表中一半元素，时间复杂度为O(n)</td>
<td>不需要移动元素，确定插入、删除位置后，时间复杂度为O(1)</td>
</tr>
<tr>
<td>适用情况</td>
<td></td>
<td>表长变化不大，且能事先确定变化的范围；很少进行插入或删除操作，经常按元素位置序号访问数据元素</td>
<td>长度变化较大；频繁进行插入或删除操作</td>
</tr>
</tbody></table>
<h3 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h3><p><strong>线性表的合并</strong></p>
<p>假设利用两个线性表La和Lb分别表示两个集合A和B，现要求一个新的集合A=AUB</p>
<p>算法步骤：依次取出Lb中的元素，执行以下操作：在La中查找该元素；如果找不到，则将其插入到La的最后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(List &amp;La, List Lb)</span></span>&#123;</span><br><span class="line">    La_len=<span class="built_in">ListLength</span>(La);</span><br><span class="line">    Lb_len=<span class="built_in">ListLength</span>(Lb);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=Lb_len;i++)&#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(Lb,i,e);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(La,e))</span><br><span class="line">            <span class="built_in">ListInsert</span>(&amp;La, ++La_len,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有序表的合并</strong></p>
<p>一致线性表La和Lb中的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc，且Lc中的数据元素按值非递减有序排列。</p>
<p>算法步骤：创建一个空表Lc；依次从La或Lb中摘取元素较小的结点插入到Lc表的最后，直至其中一个表空为止；继续将La或Lb其中一个表中的剩余结点插入在Lc表的最后。</p>
<p><strong>顺序表的实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList LA, SqList LB, SqList &amp;LC)</span></span>&#123;</span><br><span class="line">    pa=LA.elem;</span><br><span class="line">    pb=LB.elem;</span><br><span class="line">    LC.length=LA.length+LB.length;</span><br><span class="line">    LC.elem=<span class="keyword">new</span> ElemTupe[LC.length];</span><br><span class="line">    pc=LC.elem;</span><br><span class="line">    pa_last=LA.elem+LA.length<span class="number">-1</span>;</span><br><span class="line">    pb_last=LB.elem+LB.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pa &lt;=pa_last &amp;&amp; pb &lt;= pb_last)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*pa &lt;= *pb) *pc++ = *pa++;</span><br><span class="line">        <span class="keyword">else</span> *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pa &lt;= pa_last) *pc++ = *pa++;</span><br><span class="line">    <span class="keyword">while</span>(pb &lt;= pb_last) *pc++ = *pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为：O(ListLength(La) + ListLength(Lb))；算法的空间复杂度是：O(ListLength(La) + ListLength(Lb))</p>
<p><strong>链表的实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">    pa=La-&gt;next;</span><br><span class="line">    pb=Lb-&gt;next;</span><br><span class="line">    pc=Lc=La;</span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class="line">            pc-&gt;next=pa;</span><br><span class="line">            pc=pa;</span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pc-&gt;next=pb;</span><br><span class="line">            pc=pb;</span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next=pa ? pa : pb;</span><br><span class="line">    <span class="keyword">delete</span> Lb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法的时间复杂度为O(ListLength(La) + ListLength(Lb))；空间复杂度为：O(1)。</p>
<h3 id="案例分析与实现"><a href="#案例分析与实现" class="headerlink" title="案例分析与实现"></a>案例分析与实现</h3><h4 id="一元多项式的运算：实现两个多项式加、减、乘运算"><a href="#一元多项式的运算：实现两个多项式加、减、乘运算" class="headerlink" title="一元多项式的运算：实现两个多项式加、减、乘运算"></a>一元多项式的运算：实现两个多项式加、减、乘运算</h4><p>例如：$P_a(x)=10+5x-4x^2+3x^3+2x^4,P_b(x)=-3+8x+4x^2-5x^4+7x^5-2x^6$</p>
<h4 id="稀疏多项式的运算"><a href="#稀疏多项式的运算" class="headerlink" title="稀疏多项式的运算"></a>稀疏多项式的运算</h4><p>例如：$A(x)=7+3x+9x^8+5x^{17}, B(X)=8x+22x^7-9x^8$<br>线性表A=((7,0), (3,1), (9,8), (5,17))；线性表B=((8,1), (22,7), (-9,8))</p>
<p>顺序存储结构实现：<br>算法步骤：创建一个新数组c；分别从头遍历比较a和b的每一项：指数相同，对应系数相加，若其和不为零，则在c中增加一个新项，指数不相同，则将指数较小的项复制到C中；一个多项式已遍历完毕，将另一个剩余项依次复制到c中即可。</p>
<p>链式存储结构实现：<br>算法步骤：①创建一个只有头结点的空链表；②根据多项式的项的个数n，循环n次执行以下操作：1.生成一个新结点*s；2.输入多项式当前项的系数和指数赋给新结点的*s的数据域；设置一个前驱指针pre，用于指向待找到的第一个大于输入项指数的结点的前驱，pre初值指向头结点；3.指针q初始化，指向首元结点；4.顺链向下逐个比较链中当前结点与输入项指数，找到第一个大于输入项指数的结点*q；5.将输入项结点*s插入到结点*q之前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePolyn</span><span class="params">(Polynomial &amp;p, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    P= <span class="keyword">new</span> PNode;</span><br><span class="line">    P-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        s=<span class="keyword">new</span> PNode;</span><br><span class="line">        cin&gt;&gt;s-&gt;coef&gt;&gt;s-&gt;expn;</span><br><span class="line">        pre=P;</span><br><span class="line">        q=P-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q&amp;&amp;q-&gt;expn&lt;s-&gt;expn)&#123;</span><br><span class="line">            pre=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;next=q;</span><br><span class="line">        pre-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相加算法步骤：①指针p1和p2初始化，分别指向pa和pb的首元结点；②p3指向多项式的当前结点，初值为pa的头结点；③当指针p1和p2均未到达相应表尾时，则循环比较p1和p2所指结点对应的指数值，有下列3种情况：(1)当p1-&gt;expn==p2-&gt;expn时，则将两个结点中的系数相加，若和不为零，则修改p1所指结点的系数值，同时删除p2所指结点，若和为零，则删除p1和p2所指结点；当p1-&gt;expn &lt; p2-&gt;expn时，则应摘取p1所指结点插入到“和多项式”链表中去；当p1-&gt;expn &gt; p2-&gt;expn时，则应摘取p2所指结点插入到“和多项式”链表中去；④将非空多项式的剩余段插入到p3所指结点之后；⑤释放Pb的头结点。</p>
<hr>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈和队列的定义和特点"><a href="#栈和队列的定义和特点" class="headerlink" title="栈和队列的定义和特点"></a>栈和队列的定义和特点</h3><ul>
<li>栈和队列是两种常用、重要的数据结构</li>
<li>栈和队列是限定插入和删除只能在表的“端点”进行的线性表</li>
<li>栈和队列是线性表的子集(是插入和删除位置受限的线性表)</li>
</ul>
<p><strong>栈</strong></p>
<p>​        由于栈的操作具有后进先出的固有特性，使得栈成为程序设计中的有用工具。另外，若问题求解的过程具有“后进先出”的天然特性的话，则求解的算法中也必然需要利用“栈”。</p>
<p><strong>栈的定义和特点</strong></p>
<p>​        栈(Stack)是一个特殊的线性表，是限定仅在一端(通常是表尾)进行插入和删除操作的线性表。又称为后进先出(Last In First Out)的线性表，简称LIFO结构。</p>
<p>​        栈是仅在表尾进行插入、删除操作的线性表。表尾称为栈顶Top；表头称为栈底Base。插入元素到栈顶的操作，称为入栈。从栈顶删除最后一个元素的操作，称为出栈。</p>
<p><strong>队列</strong></p>
<p>​        由于队列的操作具有先进先出的特性，使得队列称为程序设计中解决类似排队问题的有用工具。</p>
<p><strong>队列的定义和特点</strong></p>
<p>​        队列(queue)是一种先进先出(First In First Out，FIFO)的线性表。在表一端插入(表尾)，在另一端(表头)删除。</p>
<h3 id="案例引入-1"><a href="#案例引入-1" class="headerlink" title="案例引入"></a>案例引入</h3><p><strong>进制转换</strong></p>
<p>十进制整数N向其它进制数d(二、八、十六)的转换是计算机实现计算的基本问题。</p>
<p>例如：把十进制数159转换成八进制数。</p>
<p><strong>括号匹配的检验</strong></p>
<p>假设表达式中允许包含两种括号：圆括号和方括号；其嵌套的顺序随意。</p>
<p>算法思路：可以利用一个栈结构保存每个出现的左括号，当遇到右括号时，从栈中弹出左括号，检验其匹配情况；在检验过程中，若遇到以下几种情况之一，就可以得出括号不匹配的结论：(1)当遇到某一个右括号时，栈已空，说明到目前为止，右括号多于左括号；(2)从栈中弹出的左括号与当前检验的右括号类型不同，说明出现了括号交叉情况；(3)算数表达式输入完毕，但栈中还没没有匹配的左括号，说明左括号多于右括号。</p>
<p><strong>表达式求值</strong></p>
<p>表达式求值是程序设计语言中一个最基本的问题，它的实现也需要运用栈。这里介绍的算法是由运算符优先级确定运算顺序的对表达式求值算法。</p>
<p>算法思路：为了实现表达式求值。需要两个栈：一个是算符栈OPTR，用于寄存运算符；另一个称为操作数OPND，用于寄存运算数和运算结果。</p>
<p>求值的处理过程是自左向右扫描表达式的每一个字符：</p>
<ul>
<li>当扫描到的是运算数，则将其压入栈OPND</li>
<li>当扫描到的是运算符时<ul>
<li>若这个运算符比OPTR栈顶运算符的优先级高，则入栈OPTP，继续向后处理</li>
<li>若这个运算符比ORTR栈顶运算符优先级低，则从OPND栈中弹出两个运算数，从栈OPTR中弹出栈顶运算符进行运算，并将运算结果压入栈OPND。</li>
</ul>
</li>
<li>继续处理当前字符，知道遇到结束符为止。</li>
</ul>
<p><strong>舞伴问题</strong></p>
<p>​        首先构造两个队列；依次将头元素出队配成舞伴；某队为空，则另外一队等待着则是下一舞曲第一个可获得舞伴的人。</p>
<h3 id="栈的表示和操作的实现"><a href="#栈的表示和操作的实现" class="headerlink" title="栈的表示和操作的实现"></a>栈的表示和操作的实现</h3><ul>
<li>InitStack(&amp;s)初始化操作：构造一个空栈S</li>
<li>DestroyStack(&amp;S)销毁栈操作：栈S被销毁</li>
<li>StackEmpty(S)判定S是否为空战</li>
<li>StackLength(S)求栈的长度</li>
<li>GetTop(S, &amp;e)取栈顶元素</li>
<li>ClearStack(&amp;S)栈置空操作</li>
<li>Push(&amp;S, e)入栈操作</li>
<li>Pop(&amp;S, &amp;e)出栈操作</li>
</ul>
<p><strong>栈的表示和实现</strong></p>
<p>​        由于栈本身就是线性表，于是栈也有顺序存储和链式存储两种实现方式。栈的顺序存储——顺序栈；栈的链式存储——链栈。</p>
<h4 id="顺序栈的表示和实现"><a href="#顺序栈的表示和实现" class="headerlink" title="顺序栈的表示和实现"></a>顺序栈的表示和实现</h4><p>​        存储方式：同一般线性表的顺序存储结构完全相同，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。栈底一般在低地址段。</p>
<p>​        附设top指针，指示栈顶元素在顺序栈中的位置(但是，为了方便操作，通常top指示真正的栈顶元素之上的下标地址)；另设base指针，指示栈底元素在顺序栈中的位置。另外，用stacksize表示栈可使用的最大容量。</p>
<p>​        使用数组作为顺序栈存储方式的特点：简单，方便，但易产生溢出(数组大小固定)。上溢(overflow)：栈已经满，又要压入元素；下溢(underflow)：栈已经空，还要弹出元素。注：上溢是一种错误，使问题的处理无法进行；而下溢一般认为是一种结束条件，即问题处理结束。</p>
<p><strong>顺序栈的表示</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;<span class="comment">//栈底指针</span></span><br><span class="line">    SElemType *top;<span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;<span class="comment">//栈可用最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<p><strong>顺序栈的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.base = <span class="keyword">new</span> SElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!S.base)<span class="built_in">exit</span> (OVERFLOW);</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序栈判断栈是否为空</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>求顺序栈的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stacklength</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top - S.base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>清空顺序栈</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base) S.top = S.base;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>销毁顺序栈</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base)&#123;</span><br><span class="line">        <span class="keyword">delete</span> S.base;</span><br><span class="line">        S.stacksize=<span class="number">0</span>;</span><br><span class="line">        S.base = S.top = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序栈的入栈</strong></p>
<p>判断是否满栈，若满则出错；元素e压入栈顶；栈顶指针+1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base == S.stacksize)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顺序栈的出栈</strong></p>
<p>判断是否栈空，若空则出错；获取栈顶元素e；栈顶指针-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链栈的表示和实现"><a href="#链栈的表示和实现" class="headerlink" title="链栈的表示和实现"></a>链栈的表示和实现</h4><p>链栈是运算受限的单链表，只能在链表头部进行操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStack;</span><br><span class="line">LinkStack S;</span><br></pre></td></tr></table></figure>

<p>​        链表的头指针就是栈顶；不需要头结点；基本不存在栈满的情况；空栈相当于头指针指向空；插入和删除仅在栈顶处执行。</p>
<p><strong>链栈的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span></span>&#123;</span><br><span class="line">    S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断链栈是否为空</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链栈的入栈</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span></span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> StackNode;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S;</span><br><span class="line">    S=p;</span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链栈的出栈</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S, SElemtype &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    p=S;</span><br><span class="line">    S=S-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取栈顶元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h3><p>递归的定义：</p>
<ul>
<li><p>若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的；</p>
</li>
<li><p>若一个过程直接地或间接地调用自己，则称这个过程是递归的过程。</p>
<ul>
<li>递归求n的阶乘：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fact</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * <span class="built_in">Fact</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>以下三种情况常常用到递归方法：</strong></p>
<ul>
<li>递归定义的数学函数：<ul>
<li>阶乘函数</li>
<li>2阶Fibonaci数列：</li>
</ul>
</li>
<li>具有递归特性的数据结构：<ul>
<li>二叉树</li>
<li>广义表</li>
</ul>
</li>
<li>可递归求解的问题<ul>
<li>迷宫问题</li>
<li>Hanoi塔问题</li>
</ul>
</li>
</ul>
<p><strong>递归问题——用分治法求解</strong><br>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解。</p>
<p>必备的三个条件：</p>
<ul>
<li>能将一个问题转变成一个新的问题，而新的问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的。</li>
<li>可以通过上述转化而使问题简化</li>
<li>必须有一个明确的递归出口，或者递归的边界</li>
</ul>
<p><strong>分治法求解递归问题算法的一般形式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(参数列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(递归结束条件)	可直接求解步骤;</span><br><span class="line">        <span class="keyword">else</span> p(较小的参数);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数调用的过程：</strong></p>
<p>调用前，系统完成：</p>
<ul>
<li>将实参、返回地址等传递给被调用函数</li>
<li>为被调用函数的局部变量分配存储区</li>
<li>将控制转移到被调用函数的入口</li>
</ul>
<p>调用后，系统完成：</p>
<ul>
<li>保存被调用函数的计算结果</li>
<li>释放被调用函数的数据区</li>
<li>依照被调用函数保存的返回地址将控制转移到调用函数</li>
</ul>
<p>当多个函数构成嵌套调用时：遵循后调用的先返回。</p>
<p>递归的优缺点：</p>
<ul>
<li>优点：结构清晰，程序易读</li>
<li>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销较大。</li>
</ul>
<p>递归-&gt;非递归：</p>
<ul>
<li><p>方法1：尾递归、单项递归-&gt;循环结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fact</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n *<span class="built_in">Fact</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fact</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) t=t*i;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fib</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Fib</span>(n<span class="number">-1</span>)  +<span class="built_in">Fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fib</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t1 = <span class="number">1</span>;t2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">3</span> i &lt;= n; i++)&#123;</span><br><span class="line">            t3 = t1+t2;</span><br><span class="line">            t1 = t2; t2=t3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自用栈模拟系统的运行时栈</p>
</li>
</ul>
<h3 id="队列的表示和操作的实现"><a href="#队列的表示和操作的实现" class="headerlink" title="队列的表示和操作的实现"></a>队列的表示和操作的实现</h3><p><strong>相关术语</strong></p>
<ul>
<li>队列(Queue)是仅在表尾进行插入操作，在表头进行删除操作的线性表。</li>
<li>表尾即$a_n$端，称为队尾；表头即$a_1$端，称为队头。</li>
<li>它是一种先进先出(FIFO)的线性表。</li>
<li>插入元素称为入队；删除元素称为出队。</li>
<li>队列的存储结构为链队或顺序队(常用循环顺序队)</li>
</ul>
<p><strong>队列的相关概念</strong></p>
<ul>
<li>定义：只能在表的一端进行插入运算，在表的另一端进行删除运算的线性表。</li>
<li>逻辑结构：与同线性表相同，仍为一对一关系。</li>
<li>存储结构：顺序队和链队。</li>
<li>运算规则：只能在队首和队尾运算，且访问结点时依照先进先出(FIFO)的原则。</li>
<li>实现方式：关键是掌握入队和出队操作，具体实现依照顺序队和链队的不同而不同。</li>
</ul>
<p><strong>队列的常见应用</strong></p>
<ul>
<li>脱机打印输出：按申请的先后顺序依次输出</li>
<li>多用户系统中，多个用户排成队，分时地循环使用CPU和主存</li>
<li>按用户的优先级排成多个队，每个优先级一个队列</li>
<li>实时控制系统中，信号按接收的先后顺序依次处理</li>
<li>网络电文传输，按到达的时间先后顺序依次进行</li>
</ul>
<p><strong>队列的抽象数据类型定义</strong></p>
<p><strong>队列的顺序表示</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 100</span></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QElemType *base;<span class="comment">//初始化的动态分配存储空间</span></span><br><span class="line">    <span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line">    <span class="keyword">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<p>存在的问题：</p>
<p>设数组大小为MAXQSIZE，当rear=MAXQSIZE时，发生溢出；若front=0，rear=MAXQSIZE时再入队，则发生真溢出；当front$\neq 0$，rear=MAXQSIZE时，再入队，则发生假溢出。</p>
<p>解决假上溢的方法：</p>
<p>1.将队中元素依次向队头方向移动。缺点：浪费时间。每移动一次，队中元素都要移动</p>
<p>2.将队空间设想成一个循环的表即分配给队列的m个存储单元可以循环使用，当rear为maxqsize时，若向量的开始端空着，又可以从头使用空着空间。当front为maxqsize时，也是一样。</p>
<p>队空队满的判断：1.另外设一个标志以区别队空、队满；2.另一个变量，记录元素个数；3.少用一个元素空间</p>
<p>少用一个元素空间：队空：front==rear；队满：(rear+1)%MAXQSIZE==front</p>
<p><strong>循环队列的操作——队列的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.base = <span class="keyword">new</span> QElemType[MAXQSIZE];<span class="comment">//分配数组空间</span></span><br><span class="line">    <span class="keyword">if</span>(!Q.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">    Q.front=Q.rear = <span class="number">0</span>;<span class="comment">//头指针尾指针置为0，队列为空</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>求队列的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环队列入队</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, QElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MAXQSIZE == Q.front) <span class="keyword">return</span> ERROR;<span class="comment">//队满</span></span><br><span class="line">    Q.base[Q.rear] = e;</span><br><span class="line">    Q.rear = (Q.rear+<span class="number">1</span>)%MAXQSIZE;<span class="comment">//队尾指针+1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环队列出队</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.front == Q.rear)) <span class="keyword">return</span> ERROR;<span class="comment">//队空</span></span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取队头元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetHead</span><span class="params">(SqQuere Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front != Q.rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> Q.base[Q.front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>队列的链式表示和实现</strong></p>
<p>若用户无法估计所用队列的长度，则宜采用链队列</p>
<p><strong>链队列的类型定义</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span>&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QuenePtr;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QuenePtr front;<span class="comment">//队头指针</span></span><br><span class="line">    QuenePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<p><strong>链队列初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>销毁链队列</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(Q.front)&#123;</span><br><span class="line">        p = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q.front);</span><br><span class="line">        Q.front = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将元素e入队</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span>&#123;</span><br><span class="line">    p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    P-&gt;data = e;</span><br><span class="line">    p-&gt;next=null;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链队列出队</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    P = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)</span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链队列的队头元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q, QElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = Q.front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="串、数组和广义表"><a href="#串、数组和广义表" class="headerlink" title="串、数组和广义表"></a>串、数组和广义表</h2><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h4><p>串(String)——零个或多个任意字符串组成的有限序列</p>
<p>字串：串中任意个连续字符组成的子序列称为该串的子串。真子串是指不包含自身的所有子串。</p>
<p>主串：包含子串的串相应地称为主串</p>
<p>字符位置：字符在序列中的序号为该字符在串中的位置</p>
<p>字串位置：子串第一个字符在主串中的位置</p>
<p>空格串：由一个或多个空格串组成的串</p>
<p>串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。所有的空串都是相等的。</p>
<h4 id="案例引入-2"><a href="#案例引入-2" class="headerlink" title="案例引入"></a>案例引入</h4><p>串的应用非常广泛，计算机上的非数值处理的对象大部分是字符串数据，例如：文字编辑、符号处理、各种信息处理系统等等。</p>
<p>案例：病毒感染检测</p>
<p>研究者将人的DNA和病毒DNA均表示成由一些字母组成的字符串序列。然后检测某种病毒DNA序列是否在患者的DNA序列中出现过，如果出现过，则此人感染了该病毒，否则没有感染。</p>
<p>例如：假设病毒的DNA序列为baa，患者1的DNA序列为aaabbba，则感染，患者2的DNA序列为babbba，则未感染。(注意，人的DNA序列是线性的，而病毒的DNA序列是环状的)</p>
<h4 id="串的类型定义、存储结构及运算"><a href="#串的类型定义、存储结构及运算" class="headerlink" title="串的类型定义、存储结构及运算"></a>串的类型定义、存储结构及运算</h4><p>串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构。</p>
<p><strong>串的顺序存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN+<span class="number">1</span>];<span class="comment">//存储串的一维数组</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//串的当前长度长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>

<p><strong>串的链式存储结构</strong></p>
<p>优点：操作方便；缺点：存储密度较低。【存储密度=串所占的存储/实际分配的存储】</p>
<p>可以将多个字符存放在一个结点中，以克服其缺点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Chunk *head, *tail;<span class="comment">//串的头指针和尾指针</span></span><br><span class="line">    <span class="keyword">int</span> curlen;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;LString;<span class="comment">//字符串的块链结构</span></span><br></pre></td></tr></table></figure>

<p><strong>串的模式匹配算法</strong></p>
<p>算法的目的：确定主串中所含子串(模式串)第一次出现的位置</p>
<p>算法应用：搜索引擎、拼写检查、语言翻译、数据压缩</p>
<p>算法种类：BF算法(Brute-Force，又称古典的、经典的、朴素的、穷举的)、KMP算法(特点：速度快)</p>
<h4 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h4><p><strong>BF算法</strong></p>
<p>Brute-Force简称为BF算法，亦称简单匹配算法。采用穷举法的思路。</p>
<p>算法设计思想：将主串中的第pos个字符和模式串的第一个字符比较；若相等，继续逐个比较后续字符；若不相等，从主串的下一字符起，重新与模式串的第一个字符比较。直到主串中的第一个连续子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。否则，匹配失败，返回值0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(SString S, SString T, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=pos, j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == t.ch[j])&#123;<span class="comment">//主串和子串依次匹配字符</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//主串和子串指针回溯重新开始下一次匹配</span></span><br><span class="line">            i = i-(j<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; S.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> j-i+<span class="number">1</span>;<span class="comment">//返回匹配的第一个字符的下标 i-T.length</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//模板匹配不成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BF算法的时间复杂度：若n为主串长度，m为子串长度；最好的情况：比较m此；最坏情况：主串前面n-m个位置都部分匹配到子串的最后一位，(n-m)*m+m=(n-m+1)*m，若n&gt;&gt;m，则算法复杂度为O(n*m)。</p>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p>在定义next[j]函数，表名当前模式中第j个字符与主串中相应字符“失配”时，在模式中需重新和主串中该字符进行比较和字符的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; T,length) <span class="keyword">return</span> i-T.length;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString T, <span class="keyword">int</span> &amp;next[])</span></span>&#123;</span><br><span class="line">    i = <span class="number">1</span>; next[<span class="number">1</span>] = <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || T.ch[i] == T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="next函数的改进"><a href="#next函数的改进" class="headerlink" title="next函数的改进"></a>next函数的改进</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(SString T, <span class="keyword">int</span> &amp;nextval[])</span></span>&#123;</span><br><span class="line">    i = <span class="number">1</span>; nextval[<span class="number">1</span>] = <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || T,ch[i] == T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(T.ch[i] != T.ch[j])&#123;</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>按一定格式排列起来具有相同类型的数据元素的集合。</p>
<p>一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组。</p>
<p>一维数组的逻辑结构：线性结构。定长的线性表。</p>
<p>声明格式：数据类型 变量名称[长度]</p>
<p>二维数组：若一维数组中的数据元素又是一维数组结构，则称为二维数组。每一个元素既在一个行表中，又在一个列表中。该线性表的每个元素也是一个定长的线性表。</p>
<p>二维数组的逻辑结构：1.非线性结构；2.线性结构定长的线性表</p>
<p>声明格式：数据类型 变量名称[行数][列数]。在C语言中，一个二维数组类型也可以定义为一维数组类型。</p>
<p>三维数组：若二维数组中的元素又是一个一维数组，则称作三维数组。</p>
<p>n维数组：若n-1维数组中的元素又是一个一维数组结构，则称作n维数组。</p>
<p><strong>结论：线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。</strong></p>
<p><strong>数组的特点：结构固定——定义后，维数和维界不再改变。</strong></p>
<p>数组基本操作：除了结构的初始化和销毁之外，只有取元素和修改元素值的操作。</p>
<h4 id="数组的抽象数据类型定义"><a href="#数组的抽象数据类型定义" class="headerlink" title="数组的抽象数据类型定义"></a>数组的抽象数据类型定义</h4><h4 id="数组的顺序存储"><a href="#数组的顺序存储" class="headerlink" title="数组的顺序存储"></a>数组的顺序存储</h4><p>因为数组的特点：结构固定；数组基本操作：一般不做插入和删除操作。所以：一般都是采用顺序存储结构来表示数组。</p>
<p><strong>注意：</strong>数组可以是多维的，但存储元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决多维关系映射到一维关系的问题。</p>
<p><strong>一维数组</strong></p>
<p>例，有数组定义：int a[5]。每个元素占用4字节，假设a[0]存储在2000单元，a[3]地址是多少？2012。LOC(0)=2000，L=4，LOC(3)=LOC(0)+3XL=2012。LOC(i) = LOC(0)+L$\times$i。</p>
<p><strong>二维数组</strong></p>
<p>两种顺序存储方式：1.以行序为主序BASIC、COBOL和PASCAL；2.以列为主序FORTRAN。</p>
<p>以行序为主序：数组元素a[i][j]的存储位置是：LOC(i，j)=LOC(0,0)+(n*i+j)*L</p>
<p><strong>三维数组</strong></p>
<p>按页/行/列存放，页优先的顺序存储。</p>
<p>$LOC(i_1,i_2,i_3)=a+(i_1<em>m_2</em>m_3+i_2*m_3+i_3)*L$</p>
<p><strong>n维数组</strong></p>
<p>$LOC(i_1,i_2,…,i_n)=a+(i_1<em>m_2</em>m_3*…m_n+i_2<em>m_3</em>m_4*…m_n+…+i_{n-1}*m_n+i_n)*L$</p>
<p>例：设有一个二维数组A[m][n]按行优先存储，假设A[0][0]存放位置在$644_{(10)}$，A[2][2]存放在$676_{(10)}$，每个元素占一个空间，问A[3][3]存放在什么位置？</p>
<p>676=x+(2n+2);644=x; ——&gt; n=15 ——&gt; A[3][3]=644+(3*15+3)=692</p>
<p><strong>特殊矩阵的压缩存储</strong></p>
<p>矩阵的常规存储：将矩阵描述为一个二维数组。</p>
<p>矩阵的常规存储的特点：可以对其元素进行随机存取；矩阵运算非常简单；存储的密度为1。</p>
<p>不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素较多</p>
<p><strong>矩阵的压缩存储：</strong>为多个相同的非零元素只分配一个存储空间；对零元素不分配空间。</p>
<p>什么样的矩阵能够压缩存储？一些特殊矩阵，如：对称矩阵、对角矩阵、三角矩阵、稀疏矩阵等。</p>
<p>什么叫稀疏矩阵？矩阵中非零元素的个数较少(一般小于5%)</p>
<p><strong>对称矩阵</strong></p>
<p>特点：在$n\times n$的矩阵a中，满足如下性质：$a_{ij}=a_{ji}(1\leq i, j\leq n)$</p>
<p>存储方法：只存储下(或者上)三角(包括主对角线)的数据元素。共占用n(n+1)/2个元素空间。</p>
<p>可以以行序为主序将元素存放在一个一维数组sa[n(n+1)/2]中。$a_{ij}=(1+i)(i)/2+j=i(i+1)/2+j$</p>
<p><strong>三角矩阵</strong></p>
<p>特点：对角线以下(或者以上)的数据元素(不包括对角线)全部为常数C。</p>
<p>存储方法c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间：sa[n(n+1)/2+1]</p>
<p>上三角矩阵：<br>$$<br>a_{ij}=<br>\begin{cases}<br>(2n-i-1)i/2+j, i\leq j\<br>n(n+1)/2+1, i&gt;j\<br>\end{cases}<br>$$<br>下三角矩阵：<br>$$<br>a_{ij}=<br>\begin{cases}<br>i(i+1)/2+j,i\geq j\<br>n(n+1)/2+1, i&lt;j\<br>\end{cases}<br>$$<br><strong>对角矩阵</strong></p>
<p>特点：在n$\times$n的方针中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等。</p>
<p><strong>稀疏矩阵</strong></p>
<p>特点：在m$\times$n的矩阵中有t个非零元素。令$\delta=t(m\times n)$当$\delta \leq0.05$时称为稀疏矩阵。</p>
<p>压缩存储原则：存各非零元的值、行列位置和矩阵的行列数。三元组的不同表示方法可以决定稀疏矩阵不同的压缩存储方法。</p>
<p>三元组顺序表又称有序的双下标法。三元组顺序表的优点：非零元素在表中按行序有序存储，因此便于进行依行顺序处理的矩阵运算。三元组顺序表的缺点：不能随机存取。若按行号存取某一行中的非零元，则需从头开始进行查找。</p>
<p>稀疏矩阵的链式存储结构：十字链表</p>
<p>优点：它能够灵活地插入因运算而产生的新的非零元素，删除因运算而产生的新的零元素，实现矩阵的各种运算。</p>
<p>在十字链表中，矩阵的每一个非零元素用一个结点表示，该结点除了(row,col,value)以外，还要有两个域：right：用于链接同一行中的下一个非零元素；down：用以链接同一列中的下一个非零元素。</p>
<h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p>广义表(又称列表Lists)是$n\geq 0$个元素$a_0,a_1,…a_{n-1}$的有限序列，其中每一个$a_i$或者是原子，或者是一个广义表。</p>
<p>广义表通常记作：$LS=(a_1,a_2,..,a_n)$其中：LS为表名，n为表的长度，每一个$a_i$为表的的元素。</p>
<p>习惯上，一般用大写字母表示广义表。小写字母表示原子。</p>
<p>表头：若LS非空，则其中第一个元素$a_1$就是表头。记作head(LS)=$a_1$。注：表头也可以是原子，也可以是子表。</p>
<p>表尾：除表头之外的其它元素组成的表。记作tail(LS)=$(a_2,…a_n)$。注：表尾不是最后一个元素，而是一个子表。</p>
<p>例：(1) A=() 空表，长度为0；(2) B=(()) 长度为1，表头，表尾均为()；(3) C=(a, (b, c)) 长度为2，由原子a和子表(b, c)构成。表头为a；表尾为((b, c))；(4) D=(x, y, z) 长度为3，每一项都是原子。表头为x；表尾为(y,z)；(5) E=(C, D) 长度为2，每一项都是子表。表头为C，表尾为(D)；(6) F(a, F) 长度为2，第一项为原子，第二项为它本身。表头为a，表尾为(F)。</p>
<h4 id="广义表的性质"><a href="#广义表的性质" class="headerlink" title="广义表的性质"></a>广义表的性质</h4><ul>
<li><p>广义表中的数据元素有相对次序；一个直接前驱和一个直接后继。</p>
</li>
<li><p>广义表的长度定义为最外层所包含元素的个数；如：C=(a, (b, c))是长度为2的广义表。</p>
</li>
<li><p>广义表的深度定义为该广义表展开后所包含括号的重数；A=(b, c)的深度为1，B=(A, d)的深度为2，C=(f, B, h)的深度为3。注意：“原子”的深度为0；“空表”的深度为1。</p>
</li>
<li><p>广义表可以为其他广义表共享，如：广义表B就共享表A。在B中不必列出A的值，而是通过名称来引用，B=(A)。</p>
</li>
<li><p>广义表可以是一个递归的表。如：F=(a, F)=(a, (a, (a, …)))。注意：递归表是深度是无穷值，长度是有限值。</p>
</li>
<li><p>广义表是多层次的结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表。可以用图形象地表示。例：D=(E, F)，其中：E=(a, (b, c)) F=(d, (e))</p>
</li>
</ul>
<p><strong>广义表与线性表的区别？</strong></p>
<p>广义表可以看成是线性表的推广，线性表是广义表的特例。广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。</p>
<p>当二维数组的每行(或每列)作为子表处理时，二维数组即为一个广义表。</p>
<p>另外，树和有向图也可以用广义表来表示。</p>
<p>由于广义表不仅集中了线性表、数组、树、有向图等常见的数据结构的特点，而且可有效地利用存储空间，因此在计算机的许多领域都有成功使用广义表的实例。</p>
<h4 id="广义表的基本运算"><a href="#广义表的基本运算" class="headerlink" title="广义表的基本运算"></a>广义表的基本运算</h4><p>求表头GetHead(L)：非空广义表的第一个元素，可以是一个原子，也可以是一个子表</p>
<p>求表尾GetTail(L)：非空广义表除去表头元素以外其它元素所构成的表。表尾一定是一个表。</p>
<p>例：D=(E, F)=((a,(b, c)), F) GetHead(D) = E；GetTail(D) = (F)；GetHead(E) = a；GetTail(E) = ((b, c))；GetHead(((b, c))) = (b, c)；GetTail(((b, c))) = ()；GetHead((b, c)) = b；GetTail((b, c)) = (c)；GetHead((c)) = c；GetTail((c)) = ()。</p>
<h3 id="案例分析与实现-1"><a href="#案例分析与实现-1" class="headerlink" title="案例分析与实现"></a>案例分析与实现</h3><p>案例：病毒感染检测</p>
<p>研究者将人的DNA和病毒DNA均表示成由一些字母组成的字符串序列。然后检测某种病毒DNA序列是否在患者的DNA序列中出现过，如果出现过，则此人感染了该病毒，否则没有感染。</p>
<p>例如：假设病毒的DNA序列为baa，患者1的DNA序列为aaabbba，则感染，患者2的DNA序列为babbba，则未感染。(注意，人的DNA序列是线性的，而病毒的DNA序列是环状的)</p>
<p>分析：</p>
<ul>
<li>因为患者的DNA和病毒DNA均是由一些字母组成的字符串序列，要检测某种病毒DNA序列是否在患者的DNA序列中出现过，实际上就是字符串的模式匹配问题。</li>
<li>可以利用BD算法，也可以利用更高效的KMP算法。</li>
<li>但与一般的模式匹配问题不同的是，此案例中病毒的DNA序列是环状的。</li>
<li>这样需要对传统的BF算法或KMP算法进行改进。</li>
</ul>
<p>案例实现：</p>
<ul>
<li>对于每一个待检测的任务，假设病毒DNA序列的长度是m，因为病毒DNA序列是环状的，为了线性取到每个可行的长度为m的模式串，可将存储病毒DNA序列的字符串长度扩大为2m，将病毒DNA序列连续存储两次。</li>
<li>然后循环m次，依次取得每个长度为m的环状字符串，将次字符串作为模式串，将人的DNA序列作为主串，调用BF算法进行模式串，将人的DNA序列作为主串，调用BF算法进行模式匹配。</li>
<li>只要匹配成功，即可中止循环，表名该人感染了对应的病毒；否则，循环m次结束循环时，可通过BF算法的返回值判断该人是否感染了对应的病毒。</li>
</ul>
<h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><p>树形结构(非线性结构)：结点之间有分支、具有层次关系。</p>
<h3 id="树和二叉树的定义"><a href="#树和二叉树的定义" class="headerlink" title="树和二叉树的定义"></a>树和二叉树的定义</h3><h4 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h4><p>树(Tree)是$n\geq 0$个结点的有限集。若n=0，称为空数；若$n &gt; 0$，则它满足如下两个条件：(1)有且仅有一个特定的称为根(Root)的结点；(2)其余结点可以分为m$(m\geq 0)$个互不相交的有限集$T_1,T_2,T_3,…,T_m$，其中每一个集合本身又是一棵树，并称为根的子树(SubTree)。</p>
<p>显然，树的定义是一个递归的定义。</p>
<h4 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h4><p>结点：数据元素以及指向子数的分支。</p>
<p>根结点：非空树中无前驱结点的结点。</p>
<p>结点的度：结点拥有的子树数。</p>
<p>树的度：树内各结点的度的最大值。</p>
<p>叶子结点(终端结点)：度为0的结点。</p>
<p>分支结点(非终端结点)：度不为0的结点。</p>
<p>内部结点：除根结点以外的其他分支结点。</p>
<p>结点的子树的根称为该结点的<strong>孩子</strong>，该结点称为孩子的<strong>双亲</strong>。</p>
<p>结点的祖先：从根到该结点所经分支上的所有结点。</p>
<p>结点的子孙：以某结点为根的子数中的任一结点。</p>
<p>树的深度：树中结点的最大层次。</p>
<p>有序树：树中结点的各子树从左到右有次序。</p>
<p>无序树：树中结点的各子树无次序。</p>
<p>森林：是m$(m\geq0)$棵互不相交的树的集合。</p>
<h4 id="树结构和线性结构的比较"><a href="#树结构和线性结构的比较" class="headerlink" title="树结构和线性结构的比较"></a>树结构和线性结构的比较</h4><table>
<thead>
<tr>
<th align="center">线性结构</th>
<th align="center">树结构</th>
</tr>
</thead>
<tbody><tr>
<td align="center">第一个数据元素(无前驱)</td>
<td align="center">根结点(无双亲)</td>
</tr>
<tr>
<td align="center">最后一个数据元素(无后继)</td>
<td align="center">叶子结点(可以有多个)</td>
</tr>
<tr>
<td align="center">其它数据元素</td>
<td align="center">其它结点——中间结点</td>
</tr>
<tr>
<td align="center">一个前驱，一个后继</td>
<td align="center">一个双亲，多个孩子</td>
</tr>
<tr>
<td align="center">一对一</td>
<td align="center">一对多</td>
</tr>
</tbody></table>
<h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>为什么要重点研究每结点最多只有两个“叉”的树？</p>
<p>二叉树的结构最简单，规律性最强；可以证明，所有树都能转为唯一对应的二叉树，不失一般性。</p>
<p>普通树(多叉树)若不转化为二叉树，则运算很难实现。</p>
<p>二叉树在树结构的应用中起着非常重要的作用，因为对二叉的许多操作算法简单，而任何树都可以与二叉树相互转换，这样就解决了树的存储结构及其运算中存在的复杂性。</p>
<p>二叉树是$n\geq 0$个结点的有限集，它或者是空集(n=0)，或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成。</p>
<p>特点：</p>
<ul>
<li>1.每个结点最多有两个孩子(二叉树中不存在度大于2的结点)。</li>
<li>2.子树有左右之分，其次序不能颠倒。</li>
<li>二叉树可以是空集合，根可以有空的左子树或空的右子树。</li>
</ul>
<p>注：二叉树不是树的特殊情况，它们是两个概念</p>
<p>二叉树结点的子树要区分左子树和右子树，即使只有一颗树也要进行区分，说明它是左子树，还是右子树。</p>
<p>树当结点只有一个孩子时，就无需区分它是左还是右的次序。因此二者是不同的。这是二叉树与树的最主要的差别。</p>
<p>二叉树的五种基本形态：空二叉树、根和空的左右子树、根和左子树、根和右子树、根和左右子树。</p>
<p>注：虽然二叉树和树概念不同，但有关树的基本术语对二叉树都适用。</p>
<h3 id="案例引入-3"><a href="#案例引入-3" class="headerlink" title="案例引入"></a>案例引入</h3><p>案例1：数据压缩问题</p>
<p>将数据文件转换成由0、1组成的二进制串，称之为编码。编码的形式：(a)等长编码；(b)不等长编码方案1；(c)不等长编码方案2。</p>
<p>案例2：利用二叉树求解表达式的值</p>
<p>以二叉树表示表达式的递归定义如下：(1)若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息；(2)若表达式为“第一操作数运算符第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符，其中，操作数本身又为表达式。</p>
<h3 id="树和二叉树的抽象数据类型定义"><a href="#树和二叉树的抽象数据类型定义" class="headerlink" title="树和二叉树的抽象数据类型定义"></a>树和二叉树的抽象数据类型定义</h3><p><strong>二叉树的抽象数据类型定义</strong></p>
<p>数据对象D：D是具有相同特性的数据元素的集合</p>
<p>数据关系R：</p>
<p>基本操作P：创建二叉树、前序遍历、中序遍历、后序遍历。。。</p>
<h3 id="二叉树的性质和存储结构"><a href="#二叉树的性质和存储结构" class="headerlink" title="二叉树的性质和存储结构"></a>二叉树的性质和存储结构</h3><p>性质1：在二叉树的第i层上至多有$2^{i-1}$个结点。在第i层上至少有1个结点。</p>
<p>性质2：深度为k的二叉树至多有$2^k-1$个结点。深度为k的二叉树至少有k个结点。</p>
<p>性质3：对任意一颗二叉树T，如果其叶子数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。</p>
<p>性质4：具有n个结点的完全二叉树的深度为[logn]+1。[x]称作x的底，表示不大于x的最大整数。</p>
<p>性质5：如果对一颗有n个结点的完全二叉树的结点按层序编号，则对任一结点i，有：(1)如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]；(2)如果2i&gt;n，则结点i为叶子结点，无左孩子；否则，其左孩子是结点2i；(3)如果2i+1&gt;n，则结点i无右孩子；否则，其右孩子是结点2i+1。(性质5表名了完全二叉树中双亲结点编号与孩子结点编号之间的关系)</p>
<h4 id="两种特殊形式的二叉树"><a href="#两种特殊形式的二叉树" class="headerlink" title="两种特殊形式的二叉树"></a>两种特殊形式的二叉树</h4><p><strong>满二叉树</strong></p>
<p>一棵深度为k且有$2^k-1$个结点的二叉树称为满二叉树。</p>
<p>特点：每一层上的结点数都是最大结点数；叶子结点全部在最底层。</p>
<p>对满二叉树结点位置进行编号：编号规则：从根结点开始，自上而下，自左而右；每一个结点位置都有元素。</p>
<p>满二叉树在同样深度的二叉树中结点个数最多；满二叉树在同样深度的二叉树中叶子结点个数最多。</p>
<p><strong>完全二叉树</strong></p>
<p>深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中的编号为1~n的结点——对应时，称之为完全二叉树。</p>
<p>注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一颗完全二叉树。</p>
<p>特点：1.叶子只可能分布在层次最大的两层上；2.对任一结点，如果其右子树的最大层次为i，则其左子树的最大层次必须为i或i+1。</p>
<h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><ul>
<li><p>1.顺序存储结构；</p>
</li>
<li><p>2.链式存储结构：</p>
<ul>
<li>1.二叉链表；</li>
<li>2.三叉链表；</li>
</ul>
</li>
</ul>
<p><strong>二叉树的顺序存储结构</strong></p>
<p>实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAXTSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAXTSIZE]</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>

<p>二叉树的顺序存储特点：最坏情况：深度为k的且只有k个结点的单支树需要长度为$2^k-1$的一维数组。</p>
<p>特点：结点间关系蕴含在其存储位置中，浪费空间，适于存满二叉树和完全二叉树。</p>
<p><strong>二叉树的链式存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiNode, *BiTree;</span><br></pre></td></tr></table></figure>

<p>在n个结点的二叉链表中，有n+1个空指针域。分析：必有2n个链域。除根结点外，每个结点有且仅有一个双亲，所以只会有n-1个结点的链域存放指针，指向非空子女结点。空指针数目=2n - (n-1) = n+1。</p>
<p><strong>三叉链表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span>&#123;</span></span><br><span class="line">    TelemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">lchild</span>, *<span class="title">parent</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;TriTNode, *TriTNode;</span><br></pre></td></tr></table></figure>

<h3 id="遍历二叉树和线索二叉树"><a href="#遍历二叉树和线索二叉树" class="headerlink" title="遍历二叉树和线索二叉树"></a>遍历二叉树和线索二叉树</h3><p>遍历定义——顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次。(“访问”的含义很广，可以是对结点做各种处理，如：输出结点的信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构。)</p>
<p>遍历目的——得到树中所有结点的一个线性排列。</p>
<p>遍历用途——它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。</p>
<h4 id="遍历二叉树算法描述"><a href="#遍历二叉树算法描述" class="headerlink" title="遍历二叉树算法描述"></a>遍历二叉树算法描述</h4><ul>
<li><p>遍历方法：假设L：遍历左子树；D：访问根结点；R：遍历右子树；则遍历整个二叉树方案共有：DLR、LDR、LRD、DRL、RDL、RLD六种。<br>若规定先左后右，则只有前三种情况：</p>
<ul>
<li>DLR——根左右，前序遍历</li>
<li>LDR——左根右，中序遍历</li>
<li>LRD——左右根，后序遍历</li>
</ul>
<p>前序遍历二叉树的操作定义：若二叉树为空，则空操作；否则：(1)访问根结点；(2)前序遍历左子树；(3)前序遍历右子树。</p>
<p>中序遍历二叉树的操作定义：若二叉树为空，则空操作；否则：(1)中序遍历左子树；(2)访问根结点；(3)中序遍历右子树。</p>
<p>后序遍历二叉树的操作定义：若二叉树为空，则空操作；否则：(1)后序遍历左子树；(2)后序遍历右子树；(3)访问根结点。</p>
</li>
</ul>
<h4 id="根据遍历序列确定二叉树"><a href="#根据遍历序列确定二叉树" class="headerlink" title="根据遍历序列确定二叉树"></a>根据遍历序列确定二叉树</h4><p>若二叉树中各结点的值均不相同，则二叉树结点的前序序列、中序序列、后序序列都是唯一的。</p>
<p>由二叉树的前序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一颗二叉树</p>
<h4 id="遍历算法的递归实现"><a href="#遍历算法的递归实现" class="headerlink" title="遍历算法的递归实现"></a>遍历算法的递归实现</h4><p><strong>二叉树的前序遍历算法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="built_in">visit</span>(T);<span class="comment">//访问根结点</span></span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的中序遍历算法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)<span class="keyword">return</span> OK;</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">visit</span>(T);</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的后序遍历算法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">visit</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历算法的分析</strong></p>
<p>如果去掉输出语句，从递归的角度看，三种算法是完全相同的，或说这三种算法的访问路径是相同的，只是访问结点的时机不同。</p>
<p>时间复杂度：O(n)；空间复杂度：O(n)</p>
<h4 id="遍历算法的非递归实现"><a href="#遍历算法的非递归实现" class="headerlink" title="遍历算法的非递归实现"></a>遍历算法的非递归实现</h4><p><strong>二叉树的中序遍历算法</strong></p>
<p>二叉树的中序遍历的非递归算法的关键：在中序遍历过某结点的整个左子树，如何找到该结点的根以及右子树。</p>
<p>基本思想：(1)建立一个栈；(2)根结点进栈，遍历左子树；(3)根结点出栈，输出根结点，遍历右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    BiTree p; <span class="built_in">InitStack</span>(S); p=T;</span><br><span class="line">    <span class="keyword">while</span>(p || !<span class="built_in">StackEmpty</span>(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            <span class="built_in">Push</span>(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">Pop</span>(S, q);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, q-&gt;data);</span><br><span class="line">            p = q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的层次遍历方法"><a href="#二叉树的层次遍历方法" class="headerlink" title="二叉树的层次遍历方法"></a>二叉树的层次遍历方法</h4><p>对于一棵二叉树，从根结点开始，从上到下、从左到右的顺序访问每一个结点。每一个结点仅仅访问一次。</p>
<p>算法设计思路：(1)将根结点进队；(2)队不空时循环：从队列中出列一个结点p，访问它；若它有左孩子结点，将左孩子结点进队；若它有右孩子结点，将右孩子结点进队。</p>
<p>使用的队列类型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    BTNode data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<p>二叉树的层次遍历算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line">    BTNode *p; SqQueue *qu;</span><br><span class="line">    <span class="built_in">InitQueue</span>(qu);<span class="comment">//初始化队列</span></span><br><span class="line">    <span class="built_in">enQueue</span>(qu, b);<span class="comment">//根结点指针入队</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(qu))&#123;<span class="comment">//队列不为空，则循环</span></span><br><span class="line">        <span class="built_in">deQueue</span>(qu, p);<span class="comment">//出队结点p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;data);<span class="comment">//访问结点p</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">enQueue</span>(qu, p-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">enQueue</span>(qu, p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树遍历算法的应用"><a href="#二叉树遍历算法的应用" class="headerlink" title="二叉树遍历算法的应用"></a>二叉树遍历算法的应用</h4><p><strong>二叉树的建立</strong></p>
<p>按前序遍历建立二叉树的二叉链表</p>
<p>(1)从键盘输入二叉树的结点信息，建立二叉树的存储结构；(2)在建立二叉树的过程中按照二叉树前序方式建立；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(T=(BiTNode*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BiTNode))))&#123;</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        &#125;</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复制二叉树</strong></p>
<p>如果是空树，递归结束；否则，申请新结点空间，复制根结点；递归复制左子树，递归复制右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Copy</span><span class="params">(BiTree T, BiTree &amp;NewT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        NewT = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        NewT = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        NewT-&gt;data = T-&gt;data;</span><br><span class="line">        <span class="built_in">Copy</span>(T-&gt;lchild, NewT-&gt;lchild);</span><br><span class="line">        <span class="built_in">Copy</span>(T-&gt;rchild, NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算二叉树深度</strong></p>
<p>如果是空树，则深度为0；否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大者加1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        m = <span class="built_in">Depth</span>(T-&gt;lchild);</span><br><span class="line">        n = <span class="built_in">Depth</span>(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> m+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算二叉树结点总数</strong></p>
<p>如果是空树，则结点个数为0；否则，结点个数为左子树的结点个数+右子树的结点 个数+1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NodeCount</span>(T-&gt;lchild) + <span class="built_in">NodeCount</span>(T-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算叶子结点数</strong></p>
<p>如果是空树，则叶子结点个数为0；否则，为左子树的叶子结点个数+右子数的叶子结点个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LeafCount</span>(T-&gt;lchild) + <span class="built_in">LeafCount</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>为什么要研究线索二叉树？当用二叉树链表作为二叉树的存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，无法直接找到该结点在某种遍历序列中的前驱和后继结点。</p>
<p>如何寻找特定遍历序列中的二叉树结点的前驱和后继？</p>
<p>1.通过遍历寻找——费时间；2.再增设前驱、后继指针域——增加了存储负担；3.利用二叉链表中的空指针域。</p>
<p>利用二叉链表中的空指针域：</p>
<p>如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继。</p>
<p>这种改变指向的指针称为<strong>线索</strong>。加上了线索的二叉树称为<strong>线索二叉树</strong>(Threaded Binary Tree)。</p>
<p>对二叉树按某种遍历次序使其变为线索二叉树的过程叫<strong>线索化</strong>。</p>
<p>为区分lrchild和rchild指针到底是指向孩子的指针，还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域ltag和rtag，并约定：ltag=0 lchild指向该结点的孩子左孩子；ltag=1 lchild指向该结点的前驱；rtag=0 rchild指向该结点的右孩子；rtag=1 rchild指向该结点的后继。</p>
<p>这样，结点的结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">    Struct BiThrNode *lchild, *rchild;</span><br><span class="line">&#125;BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>

<p>增设了一个头结点：ltag=0，lchild指向根结点，rtag=1，rchild指向遍历序列中最后一个结点；遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点。</p>
<h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><p>树(Tree)是n$(n\geq0)$个结点的有限集。若n=0，称为空树；若n&gt;0：(1)有且仅有一个特定的称为根(Root)的结点；(2)其余结点可分为m$(m\geq0)$个互不相交的有限集$T_1,T_2,T_3,…,T_n$。</p>
<p>森林：是m$(m\geq0)$棵互不相交的树的集合。</p>
<h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><p><strong>双亲表示法</strong></p>
<p>实现：</p>
<p>定义结构数组；</p>
<p>存放树的结点，每个结点含两个域：</p>
<ul>
<li>数据域：存放结点本身信息</li>
<li>双亲域：指示本结点的双亲结点在数组中的位置</li>
</ul>
<p>特点：找双亲容易，找孩子结点苦难</p>
<p>结点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br></pre></td></tr></table></figure>

<p>树结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> r, n;</span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>

<p><strong>孩子链表</strong></p>
<p>把每个结点的孩子排列起来，看成是一个线性表，用单链表存储，则n个结点有n个孩子链表(叶子的孩子链表为空表)。而n个头指针又组成一个线性表，用顺序表(含n个元素的结构数组)存储。</p>
<p>孩子结点结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*ChildPtr;</span><br></pre></td></tr></table></figure>

<p>双亲结点结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br></pre></td></tr></table></figure>

<p>树结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n, r;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>

<p>特点：找孩子容易，找双亲难。</p>
<p><strong>孩子兄弟表示法</strong></p>
<p>实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>

<h4 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h4><p>将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作。</p>
<p>由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表作为媒介可以导出树与二叉树之间的一个对应关系。</p>
<p><strong>将树转化成二叉树</strong></p>
<p>①加线：在兄弟之间加一连线；②抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系；③旋转：以树的根结点为轴心，将整树顺时针转45°。(兄弟相连留长子）</p>
<p><strong>将二叉树转换成树</strong></p>
<p>①加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子…沿分支找到的所有右孩子，都与p的双亲用线连起来；②抹线：抹掉原二叉树这双亲与右孩子之间的连线；③调整：将结点按层次排序，形成树结构。(左孩子右右连双亲，去掉原来右孩线)</p>
<h3 id="哈夫曼树及其应用"><a href="#哈夫曼树及其应用" class="headerlink" title="哈夫曼树及其应用"></a>哈夫曼树及其应用</h3><h3 id="案例分析与实现-2"><a href="#案例分析与实现-2" class="headerlink" title="案例分析与实现"></a>案例分析与实现</h3>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt=" 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    NoTrouble
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法">http://yoursite.com/2021/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构与算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/13/ArrayList%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" rel="next" title="ArrayList原理解析">
                <i class="fa fa-chevron-left"></i> ArrayList原理解析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/14/MyBatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" rel="prev" title="MyBatis基本使用">
                MyBatis基本使用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
    

  


    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC81MDk0MC8yNzQyMg=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/wk.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/NoTrouble-EL" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wukun0221@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://space.bilibili.com/53303565" target="_blank" title="Bilibili">
                      
                        <i class="fa fa-fw fa-youtube"></i>Bilibili</a>
                  </span>
                
            </div>
          

          
          

          
          

          <script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5clr89hn3fz&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;s=340" async="async"></script>

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">算法与算法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87%E5%BA%A6%E9%87%8F"><span class="nav-number">1.1.</span> <span class="nav-text">算法时间效率度量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.</span> <span class="nav-text">算法时间复杂度定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">分析算法时间复杂度的基本方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="nav-number">1.4.</span> <span class="nav-text">算法时间复杂度计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">1.5.</span> <span class="nav-text">算法时间效率的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%90%E8%BF%9B%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.6.</span> <span class="nav-text">渐进空间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.7.</span> <span class="nav-text">设计好算法的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">线性表的定义和特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5"><span class="nav-number">2.2.</span> <span class="nav-text">案例引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">2.3.</span> <span class="nav-text">线性的类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.4.</span> <span class="nav-text">线性表的顺序表示和实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.5.</span> <span class="nav-text">线性表的链式表示和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.5.1.</span> <span class="nav-text">单链表的定义和表示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">2.6.</span> <span class="nav-text">顺序表和链表的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">2.7.</span> <span class="nav-text">线性表的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.8.</span> <span class="nav-text">案例分析与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8A%A0%E3%80%81%E5%87%8F%E3%80%81%E4%B9%98%E8%BF%90%E7%AE%97"><span class="nav-number">2.8.1.</span> <span class="nav-text">一元多项式的运算：实现两个多项式加、减、乘运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%80%E7%96%8F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-number">2.8.2.</span> <span class="nav-text">稀疏多项式的运算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-number">3.1.</span> <span class="nav-text">栈和队列的定义和特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5-1"><span class="nav-number">3.2.</span> <span class="nav-text">案例引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.</span> <span class="nav-text">栈的表示和操作的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.1.</span> <span class="nav-text">顺序栈的表示和实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.2.</span> <span class="nav-text">链栈的表示和实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92"><span class="nav-number">3.4.</span> <span class="nav-text">栈与递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.5.</span> <span class="nav-text">队列的表示和操作的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-number">4.</span> <span class="nav-text">串、数组和广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-number">4.1.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.1.</span> <span class="nav-text">串的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5-2"><span class="nav-number">4.1.2.</span> <span class="nav-text">案例引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%90%E7%AE%97"><span class="nav-number">4.1.3.</span> <span class="nav-text">串的类型定义、存储结构及运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BF"><span class="nav-number">4.1.4.</span> <span class="nav-text">BF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KMP"><span class="nav-number">4.1.5.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#next%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="nav-number">4.1.6.</span> <span class="nav-text">next函数的改进</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">4.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">4.2.1.</span> <span class="nav-text">数组的抽象数据类型定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-number">4.2.2.</span> <span class="nav-text">数组的顺序存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="nav-number">4.3.</span> <span class="nav-text">广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">4.3.1.</span> <span class="nav-text">广义表的性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97"><span class="nav-number">4.3.2.</span> <span class="nav-text">广义表的基本运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">4.4.</span> <span class="nav-text">案例分析与实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.</span> <span class="nav-text">树和二叉树的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.1.</span> <span class="nav-text">树的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-number">5.1.2.</span> <span class="nav-text">树的基本术语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84%E5%92%8C%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">5.1.3.</span> <span class="nav-text">树结构和线性结构的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.4.</span> <span class="nav-text">二叉树的定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5-3"><span class="nav-number">5.2.</span> <span class="nav-text">案例引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">5.3.</span> <span class="nav-text">树和二叉树的抽象数据类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E5%92%8C%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.</span> <span class="nav-text">二叉树的性质和存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.4.1.</span> <span class="nav-text">两种特殊形式的二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.2.</span> <span class="nav-text">二叉树的存储结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.5.</span> <span class="nav-text">遍历二叉树和线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="nav-number">5.5.1.</span> <span class="nav-text">遍历二叉树算法描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.5.2.</span> <span class="nav-text">根据遍历序列确定二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.5.3.</span> <span class="nav-text">遍历算法的递归实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.5.4.</span> <span class="nav-text">遍历算法的非递归实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="nav-number">5.5.5.</span> <span class="nav-text">二叉树的层次遍历方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">5.5.6.</span> <span class="nav-text">二叉树遍历算法的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.5.7.</span> <span class="nav-text">线索二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="nav-number">5.6.</span> <span class="nav-text">树和森林</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.6.1.</span> <span class="nav-text">树的存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.6.2.</span> <span class="nav-text">树与二叉树的转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-number">5.7.</span> <span class="nav-text">哈夫曼树及其应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">5.8.</span> <span class="nav-text">案例分析与实现</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NoTrouble</span>

  
</div>





            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  

  <script async src="/js/cursor/text.js"></script>


</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
