---
title: 内存分配与回收策略
date: 2021-06-26 19:56:52
tags:
- JVM
categories: JVM
mathjax: true
---

​		Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：自动给对象分配内存以及自动回收分配给对象的内存。

​		对象的内存分配，从概念上讲，应该都是在堆上分配(实际上也有可能经过即时编译后被拆散为标量类型并间接地在栈上分配)。在经典分代的设计下，新生对象通常会分配在新生代中，少数情况下也可能会直接分配在老年代。对象分配的规则并不是固定的，《Java虚拟机规范》并未规定新对象的创建和存储细节，这取决于虚拟机当前使用的是哪一种垃圾收集器，以及虚拟机中与内存相关的参数的设定。

 <!-- more --> 

## 对象优先在Eden分配

​		大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

​		HotSpot虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出时输出当前内存各区域分配情况。

## 大对象直接进入老年代

​		大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串、或者元素数量很庞大的数组。大对象对于虚拟机的内存分配来说就是一个不折不扣的坏消息，比遇到一个大对象更加坏的消息就是遇到一群“朝升夕灭”的“短命大对象”，我们写程序的时候应该注意避免。在Java虚拟机中要避免大对象的原因是，分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获得足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。HotSpot虚拟机提供了-XX:PretenureSizeThreshold参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。

## 长期存活的对象将进入老年代

​		HotSpot虚拟机中大多数收集器都采用了分代收集来管理堆内存，哪些内存回收时就必须能决策哪些存活对象应当放在新生代，哪些存活对象放在老年代中。为做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过一次Minor GC后仍然存活，并且能够Survivor容纳的话，该对象被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。

## 动态对象年龄判定

​		为了更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX:MaxTenuringThreshold才能晋升老年代，如果Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到-XX:MaxTenuringThreshold中要求的年龄。

## 空间分配担保

​		在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX:HandlePromotionFailure参数的设置值是否允许担保失败；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。

​		解释一下“冒险”是冒了什么风险：新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况——最极端的情况就是内存回收后新生代中所有对象都存活，需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，但一共有多少对象会在次回收中存活下来在实际完成内存回收之前是无法明确知道的，所以只能取之前每一次回收晋升到老年对象容量的平均大小作为经验值，与老年的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。

​		取历史平均值来比较其实仍然是一种赌概率的解决办法，如果某次Minor GC存活后的对象突增，远远高于历史平均值的话，依然会导致担保失败。如果出现了担保失败，那就只能重新发起一次Full GC，这样停顿时间就很长了。虽然担保失败时绕的圈子很大，但通常情况下都还是会将-XX:HandlePromotionFailure开关打开，避免Full GC过于频繁。

​		在JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则就会Full GC。
