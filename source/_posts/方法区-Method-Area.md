---
title: 方法区(Method Area)
date: 2021-06-05 22:38:10
tags:
- JVM
categories: JVM
mathjax: true
---

​		方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”(Non-Heap)，目的是与Java堆区分开来。

 <!-- more --> 

## 概述

​		说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK8以前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”(Permanent Generation)，或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机实现，譬如BEA、JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头来看，当年使用永久代来实现方法区的决定不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出的问题(永久代有-XX:MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出现问题)，而且有极少数方法(例如 String::intern())会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control 管理工具，移植到HotSpot虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存(Native Memory)来实现方法区的计划了，到JDK7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta space)来代替，把JDK7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。

​		《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集，相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sum公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。

​		根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

## 运行时常量池

​		运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

​		Java虚拟机对于Class文件中每一部分的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，《Java虚拟机规范》并没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。

​		运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可也将新的常量放入池中，这种特性被开发人员利用的比较多的便是String类的intern()方法。

​		既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

## 总结

### 方法区的内部结构

​		它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

#### 类型信息

​		对每个加载的类型(类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息：

* 这个类型的完整有效包名(全名=包名.类名)
* 这个类型直接父类的完整有效名(对于interface或java.lang.object，都没有父类)
* 这个类型的修饰符(public，abstract，final的某个子集)
* 这个类型直接接口的一个有序列表

#### 域信息

​		JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。域的相关信息包括：域名称、域类型、域修饰符(public，private，protected，static，final，volatile，transient的某个子集)

#### 方法信息

​		JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：

* 方法名称
* 方法的返回类型(或void)
* 方法的参数的数量和类型
* 方法的修饰符(public，private，protected，static，final，synchronized，native，abstract的某个子集)
* 方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)
* 异常表(abstract和native方法除外)

#### non-final的类变量

* 静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分
* 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它

#### 全局常量

* 全局常量就是使用static final进行修饰
* 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。

### HotSpot中方法区的演进

​		在JDK7之前，习惯上把方法区，称为永久代。从JDK8开始，使用了元空间取代了永久代。JDK8后，元空间存放在堆外内存中。本质上，方法区和永久代不等价。仅是对HotSpot而言的。

​		现在看来，当年使用永久代，不是好的idea。导致Java程序更容易OOM；而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间来代替。

​		元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。

​		永久代、元空间二者并不只是名字变了，内部结构也调整了；根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。

### 设置方法区大小与OOM

​		方法区的大小不是固定的，JVM可以根据应用的需要动态调整。

#### JDK7及以前

* 通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M
* -XX:MaxPermsize来设定永久代最大可分配的空间。32位机器默认是64M，64位机器模式是82M
* 当JVM加载的类信息容量超过了这个值，会报异常OOM

#### JDK8以后

* 元空间大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定
* 默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制

与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元空间发生溢出，虚拟机一样会抛出异常OOM

-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize是21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没有用的类，然后这个高水位线将会重置。新的高水位线的取值取决于GC释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。

如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。
